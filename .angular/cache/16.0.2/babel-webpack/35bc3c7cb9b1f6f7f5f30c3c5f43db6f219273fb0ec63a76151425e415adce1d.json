{"ast":null,"code":"/*\n Highcharts JS v11.0.1 (2023-05-08)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (S, M) {\n  \"object\" === typeof module && module.exports ? (M[\"default\"] = M, module.exports = S.document ? M(S) : M) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts\", function () {\n    return M(S);\n  }) : (S.Highcharts && S.Highcharts.error(16, !0), S.Highcharts = M(S));\n})(\"undefined\" !== typeof window ? window : this, function (S) {\n  function M(a, y, G, L) {\n    a.hasOwnProperty(y) || (a[y] = L.apply(null, G), \"function\" === typeof CustomEvent && S.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: y,\n        module: a[y]\n      }\n    })));\n  }\n  var a = {};\n  M(a, \"Core/Globals.js\", [], function () {\n    var a;\n    (function (a) {\n      a.SVG_NS = \"http://www.w3.org/2000/svg\";\n      a.product = \"Highcharts\";\n      a.version = \"11.0.1\";\n      a.win = \"undefined\" !== typeof S ? S : {};\n      a.doc = a.win.document;\n      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, \"svg\").createSVGRect;\n      a.userAgent = a.win.navigator && a.win.navigator.userAgent || \"\";\n      a.isChrome = -1 !== a.userAgent.indexOf(\"Chrome\");\n      a.isFirefox = -1 !== a.userAgent.indexOf(\"Firefox\");\n      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;\n      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf(\"Safari\");\n      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);\n      a.isWebKit = -1 !== a.userAgent.indexOf(\"AppleWebKit\");\n      a.deg2rad = 2 * Math.PI / 360;\n      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split(\"Firefox/\")[1], 10);\n      a.hasTouch = !!a.win.TouchEvent;\n      a.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"];\n      a.noop = function () {};\n      a.supportsPassiveEvents = function () {\n        let x = !1;\n        if (!a.isMS) {\n          const y = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              x = !0;\n            }\n          });\n          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener(\"testPassive\", a.noop, y), a.win.removeEventListener(\"testPassive\", a.noop, y));\n        }\n        return x;\n      }();\n      a.charts = [];\n      a.dateFormats = {};\n      a.seriesTypes = {};\n      a.symbolSizes = {};\n      a.chartCount = 0;\n    })(a || (a = {}));\n    \"\";\n    return a;\n  });\n  M(a, \"Core/Utilities.js\", [a[\"Core/Globals.js\"]], function (a) {\n    function x(d, k, b, f) {\n      const E = k ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === d && (d = `${E}: Deprecated member`);\n      const m = v(d);\n      let g = m ? `${E} #${d}: www.highcharts.com/errors/${d}/` : d.toString();\n      if (\"undefined\" !== typeof f) {\n        let d = \"\";\n        m && (g += \"?\");\n        J(f, function (k, b) {\n          d += `\\n - ${b}: ${k}`;\n          m && (g += encodeURI(b) + \"=\" + encodeURI(k));\n        });\n        g += d;\n      }\n      e(a, \"displayError\", {\n        chart: b,\n        code: d,\n        message: g,\n        params: f\n      }, function () {\n        if (k) throw Error(g);\n        p.console && -1 === x.messages.indexOf(g) && console.warn(g);\n      });\n      x.messages.push(g);\n    }\n    function G(d, k) {\n      const b = {};\n      J(d, function (f, E) {\n        if (C(d[E], !0) && !d.nodeType && k[E]) f = G(d[E], k[E]), Object.keys(f).length && (b[E] = f);else if (C(d[E]) || d[E] !== k[E] || E in d && !(E in k)) b[E] = d[E];\n      });\n      return b;\n    }\n    function L(d, k) {\n      return parseInt(d, k || 10);\n    }\n    function A(d) {\n      return \"string\" === typeof d;\n    }\n    function D(d) {\n      d = Object.prototype.toString.call(d);\n      return \"[object Array]\" === d || \"[object Array Iterator]\" === d;\n    }\n    function C(d, k) {\n      return !!d && \"object\" === typeof d && (!k || !D(d));\n    }\n    function z(d) {\n      return C(d) && \"number\" === typeof d.nodeType;\n    }\n    function t(d) {\n      const k = d && d.constructor;\n      return !(!C(d, !0) || z(d) || !k || !k.name || \"Object\" === k.name);\n    }\n    function v(d) {\n      return \"number\" === typeof d && !isNaN(d) && Infinity > d && -Infinity < d;\n    }\n    function c(d) {\n      return \"undefined\" !== typeof d && null !== d;\n    }\n    function n(d, k, b) {\n      const f = A(k) && !c(b);\n      let E;\n      const e = (k, b) => {\n        c(k) ? d.setAttribute(b, k) : f ? (E = d.getAttribute(b)) || \"class\" !== b || (E = d.getAttribute(b + \"Name\")) : d.removeAttribute(b);\n      };\n      A(k) ? e(b, k) : J(k, e);\n      return E;\n    }\n    function r(d, b) {\n      let k;\n      d || (d = {});\n      for (k in b) d[k] = b[k];\n      return d;\n    }\n    function l() {\n      const d = arguments,\n        b = d.length;\n      for (let k = 0; k < b; k++) {\n        const b = d[k];\n        if (\"undefined\" !== typeof b && null !== b) return b;\n      }\n    }\n    function h(d, b) {\n      a.isMS && !a.svg && b && c(b.opacity) && (b.filter = `alpha(opacity=${100 * b.opacity})`);\n      r(d.style, b);\n    }\n    function q(d) {\n      return Math.pow(10, Math.floor(Math.log(d) / Math.LN10));\n    }\n    function g(d, b) {\n      return 1E14 < d ? d : parseFloat(d.toPrecision(b || 14));\n    }\n    function w(d, b, f) {\n      let k;\n      if (\"width\" === b) return b = Math.min(d.offsetWidth, d.scrollWidth), f = d.getBoundingClientRect && d.getBoundingClientRect().width, f < b && f >= b - 1 && (b = Math.floor(f)), Math.max(0, b - (w(d, \"padding-left\", !0) || 0) - (w(d, \"padding-right\", !0) || 0));\n      if (\"height\" === b) return Math.max(0, Math.min(d.offsetHeight, d.scrollHeight) - (w(d, \"padding-top\", !0) || 0) - (w(d, \"padding-bottom\", !0) || 0));\n      if (d = p.getComputedStyle(d, void 0)) k = d.getPropertyValue(b), l(f, \"opacity\" !== b) && (k = L(k));\n      return k;\n    }\n    function J(d, b, f) {\n      for (const k in d) Object.hasOwnProperty.call(d, k) && b.call(f || d[k], d[k], k, d);\n    }\n    function F(d, b, f) {\n      function k(b, k) {\n        const f = d.removeEventListener;\n        f && f.call(d, b, k, !1);\n      }\n      function e(f) {\n        let e, K;\n        d.nodeName && (b ? (e = {}, e[b] = !0) : e = f, J(e, function (d, b) {\n          if (f[b]) for (K = f[b].length; K--;) k(b, f[b][K].fn);\n        }));\n      }\n      var p = \"function\" === typeof d && d.prototype || d;\n      if (Object.hasOwnProperty.call(p, \"hcEvents\")) {\n        const d = p.hcEvents;\n        b ? (p = d[b] || [], f ? (d[b] = p.filter(function (d) {\n          return f !== d.fn;\n        }), k(b, f)) : (e(d), d[b] = [])) : (e(d), delete p.hcEvents);\n      }\n    }\n    function e(d, b, f, e) {\n      f = f || {};\n      if (u.createEvent && (d.dispatchEvent || d.fireEvent && d !== a)) {\n        var k = u.createEvent(\"Events\");\n        k.initEvent(b, !0, !0);\n        f = r(k, f);\n        d.dispatchEvent ? d.dispatchEvent(f) : d.fireEvent(b, f);\n      } else if (d.hcEvents) {\n        f.target || r(f, {\n          preventDefault: function () {\n            f.defaultPrevented = !0;\n          },\n          target: d,\n          type: b\n        });\n        k = [];\n        let e = d,\n          E = !1;\n        for (; e.hcEvents;) Object.hasOwnProperty.call(e, \"hcEvents\") && e.hcEvents[b] && (k.length && (E = !0), k.unshift.apply(k, e.hcEvents[b])), e = Object.getPrototypeOf(e);\n        E && k.sort((d, b) => d.order - b.order);\n        k.forEach(b => {\n          !1 === b.fn.call(d, f) && f.preventDefault();\n        });\n      }\n      e && !f.defaultPrevented && e.call(d, f);\n    }\n    const {\n      charts: m,\n      doc: u,\n      win: p\n    } = a;\n    (x || (x = {})).messages = [];\n    Math.easeInOutSine = function (d) {\n      return -.5 * (Math.cos(Math.PI * d) - 1);\n    };\n    var H = Array.prototype.find ? function (d, b) {\n      return d.find(b);\n    } : function (d, b) {\n      let k;\n      const f = d.length;\n      for (k = 0; k < f; k++) if (b(d[k], k)) return d[k];\n    };\n    J({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (d, b) {\n      a[b] = function (k) {\n        x(32, !1, void 0, {\n          [`Highcharts.${b}`]: `use Array.${d}`\n        });\n        return Array.prototype[d].apply(k, [].slice.call(arguments, 1));\n      };\n    });\n    let b;\n    const f = function () {\n      const d = Math.random().toString(36).substring(2, 9) + \"-\";\n      let k = 0;\n      return function () {\n        return \"highcharts-\" + (b ? \"\" : d) + k++;\n      };\n    }();\n    p.jQuery && (p.jQuery.fn.highcharts = function () {\n      const d = [].slice.call(arguments);\n      if (this[0]) return d[0] ? (new a[A(d[0]) ? d.shift() : \"Chart\"](this[0], d[0], d[1]), this) : m[n(this[0], \"data-highcharts-chart\")];\n    });\n    H = {\n      addEvent: function (d, b, f, e = {}) {\n        var k = \"function\" === typeof d && d.prototype || d;\n        Object.hasOwnProperty.call(k, \"hcEvents\") || (k.hcEvents = {});\n        k = k.hcEvents;\n        a.Point && d instanceof a.Point && d.series && d.series.chart && (d.series.chart.runTrackerClick = !0);\n        const p = d.addEventListener;\n        p && p.call(d, b, f, a.supportsPassiveEvents ? {\n          passive: void 0 === e.passive ? -1 !== b.indexOf(\"touch\") : e.passive,\n          capture: !1\n        } : !1);\n        k[b] || (k[b] = []);\n        k[b].push({\n          fn: f,\n          order: \"number\" === typeof e.order ? e.order : Infinity\n        });\n        k[b].sort((d, b) => d.order - b.order);\n        return function () {\n          F(d, b, f);\n        };\n      },\n      arrayMax: function (d) {\n        let b = d.length,\n          f = d[0];\n        for (; b--;) d[b] > f && (f = d[b]);\n        return f;\n      },\n      arrayMin: function (d) {\n        let b = d.length,\n          f = d[0];\n        for (; b--;) d[b] < f && (f = d[b]);\n        return f;\n      },\n      attr: n,\n      clamp: function (d, b, f) {\n        return d > b ? d < f ? d : f : b;\n      },\n      cleanRecursively: G,\n      clearTimeout: function (b) {\n        c(b) && clearTimeout(b);\n      },\n      correctFloat: g,\n      createElement: function (b, k, f, e, p) {\n        b = u.createElement(b);\n        k && r(b, k);\n        p && h(b, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        });\n        f && h(b, f);\n        e && e.appendChild(b);\n        return b;\n      },\n      css: h,\n      defined: c,\n      destroyObjectProperties: function (b, k) {\n        J(b, function (d, f) {\n          d && d !== k && d.destroy && d.destroy();\n          delete b[f];\n        });\n      },\n      discardElement: function (b) {\n        b && b.parentElement && b.parentElement.removeChild(b);\n      },\n      erase: function (b, k) {\n        let d = b.length;\n        for (; d--;) if (b[d] === k) {\n          b.splice(d, 1);\n          break;\n        }\n      },\n      error: x,\n      extend: r,\n      extendClass: function (b, k) {\n        const d = function () {};\n        d.prototype = new b();\n        r(d.prototype, k);\n        return d;\n      },\n      find: H,\n      fireEvent: e,\n      getMagnitude: q,\n      getNestedProperty: function (b, k) {\n        for (b = b.split(\".\"); b.length && c(k);) {\n          const d = b.shift();\n          if (\"undefined\" === typeof d || \"__proto__\" === d) return;\n          k = k[d];\n          if (!c(k) || \"function\" === typeof k || \"number\" === typeof k.nodeType || k === p) return;\n        }\n        return k;\n      },\n      getStyle: w,\n      inArray: function (b, k, f) {\n        x(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return k.indexOf(b, f);\n      },\n      isArray: D,\n      isClass: t,\n      isDOMElement: z,\n      isFunction: function (b) {\n        return \"function\" === typeof b;\n      },\n      isNumber: v,\n      isObject: C,\n      isString: A,\n      keys: function (b) {\n        x(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(b);\n      },\n      merge: function () {\n        let b,\n          k = arguments,\n          f = {};\n        const e = function (b, d) {\n          \"object\" !== typeof b && (b = {});\n          J(d, function (k, f) {\n            \"__proto__\" !== f && \"constructor\" !== f && (!C(k, !0) || t(k) || z(k) ? b[f] = d[f] : b[f] = e(b[f] || {}, k));\n          });\n          return b;\n        };\n        !0 === k[0] && (f = k[1], k = Array.prototype.slice.call(k, 2));\n        const p = k.length;\n        for (b = 0; b < p; b++) f = e(f, k[b]);\n        return f;\n      },\n      normalizeTickInterval: function (b, k, f, e, p) {\n        let d = b;\n        f = l(f, q(b));\n        const E = b / f;\n        k || (k = p ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === e && (1 === f ? k = k.filter(function (b) {\n          return 0 === b % 1;\n        }) : .1 >= f && (k = [1 / f])));\n        for (e = 0; e < k.length && !(d = k[e], p && d * f >= b || !p && E <= (k[e] + (k[e + 1] || k[e])) / 2); e++);\n        return d = g(d * f, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: J,\n      offset: function (b) {\n        const d = u.documentElement;\n        b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: b.top + (p.pageYOffset || d.scrollTop) - (d.clientTop || 0),\n          left: b.left + (p.pageXOffset || d.scrollLeft) - (d.clientLeft || 0),\n          width: b.width,\n          height: b.height\n        };\n      },\n      pad: function (b, f, e) {\n        return Array((f || 2) + 1 - String(b).replace(\"-\", \"\").length).join(e || \"0\") + b;\n      },\n      pick: l,\n      pInt: L,\n      pushUnique: function (b, f) {\n        return 0 > b.indexOf(f) && !!b.push(f);\n      },\n      relativeLength: function (b, f, e) {\n        return /%$/.test(b) ? f * parseFloat(b) / 100 + (e || 0) : parseFloat(b);\n      },\n      removeEvent: F,\n      splat: function (b) {\n        return D(b) ? b : [b];\n      },\n      stableSort: function (b, f) {\n        const d = b.length;\n        let k, e;\n        for (e = 0; e < d; e++) b[e].safeI = e;\n        b.sort(function (b, d) {\n          k = f(b, d);\n          return 0 === k ? b.safeI - d.safeI : k;\n        });\n        for (e = 0; e < d; e++) delete b[e].safeI;\n      },\n      syncTimeout: function (b, f, e) {\n        if (0 < f) return setTimeout(b, f, e);\n        b.call(0, e);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: f,\n      useSerialIds: function (d) {\n        return b = l(d, b);\n      },\n      wrap: function (b, f, e) {\n        const d = b[f];\n        b[f] = function () {\n          const b = arguments,\n            f = this;\n          return e.apply(this, [function () {\n            return d.apply(f, arguments.length ? arguments : b);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n    \"\";\n    return H;\n  });\n  M(a, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {\n          zIndex: 6\n        },\n        position: {\n          align: \"right\",\n          x: -10,\n          y: 10\n        }\n      },\n      reflow: !0,\n      type: \"line\",\n      zoomBySingleTouch: !1,\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#334eff\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  });\n  M(a, \"Core/Color/Color.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n      isNumber: x,\n      merge: L,\n      pInt: A\n    } = y;\n    class D {\n      static parse(a) {\n        return a ? new D(a) : D.None;\n      }\n      constructor(x) {\n        this.rgba = [NaN, NaN, NaN, NaN];\n        this.input = x;\n        const z = a.Color;\n        if (z && z !== D) return new z(x);\n        this.init(x);\n      }\n      init(a) {\n        let z;\n        let t;\n        if (\"object\" === typeof a && \"undefined\" !== typeof a.stops) this.stops = a.stops.map(c => new D(c[1]));else if (\"string\" === typeof a) {\n          this.input = a = D.names[a.toLowerCase()] || a;\n          if (\"#\" === a.charAt(0)) {\n            var v = a.length;\n            var c = parseInt(a.substr(1), 16);\n            7 === v ? z = [(c & 16711680) >> 16, (c & 65280) >> 8, c & 255, 1] : 4 === v && (z = [(c & 3840) >> 4 | (c & 3840) >> 8, (c & 240) >> 4 | c & 240, (c & 15) << 4 | c & 15, 1]);\n          }\n          if (!z) for (c = D.parsers.length; c-- && !z;) t = D.parsers[c], (v = t.regex.exec(a)) && (z = t.parse(v));\n        }\n        z && (this.rgba = z);\n      }\n      get(a) {\n        const z = this.input,\n          t = this.rgba;\n        if (\"object\" === typeof z && \"undefined\" !== typeof this.stops) {\n          const v = L(z);\n          v.stops = [].slice.call(v.stops);\n          this.stops.forEach((c, n) => {\n            v.stops[n] = [v.stops[n][0], c.get(a)];\n          });\n          return v;\n        }\n        return t && x(t[0]) ? \"rgb\" === a || !a && 1 === t[3] ? \"rgb(\" + t[0] + \",\" + t[1] + \",\" + t[2] + \")\" : \"a\" === a ? `${t[3]}` : \"rgba(\" + t.join(\",\") + \")\" : z;\n      }\n      brighten(a) {\n        const z = this.rgba;\n        if (this.stops) this.stops.forEach(function (t) {\n          t.brighten(a);\n        });else if (x(a) && 0 !== a) for (let t = 0; 3 > t; t++) z[t] += A(255 * a), 0 > z[t] && (z[t] = 0), 255 < z[t] && (z[t] = 255);\n        return this;\n      }\n      setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      }\n      tweenTo(a, z) {\n        const t = this.rgba,\n          v = a.rgba;\n        if (!x(t[0]) || !x(v[0])) return a.input || \"none\";\n        a = 1 !== v[3] || 1 !== t[3];\n        return (a ? \"rgba(\" : \"rgb(\") + Math.round(v[0] + (t[0] - v[0]) * (1 - z)) + \",\" + Math.round(v[1] + (t[1] - v[1]) * (1 - z)) + \",\" + Math.round(v[2] + (t[2] - v[2]) * (1 - z)) + (a ? \",\" + (v[3] + (t[3] - v[3]) * (1 - z)) : \"\") + \")\";\n      }\n    }\n    D.names = {\n      white: \"#ffffff\",\n      black: \"#000000\"\n    };\n    D.parsers = [{\n      regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n      parse: function (a) {\n        return [A(a[1]), A(a[2]), A(a[3]), parseFloat(a[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n      parse: function (a) {\n        return [A(a[1]), A(a[2]), A(a[3]), 1];\n      }\n    }];\n    D.None = new D(\"\");\n    \"\";\n    return D;\n  });\n  M(a, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: \"#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1\".split(\" \")\n    };\n  });\n  M(a, \"Core/Time.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n        win: x\n      } = a,\n      {\n        defined: L,\n        error: A,\n        extend: D,\n        isObject: C,\n        merge: z,\n        objectEach: t,\n        pad: v,\n        pick: c,\n        splat: n,\n        timeUnits: r\n      } = y,\n      l = a.isSafari && x.Intl && x.Intl.DateTimeFormat.prototype.formatRange,\n      h = a.isSafari && x.Intl && !x.Intl.DateTimeFormat.prototype.formatRange;\n    class q {\n      constructor(g) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = x.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(g);\n      }\n      get(g, w) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          const c = w.getTime(),\n            l = c - this.getTimezoneOffset(w);\n          w.setTime(l);\n          g = w[\"getUTC\" + g]();\n          w.setTime(c);\n          return g;\n        }\n        return this.useUTC ? w[\"getUTC\" + g]() : w[\"get\" + g]();\n      }\n      set(g, c, q) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === g || \"Seconds\" === g || \"Minutes\" === g && 0 === this.getTimezoneOffset(c) % 36E5) return c[\"setUTC\" + g](q);\n          var w = this.getTimezoneOffset(c);\n          w = c.getTime() - w;\n          c.setTime(w);\n          c[\"setUTC\" + g](q);\n          g = this.getTimezoneOffset(c);\n          w = c.getTime() + g;\n          return c.setTime(w);\n        }\n        return this.useUTC || l && \"FullYear\" === g ? c[\"setUTC\" + g](q) : c[\"set\" + g](q);\n      }\n      update(g = {}) {\n        const w = c(g.useUTC, !0);\n        this.options = g = z(!0, this.options, g);\n        this.Date = g.Date || x.Date || Date;\n        this.timezoneOffset = (this.useUTC = w) && g.timezoneOffset || void 0;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = w && !(!g.getTimezoneOffset && !g.timezone);\n      }\n      makeTime(g, w, l, q, e, m) {\n        let u, p, H;\n        this.useUTC ? (u = this.Date.UTC.apply(0, arguments), p = this.getTimezoneOffset(u), u += p, H = this.getTimezoneOffset(u), p !== H ? u += H - p : p - 36E5 !== this.getTimezoneOffset(u - 36E5) || h || (u -= 36E5)) : u = new this.Date(g, w, c(l, 1), c(q, 0), c(e, 0), c(m, 0)).getTime();\n        return u;\n      }\n      timezoneOffsetFunction() {\n        const g = this,\n          c = this.options,\n          l = c.getTimezoneOffset,\n          q = c.moment || x.moment;\n        if (!this.useUTC) return function (e) {\n          return 6E4 * new Date(e.toString()).getTimezoneOffset();\n        };\n        if (c.timezone) {\n          if (q) return function (e) {\n            return 6E4 * -q.tz(e, c.timezone).utcOffset();\n          };\n          A(25);\n        }\n        return this.useUTC && l ? function (e) {\n          return 6E4 * l(e.valueOf());\n        } : function () {\n          return 6E4 * (g.timezoneOffset || 0);\n        };\n      }\n      dateFormat(g, w, l) {\n        if (!L(w) || isNaN(w)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || \"\";\n        g = c(g, \"%Y-%m-%d %H:%M:%S\");\n        const q = this;\n        var e = new this.Date(w);\n        const m = this.get(\"Hours\", e),\n          u = this.get(\"Day\", e),\n          p = this.get(\"Date\", e),\n          h = this.get(\"Month\", e),\n          b = this.get(\"FullYear\", e),\n          f = a.defaultOptions.lang,\n          d = f && f.weekdays,\n          k = f && f.shortWeekdays;\n        e = D({\n          a: k ? k[u] : d[u].substr(0, 3),\n          A: d[u],\n          d: v(p),\n          e: v(p, 2, \" \"),\n          w: u,\n          b: f.shortMonths[h],\n          B: f.months[h],\n          m: v(h + 1),\n          o: h + 1,\n          y: b.toString().substr(2, 2),\n          Y: b,\n          H: v(m),\n          k: m,\n          I: v(m % 12 || 12),\n          l: m % 12 || 12,\n          M: v(this.get(\"Minutes\", e)),\n          p: 12 > m ? \"AM\" : \"PM\",\n          P: 12 > m ? \"am\" : \"pm\",\n          S: v(e.getSeconds()),\n          L: v(Math.floor(w % 1E3), 3)\n        }, a.dateFormats);\n        t(e, function (b, d) {\n          for (; -1 !== g.indexOf(\"%\" + d);) g = g.replace(\"%\" + d, \"function\" === typeof b ? b.call(q, w) : b);\n        });\n        return l ? g.substr(0, 1).toUpperCase() + g.substr(1) : g;\n      }\n      resolveDTLFormat(g) {\n        return C(g, !0) ? g : (g = n(g), {\n          main: g[0],\n          from: g[1],\n          to: g[2]\n        });\n      }\n      getTimeTicks(g, w, l, q) {\n        const e = this,\n          m = [],\n          u = {};\n        var p = new e.Date(w);\n        const h = g.unitRange,\n          b = g.count || 1;\n        let f;\n        q = c(q, 1);\n        if (L(w)) {\n          e.set(\"Milliseconds\", p, h >= r.second ? 0 : b * Math.floor(e.get(\"Milliseconds\", p) / b));\n          h >= r.second && e.set(\"Seconds\", p, h >= r.minute ? 0 : b * Math.floor(e.get(\"Seconds\", p) / b));\n          h >= r.minute && e.set(\"Minutes\", p, h >= r.hour ? 0 : b * Math.floor(e.get(\"Minutes\", p) / b));\n          h >= r.hour && e.set(\"Hours\", p, h >= r.day ? 0 : b * Math.floor(e.get(\"Hours\", p) / b));\n          h >= r.day && e.set(\"Date\", p, h >= r.month ? 1 : Math.max(1, b * Math.floor(e.get(\"Date\", p) / b)));\n          if (h >= r.month) {\n            e.set(\"Month\", p, h >= r.year ? 0 : b * Math.floor(e.get(\"Month\", p) / b));\n            var d = e.get(\"FullYear\", p);\n          }\n          h >= r.year && e.set(\"FullYear\", p, d - d % b);\n          h === r.week && (d = e.get(\"Day\", p), e.set(\"Date\", p, e.get(\"Date\", p) - d + q + (d < q ? -7 : 0)));\n          d = e.get(\"FullYear\", p);\n          q = e.get(\"Month\", p);\n          const k = e.get(\"Date\", p),\n            g = e.get(\"Hours\", p);\n          w = p.getTime();\n          !e.variableTimezone && e.useUTC || !L(l) || (f = l - w > 4 * r.month || e.getTimezoneOffset(w) !== e.getTimezoneOffset(l));\n          w = p.getTime();\n          for (p = 1; w < l;) m.push(w), w = h === r.year ? e.makeTime(d + p * b, 0) : h === r.month ? e.makeTime(d, q + p * b) : !f || h !== r.day && h !== r.week ? f && h === r.hour && 1 < b ? e.makeTime(d, q, k, g + p * b) : w + h * b : e.makeTime(d, q, k + p * b * (h === r.day ? 1 : 7)), p++;\n          m.push(w);\n          h <= r.hour && 1E4 > m.length && m.forEach(function (b) {\n            0 === b % 18E5 && \"000000000\" === e.dateFormat(\"%H%M%S%L\", b) && (u[b] = \"day\");\n          });\n        }\n        m.info = D(g, {\n          higherRanks: u,\n          totalRange: h * b\n        });\n        return m;\n      }\n      getDateFormat(g, c, q, l) {\n        const e = this.dateFormat(\"%m-%d %H:%M:%S.%L\", c),\n          m = {\n            millisecond: 15,\n            second: 12,\n            minute: 9,\n            hour: 6,\n            day: 3\n          };\n        let u,\n          p = \"millisecond\";\n        for (u in r) {\n          if (g === r.week && +this.dateFormat(\"%w\", c) === q && \"00:00:00.000\" === e.substr(6)) {\n            u = \"week\";\n            break;\n          }\n          if (r[u] > g) {\n            u = p;\n            break;\n          }\n          if (m[u] && e.substr(m[u]) !== \"01-01 00:00:00.000\".substr(m[u])) break;\n          \"week\" !== u && (p = u);\n        }\n        return this.resolveDTLFormat(l[u]).main;\n      }\n    }\n    \"\";\n    return q;\n  });\n  M(a, \"Core/Defaults.js\", [a[\"Core/Chart/ChartDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Color/Palettes.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D) {\n    const {\n        isTouchDevice: x,\n        svg: z\n      } = G,\n      {\n        merge: t\n      } = D,\n      v = {\n        colors: L.colors,\n        symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n        lang: {\n          loading: \"Loading...\",\n          months: \"January February March April May June July August September October November December\".split(\" \"),\n          shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n          weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n          decimalPoint: \".\",\n          numericSymbols: \"kMGTPE\".split(\"\"),\n          resetZoom: \"Reset zoom\",\n          resetZoomTitle: \"Reset zoom level 1:1\",\n          thousandsSep: \" \"\n        },\n        global: {},\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: a,\n        title: {\n          text: \"Chart title\",\n          align: \"center\",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          text: \"\",\n          align: \"center\",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          text: \"\",\n          align: \"left\",\n          verticalAlign: \"bottom\"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: \"center\",\n          alignColumns: !0,\n          className: \"highcharts-no-tooltip\",\n          layout: \"horizontal\",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function () {\n            return this.name;\n          },\n          borderColor: \"#999999\",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: \"0.8em\"\n            },\n            activeColor: \"#0022ff\",\n            inactiveColor: \"#cccccc\"\n          },\n          itemStyle: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            textDecoration: \"none\",\n            textOverflow: \"ellipsis\"\n          },\n          itemHoverStyle: {\n            color: \"#000000\"\n          },\n          itemHiddenStyle: {\n            color: \"#666666\",\n            textDecoration: \"line-through\"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: \"absolute\",\n            width: \"13px\",\n            height: \"13px\"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: \"0.8em\",\n              fontWeight: \"bold\"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: \"bold\",\n            position: \"relative\",\n            top: \"45%\"\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#ffffff\",\n            opacity: .5,\n            textAlign: \"center\"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: z,\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n            second: \"%A, %e %b, %H:%M:%S\",\n            minute: \"%A, %e %b, %H:%M\",\n            hour: \"%A, %e %b, %H:%M\",\n            day: \"%A, %e %b %Y\",\n            week: \"Week from %A, %e %b %Y\",\n            month: \"%B %Y\",\n            year: \"%Y\"\n          },\n          footerFormat: \"\",\n          headerShape: \"callout\",\n          hideDelay: 500,\n          padding: 8,\n          shape: \"callout\",\n          shared: !1,\n          snap: x ? 25 : 10,\n          headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n          backgroundColor: \"#ffffff\",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: \"https://www.highcharts.com?credits\",\n          position: {\n            align: \"right\",\n            x: -10,\n            verticalAlign: \"bottom\",\n            y: -5\n          },\n          style: {\n            cursor: \"pointer\",\n            color: \"#999999\",\n            fontSize: \"0.6em\"\n          },\n          text: \"Highcharts.com\"\n        }\n      };\n    v.chart.styledMode = !1;\n    \"\";\n    const c = new A(v.time);\n    a = {\n      defaultOptions: v,\n      defaultTime: c,\n      getOptions: function () {\n        return v;\n      },\n      setOptions: function (n) {\n        t(!0, v, n);\n        if (n.time || n.global) G.time ? G.time.update(t(v.global, v.time, n.global, n.time)) : G.time = c;\n        return v;\n      }\n    };\n    \"\";\n    return a;\n  });\n  M(a, \"Core/Animation/Fx.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        parse: x\n      } = a,\n      {\n        win: A\n      } = y,\n      {\n        isNumber: D,\n        objectEach: C\n      } = G;\n    let z = /*#__PURE__*/(() => {\n      class z {\n        constructor(a, v, c) {\n          this.pos = NaN;\n          this.options = v;\n          this.elem = a;\n          this.prop = c;\n        }\n        dSetter() {\n          var a = this.paths;\n          const v = a && a[0];\n          a = a && a[1];\n          const c = this.now || 0;\n          let n = [];\n          if (1 !== c && v && a) {\n            if (v.length === a.length && 1 > c) for (let r = 0; r < a.length; r++) {\n              const l = v[r],\n                h = a[r],\n                q = [];\n              for (let g = 0; g < h.length; g++) {\n                const w = l[g],\n                  a = h[g];\n                D(w) && D(a) && (\"A\" !== h[0] || 4 !== g && 5 !== g) ? q[g] = w + c * (a - w) : q[g] = a;\n              }\n              n.push(q);\n            } else n = a;\n          } else n = this.toD || [];\n          this.elem.attr(\"d\", n, void 0, !0);\n        }\n        update() {\n          const a = this.elem,\n            v = this.prop,\n            c = this.now,\n            n = this.options.step;\n          if (this[v + \"Setter\"]) this[v + \"Setter\"]();else a.attr ? a.element && a.attr(v, c, null, !0) : a.style[v] = c + this.unit;\n          n && n.call(a, c, this);\n        }\n        run(a, v, c) {\n          const n = this,\n            r = n.options,\n            l = function (g) {\n              return l.stopped ? !1 : n.step(g);\n            },\n            h = A.requestAnimationFrame || function (g) {\n              setTimeout(g, 13);\n            },\n            q = function () {\n              for (let g = 0; g < z.timers.length; g++) z.timers[g]() || z.timers.splice(g--, 1);\n              z.timers.length && h(q);\n            };\n          a !== v || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = a, this.end = v, this.unit = c, this.now = this.start, this.pos = 0, l.elem = this.elem, l.prop = this.prop, l() && 1 === z.timers.push(l) && h(q)) : (delete r.curAnim[this.prop], r.complete && 0 === Object.keys(r.curAnim).length && r.complete.call(this.elem));\n        }\n        step(a) {\n          const v = +new Date(),\n            c = this.options,\n            n = this.elem,\n            r = c.complete,\n            l = c.duration,\n            h = c.curAnim;\n          let q;\n          n.attr && !n.element ? a = !1 : a || v >= l + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), q = h[this.prop] = !0, C(h, function (g) {\n            !0 !== g && (q = !1);\n          }), q && r && r.call(n), a = !1) : (this.pos = c.easing((v - this.startTime) / l), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0);\n          return a;\n        }\n        initPath(a, v, c) {\n          function n(e, m) {\n            for (; e.length < J;) {\n              var g = e[0];\n              const p = m[J - e.length];\n              p && \"M\" === g[0] && (e[0] = \"C\" === p[0] ? [\"C\", g[1], g[2], g[1], g[2], g[1], g[2]] : [\"L\", g[1], g[2]]);\n              e.unshift(g);\n              q && (g = e.pop(), e.push(e[e.length - 1], g));\n            }\n          }\n          function r(e, m) {\n            for (; e.length < J;) if (m = e[Math.floor(e.length / g) - 1].slice(), \"C\" === m[0] && (m[1] = m[5], m[2] = m[6]), q) {\n              const c = e[Math.floor(e.length / g)].slice();\n              e.splice(e.length / 2, 0, m, c);\n            } else e.push(m);\n          }\n          const l = a.startX,\n            h = a.endX;\n          c = c.slice();\n          const q = a.isArea,\n            g = q ? 2 : 1;\n          let w, J, F;\n          v = v && v.slice();\n          if (!v) return [c, c];\n          if (l && h && h.length) {\n            for (a = 0; a < l.length; a++) if (l[a] === h[0]) {\n              w = a;\n              break;\n            } else if (l[0] === h[h.length - l.length + a]) {\n              w = a;\n              F = !0;\n              break;\n            } else if (l[l.length - 1] === h[h.length - l.length + a]) {\n              w = l.length - a;\n              break;\n            }\n            \"undefined\" === typeof w && (v = []);\n          }\n          v.length && D(w) && (J = c.length + w * g, F ? (n(v, c), r(c, v)) : (n(c, v), r(v, c)));\n          return [v, c];\n        }\n        fillSetter() {\n          z.prototype.strokeSetter.apply(this, arguments);\n        }\n        strokeSetter() {\n          this.elem.attr(this.prop, x(this.start).tweenTo(x(this.end), this.pos), void 0, !0);\n        }\n      }\n      z.timers = [];\n      return z;\n    })();\n    return z;\n  });\n  M(a, \"Core/Animation/AnimationUtilities.js\", [a[\"Core/Animation/Fx.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x(c) {\n      return t(c) ? v({\n        duration: 500,\n        defer: 0\n      }, c) : {\n        duration: c ? 500 : 0,\n        defer: 0\n      };\n    }\n    function L(c, l) {\n      let h = a.timers.length;\n      for (; h--;) a.timers[h].elem !== c || l && l !== a.timers[h].prop || (a.timers[h].stopped = !0);\n    }\n    const {\n      defined: A,\n      getStyle: D,\n      isArray: C,\n      isNumber: z,\n      isObject: t,\n      merge: v,\n      objectEach: c,\n      pick: n\n    } = y;\n    return {\n      animate: function (n, l, h) {\n        let q,\n          g = \"\",\n          w,\n          J,\n          r;\n        t(h) || (r = arguments, h = {\n          duration: r[2],\n          easing: r[3],\n          complete: r[4]\n        });\n        z(h.duration) || (h.duration = 400);\n        h.easing = \"function\" === typeof h.easing ? h.easing : Math[h.easing] || Math.easeInOutSine;\n        h.curAnim = v(l);\n        c(l, function (e, m) {\n          L(n, m);\n          J = new a(n, h, m);\n          w = void 0;\n          \"d\" === m && C(l.d) ? (J.paths = J.initPath(n, n.pathArray, l.d), J.toD = l.d, q = 0, w = 1) : n.attr ? q = n.attr(m) : (q = parseFloat(D(n, m)) || 0, \"opacity\" !== m && (g = \"px\"));\n          w || (w = e);\n          \"string\" === typeof w && w.match(\"px\") && (w = w.replace(/px/g, \"\"));\n          J.run(q, w, g);\n        });\n      },\n      animObject: x,\n      getDeferredAnimation: function (c, l, a) {\n        const q = x(l);\n        let g = 0,\n          w = 0;\n        (a ? [a] : c.series).forEach(c => {\n          c = x(c.options.animation);\n          g = l && A(l.defer) ? q.defer : Math.max(g, c.duration + c.defer);\n          w = Math.min(q.duration, c.duration);\n        });\n        c.renderer.forExport && (g = 0);\n        return {\n          defer: Math.max(0, g - w),\n          duration: Math.min(g, w)\n        };\n      },\n      setAnimation: function (c, l) {\n        l.renderer.globalAnimation = n(c, l.options.chart.animation, !0);\n      },\n      stop: L\n    };\n  });\n  M(a, \"Core/Renderer/HTML/AST.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n        SVG_NS: x,\n        win: L\n      } = a,\n      {\n        attr: A,\n        createElement: D,\n        css: C,\n        error: z,\n        isFunction: t,\n        isString: v,\n        objectEach: c,\n        splat: n\n      } = y;\n    ({\n      trustedTypes: y\n    } = L);\n    const r = y && t(y.createPolicy) && y.createPolicy(\"highcharts\", {\n      createHTML: g => g\n    });\n    y = r ? r.createHTML(\"\") : \"\";\n    try {\n      var l = !!new DOMParser().parseFromString(y, \"text/html\");\n    } catch (g) {\n      l = !1;\n    }\n    const h = l;\n    class q {\n      static filterUserAttributes(g) {\n        c(g, (c, l) => {\n          let a = !0;\n          -1 === q.allowedAttributes.indexOf(l) && (a = !1);\n          -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(l) && (a = v(c) && q.allowedReferences.some(e => 0 === c.indexOf(e)));\n          a || (z(33, !1, void 0, {\n            \"Invalid attribute in config\": `${l}`\n          }), delete g[l]);\n          v(c) && g[l] && (g[l] = c.replace(/</g, \"&lt;\"));\n        });\n        return g;\n      }\n      static parseStyle(g) {\n        return g.split(\";\").reduce((g, c) => {\n          c = c.split(\":\").map(e => e.trim());\n          const l = c.shift();\n          l && c.length && (g[l.replace(/-([a-z])/g, e => e[1].toUpperCase())] = c.join(\":\"));\n          return g;\n        }, {});\n      }\n      static setElementHTML(g, c) {\n        g.innerHTML = q.emptyHTML;\n        c && new q(c).addToDOM(g);\n      }\n      constructor(g) {\n        this.nodes = \"string\" === typeof g ? this.parseMarkup(g) : g;\n      }\n      addToDOM(g) {\n        function l(g, h) {\n          let e;\n          n(g).forEach(function (m) {\n            var g = m.tagName;\n            const p = m.textContent ? a.doc.createTextNode(m.textContent) : void 0,\n              w = q.bypassHTMLFiltering;\n            let b;\n            if (g) if (\"#text\" === g) b = p;else if (-1 !== q.allowedTags.indexOf(g) || w) {\n              g = a.doc.createElementNS(\"svg\" === g ? x : h.namespaceURI || x, g);\n              const f = m.attributes || {};\n              c(m, function (b, k) {\n                \"tagName\" !== k && \"attributes\" !== k && \"children\" !== k && \"style\" !== k && \"textContent\" !== k && (f[k] = b);\n              });\n              A(g, w ? f : q.filterUserAttributes(f));\n              m.style && C(g, m.style);\n              p && g.appendChild(p);\n              l(m.children || [], g);\n              b = g;\n            } else z(33, !1, void 0, {\n              \"Invalid tagName in config\": g\n            });\n            b && h.appendChild(b);\n            e = b;\n          });\n          return e;\n        }\n        return l(this.nodes, g);\n      }\n      parseMarkup(g) {\n        const c = [];\n        g = g.trim().replace(/ style=([\"'])/g, \" data-style=$1\");\n        if (h) g = new DOMParser().parseFromString(r ? r.createHTML(g) : g, \"text/html\");else {\n          const c = D(\"div\");\n          c.innerHTML = g;\n          g = {\n            body: c\n          };\n        }\n        const l = (g, e) => {\n          var m = g.nodeName.toLowerCase();\n          const c = {\n            tagName: m\n          };\n          \"#text\" === m && (c.textContent = g.textContent || \"\");\n          if (m = g.attributes) {\n            const e = {};\n            [].forEach.call(m, p => {\n              \"data-style\" === p.name ? c.style = q.parseStyle(p.value) : e[p.name] = p.value;\n            });\n            c.attributes = e;\n          }\n          if (g.childNodes.length) {\n            const e = [];\n            [].forEach.call(g.childNodes, p => {\n              l(p, e);\n            });\n            e.length && (c.children = e);\n          }\n          e.push(c);\n        };\n        [].forEach.call(g.body.childNodes, g => l(g, c));\n        return c;\n      }\n    }\n    q.allowedAttributes = \"alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex\".split(\" \");\n    q.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n    q.allowedTags = \"a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text\".split(\" \");\n    q.emptyHTML = y;\n    q.bypassHTMLFiltering = !1;\n    \"\";\n    return q;\n  });\n  M(a, \"Core/FormatUtilities.js\", [a[\"Core/Defaults.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x(a, c, n, r) {\n      a = +a || 0;\n      c = +c;\n      const l = L.lang;\n      var h = (a.toString().split(\".\")[1] || \"\").split(\"e\")[0].length;\n      const q = a.toString().split(\"e\"),\n        g = c;\n      if (-1 === c) c = Math.min(h, 20);else if (!C(c)) c = 2;else if (c && q[1] && 0 > q[1]) {\n        var w = c + +q[1];\n        0 <= w ? (q[0] = (+q[0]).toExponential(w).split(\"e\")[0], c = w) : (q[0] = q[0].split(\".\")[0] || 0, a = 20 > c ? (q[0] * Math.pow(10, q[1])).toFixed(c) : 0, q[1] = 0);\n      }\n      w = (Math.abs(q[1] ? q[0] : a) + Math.pow(10, -Math.max(c, h) - 1)).toFixed(c);\n      h = String(t(w));\n      const J = 3 < h.length ? h.length % 3 : 0;\n      n = z(n, l.decimalPoint);\n      r = z(r, l.thousandsSep);\n      a = (0 > a ? \"-\" : \"\") + (J ? h.substr(0, J) + r : \"\");\n      a = 0 > +q[1] && !g ? \"0\" : a + h.substr(J).replace(/(\\d{3})(?=\\d)/g, \"$1\" + r);\n      c && (a += n + w.slice(-c));\n      q[1] && 0 !== +a && (a += \"e\" + q[1]);\n      return a;\n    }\n    const {\n        defaultOptions: L,\n        defaultTime: A\n      } = a,\n      {\n        getNestedProperty: D,\n        isNumber: C,\n        pick: z,\n        pInt: t\n      } = y;\n    return {\n      dateFormat: function (a, c, n) {\n        return A.dateFormat(a, c, n);\n      },\n      format: function (a, c, n) {\n        var r = \"{\";\n        let l = !1;\n        let h;\n        const q = /f$/,\n          g = /\\.([0-9])/,\n          w = L.lang,\n          J = n && n.time || A;\n        n = n && n.numberFormatter || x;\n        const F = [];\n        for (; a;) {\n          h = a.indexOf(r);\n          if (-1 === h) break;\n          var e = a.slice(0, h);\n          if (l) {\n            e = e.split(\":\");\n            r = D(e.shift() || \"\", c);\n            if (e.length && \"number\" === typeof r) if (e = e.join(\":\"), q.test(e)) {\n              const m = parseInt((e.match(g) || [\"\", \"-1\"])[1], 10);\n              null !== r && (r = n(r, m, w.decimalPoint, -1 < e.indexOf(\",\") ? w.thousandsSep : \"\"));\n            } else r = J.dateFormat(e, r);\n            F.push(r);\n          } else F.push(e);\n          a = a.slice(h + 1);\n          r = (l = !l) ? \"}\" : \"{\";\n        }\n        F.push(a);\n        return F.join(\"\");\n      },\n      numberFormat: x\n    };\n  });\n  M(a, \"Core/Renderer/RendererUtilities.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      clamp: x,\n      pick: G,\n      stableSort: L\n    } = a;\n    var A;\n    (function (a) {\n      function y(a, t, v) {\n        const c = a;\n        var n = c.reducedLen || t,\n          r = (g, c) => (c.rank || 0) - (g.rank || 0);\n        const l = (g, c) => g.target - c.target;\n        let h,\n          q = !0,\n          g = [],\n          w = 0;\n        for (h = a.length; h--;) w += a[h].size;\n        if (w > n) {\n          L(a, r);\n          for (w = h = 0; w <= n;) w += a[h].size, h++;\n          g = a.splice(h - 1, a.length);\n        }\n        L(a, l);\n        for (a = a.map(g => ({\n          size: g.size,\n          targets: [g.target],\n          align: G(g.align, .5)\n        })); q;) {\n          for (h = a.length; h--;) n = a[h], r = (Math.min.apply(0, n.targets) + Math.max.apply(0, n.targets)) / 2, n.pos = x(r - n.size * n.align, 0, t - n.size);\n          h = a.length;\n          for (q = !1; h--;) 0 < h && a[h - 1].pos + a[h - 1].size > a[h].pos && (a[h - 1].size += a[h].size, a[h - 1].targets = a[h - 1].targets.concat(a[h].targets), a[h - 1].align = .5, a[h - 1].pos + a[h - 1].size > t && (a[h - 1].pos = t - a[h - 1].size), a.splice(h, 1), q = !0);\n        }\n        c.push.apply(c, g);\n        h = 0;\n        a.some(g => {\n          let a = 0;\n          return (g.targets || []).some(() => {\n            c[h].pos = g.pos + a;\n            if (\"undefined\" !== typeof v && Math.abs(c[h].pos - c[h].target) > v) return c.slice(0, h + 1).forEach(e => delete e.pos), c.reducedLen = (c.reducedLen || t) - .1 * t, c.reducedLen > .1 * t && y(c, t, v), !0;\n            a += c[h].size;\n            h++;\n            return !1;\n          });\n        });\n        L(c, l);\n        return c;\n      }\n      a.distribute = y;\n    })(A || (A = {}));\n    return A;\n  });\n  M(a, \"Core/Renderer/SVG/SVGElement.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L) {\n    const {\n        animate: x,\n        animObject: D,\n        stop: C\n      } = a,\n      {\n        deg2rad: z,\n        doc: t,\n        svg: v,\n        SVG_NS: c,\n        win: n\n      } = G,\n      {\n        addEvent: r,\n        attr: l,\n        createElement: h,\n        css: q,\n        defined: g,\n        erase: w,\n        extend: J,\n        fireEvent: F,\n        isArray: e,\n        isFunction: m,\n        isObject: u,\n        isString: p,\n        merge: H,\n        objectEach: b,\n        pick: f,\n        pInt: d,\n        syncTimeout: k,\n        uniqueKey: O\n      } = L;\n    class N {\n      constructor() {\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = c;\n      }\n      _defaultGetter(b) {\n        b = f(this[b + \"Value\"], this[b], this.element ? this.element.getAttribute(b) : null, 0);\n        /^[\\-0-9\\.]+$/.test(b) && (b = parseFloat(b));\n        return b;\n      }\n      _defaultSetter(b, d, f) {\n        f.setAttribute(d, b);\n      }\n      add(b) {\n        const d = this.renderer,\n          f = this.element;\n        let k;\n        b && (this.parentGroup = b);\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && d.buildText(this);\n        this.added = !0;\n        if (!b || b.handleZ || this.zIndex) k = this.zIndexSetter();\n        k || (b ? b.element : d.box).appendChild(f);\n        if (this.onAdd) this.onAdd();\n        return this;\n      }\n      addClass(b, d) {\n        const f = d ? \"\" : this.attr(\"class\") || \"\";\n        b = (b || \"\").split(/ /g).reduce(function (b, d) {\n          -1 === f.indexOf(d) && b.push(d);\n          return b;\n        }, f ? [f] : []).join(\" \");\n        b !== f && this.attr(\"class\", b);\n        return this;\n      }\n      afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      }\n      align(b, d, k) {\n        const e = {};\n        var K = this.renderer,\n          m = K.alignedObjects,\n          g;\n        let E, c;\n        if (b) {\n          if (this.alignOptions = b, this.alignByTranslate = d, !k || p(k)) this.alignTo = g = k || \"renderer\", w(m, this), m.push(this), k = void 0;\n        } else b = this.alignOptions, d = this.alignByTranslate, g = this.alignTo;\n        k = f(k, K[g], \"scrollablePlotBox\" === g ? K.plotBox : void 0, K);\n        g = b.align;\n        const B = b.verticalAlign;\n        K = (k.x || 0) + (b.x || 0);\n        m = (k.y || 0) + (b.y || 0);\n        \"right\" === g ? E = 1 : \"center\" === g && (E = 2);\n        E && (K += (k.width - (b.width || 0)) / E);\n        e[d ? \"translateX\" : \"x\"] = Math.round(K);\n        \"bottom\" === B ? c = 1 : \"middle\" === B && (c = 2);\n        c && (m += (k.height - (b.height || 0)) / c);\n        e[d ? \"translateY\" : \"y\"] = Math.round(m);\n        this[this.placed ? \"animate\" : \"attr\"](e);\n        this.placed = !0;\n        this.alignAttr = e;\n        return this;\n      }\n      alignSetter(b) {\n        const d = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        d[b] && (this.alignValue = b, this.element.setAttribute(\"text-anchor\", d[b]));\n      }\n      animate(d, e, p) {\n        const m = D(f(e, this.renderer.globalAnimation, !0));\n        e = m.defer;\n        t.hidden && (m.duration = 0);\n        0 !== m.duration ? (p && (m.complete = p), k(() => {\n          this.element && x(this, d, m);\n        }, e)) : (this.attr(d, void 0, p || m.complete), b(d, function (b, d) {\n          m.step && m.step.call(this, b, {\n            prop: d,\n            pos: 1,\n            elem: this\n          });\n        }, this));\n        return this;\n      }\n      applyTextOutline(b) {\n        const d = this.element;\n        -1 !== b.indexOf(\"contrast\") && (b = b.replace(/contrast/g, this.renderer.getContrast(d.style.fill)));\n        var f = b.split(\" \");\n        b = f[f.length - 1];\n        if ((f = f[0]) && \"none\" !== f && G.svg) {\n          this.fakeTS = !0;\n          f = f.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, d, f) {\n            return 2 * Number(d) + f;\n          });\n          this.removeTextOutline();\n          const k = t.createElementNS(c, \"tspan\");\n          l(k, {\n            \"class\": \"highcharts-text-outline\",\n            fill: b,\n            stroke: b,\n            \"stroke-width\": f,\n            \"stroke-linejoin\": \"round\"\n          });\n          b = d.querySelector(\"textPath\") || d;\n          [].forEach.call(b.childNodes, b => {\n            const d = b.cloneNode(!0);\n            d.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(b => d.removeAttribute(b));\n            k.appendChild(d);\n          });\n          let e = 0;\n          [].forEach.call(b.querySelectorAll(\"text tspan\"), b => {\n            e += Number(b.getAttribute(\"dy\"));\n          });\n          f = t.createElementNS(c, \"tspan\");\n          f.textContent = \"\\u200b\";\n          l(f, {\n            x: Number(d.getAttribute(\"x\")),\n            dy: -e\n          });\n          k.appendChild(f);\n          b.insertBefore(k, b.firstChild);\n        }\n      }\n      attr(d, f, k, e) {\n        const K = this.element,\n          p = N.symbolCustomAttribs;\n        let m,\n          g,\n          c = this,\n          B,\n          E;\n        \"string\" === typeof d && \"undefined\" !== typeof f && (m = d, d = {}, d[m] = f);\n        \"string\" === typeof d ? c = (this[d + \"Getter\"] || this._defaultGetter).call(this, d, K) : (b(d, function (b, f) {\n          B = !1;\n          e || C(this, f);\n          this.symbolName && -1 !== p.indexOf(f) && (g || (this.symbolAttr(d), g = !0), B = !0);\n          !this.rotation || \"x\" !== f && \"y\" !== f || (this.doTransform = !0);\n          B || (E = this[f + \"Setter\"] || this._defaultSetter, E.call(this, b, f, K));\n        }, this), this.afterSetters());\n        k && k.call(this);\n        return c;\n      }\n      clip(b) {\n        return this.attr(\"clip-path\", b ? \"url(\" + this.renderer.url + \"#\" + b.id + \")\" : \"none\");\n      }\n      crisp(b, d) {\n        d = d || b.strokeWidth || 0;\n        const f = Math.round(d) % 2 / 2;\n        b.x = Math.floor(b.x || this.x || 0) + f;\n        b.y = Math.floor(b.y || this.y || 0) + f;\n        b.width = Math.floor((b.width || this.width || 0) - 2 * f);\n        b.height = Math.floor((b.height || this.height || 0) - 2 * f);\n        g(b.strokeWidth) && (b.strokeWidth = d);\n        return b;\n      }\n      complexColor(d, f, k) {\n        const p = this.renderer;\n        let K,\n          m,\n          c,\n          a,\n          E,\n          B,\n          l,\n          I,\n          q,\n          u,\n          h = [],\n          w;\n        F(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          d.radialGradient ? m = \"radialGradient\" : d.linearGradient && (m = \"linearGradient\");\n          if (m) {\n            c = d[m];\n            E = p.gradients;\n            B = d.stops;\n            q = k.radialReference;\n            e(c) && (d[m] = c = {\n              x1: c[0],\n              y1: c[1],\n              x2: c[2],\n              y2: c[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === m && q && !g(c.gradientUnits) && (a = c, c = H(c, p.getRadialAttr(q, a), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            b(c, function (b, d) {\n              \"id\" !== d && h.push(d, b);\n            });\n            b(B, function (b) {\n              h.push(b);\n            });\n            h = h.join(\",\");\n            if (E[h]) u = E[h].attr(\"id\");else {\n              c.id = u = O();\n              const b = E[h] = p.createElement(m).attr(c).add(p.defs);\n              b.radAttr = a;\n              b.stops = [];\n              B.forEach(function (d) {\n                0 === d[1].indexOf(\"rgba\") ? (K = y.parse(d[1]), l = K.get(\"rgb\"), I = K.get(\"a\")) : (l = d[1], I = 1);\n                d = p.createElement(\"stop\").attr({\n                  offset: d[0],\n                  \"stop-color\": l,\n                  \"stop-opacity\": I\n                }).add(b);\n                b.stops.push(d);\n              });\n            }\n            w = \"url(\" + p.url + \"#\" + u + \")\";\n            k.setAttribute(f, w);\n            k.gradient = h;\n            d.toString = function () {\n              return w;\n            };\n          }\n        });\n      }\n      css(f) {\n        const k = this.styles,\n          e = {},\n          p = this.element;\n        let K,\n          m = !k;\n        f.color && (f.fill = f.color);\n        k && b(f, function (b, d) {\n          k && k[d] !== b && (e[d] = b, m = !0);\n        });\n        if (m) {\n          k && (f = J(k, e));\n          null === f.width || \"auto\" === f.width ? delete this.textWidth : \"text\" === p.nodeName.toLowerCase() && f.width && (K = this.textWidth = d(f.width));\n          this.styles = f;\n          K && !v && this.renderer.forExport && delete f.width;\n          const b = H(f);\n          p.namespaceURI === this.SVG_NS && [\"textOutline\", \"textOverflow\", \"width\"].forEach(d => b && delete b[d]);\n          q(p, b);\n        }\n        this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), f.textOutline && this.applyTextOutline(f.textOutline));\n        return this;\n      }\n      dashstyleSetter(b) {\n        let k = this[\"stroke-width\"];\n        \"inherit\" === k && (k = 1);\n        if (b = b && b.toLowerCase()) {\n          const e = b.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n          for (b = e.length; b--;) e[b] = \"\" + d(e[b]) * f(k, NaN);\n          b = e.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", b);\n        }\n      }\n      destroy() {\n        const d = this;\n        var f = d.element || {};\n        const k = d.renderer;\n        var e = f.ownerSVGElement;\n        let p = \"SPAN\" === f.nodeName && d.parentGroup || void 0;\n        f.onclick = f.onmouseout = f.onmouseover = f.onmousemove = f.point = null;\n        C(d);\n        if (d.clipPath && e) {\n          const b = d.clipPath;\n          [].forEach.call(e.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (d) {\n            -1 < d.getAttribute(\"clip-path\").indexOf(b.element.id) && d.removeAttribute(\"clip-path\");\n          });\n          d.clipPath = b.destroy();\n        }\n        if (d.stops) {\n          for (e = 0; e < d.stops.length; e++) d.stops[e].destroy();\n          d.stops.length = 0;\n          d.stops = void 0;\n        }\n        for (d.safeRemoveChild(f); p && p.div && 0 === p.div.childNodes.length;) f = p.parentGroup, d.safeRemoveChild(p.div), delete p.div, p = f;\n        d.alignTo && w(k.alignedObjects, d);\n        b(d, function (b, f) {\n          d[f] && d[f].parentGroup === d && d[f].destroy && d[f].destroy();\n          delete d[f];\n        });\n      }\n      dSetter(b, d, f) {\n        e(b) && (\"string\" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce((b, d, f) => d && d.join ? (f ? b + \" \" : \"\") + d.join(\" \") : (d || \"\").toString(), \"\"));\n        /(NaN| {2}|^$)/.test(b) && (b = \"M 0 0\");\n        this[d] !== b && (f.setAttribute(d, b), this[d] = b);\n      }\n      fadeOut(b) {\n        const d = this;\n        d.animate({\n          opacity: 0\n        }, {\n          duration: f(b, 150),\n          complete: function () {\n            d.hide();\n          }\n        });\n      }\n      fillSetter(b, d, f) {\n        \"string\" === typeof b ? f.setAttribute(d, b) : b && this.complexColor(b, d, f);\n      }\n      getBBox(b, d) {\n        const {\n            alignValue: k,\n            element: e,\n            renderer: p,\n            styles: c,\n            textStr: a\n          } = this,\n          {\n            cache: l,\n            cacheKeys: u\n          } = p;\n        var B = e.namespaceURI === this.SVG_NS;\n        d = f(d, this.rotation, 0);\n        var P = p.styledMode ? e && N.prototype.getStyle.call(e, \"font-size\") : c && c.fontSize;\n        let I;\n        let h;\n        g(a) && (h = a.toString(), -1 === h.indexOf(\"<\") && (h = h.replace(/[0-9]/g, \"0\")), h += [\"\", p.rootFontSize, P, d, this.textWidth, k, c && c.textOverflow, c && c.fontWeight].join());\n        h && !b && (I = l[h]);\n        if (!I) {\n          if (B || p.forExport) {\n            try {\n              var E = this.fakeTS && function (b) {\n                const d = e.querySelector(\".highcharts-text-outline\");\n                d && q(d, {\n                  display: b\n                });\n              };\n              m(E) && E(\"none\");\n              I = e.getBBox ? J({}, e.getBBox()) : {\n                width: e.offsetWidth,\n                height: e.offsetHeight,\n                x: 0,\n                y: 0\n              };\n              m(E) && E(\"\");\n            } catch (ha) {\n              \"\";\n            }\n            if (!I || 0 > I.width) I = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n          } else I = this.htmlGetBBox();\n          E = I.width;\n          b = I.height;\n          B && (I.height = b = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[`${P || \"\"},${Math.round(b)}`] || b);\n          if (d) {\n            B = Number(e.getAttribute(\"y\") || 0) - I.y;\n            P = {\n              right: 1,\n              center: .5\n            }[k || 0] || 0;\n            var w = d * z,\n              n = (d - 90) * z,\n              r = E * Math.cos(w);\n            d = E * Math.sin(w);\n            var H = Math.cos(n);\n            w = Math.sin(n);\n            E = I.x + P * (E - r) + B * H;\n            n = E + r;\n            H = n - b * H;\n            r = H - r;\n            B = I.y + B - P * d + B * w;\n            P = B + d;\n            b = P - b * w;\n            d = b - d;\n            I.x = Math.min(E, n, H, r);\n            I.y = Math.min(B, P, b, d);\n            I.width = Math.max(E, n, H, r) - I.x;\n            I.height = Math.max(B, P, b, d) - I.y;\n          }\n        }\n        if (h && (\"\" === a || 0 < I.height)) {\n          for (; 250 < u.length;) delete l[u.shift()];\n          l[h] || u.push(h);\n          l[h] = I;\n        }\n        return I;\n      }\n      getStyle(b) {\n        return n.getComputedStyle(this.element || this, \"\").getPropertyValue(b);\n      }\n      hasClass(b) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(b);\n      }\n      hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      }\n      htmlGetBBox() {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      }\n      init(b, d) {\n        this.element = \"span\" === d ? h(d) : t.createElementNS(this.SVG_NS, d);\n        this.renderer = b;\n        F(this, \"afterInit\");\n      }\n      on(b, d) {\n        const {\n          onEvents: f\n        } = this;\n        if (f[b]) f[b]();\n        f[b] = r(this.element, b, d);\n        return this;\n      }\n      opacitySetter(b, d, f) {\n        this.opacity = b = Number(Number(b).toFixed(3));\n        f.setAttribute(d, b);\n      }\n      removeClass(b) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(p(b) ? new RegExp(`(^| )${b}( |$)`) : b, \" \").replace(/ +/g, \" \").trim());\n      }\n      removeTextOutline() {\n        const b = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        b && this.safeRemoveChild(b);\n      }\n      safeRemoveChild(b) {\n        const d = b.parentNode;\n        d && d.removeChild(b);\n      }\n      setRadialReference(b) {\n        const d = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = b;\n        d && d.radAttr && d.animate(this.renderer.getRadialAttr(b, d.radAttr));\n        return this;\n      }\n      setTextPath(b, d) {\n        d = H(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, d);\n        const f = this.renderer.url,\n          k = this.text || this,\n          e = k.textPath,\n          {\n            attributes: p,\n            enabled: m\n          } = d;\n        b = b || e && e.path;\n        e && e.undo();\n        b && m ? (d = r(k, \"afterModifyTree\", d => {\n          if (b && m) {\n            let B = b.attr(\"id\");\n            B || b.attr(\"id\", B = O());\n            var e = {\n              x: 0,\n              y: 0\n            };\n            g(p.dx) && (e.dx = p.dx, delete p.dx);\n            g(p.dy) && (e.dy = p.dy, delete p.dy);\n            k.attr(e);\n            this.attr({\n              transform: \"\"\n            });\n            this.box && (this.box = this.box.destroy());\n            e = d.nodes.slice(0);\n            d.nodes.length = 0;\n            d.nodes[0] = {\n              tagName: \"textPath\",\n              attributes: J(p, {\n                \"text-anchor\": p.textAnchor,\n                href: `${f}#${B}`\n              }),\n              children: e\n            };\n          }\n        }), k.textPath = {\n          path: b,\n          undo: d\n        }) : (k.attr({\n          dx: 0,\n          dy: 0\n        }), delete k.textPath);\n        this.added && (k.textCache = \"\", this.renderer.buildText(k));\n        return this;\n      }\n      shadow(b) {\n        var d;\n        const {\n            renderer: f\n          } = this,\n          k = H(90 === (null === (d = this.parentGroup) || void 0 === d ? void 0 : d.rotation) ? {\n            offsetX: -1,\n            offsetY: -1\n          } : {}, u(b) ? b : {});\n        d = f.shadowDefinition(k);\n        return this.attr({\n          filter: b ? `url(${f.url}#${d})` : \"none\"\n        });\n      }\n      show(b = !0) {\n        return this.attr({\n          visibility: b ? \"inherit\" : \"visible\"\n        });\n      }\n      [\"stroke-widthSetter\"](b, d, f) {\n        this[d] = b;\n        f.setAttribute(d, b);\n      }\n      strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        const b = this.getStyle(\"stroke-width\");\n        let f = 0,\n          k;\n        b.indexOf(\"px\") === b.length - 2 ? f = d(b) : \"\" !== b && (k = t.createElementNS(c, \"rect\"), l(k, {\n          width: b,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(k), f = k.getBBox().width, k.parentNode.removeChild(k));\n        return f;\n      }\n      symbolAttr(b) {\n        const d = this;\n        N.symbolCustomAttribs.forEach(function (k) {\n          d[k] = f(b[k], d[k]);\n        });\n        d.attr({\n          d: d.renderer.symbols[d.symbolName](d.x, d.y, d.width, d.height, d)\n        });\n      }\n      textSetter(b) {\n        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));\n      }\n      titleSetter(b) {\n        const d = this.element,\n          k = d.getElementsByTagName(\"title\")[0] || t.createElementNS(this.SVG_NS, \"title\");\n        d.insertBefore ? d.insertBefore(k, d.firstChild) : d.appendChild(k);\n        k.textContent = String(f(b, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      }\n      toFront() {\n        const b = this.element;\n        b.parentNode.appendChild(b);\n        return this;\n      }\n      translate(b, d) {\n        return this.attr({\n          translateX: b,\n          translateY: d\n        });\n      }\n      updateTransform() {\n        const {\n            element: b,\n            matrix: d,\n            rotation: k = 0,\n            scaleX: e,\n            scaleY: p,\n            translateX: m = 0,\n            translateY: c = 0\n          } = this,\n          a = [\"translate(\" + m + \",\" + c + \")\"];\n        g(d) && a.push(\"matrix(\" + d.join(\",\") + \")\");\n        k && a.push(\"rotate(\" + k + \" \" + f(this.rotationOriginX, b.getAttribute(\"x\"), 0) + \" \" + f(this.rotationOriginY, b.getAttribute(\"y\") || 0) + \")\");\n        (g(e) || g(p)) && a.push(\"scale(\" + f(e, 1) + \" \" + f(p, 1) + \")\");\n        a.length && !(this.text || this).textPath && b.setAttribute(\"transform\", a.join(\" \"));\n      }\n      visibilitySetter(b, d, f) {\n        \"inherit\" === b ? f.removeAttribute(d) : this[d] !== b && f.setAttribute(d, b);\n        this[d] = b;\n      }\n      xGetter(b) {\n        \"circle\" === this.element.nodeName && (\"x\" === b ? b = \"cx\" : \"y\" === b && (b = \"cy\"));\n        return this._defaultGetter(b);\n      }\n      zIndexSetter(b, f) {\n        var k = this.renderer,\n          e = this.parentGroup;\n        const p = (e || k).element || k.box,\n          m = this.element;\n        k = p === k.box;\n        let c = !1,\n          a;\n        var l = this.added;\n        let B;\n        g(b) ? (m.setAttribute(\"data-z-index\", b), b = +b, this[f] === b && (l = !1)) : g(this[f]) && m.removeAttribute(\"data-z-index\");\n        this[f] = b;\n        if (l) {\n          (b = this.zIndex) && e && (e.handleZ = !0);\n          f = p.childNodes;\n          for (B = f.length - 1; 0 <= B && !c; B--) if (e = f[B], l = e.getAttribute(\"data-z-index\"), a = !g(l), e !== m) if (0 > b && a && !k && !B) p.insertBefore(m, f[B]), c = !0;else if (d(l) <= b || a && (!g(b) || 0 <= b)) p.insertBefore(m, f[B + 1]), c = !0;\n          c || (p.insertBefore(m, f[k ? 3 : 0]), c = !0);\n        }\n        return c;\n      }\n    }\n    N.symbolCustomAttribs = \"anchorX anchorY clockwise end height innerR r start width x y\".split(\" \");\n    N.prototype.strokeSetter = N.prototype.fillSetter;\n    N.prototype.yGetter = N.prototype.xGetter;\n    N.prototype.matrixSetter = N.prototype.rotationOriginXSetter = N.prototype.rotationOriginYSetter = N.prototype.rotationSetter = N.prototype.scaleXSetter = N.prototype.scaleYSetter = N.prototype.translateXSetter = N.prototype.translateYSetter = N.prototype.verticalAlignSetter = function (b, d) {\n      this[d] = b;\n      this.doTransform = !0;\n    };\n    \"\";\n    return N;\n  });\n  M(a, \"Core/Renderer/RendererRegistry.js\", [a[\"Core/Globals.js\"]], function (a) {\n    var x;\n    (function (x) {\n      x.rendererTypes = {};\n      let y;\n      x.getRendererType = function (a = y) {\n        return x.rendererTypes[a] || x.rendererTypes[y];\n      };\n      x.registerRendererType = function (A, D, C) {\n        x.rendererTypes[A] = D;\n        if (!y || C) y = A, a.Renderer = D;\n      };\n    })(x || (x = {}));\n    return x;\n  });\n  M(a, \"Core/Renderer/SVG/SVGLabel.js\", [a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n      defined: x,\n      extend: L,\n      isNumber: A,\n      merge: D,\n      pick: C,\n      removeEvent: z\n    } = y;\n    class t extends a {\n      constructor(a, c, n, r, l, h, q, g, w, J) {\n        super();\n        this.paddingRightSetter = this.paddingLeftSetter = this.paddingSetter;\n        this.init(a, \"g\");\n        this.textStr = c;\n        this.x = n;\n        this.y = r;\n        this.anchorX = h;\n        this.anchorY = q;\n        this.baseline = w;\n        this.className = J;\n        this.addClass(\"button\" === J ? \"highcharts-no-tooltip\" : \"highcharts-label\");\n        J && this.addClass(\"highcharts-\" + J);\n        this.text = a.text(void 0, 0, 0, g).attr({\n          zIndex: 1\n        });\n        let F;\n        \"string\" === typeof l && ((F = /^url\\((.*?)\\)$/.test(l)) || this.renderer.symbols[l]) && (this.symbolKey = l);\n        this.bBox = t.emptyBBox;\n        this.padding = 3;\n        this.baselineOffset = 0;\n        this.needsBox = a.styledMode || F;\n        this.deferredAttr = {};\n        this.alignFactor = 0;\n      }\n      alignSetter(a) {\n        a = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[a];\n        a !== this.alignFactor && (this.alignFactor = a, this.bBox && A(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      }\n      anchorXSetter(a, c) {\n        this.anchorX = a;\n        this.boxAttr(c, Math.round(a) - this.getCrispAdjust() - this.xSetting);\n      }\n      anchorYSetter(a, c) {\n        this.anchorY = a;\n        this.boxAttr(c, a - this.ySetting);\n      }\n      boxAttr(a, c) {\n        this.box ? this.box.attr(a, c) : this.deferredAttr[a] = c;\n      }\n      css(v) {\n        if (v) {\n          const c = {};\n          v = D(v);\n          t.textProps.forEach(a => {\n            \"undefined\" !== typeof v[a] && (c[a] = v[a], delete v[a]);\n          });\n          this.text.css(c);\n          \"fontSize\" in c || \"fontWeight\" in c ? this.updateTextPadding() : (\"width\" in c || \"textOverflow\" in c) && this.updateBoxSize();\n        }\n        return a.prototype.css.call(this, v);\n      }\n      destroy() {\n        z(this.element, \"mouseenter\");\n        z(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        a.prototype.destroy.call(this);\n      }\n      fillSetter(a, c) {\n        a && (this.needsBox = !0);\n        this.fill = a;\n        this.boxAttr(c, a);\n      }\n      getBBox() {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        const a = this.padding,\n          c = C(this.paddingLeft, a);\n        return {\n          width: this.width,\n          height: this.height,\n          x: this.bBox.x - c,\n          y: this.bBox.y - a\n        };\n      }\n      getCrispAdjust() {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      }\n      heightSetter(a) {\n        this.heightSetting = a;\n      }\n      onAdd() {\n        this.text.add(this);\n        this.attr({\n          text: C(this.textStr, \"\"),\n          x: this.x || 0,\n          y: this.y || 0\n        });\n        this.box && x(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      }\n      paddingSetter(a, c) {\n        A(a) ? a !== this[c] && (this[c] = a, this.updateTextPadding()) : this[c] = void 0;\n      }\n      rSetter(a, c) {\n        this.boxAttr(c, a);\n      }\n      strokeSetter(a, c) {\n        this.stroke = a;\n        this.boxAttr(c, a);\n      }\n      [\"stroke-widthSetter\"](a, c) {\n        a && (this.needsBox = !0);\n        this[\"stroke-width\"] = a;\n        this.boxAttr(c, a);\n      }\n      [\"text-alignSetter\"](a) {\n        this.textAlign = a;\n      }\n      textSetter(a) {\n        \"undefined\" !== typeof a && this.text.attr({\n          text: a\n        });\n        this.updateTextPadding();\n      }\n      updateBoxSize() {\n        var a = this.text;\n        const c = {},\n          n = this.padding,\n          r = this.bBox = A(this.widthSetting) && A(this.heightSetting) && !this.textAlign || !x(a.textStr) ? t.emptyBBox : a.getBBox();\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || r.height || 0) + 2 * n;\n        const l = this.renderer.fontMetrics(a);\n        this.baselineOffset = n + Math.min((this.text.firstLineMetrics || l).b, r.height || Infinity);\n        this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2);\n        this.needsBox && !a.textPath && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), a.add(this)), a = this.getCrispAdjust(), c.x = a, c.y = (this.baseline ? -this.baselineOffset : 0) + a, c.width = Math.round(this.width), c.height = Math.round(this.height), this.box.attr(L(c, this.deferredAttr)), this.deferredAttr = {});\n      }\n      updateTextPadding() {\n        const a = this.text;\n        if (!a.textPath) {\n          this.updateBoxSize();\n          const c = this.baseline ? 0 : this.baselineOffset;\n          let n = C(this.paddingLeft, this.padding);\n          x(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (n += {\n            center: .5,\n            right: 1\n          }[this.textAlign] * (this.widthSetting - this.bBox.width));\n          if (n !== a.x || c !== a.y) a.attr(\"x\", n), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)), \"undefined\" !== typeof c && a.attr(\"y\", c);\n          a.x = n;\n          a.y = c;\n        }\n      }\n      widthSetter(a) {\n        this.widthSetting = A(a) ? a : void 0;\n      }\n      getPaddedWidth() {\n        var a = this.padding;\n        const c = C(this.paddingLeft, a);\n        a = C(this.paddingRight, a);\n        return (this.widthSetting || this.bBox.width || 0) + c + a;\n      }\n      xSetter(a) {\n        this.x = a;\n        this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(a);\n        this.attr(\"translateX\", this.xSetting);\n      }\n      ySetter(a) {\n        this.ySetting = this.y = Math.round(a);\n        this.attr(\"translateY\", this.ySetting);\n      }\n    }\n    t.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n    t.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width\".split(\" \");\n    return t;\n  });\n  M(a, \"Core/Renderer/SVG/Symbols.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function x(a, t, v, c, n) {\n      const r = [];\n      if (n) {\n        const l = n.start || 0,\n          h = C(n.r, v);\n        v = C(n.r, c || v);\n        c = (n.end || 0) - .001;\n        const q = n.innerR,\n          g = C(n.open, .001 > Math.abs((n.end || 0) - l - 2 * Math.PI)),\n          w = Math.cos(l),\n          J = Math.sin(l),\n          F = Math.cos(c),\n          e = Math.sin(c),\n          m = C(n.longArc, .001 > c - l - Math.PI ? 0 : 1);\n        let u = [\"A\", h, v, 0, m, C(n.clockwise, 1), a + h * F, t + v * e];\n        u.params = {\n          start: l,\n          end: c,\n          cx: a,\n          cy: t\n        };\n        r.push([\"M\", a + h * w, t + v * J], u);\n        A(q) && (u = [\"A\", q, q, 0, m, A(n.clockwise) ? 1 - n.clockwise : 0, a + q * w, t + q * J], u.params = {\n          start: c,\n          end: l,\n          cx: a,\n          cy: t\n        }, r.push(g ? [\"M\", a + q * F, t + q * e] : [\"L\", a + q * F, t + q * e], u));\n        g || r.push([\"Z\"]);\n      }\n      return r;\n    }\n    function G(a, t, v, c, n) {\n      return n && n.r ? L(a, t, v, c, n) : [[\"M\", a, t], [\"L\", a + v, t], [\"L\", a + v, t + c], [\"L\", a, t + c], [\"Z\"]];\n    }\n    function L(a, t, v, c, n) {\n      n = (null === n || void 0 === n ? void 0 : n.r) || 0;\n      return [[\"M\", a + n, t], [\"L\", a + v - n, t], [\"A\", n, n, 0, 0, 1, a + v, t + n], [\"L\", a + v, t + c - n], [\"A\", n, n, 0, 0, 1, a + v - n, t + c], [\"L\", a + n, t + c], [\"A\", n, n, 0, 0, 1, a, t + c - n], [\"L\", a, t + n], [\"A\", n, n, 0, 0, 1, a + n, t], [\"Z\"]];\n    }\n    const {\n      defined: A,\n      isNumber: D,\n      pick: C\n    } = a;\n    return {\n      arc: x,\n      callout: function (a, t, v, c, n) {\n        const r = Math.min(n && n.r || 0, v, c),\n          l = r + 6,\n          h = n && n.anchorX;\n        n = n && n.anchorY || 0;\n        const q = L(a, t, v, c, {\n          r\n        });\n        if (!D(h)) return q;\n        a + h >= v ? n > t + l && n < t + c - l ? q.splice(3, 1, [\"L\", a + v, n - 6], [\"L\", a + v + 6, n], [\"L\", a + v, n + 6], [\"L\", a + v, t + c - r]) : q.splice(3, 1, [\"L\", a + v, c / 2], [\"L\", h, n], [\"L\", a + v, c / 2], [\"L\", a + v, t + c - r]) : 0 >= a + h ? n > t + l && n < t + c - l ? q.splice(7, 1, [\"L\", a, n + 6], [\"L\", a - 6, n], [\"L\", a, n - 6], [\"L\", a, t + r]) : q.splice(7, 1, [\"L\", a, c / 2], [\"L\", h, n], [\"L\", a, c / 2], [\"L\", a, t + r]) : n && n > c && h > a + l && h < a + v - l ? q.splice(5, 1, [\"L\", h + 6, t + c], [\"L\", h, t + c + 6], [\"L\", h - 6, t + c], [\"L\", a + r, t + c]) : n && 0 > n && h > a + l && h < a + v - l && q.splice(1, 1, [\"L\", h - 6, t], [\"L\", h, t - 6], [\"L\", h + 6, t], [\"L\", v - r, t]);\n        return q;\n      },\n      circle: function (a, t, v, c) {\n        return x(a + v / 2, t + c / 2, v / 2, c / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (a, t, v, c) {\n        return [[\"M\", a + v / 2, t], [\"L\", a + v, t + c / 2], [\"L\", a + v / 2, t + c], [\"L\", a, t + c / 2], [\"Z\"]];\n      },\n      rect: G,\n      roundedRect: L,\n      square: G,\n      triangle: function (a, t, v, c) {\n        return [[\"M\", a + v / 2, t], [\"L\", a + v, t + c], [\"L\", a, t + c], [\"Z\"]];\n      },\n      \"triangle-down\": function (a, t, v, c) {\n        return [[\"M\", a, t], [\"L\", a + v, t], [\"L\", a + v / 2, t + c], [\"Z\"]];\n      }\n    };\n  });\n  M(a, \"Core/Renderer/SVG/TextBuilder.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        doc: x,\n        SVG_NS: A,\n        win: D\n      } = y,\n      {\n        attr: C,\n        extend: z,\n        fireEvent: t,\n        isString: v,\n        objectEach: c,\n        pick: n\n      } = G;\n    class r {\n      constructor(a) {\n        const c = a.styles;\n        this.renderer = a.renderer;\n        this.svgElement = a;\n        this.width = a.textWidth;\n        this.textLineHeight = c && c.lineHeight;\n        this.textOutline = c && c.textOutline;\n        this.ellipsis = !(!c || \"ellipsis\" !== c.textOverflow);\n        this.noWrap = !(!c || \"nowrap\" !== c.whiteSpace);\n      }\n      buildSVG() {\n        const c = this.svgElement,\n          h = c.element;\n        var q = c.renderer,\n          g = n(c.textStr, \"\").toString();\n        const w = -1 !== g.indexOf(\"<\"),\n          r = h.childNodes;\n        q = !c.added && q.box;\n        const F = /<br.*?>/g;\n        var e = [g, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, c.getStyle(\"font-size\"), this.width].join();\n        if (e !== c.textCache) {\n          c.textCache = e;\n          delete c.actualWidth;\n          for (e = r.length; e--;) h.removeChild(r[e]);\n          w || this.ellipsis || this.width || c.textPath || -1 !== g.indexOf(\" \") && (!this.noWrap || F.test(g)) ? \"\" !== g && (q && q.appendChild(h), g = new a(g), this.modifyTree(g.nodes), g.addToDOM(h), this.modifyDOM(), this.ellipsis && -1 !== (h.textContent || \"\").indexOf(\"\\u2026\") && c.attr(\"title\", this.unescapeEntities(c.textStr || \"\", [\"&lt;\", \"&gt;\"])), q && q.removeChild(h)) : h.appendChild(x.createTextNode(this.unescapeEntities(g)));\n          v(this.textOutline) && c.applyTextOutline && c.applyTextOutline(this.textOutline);\n        }\n      }\n      modifyDOM() {\n        const a = this.svgElement,\n          c = C(a.element, \"x\");\n        a.firstLineMetrics = void 0;\n        let q;\n        for (; q = a.element.firstChild;) if (/^[\\s\\u200B]*$/.test(q.textContent || \" \")) a.element.removeChild(q);else break;\n        [].forEach.call(a.element.querySelectorAll(\"tspan.highcharts-br\"), (g, e) => {\n          g.nextSibling && g.previousSibling && (0 === e && 1 === g.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(g.previousSibling)), C(g, {\n            dy: this.getLineHeight(g.nextSibling),\n            x: c\n          }));\n        });\n        const g = this.width || 0;\n        if (g) {\n          var w = (q, e) => {\n              var m = q.textContent || \"\";\n              const u = m.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n              var p = !this.noWrap && (1 < u.length || 1 < a.element.childNodes.length);\n              const l = this.getLineHeight(e);\n              let b = 0,\n                f = a.actualWidth;\n              if (this.ellipsis) m && this.truncate(q, m, void 0, 0, Math.max(0, g - .8 * l), (b, f) => b.substring(0, f) + \"\\u2026\");else if (p) {\n                m = [];\n                for (p = []; e.firstChild && e.firstChild !== q;) p.push(e.firstChild), e.removeChild(e.firstChild);\n                for (; u.length;) u.length && !this.noWrap && 0 < b && (m.push(q.textContent || \"\"), q.textContent = u.join(\" \").replace(/- /g, \"-\")), this.truncate(q, void 0, u, 0 === b ? f || 0 : 0, g, (b, f) => u.slice(0, f).join(\" \").replace(/- /g, \"-\")), f = a.actualWidth, b++;\n                p.forEach(b => {\n                  e.insertBefore(b, q);\n                });\n                m.forEach(b => {\n                  e.insertBefore(x.createTextNode(b), q);\n                  b = x.createElementNS(A, \"tspan\");\n                  b.textContent = \"\\u200b\";\n                  C(b, {\n                    dy: l,\n                    x: c\n                  });\n                  e.insertBefore(b, q);\n                });\n              }\n            },\n            n = c => {\n              [].slice.call(c.childNodes).forEach(e => {\n                e.nodeType === D.Node.TEXT_NODE ? w(e, c) : (-1 !== e.className.baseVal.indexOf(\"highcharts-br\") && (a.actualWidth = 0), n(e));\n              });\n            };\n          n(a.element);\n        }\n      }\n      getLineHeight(a) {\n        a = a.nodeType === D.Node.TEXT_NODE ? a.parentElement : a;\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a || this.svgElement.element).h;\n      }\n      modifyTree(a) {\n        const c = (q, g) => {\n          const {\n              attributes: h = {},\n              children: l,\n              style: n = {},\n              tagName: e\n            } = q,\n            m = this.renderer.styledMode;\n          if (\"b\" === e || \"strong\" === e) m ? h[\"class\"] = \"highcharts-strong\" : n.fontWeight = \"bold\";else if (\"i\" === e || \"em\" === e) m ? h[\"class\"] = \"highcharts-emphasized\" : n.fontStyle = \"italic\";\n          n && n.color && (n.fill = n.color);\n          \"br\" === e ? (h[\"class\"] = \"highcharts-br\", q.textContent = \"\\u200b\", (g = a[g + 1]) && g.textContent && (g.textContent = g.textContent.replace(/^ +/gm, \"\"))) : \"a\" === e && l && l.some(e => \"#text\" === e.tagName) && (q.children = [{\n            children: l,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== e && \"a\" !== e && (q.tagName = \"tspan\");\n          z(q, {\n            attributes: h,\n            style: n\n          });\n          l && l.filter(e => \"#text\" !== e.tagName).forEach(c);\n        };\n        a.forEach(c);\n        t(this.svgElement, \"afterModifyTree\", {\n          nodes: a\n        });\n      }\n      truncate(a, c, q, g, w, n) {\n        const l = this.svgElement,\n          {\n            rotation: e\n          } = l,\n          m = [];\n        let u = q ? 1 : 0,\n          p = (c || q || \"\").length,\n          h = p,\n          b,\n          f;\n        const d = function (b, d) {\n          b = d || b;\n          if ((d = a.parentNode) && \"undefined\" === typeof m[b] && d.getSubStringLength) try {\n            m[b] = g + d.getSubStringLength(0, q ? b + 1 : b);\n          } catch (N) {\n            \"\";\n          }\n          return m[b];\n        };\n        l.rotation = 0;\n        f = d(a.textContent.length);\n        if (g + f > w) {\n          for (; u <= p;) h = Math.ceil((u + p) / 2), q && (b = n(q, h)), f = d(h, b && b.length - 1), u === p ? u = p + 1 : f > w ? p = h - 1 : u = h;\n          0 === p ? a.textContent = \"\" : c && p === c.length - 1 || (a.textContent = b || n(c || q, h));\n        }\n        q && q.splice(0, h);\n        l.actualWidth = f;\n        l.rotation = e;\n      }\n      unescapeEntities(a, h) {\n        c(this.renderer.escapes, function (c, g) {\n          h && -1 !== h.indexOf(c) || (a = a.toString().replace(new RegExp(c, \"g\"), g));\n        });\n        return a;\n      }\n    }\n    return r;\n  });\n  M(a, \"Core/Renderer/SVG/SVGRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGLabel.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Renderer/SVG/TextBuilder.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D, C, z, t) {\n    const {\n        charts: v,\n        deg2rad: c,\n        doc: n,\n        isFirefox: r,\n        isMS: l,\n        isWebKit: h,\n        noop: q,\n        SVG_NS: g,\n        symbolSizes: w,\n        win: J\n      } = G,\n      {\n        addEvent: F,\n        attr: e,\n        createElement: m,\n        css: u,\n        defined: p,\n        destroyObjectProperties: H,\n        extend: b,\n        isArray: f,\n        isNumber: d,\n        isObject: k,\n        isString: O,\n        merge: N,\n        pick: E,\n        pInt: x,\n        uniqueKey: T\n      } = t;\n    let U;\n    class K {\n      constructor(b, d, f, k, e, a, p) {\n        this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, d, f, k, e, a, p);\n      }\n      init(b, d, f, k, a, p, m) {\n        const B = this.createElement(\"svg\").attr({\n            version: \"1.1\",\n            \"class\": \"highcharts-root\"\n          }),\n          c = B.element;\n        m || B.css(this.getStyle(k));\n        b.appendChild(c);\n        e(b, \"dir\", \"ltr\");\n        -1 === b.innerHTML.indexOf(\"xmlns\") && e(c, \"xmlns\", this.SVG_NS);\n        this.box = c;\n        this.boxWrapper = B;\n        this.alignedObjects = [];\n        this.url = this.getReferenceURL();\n        this.createElement(\"desc\").add().element.appendChild(n.createTextNode(\"Created with Highcharts 11.0.1\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = p;\n        this.forExport = a;\n        this.styledMode = m;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.rootFontSize = B.getStyle(\"font-size\");\n        this.setSize(d, f, !1);\n        let K;\n        r && b.getBoundingClientRect && (d = function () {\n          u(b, {\n            left: 0,\n            top: 0\n          });\n          K = b.getBoundingClientRect();\n          u(b, {\n            left: Math.ceil(K.left) - K.left + \"px\",\n            top: Math.ceil(K.top) - K.top + \"px\"\n          });\n        }, d(), this.unSubPixelFix = F(J, \"resize\", d));\n      }\n      definition(b) {\n        return new a([b]).addToDOM(this.defs.element);\n      }\n      getReferenceURL() {\n        if ((r || h) && n.getElementsByTagName(\"base\").length) {\n          if (!p(U)) {\n            var b = T();\n            b = new a([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: b\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": `url(#${b})`,\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(n.body);\n            u(b, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9E5\n            });\n            const d = n.elementFromPoint(6, 6);\n            U = \"hitme\" === (d && d.id);\n            n.body.removeChild(b);\n          }\n          if (U) return J.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n        return \"\";\n      }\n      getStyle(d) {\n        return this.style = b({\n          fontFamily: \"Helvetica, Arial, sans-serif\",\n          fontSize: \"1rem\"\n        }, d);\n      }\n      setStyle(b) {\n        this.boxWrapper.css(this.getStyle(b));\n      }\n      isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      }\n      destroy() {\n        const b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        H(this.gradients || {});\n        this.gradients = null;\n        this.defs = b.destroy();\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      }\n      createElement(b) {\n        const d = new this.Element();\n        d.init(this, b);\n        return d;\n      }\n      getRadialAttr(b, d) {\n        return {\n          cx: b[0] - b[2] / 2 + (d.cx || 0) * b[2],\n          cy: b[1] - b[2] / 2 + (d.cy || 0) * b[2],\n          r: (d.r || 0) * b[2]\n        };\n      }\n      shadowDefinition(b) {\n        const d = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(b).map(d => b[d])].join(\"-\").replace(/[^a-z0-9\\-]/g, \"\"),\n          f = N({\n            color: \"#000000\",\n            offsetX: 1,\n            offsetY: 1,\n            opacity: .15,\n            width: 5\n          }, b);\n        this.defs.element.querySelector(`#${d}`) || this.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: d\n          },\n          children: [{\n            tagName: \"feDropShadow\",\n            attributes: {\n              dx: f.offsetX,\n              dy: f.offsetY,\n              \"flood-color\": f.color,\n              \"flood-opacity\": Math.min(5 * f.opacity, 1),\n              stdDeviation: f.width / 2\n            }\n          }]\n        });\n        return d;\n      }\n      buildText(b) {\n        new z(b).buildSVG();\n      }\n      getContrast(b) {\n        b = y.parse(b).rgba.map(b => {\n          b /= 255;\n          return .03928 >= b ? b / 12.92 : Math.pow((b + .055) / 1.055, 2.4);\n        });\n        b = .2126 * b[0] + .7152 * b[1] + .0722 * b[2];\n        return 1.05 / (b + .05) > (b + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n      }\n      button(d, f, e, p, B = {}, m, c, K, g, q) {\n        const I = this.label(d, f, e, g, void 0, void 0, q, void 0, \"button\"),\n          u = this.styledMode;\n        d = B.states || {};\n        let h = 0;\n        B = N(B);\n        delete B.states;\n        const P = N({\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\",\n          fontWeight: \"normal\"\n        }, B.style);\n        delete B.style;\n        let w = a.filterUserAttributes(B);\n        I.attr(N({\n          padding: 8,\n          r: 2\n        }, w));\n        let Q, n, r;\n        u || (w = N({\n          fill: \"#f7f7f7\",\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1\n        }, w), m = N(w, {\n          fill: \"#e6e6e6\"\n        }, a.filterUserAttributes(m || d.hover || {})), Q = m.style, delete m.style, c = N(w, {\n          fill: \"#e6e9ff\",\n          style: {\n            color: \"#000000\",\n            fontWeight: \"bold\"\n          }\n        }, a.filterUserAttributes(c || d.select || {})), n = c.style, delete c.style, K = N(w, {\n          style: {\n            color: \"#cccccc\"\n          }\n        }, a.filterUserAttributes(K || d.disabled || {})), r = K.style, delete K.style);\n        F(I.element, l ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== h && I.setState(1);\n        });\n        F(I.element, l ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== h && I.setState(h);\n        });\n        I.setState = function (b) {\n          1 !== b && (I.state = h = b);\n          I.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          u || (I.attr([w, m, c, K][b || 0]), b = [P, Q, n, r][b || 0], k(b) && I.css(b));\n        };\n        u || (I.attr(w).css(b({\n          cursor: \"default\"\n        }, P)), q && I.text.css({\n          pointerEvents: \"none\"\n        }));\n        return I.on(\"touchstart\", b => b.stopPropagation()).on(\"click\", function (b) {\n          3 !== h && p.call(I, b);\n        });\n      }\n      crispLine(b, d, f = \"round\") {\n        const k = b[0],\n          e = b[1];\n        p(k[1]) && k[1] === e[1] && (k[1] = e[1] = Math[f](k[1]) - d % 2 / 2);\n        p(k[2]) && k[2] === e[2] && (k[2] = e[2] = Math[f](k[2]) + d % 2 / 2);\n        return b;\n      }\n      path(d) {\n        const e = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        f(d) ? e.d = d : k(d) && b(e, d);\n        return this.createElement(\"path\").attr(e);\n      }\n      circle(b, d, f) {\n        b = k(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: d,\n          r: f\n        };\n        d = this.createElement(\"circle\");\n        d.xSetter = d.ySetter = function (b, d, f) {\n          f.setAttribute(\"c\" + d, b);\n        };\n        return d.attr(b);\n      }\n      arc(b, d, f, e, a, p) {\n        k(b) ? (e = b, d = e.y, f = e.r, b = e.x) : e = {\n          innerR: e,\n          start: a,\n          end: p\n        };\n        b = this.symbol(\"arc\", b, d, f, f, e);\n        b.r = f;\n        return b;\n      }\n      rect(d, f, a, p, B, m) {\n        d = k(d) ? d : \"undefined\" === typeof d ? {} : {\n          x: d,\n          y: f,\n          r: B,\n          width: Math.max(a || 0, 0),\n          height: Math.max(p || 0, 0)\n        };\n        const c = this.createElement(\"rect\");\n        this.styledMode || (\"undefined\" !== typeof m && (d[\"stroke-width\"] = m, b(d, c.crisp(d))), d.fill = \"none\");\n        c.rSetter = function (b, d, f) {\n          c.r = b;\n          e(f, {\n            rx: b,\n            ry: b\n          });\n        };\n        c.rGetter = function () {\n          return c.r || 0;\n        };\n        return c.attr(d);\n      }\n      roundedRect(b) {\n        return this.symbol(\"roundedRect\").attr(b);\n      }\n      setSize(b, d, f) {\n        this.width = b;\n        this.height = d;\n        this.boxWrapper.animate({\n          width: b,\n          height: d\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: E(f, !0) ? void 0 : 0\n        });\n        this.alignElements();\n      }\n      g(b) {\n        const d = this.createElement(\"g\");\n        return b ? d.attr({\n          \"class\": \"highcharts-\" + b\n        }) : d;\n      }\n      image(b, f, k, e, a, p) {\n        const m = {\n            preserveAspectRatio: \"none\"\n          },\n          B = function (b, d) {\n            b.setAttributeNS ? b.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", d) : b.setAttribute(\"hc-svg-href\", d);\n          };\n        d(f) && (m.x = f);\n        d(k) && (m.y = k);\n        d(e) && (m.width = e);\n        d(a) && (m.height = a);\n        const c = this.createElement(\"image\").attr(m);\n        f = function (d) {\n          B(c.element, b);\n          p.call(c, d);\n        };\n        p ? (B(c.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), k = new J.Image(), F(k, \"load\", f), k.src = b, k.complete && f({})) : B(c.element, b);\n        return c;\n      }\n      symbol(d, f, k, a, B, c) {\n        const K = this,\n          g = /^url\\((.*?)\\)$/,\n          q = g.test(d),\n          h = !q && (this.symbols[d] ? d : \"circle\"),\n          l = h && this.symbols[h];\n        let P, Q, r, H;\n        if (l) \"number\" === typeof f && (Q = l.call(this.symbols, Math.round(f || 0), Math.round(k || 0), a || 0, B || 0, c)), P = this.path(Q), K.styledMode || P.attr(\"fill\", \"none\"), b(P, {\n          symbolName: h || void 0,\n          x: f,\n          y: k,\n          width: a,\n          height: B\n        }), c && b(P, c);else if (q) {\n          r = d.match(g)[1];\n          const b = P = this.image(r);\n          b.imgwidth = E(c && c.width, w[r] && w[r].width);\n          b.imgheight = E(c && c.height, w[r] && w[r].height);\n          H = b => b.attr({\n            width: b.width,\n            height: b.height\n          });\n          [\"width\", \"height\"].forEach(function (d) {\n            b[d + \"Setter\"] = function (b, d) {\n              this[d] = b;\n              const {\n                alignByTranslate: f,\n                element: k,\n                width: a,\n                height: m,\n                imgwidth: B,\n                imgheight: K\n              } = this;\n              b = this[\"img\" + d];\n              if (p(b)) {\n                let p = 1;\n                c && \"within\" === c.backgroundSize && a && m ? (p = Math.min(a / B, m / K), e(k, {\n                  width: Math.round(B * p),\n                  height: Math.round(K * p)\n                })) : k && k.setAttribute(d, b);\n                f || this.translate(((a || 0) - B * p) / 2, ((m || 0) - K * p) / 2);\n              }\n            };\n          });\n          p(f) && b.attr({\n            x: f,\n            y: k\n          });\n          b.isImg = !0;\n          p(b.imgwidth) && p(b.imgheight) ? H(b) : (b.attr({\n            width: 0,\n            height: 0\n          }), m(\"img\", {\n            onload: function () {\n              const d = v[K.chartIndex];\n              0 === this.width && (u(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), n.body.appendChild(this));\n              w[r] = {\n                width: this.width,\n                height: this.height\n              };\n              b.imgwidth = this.width;\n              b.imgheight = this.height;\n              b.element && H(b);\n              this.parentNode && this.parentNode.removeChild(this);\n              K.imgCount--;\n              if (!K.imgCount && d && !d.hasLoaded) d.onload();\n            },\n            src: r\n          }), this.imgCount++);\n        }\n        return P;\n      }\n      clipRect(b, d, f, k) {\n        const e = T() + \"-\",\n          a = this.createElement(\"clipPath\").attr({\n            id: e\n          }).add(this.defs);\n        b = this.rect(b, d, f, k, 0).add(a);\n        b.id = e;\n        b.clipPath = a;\n        b.count = 0;\n        return b;\n      }\n      text(b, d, f, k) {\n        const e = {};\n        if (k && (this.allowHTML || !this.forExport)) return this.html(b, d, f);\n        e.x = Math.round(d || 0);\n        f && (e.y = Math.round(f));\n        p(b) && (e.text = b);\n        b = this.createElement(\"text\").attr(e);\n        if (!k || this.forExport && !this.allowHTML) b.xSetter = function (b, d, f) {\n          const k = f.getElementsByTagName(\"tspan\"),\n            e = f.getAttribute(d);\n          for (let f = 0, a; f < k.length; f++) a = k[f], a.getAttribute(d) === e && a.setAttribute(d, b);\n          f.setAttribute(d, b);\n        };\n        return b;\n      }\n      fontMetrics(b) {\n        b = x(A.prototype.getStyle.call(b, \"font-size\") || 0);\n        const d = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: d,\n          b: Math.round(.8 * d),\n          f: b\n        };\n      }\n      rotCorr(b, d, f) {\n        let k = b;\n        d && f && (k = Math.max(k * Math.cos(d * c), 4));\n        return {\n          x: -b / 3 * Math.sin(d * c),\n          y: k\n        };\n      }\n      pathToSegments(b) {\n        const f = [],\n          k = [],\n          e = {\n            A: 8,\n            C: 7,\n            H: 2,\n            L: 3,\n            M: 3,\n            Q: 5,\n            S: 5,\n            T: 3,\n            V: 2\n          };\n        for (let a = 0; a < b.length; a++) O(k[0]) && d(b[a]) && k.length === e[k[0].toUpperCase()] && b.splice(a, 0, k[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[a] && (k.length && f.push(k.slice(0)), k.length = 0), k.push(b[a]);\n        f.push(k.slice(0));\n        return f;\n      }\n      label(b, d, f, k, e, a, p, m, c) {\n        return new D(this, b, d, f, k, e, a, p, m, c);\n      }\n      alignElements() {\n        this.alignedObjects.forEach(b => b.align());\n      }\n    }\n    b(K.prototype, {\n      Element: A,\n      SVG_NS: g,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: C,\n      draw: q\n    });\n    L.registerRendererType(\"svg\", K, !0);\n    \"\";\n    return K;\n  });\n  M(a, \"Core/Renderer/HTML/HTMLElement.js\", [a[\"Core/Globals.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        isFirefox: x,\n        isMS: A,\n        isWebKit: D,\n        win: C\n      } = a,\n      {\n        css: z,\n        defined: t,\n        extend: v,\n        pick: c,\n        pInt: n\n      } = G,\n      r = [];\n    class l extends y {\n      static compose(a) {\n        if (G.pushUnique(r, a)) {\n          const c = l.prototype,\n            g = a.prototype;\n          g.getSpanCorrection = c.getSpanCorrection;\n          g.htmlCss = c.htmlCss;\n          g.htmlGetBBox = c.htmlGetBBox;\n          g.htmlUpdateTransform = c.htmlUpdateTransform;\n          g.setSpanRotation = c.setSpanRotation;\n        }\n        return a;\n      }\n      getSpanCorrection(a, c, g) {\n        this.xCorr = -a * g;\n        this.yCorr = -c;\n      }\n      htmlCss(a) {\n        const q = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n          g = c(q && a.width, void 0);\n        let l;\n        q && (delete a.width, this.textWidth = g, l = !0);\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = v(this.styles, a);\n        z(this.element, a);\n        l && this.htmlUpdateTransform();\n        return this;\n      }\n      htmlGetBBox() {\n        const a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      }\n      htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n            c = this.element,\n            g = this.x || 0,\n            l = this.y || 0,\n            r = this.textAlign || \"left\",\n            F = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[r],\n            e = this.styles,\n            m = e && e.whiteSpace;\n          z(c, {\n            marginLeft: this.translateX || 0,\n            marginTop: this.translateY || 0\n          });\n          if (\"SPAN\" === c.tagName) {\n            e = this.rotation;\n            const p = this.textWidth && n(this.textWidth),\n              q = [e, r, c.innerHTML, this.textWidth, this.textAlign].join();\n            let b = !1;\n            if (p !== this.oldTextWidth) {\n              if (this.textPxLength) var u = this.textPxLength;else z(c, {\n                width: \"\",\n                whiteSpace: m || \"nowrap\"\n              }), u = c.offsetWidth;\n              (p > this.oldTextWidth || u > p) && (/[ \\-]/.test(c.textContent || c.innerText) || \"ellipsis\" === c.style.textOverflow) && (z(c, {\n                width: u > p || e ? p + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: m || \"normal\"\n              }), this.oldTextWidth = p, b = !0);\n            }\n            this.hasBoxWidthChanged = b;\n            q !== this.cTT && (a = a.fontMetrics(c).b, !t(e) || e === (this.oldRotation || 0) && r === this.oldAlign || this.setSpanRotation(e, F, a), this.getSpanCorrection(!t(e) && this.textPxLength || c.offsetWidth, a, F, e, r));\n            z(c, {\n              left: g + (this.xCorr || 0) + \"px\",\n              top: l + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = q;\n            this.oldRotation = e;\n            this.oldAlign = r;\n          }\n        } else this.alignOnAdd = !0;\n      }\n      setSpanRotation(a, c, g) {\n        const l = {},\n          q = A && !/Edge/.test(C.navigator.userAgent) ? \"-ms-transform\" : D ? \"-webkit-transform\" : x ? \"MozTransform\" : C.opera ? \"-o-transform\" : void 0;\n        q && (l[q] = l.transform = \"rotate(\" + a + \"deg)\", l[q + (x ? \"Origin\" : \"-origin\")] = l.transformOrigin = 100 * c + \"% \" + g + \"px\", z(this.element, l));\n      }\n    }\n    return l;\n  });\n  M(a, \"Core/Renderer/HTML/HTMLRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L) {\n    const {\n        attr: x,\n        createElement: D,\n        extend: C,\n        pick: z\n      } = L,\n      t = [];\n    class v extends G {\n      static compose(a) {\n        L.pushUnique(t, a) && (a.prototype.html = v.prototype.html);\n        return a;\n      }\n      html(c, n, r) {\n        const l = this.createElement(\"span\"),\n          h = l.element,\n          q = l.renderer,\n          g = function (a, c) {\n            [\"opacity\", \"visibility\"].forEach(function (g) {\n              a[g + \"Setter\"] = function (e, m, l) {\n                const p = a.div ? a.div.style : c;\n                y.prototype[g + \"Setter\"].call(this, e, m, l);\n                p && (p[m] = e);\n              };\n            });\n            a.addedSetters = !0;\n          };\n        l.textSetter = function (c) {\n          c !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, z(c, \"\")), this.textStr = c, l.doTransform = !0);\n        };\n        g(l, l.element.style);\n        l.xSetter = l.ySetter = l.alignSetter = l.rotationSetter = function (a, c) {\n          \"align\" === c ? l.alignValue = l.textAlign = a : l[c] = a;\n          l.doTransform = !0;\n        };\n        l.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n        l.attr({\n          text: c,\n          x: Math.round(n),\n          y: Math.round(r)\n        }).css({\n          position: \"absolute\"\n        });\n        q.styledMode || l.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        h.style.whiteSpace = \"nowrap\";\n        l.css = l.htmlCss;\n        l.add = function (a) {\n          const c = q.box.parentNode,\n            n = [];\n          let e;\n          if (this.parentGroup = a) {\n            if (e = a.div, !e) {\n              for (; a;) n.push(a), a = a.parentGroup;\n              n.reverse().forEach(function (a) {\n                function m(f, d) {\n                  a[d] = f;\n                  \"translateX\" === d ? b.left = f + \"px\" : b.top = f + \"px\";\n                  a.doTransform = !0;\n                }\n                const p = x(a.element, \"class\"),\n                  q = a.styles || {};\n                e = a.div = a.div || D(\"div\", p ? {\n                  className: p\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  visibility: a.visibility\n                }, e || c);\n                const b = e.style;\n                C(a, {\n                  classSetter: function (b) {\n                    return function (d) {\n                      this.element.setAttribute(\"class\", d);\n                      b.className = d;\n                    };\n                  }(e),\n                  css: function (f) {\n                    l.css.call(a, f);\n                    [\"cursor\", \"pointerEvents\"].forEach(d => {\n                      f[d] && (b[d] = f[d]);\n                    });\n                    return a;\n                  },\n                  on: function () {\n                    n[0].div && l.on.apply({\n                      element: n[0].div,\n                      onEvents: a.onEvents\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: m,\n                  translateYSetter: m\n                });\n                a.addedSetters || g(a);\n                a.css(q);\n              });\n            }\n          } else e = c;\n          e.appendChild(h);\n          l.added = !0;\n          l.alignOnAdd && l.htmlUpdateTransform();\n          return l;\n        };\n        return l;\n      }\n    }\n    return v;\n  });\n  M(a, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var a = /*#__PURE__*/(() => {\n      a = a || {};\n      a.defaultXAxisOptions = {\n        alignTicks: !0,\n        allowDecimals: void 0,\n        panningEnabled: !0,\n        zIndex: 2,\n        zoomEnabled: !0,\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e %b\"\n          },\n          week: {\n            main: \"%e %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        gridLineDashStyle: \"Solid\",\n        gridZIndex: 1,\n        labels: {\n          autoRotation: void 0,\n          autoRotationLimit: 80,\n          distance: 15,\n          enabled: !0,\n          indentation: 10,\n          overflow: \"justify\",\n          padding: 5,\n          reserveSpace: void 0,\n          rotation: void 0,\n          staggerLines: 0,\n          step: 0,\n          useHTML: !1,\n          zIndex: 7,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          }\n        },\n        maxPadding: .01,\n        minorGridLineDashStyle: \"Solid\",\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minorTicksPerMajor: 5,\n        minPadding: .01,\n        offset: void 0,\n        opposite: !1,\n        reversed: void 0,\n        reversedStacks: !1,\n        showEmpty: !0,\n        showFirstLabel: !0,\n        showLastLabel: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          rotation: 0,\n          useHTML: !1,\n          x: 0,\n          y: 0,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          }\n        },\n        type: \"linear\",\n        uniqueNames: !0,\n        visible: !0,\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#333333\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        gridLineWidth: void 0,\n        tickColor: \"#333333\"\n      };\n      a.defaultYAxisOptions = {\n        reversedStacks: !0,\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: void 0\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          animation: {},\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function () {\n            const {\n              numberFormatter: a\n            } = this.axis.chart;\n            return a(this.total || 0, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      a.defaultLeftAxisOptions = {\n        title: {\n          rotation: 270\n        }\n      };\n      a.defaultRightAxisOptions = {\n        title: {\n          rotation: 90\n        }\n      };\n      a.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      a.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      return a;\n    })();\n    return a;\n  });\n  M(a, \"Core/Foundation.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: x,\n      isFunction: G,\n      objectEach: L,\n      removeEvent: A\n    } = a;\n    var D = /*#__PURE__*/(() => {\n      (function (a) {\n        a.registerEventOptions = function (a, t) {\n          a.eventOptions = a.eventOptions || {};\n          L(t.events, function (t, c) {\n            a.eventOptions[c] !== t && (a.eventOptions[c] && (A(a, c, a.eventOptions[c]), delete a.eventOptions[c]), G(t) && (a.eventOptions[c] = t, x(a, c, t, {\n              order: 0\n            })));\n          });\n        };\n      })(D || (D = {}));\n      return D;\n    })();\n    return D;\n  });\n  M(a, \"Core/Axis/Tick.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        deg2rad: x\n      } = y,\n      {\n        clamp: A,\n        correctFloat: D,\n        defined: C,\n        destroyObjectProperties: z,\n        extend: t,\n        fireEvent: v,\n        isNumber: c,\n        merge: n,\n        objectEach: r,\n        pick: l\n      } = G;\n    class h {\n      constructor(a, c, l, h, n) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = a;\n        this.pos = c;\n        this.type = l || \"\";\n        this.parameters = n || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        v(this, \"init\");\n        l || h || this.addLabel();\n      }\n      addLabel() {\n        const q = this,\n          g = q.axis;\n        var h = g.options;\n        const n = g.chart;\n        var r = g.categories;\n        const e = g.logarithmic,\n          m = g.names,\n          u = q.pos,\n          p = l(q.options && q.options.labels, h.labels);\n        var H = g.tickPositions;\n        const b = u === H[0],\n          f = u === H[H.length - 1],\n          d = (!p.step || 1 === p.step) && 1 === g.tickInterval;\n        H = H.info;\n        let k = q.label,\n          O,\n          N,\n          E;\n        r = this.parameters.category || (r ? l(r[u], m[u], u) : u);\n        e && c(r) && (r = D(e.lin2log(r)));\n        g.dateTime && (H ? (N = n.time.resolveDTLFormat(h.dateTimeLabelFormats[!h.grid && H.higherRanks[u] || H.unitName]), O = N.main) : c(r) && (O = g.dateTime.getXDateFormat(r, h.dateTimeLabelFormats || {})));\n        q.isFirst = b;\n        q.isLast = f;\n        const x = {\n          axis: g,\n          chart: n,\n          dateTimeLabelFormat: O,\n          isFirst: b,\n          isLast: f,\n          pos: u,\n          tick: q,\n          tickPositionInfo: H,\n          value: r\n        };\n        v(this, \"labelFormat\", x);\n        const z = b => p.formatter ? p.formatter.call(b, b) : p.format ? (b.text = g.defaultLabelFormatter.call(b, b), a.format(p.format, b, n)) : g.defaultLabelFormatter.call(b, b);\n        h = z.call(x, x);\n        const y = N && N.list;\n        q.shortenLabel = y ? function () {\n          for (E = 0; E < y.length; E++) if (t(x, {\n            dateTimeLabelFormat: y[E]\n          }), k.attr({\n            text: z.call(x, x)\n          }), k.getBBox().width < g.getSlotWidth(q) - 2 * p.padding) return;\n          k.attr({\n            text: \"\"\n          });\n        } : void 0;\n        d && g._addedPlotLB && q.moveLabel(h, p);\n        C(k) || q.movedLabel ? k && k.textStr !== h && !d && (!k.textWidth || p.style.width || k.styles.width || k.css({\n          width: null\n        }), k.attr({\n          text: h\n        }), k.textPxLength = k.getBBox().width) : (q.label = k = q.createLabel({\n          x: 0,\n          y: 0\n        }, h, p), q.rotation = 0);\n      }\n      createLabel(a, c, l) {\n        const g = this.axis,\n          q = g.chart;\n        if (a = C(c) && l.enabled ? q.renderer.text(c, a.x, a.y, l.useHTML).add(g.labelGroup) : null) q.styledMode || a.css(n(l.style)), a.textPxLength = a.getBBox().width;\n        return a;\n      }\n      destroy() {\n        z(this, this.axis);\n      }\n      getPosition(a, c, l, h) {\n        const g = this.axis,\n          e = g.chart,\n          m = h && e.oldChartHeight || e.chartHeight;\n        a = {\n          x: a ? D(g.translate(c + l, void 0, void 0, h) + g.transB) : g.left + g.offset + (g.opposite ? (h && e.oldChartWidth || e.chartWidth) - g.right - g.left : 0),\n          y: a ? m - g.bottom + g.offset - (g.opposite ? g.height : 0) : D(m - g.translate(c + l, void 0, void 0, h) - g.transB)\n        };\n        a.y = A(a.y, -1E5, 1E5);\n        v(this, \"afterGetPosition\", {\n          pos: a\n        });\n        return a;\n      }\n      getLabelPosition(a, c, h, n, r, e, m, u) {\n        const p = this.axis,\n          g = p.transA,\n          b = p.isLinked && p.linkedParent ? p.linkedParent.reversed : p.reversed,\n          f = p.staggerLines,\n          d = p.tickRotCorr || {\n            x: 0,\n            y: 0\n          },\n          k = n || p.reserveSpaceDefault ? 0 : -p.labelOffset * (\"center\" === p.labelAlign ? .5 : 1),\n          q = r.distance,\n          w = {};\n        h = 0 === p.side ? h.rotation ? -q : -h.getBBox().height : 2 === p.side ? d.y + q : Math.cos(h.rotation * x) * (d.y - h.getBBox(!1, 0).height / 2);\n        C(r.y) && (h = 0 === p.side && p.horiz ? r.y + h : r.y);\n        a = a + l(r.x, [0, 1, 0, -1][p.side] * q) + k + d.x - (e && n ? e * g * (b ? -1 : 1) : 0);\n        c = c + h - (e && !n ? e * g * (b ? 1 : -1) : 0);\n        f && (n = m / (u || 1) % f, p.opposite && (n = f - n - 1), c += p.labelOffset / f * n);\n        w.x = a;\n        w.y = Math.round(c);\n        v(this, \"afterGetLabelPosition\", {\n          pos: w,\n          tickmarkOffset: e,\n          index: m\n        });\n        return w;\n      }\n      getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      }\n      getMarkPath(a, c, l, h, n, e) {\n        return e.crispLine([[\"M\", a, c], [\"L\", a + (n ? 0 : -l), c + (n ? l : 0)]], h);\n      }\n      handleOverflow(a) {\n        const c = this.axis,\n          h = c.options.labels,\n          n = a.x;\n        var q = c.chart.chartWidth,\n          e = c.chart.spacing;\n        const m = l(c.labelLeft, Math.min(c.pos, e[3]));\n        e = l(c.labelRight, Math.max(c.isRadial ? 0 : c.pos + c.len, q - e[1]));\n        const u = this.label,\n          p = this.rotation,\n          r = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[c.labelAlign || u.attr(\"align\")],\n          b = u.getBBox().width,\n          f = c.getSlotWidth(this),\n          d = {};\n        let k = f,\n          O = 1,\n          N;\n        if (p || \"justify\" !== h.overflow) 0 > p && n - r * b < m ? N = Math.round(n / Math.cos(p * x) - m) : 0 < p && n + r * b > e && (N = Math.round((q - n) / Math.cos(p * x)));else if (q = n + (1 - r) * b, n - r * b < m ? k = a.x + k * (1 - r) - m : q > e && (k = e - a.x + k * r, O = -1), k = Math.min(f, k), k < f && \"center\" === c.labelAlign && (a.x += O * (f - k - r * (f - Math.min(b, k)))), b > k || c.autoRotation && (u.styles || {}).width) N = k;\n        N && (this.shortenLabel ? this.shortenLabel() : (d.width = Math.floor(N) + \"px\", (h.style || {}).textOverflow || (d.textOverflow = \"ellipsis\"), u.css(d)));\n      }\n      moveLabel(a, c) {\n        const g = this;\n        var l = g.label;\n        const h = g.axis;\n        let e = !1;\n        l && l.textStr === a ? (g.movedLabel = l, e = !0, delete g.label) : r(h.ticks, function (c) {\n          e || c.isNew || c === g || !c.label || c.label.textStr !== a || (g.movedLabel = c.label, e = !0, c.labelPos = g.movedLabel.xy, delete c.label);\n        });\n        e || !g.labelPos && !l || (l = g.labelPos || l.xy, g.movedLabel = g.createLabel(l, a, c), g.movedLabel && g.movedLabel.attr({\n          opacity: 0\n        }));\n      }\n      render(a, c, h) {\n        var g = this.axis,\n          n = g.horiz,\n          e = this.pos,\n          m = l(this.tickmarkOffset, g.tickmarkOffset);\n        e = this.getPosition(n, e, m, c);\n        m = e.x;\n        const u = e.y;\n        g = n && m === g.pos + g.len || !n && u === g.pos ? -1 : 1;\n        n = l(h, this.label && this.label.newOpacity, 1);\n        h = l(h, 1);\n        this.isActive = !0;\n        this.renderGridLine(c, h, g);\n        this.renderMark(e, h, g);\n        this.renderLabel(e, c, n, a);\n        this.isNew = !1;\n        v(this, \"afterRender\");\n      }\n      renderGridLine(a, c, h) {\n        const g = this.axis,\n          n = g.options,\n          e = {},\n          m = this.pos,\n          u = this.type,\n          p = l(this.tickmarkOffset, g.tickmarkOffset),\n          q = g.chart.renderer;\n        let b = this.gridLine,\n          f = n.gridLineWidth,\n          d = n.gridLineColor,\n          k = n.gridLineDashStyle;\n        \"minor\" === this.type && (f = n.minorGridLineWidth, d = n.minorGridLineColor, k = n.minorGridLineDashStyle);\n        b || (g.chart.styledMode || (e.stroke = d, e[\"stroke-width\"] = f || 0, e.dashstyle = k), u || (e.zIndex = 1), a && (c = 0), this.gridLine = b = q.path().attr(e).addClass(\"highcharts-\" + (u ? u + \"-\" : \"\") + \"grid-line\").add(g.gridGroup));\n        if (b && (h = g.getPlotLinePath({\n          value: m + p,\n          lineWidth: b.strokeWidth() * h,\n          force: \"pass\",\n          old: a,\n          acrossPanes: !1\n        }))) b[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: h,\n          opacity: c\n        });\n      }\n      renderMark(a, c, h) {\n        const g = this.axis;\n        var n = g.options;\n        const e = g.chart.renderer,\n          m = this.type,\n          u = g.tickSize(m ? m + \"Tick\" : \"tick\"),\n          p = a.x;\n        a = a.y;\n        const q = l(n[\"minor\" !== m ? \"tickWidth\" : \"minorTickWidth\"], !m && g.isXAxis ? 1 : 0);\n        n = n[\"minor\" !== m ? \"tickColor\" : \"minorTickColor\"];\n        let b = this.mark;\n        const f = !b;\n        u && (g.opposite && (u[0] = -u[0]), b || (this.mark = b = e.path().addClass(\"highcharts-\" + (m ? m + \"-\" : \"\") + \"tick\").add(g.axisGroup), g.chart.styledMode || b.attr({\n          stroke: n,\n          \"stroke-width\": q\n        })), b[f ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(p, a, u[0], b.strokeWidth() * h, g.horiz, e),\n          opacity: c\n        }));\n      }\n      renderLabel(a, g, h, n) {\n        var r = this.axis;\n        const e = r.horiz,\n          m = r.options,\n          u = this.label,\n          p = m.labels,\n          q = p.step;\n        r = l(this.tickmarkOffset, r.tickmarkOffset);\n        const b = a.x;\n        a = a.y;\n        let f = !0;\n        u && c(b) && (u.xy = a = this.getLabelPosition(b, a, u, e, p, r, n, q), this.isFirst && !this.isLast && !m.showFirstLabel || this.isLast && !this.isFirst && !m.showLastLabel ? f = !1 : !e || p.step || p.rotation || g || 0 === h || this.handleOverflow(a), q && n % q && (f = !1), f && c(a.y) ? (a.opacity = h, u[this.isNewLabel ? \"attr\" : \"animate\"](a).show(!0), this.isNewLabel = !1) : (u.hide(), this.isNewLabel = !0));\n      }\n      replaceMovedLabel() {\n        const a = this.label,\n          c = this.axis;\n        a && !this.isNew && (a.animate({\n          opacity: 0\n        }, void 0, a.destroy), delete this.label);\n        c.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      }\n    }\n    \"\";\n    return h;\n  });\n  M(a, \"Core/Axis/Axis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/AxisDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D, C, z) {\n    const {\n        animObject: t\n      } = a,\n      {\n        defaultOptions: v\n      } = L,\n      {\n        registerEventOptions: c\n      } = A,\n      {\n        deg2rad: n\n      } = D,\n      {\n        arrayMax: r,\n        arrayMin: l,\n        clamp: h,\n        correctFloat: q,\n        defined: g,\n        destroyObjectProperties: w,\n        erase: J,\n        error: x,\n        extend: e,\n        fireEvent: m,\n        isArray: u,\n        isNumber: p,\n        isString: H,\n        merge: b,\n        normalizeTickInterval: f,\n        objectEach: d,\n        pick: k,\n        relativeLength: O,\n        removeEvent: N,\n        splat: E,\n        syncTimeout: Z\n      } = z,\n      T = (b, d) => f(d, void 0, void 0, k(b.options.allowDecimals, .5 > d || void 0 !== b.tickAmount), !!b.tickAmount);\n    class U {\n      constructor(b, d) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;\n        this.init(b, d);\n      }\n      init(b, d) {\n        const a = d.isX;\n        this.chart = b;\n        this.horiz = b.inverted && !this.isZAxis ? !a : a;\n        this.isXAxis = a;\n        this.coll = this.coll || (a ? \"xAxis\" : \"yAxis\");\n        m(this, \"init\", {\n          userOptions: d\n        });\n        this.opposite = k(d.opposite, this.opposite);\n        this.side = k(d.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n        this.setOptions(d);\n        const f = this.options,\n          e = f.labels,\n          B = f.type;\n        this.userOptions = d;\n        this.minPixelPadding = 0;\n        this.reversed = k(f.reversed, this.reversed);\n        this.visible = f.visible;\n        this.zoomEnabled = f.zoomEnabled;\n        this.hasNames = \"category\" === B || !0 === f.categories;\n        this.categories = f.categories || (this.hasNames ? [] : void 0);\n        this.names || (this.names = [], this.names.keys = {});\n        this.plotLinesAndBandsGroups = {};\n        this.positiveValuesOnly = !!this.logarithmic;\n        this.isLinked = g(f.linkedTo);\n        this.ticks = {};\n        this.labelEdge = [];\n        this.minorTicks = {};\n        this.plotLinesAndBands = [];\n        this.alternateBands = {};\n        this.len = 0;\n        this.minRange = this.userMinRange = f.minRange || f.maxZoom;\n        this.range = f.range;\n        this.offset = f.offset || 0;\n        this.min = this.max = null;\n        d = k(f.crosshair, E(b.options.tooltip.crosshairs)[a ? 0 : 1]);\n        this.crosshair = !0 === d ? {} : d;\n        -1 === b.axes.indexOf(this) && (a ? b.axes.splice(b.xAxis.length, 0, this) : b.axes.push(this), b[this.coll].push(this));\n        this.series = this.series || [];\n        b.inverted && !this.isZAxis && a && \"undefined\" === typeof this.reversed && (this.reversed = !0);\n        this.labelRotation = p(e.rotation) ? e.rotation : void 0;\n        c(this, f);\n        m(this, \"afterInit\");\n      }\n      setOptions(d) {\n        this.options = b(y.defaultXAxisOptions, \"yAxis\" === this.coll && y.defaultYAxisOptions, [y.defaultTopAxisOptions, y.defaultRightAxisOptions, y.defaultBottomAxisOptions, y.defaultLeftAxisOptions][this.side], b(v[this.coll], d));\n        m(this, \"afterSetOptions\", {\n          userOptions: d\n        });\n      }\n      defaultLabelFormatter(b) {\n        var d = this.axis;\n        ({\n          numberFormatter: b\n        } = this.chart);\n        const f = p(this.value) ? this.value : NaN,\n          a = d.chart.time,\n          k = this.dateTimeLabelFormat;\n        var e = v.lang;\n        const c = e.numericSymbols;\n        e = e.numericSymbolMagnitude || 1E3;\n        const m = d.logarithmic ? Math.abs(f) : d.tickInterval;\n        let g = c && c.length,\n          K;\n        if (d.categories) K = `${this.value}`;else if (k) K = a.dateFormat(k, f);else if (g && 1E3 <= m) for (; g-- && \"undefined\" === typeof K;) d = Math.pow(e, g + 1), m >= d && 0 === 10 * f % d && null !== c[g] && 0 !== f && (K = b(f / d, -1) + c[g]);\n        \"undefined\" === typeof K && (K = 1E4 <= Math.abs(f) ? b(f, -1) : b(f, -1, void 0, \"\"));\n        return K;\n      }\n      getSeriesExtremes() {\n        const b = this,\n          d = b.chart;\n        let f;\n        m(this, \"getSeriesExtremes\", null, function () {\n          b.hasVisibleSeries = !1;\n          b.dataMin = b.dataMax = b.threshold = null;\n          b.softThreshold = !b.isXAxis;\n          b.series.forEach(function (a) {\n            if (a.visible || !d.options.chart.ignoreHiddenSeries) {\n              var e = a.options;\n              let d = e.threshold,\n                c,\n                m;\n              b.hasVisibleSeries = !0;\n              b.positiveValuesOnly && 0 >= d && (d = null);\n              if (b.isXAxis) (e = a.xData) && e.length && (e = b.logarithmic ? e.filter(b => 0 < b) : e, f = a.getXExtremes(e), c = f.min, m = f.max, p(c) || c instanceof Date || (e = e.filter(p), f = a.getXExtremes(e), c = f.min, m = f.max), e.length && (b.dataMin = Math.min(k(b.dataMin, c), c), b.dataMax = Math.max(k(b.dataMax, m), m)));else if (a = a.applyExtremes(), p(a.dataMin) && (c = a.dataMin, b.dataMin = Math.min(k(b.dataMin, c), c)), p(a.dataMax) && (m = a.dataMax, b.dataMax = Math.max(k(b.dataMax, m), m)), g(d) && (b.threshold = d), !e.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;\n            }\n          });\n        });\n        m(this, \"afterGetSeriesExtremes\");\n      }\n      translate(b, d, f, a, k, e) {\n        const c = this.linkedParent || this,\n          m = a && c.old ? c.old.min : c.min;\n        if (!p(m)) return NaN;\n        const B = c.minPixelPadding;\n        k = (c.isOrdinal || c.brokenAxis && c.brokenAxis.hasBreaks || c.logarithmic && k) && c.lin2val;\n        let g = 1,\n          K = 0;\n        a = a && c.old ? c.old.transA : c.transA;\n        a || (a = c.transA);\n        f && (g *= -1, K = c.len);\n        c.reversed && (g *= -1, K -= g * (c.sector || c.len));\n        d ? (e = (b * g + K - B) / a + m, k && (e = c.lin2val(e))) : (k && (b = c.val2lin(b)), b = g * (b - m) * a, e = (c.isRadial ? b : q(b)) + K + g * B + (p(e) ? a * e : 0));\n        return e;\n      }\n      toPixels(b, d) {\n        return this.translate(b, !1, !this.horiz, void 0, !0) + (d ? 0 : this.pos);\n      }\n      toValue(b, d) {\n        return this.translate(b - (d ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      }\n      getPlotLinePath(b) {\n        function d(b, d, a) {\n          \"pass\" !== E && (b < d || b > a) && (E ? b = h(b, d, a) : H = !0);\n          return b;\n        }\n        const a = this,\n          f = a.chart,\n          e = a.left,\n          c = a.top,\n          g = b.old,\n          K = b.value,\n          l = b.lineWidth,\n          n = g && f.oldChartHeight || f.chartHeight,\n          u = g && f.oldChartWidth || f.chartWidth,\n          r = a.transB;\n        let q = b.translatedValue,\n          E = b.force,\n          w,\n          O,\n          N,\n          X,\n          H;\n        b = {\n          value: K,\n          lineWidth: l,\n          old: g,\n          force: E,\n          acrossPanes: b.acrossPanes,\n          translatedValue: q\n        };\n        m(this, \"getPlotLinePath\", b, function (b) {\n          q = k(q, a.translate(K, void 0, void 0, g));\n          q = h(q, -1E5, 1E5);\n          w = N = Math.round(q + r);\n          O = X = Math.round(n - q - r);\n          p(q) ? a.horiz ? (O = c, X = n - a.bottom, w = N = d(w, e, e + a.width)) : (w = e, N = u - a.right, O = X = d(O, c, c + a.height)) : (H = !0, E = !1);\n          b.path = H && !E ? null : f.renderer.crispLine([[\"M\", w, O], [\"L\", N, X]], l || 1);\n        });\n        return b.path;\n      }\n      getLinearTickPositions(b, d, a) {\n        const f = q(Math.floor(d / b) * b);\n        a = q(Math.ceil(a / b) * b);\n        const k = [];\n        let e, c;\n        q(f + b) === f && (c = 20);\n        if (this.single) return [d];\n        for (d = f; d <= a;) {\n          k.push(d);\n          d = q(d + b, c);\n          if (d === e) break;\n          e = d;\n        }\n        return k;\n      }\n      getMinorTickInterval() {\n        const b = this.options;\n        return !0 === b.minorTicks ? k(b.minorTickInterval, \"auto\") : !1 === b.minorTicks ? null : b.minorTickInterval;\n      }\n      getMinorTickPositions() {\n        var b = this.options;\n        const d = this.tickPositions,\n          a = this.minorTickInterval;\n        var f = this.pointRangePadding || 0;\n        const k = this.min - f;\n        f = this.max + f;\n        const e = f - k;\n        let c = [];\n        if (e && e / a < this.len / 3) {\n          const e = this.logarithmic;\n          if (e) this.paddedTicks.forEach(function (b, d, f) {\n            d && c.push.apply(c, e.getLogTickPositions(a, f[d - 1], f[d], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) c = c.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(a), k, f, b.startOfWeek));else for (b = k + (d[0] - k) % a; b <= f && b !== c[0]; b += a) c.push(b);\n        }\n        0 !== c.length && this.trimTicks(c);\n        return c;\n      }\n      adjustForMinRange() {\n        const b = this.options,\n          d = this.logarithmic;\n        let a = this.min;\n        var f = this.max;\n        let e,\n          c = 0,\n          p,\n          m,\n          h,\n          n,\n          u;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !d && (g(b.min) || g(b.max) || g(b.floor) || g(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {\n          h = b.xData;\n          n = b.xIncrement ? 1 : h.length - 1;\n          if (1 < h.length) for (p = n; 0 < p; p--) if (m = h[p] - h[p - 1], !c || m < c) c = m;\n        }), this.minRange = Math.min(5 * c, this.dataMax - this.dataMin)));\n        if (f - a < this.minRange) {\n          e = this.dataMax - this.dataMin >= this.minRange;\n          u = this.minRange;\n          var q = (u - f + a) / 2;\n          q = [a - q, k(b.min, a - q)];\n          e && (q[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          a = r(q);\n          f = [a + u, k(b.max, a + u)];\n          e && (f[2] = d ? d.log2lin(this.dataMax) : this.dataMax);\n          f = l(f);\n          f - a < u && (q[0] = f - u, q[1] = k(b.min, f - u), a = r(q));\n        }\n        this.min = a;\n        this.max = f;\n      }\n      getClosest() {\n        let b;\n        this.categories ? b = 1 : this.series.forEach(function (d) {\n          const a = d.closestPointRange,\n            f = d.visible || !d.chart.options.chart.ignoreHiddenSeries;\n          !d.noSharedTooltip && g(a) && f && (b = g(b) ? Math.min(b, a) : a);\n        });\n        return b;\n      }\n      nameToX(b) {\n        const d = u(this.options.categories),\n          a = d ? this.categories : this.names;\n        let f = b.options.x,\n          e;\n        b.series.requireSorting = !1;\n        g(f) || (f = this.options.uniqueNames && a ? d ? a.indexOf(b.name) : k(a.keys[b.name], -1) : b.series.autoIncrement());\n        -1 === f ? !d && a && (e = a.length) : e = f;\n        \"undefined\" !== typeof e ? (this.names[e] = b.name, this.names.keys[b.name] = e) : b.x && (e = b.x);\n        return e;\n      }\n      updateNames() {\n        const b = this,\n          d = this.names;\n        0 < d.length && (Object.keys(d.keys).forEach(function (b) {\n          delete d.keys[b];\n        }), d.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (d) {\n          d.xIncrement = null;\n          if (!d.points || d.isDirtyData) b.max = Math.max(b.max, d.xData.length - 1), d.processData(), d.generatePoints();\n          d.data.forEach(function (a, f) {\n            let e;\n            a && a.options && \"undefined\" !== typeof a.name && (e = b.nameToX(a), \"undefined\" !== typeof e && e !== a.x && (a.x = e, d.xData[f] = e));\n          });\n        }));\n      }\n      setAxisTranslation() {\n        const b = this,\n          d = b.max - b.min;\n        var a = b.linkedParent;\n        const f = !!b.categories,\n          e = b.isXAxis;\n        let c = b.axisPointRange || 0,\n          p,\n          g = 0,\n          h = 0,\n          l = b.transA;\n        if (e || f || c) p = b.getClosest(), a ? (g = a.minPointOffset, h = a.pointRangePadding) : b.series.forEach(function (d) {\n          const a = f ? 1 : e ? k(d.options.pointRange, p, 0) : b.axisPointRange || 0,\n            m = d.options.pointPlacement;\n          c = Math.max(c, a);\n          if (!b.single || f) d = d.is(\"xrange\") ? !e : e, g = Math.max(g, d && H(m) ? 0 : a / 2), h = Math.max(h, d && \"on\" === m ? 0 : a);\n        }), a = b.ordinal && b.ordinal.slope && p ? b.ordinal.slope / p : 1, b.minPointOffset = g *= a, b.pointRangePadding = h *= a, b.pointRange = Math.min(c, b.single && f ? 1 : d), e && (b.closestPointRange = p);\n        b.translationSlope = b.transA = l = b.staticScale || b.len / (d + h || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = l * g;\n        m(this, \"afterSetAxisTranslation\");\n      }\n      minFromRange() {\n        return this.max - this.range;\n      }\n      setTickInterval(b) {\n        var d = this.chart;\n        const a = this.logarithmic,\n          f = this.options,\n          e = this.isXAxis,\n          c = this.isLinked,\n          h = f.tickPixelInterval,\n          l = this.categories,\n          K = this.softThreshold;\n        let n = f.maxPadding,\n          u = f.minPadding;\n        let r = p(f.tickInterval) && 0 <= f.tickInterval ? f.tickInterval : void 0,\n          E = p(this.threshold) ? this.threshold : null,\n          w,\n          O,\n          N;\n        this.dateTime || l || c || this.getTickAmount();\n        O = k(this.userMin, f.min);\n        N = k(this.userMax, f.max);\n        if (c) {\n          this.linkedParent = d[this.coll][f.linkedTo];\n          var H = this.linkedParent.getExtremes();\n          this.min = k(H.min, H.dataMin);\n          this.max = k(H.max, H.dataMax);\n          f.type !== this.linkedParent.options.type && x(11, 1, d);\n        } else K && g(E) && (this.dataMin >= E ? (H = E, u = 0) : this.dataMax <= E && (w = E, n = 0)), this.min = k(O, H, this.dataMin), this.max = k(N, w, this.dataMax);\n        a && (this.positiveValuesOnly && !b && 0 >= Math.min(this.min, k(this.dataMin, this.min)) && x(10, 1, d), this.min = q(a.log2lin(this.min), 16), this.max = q(a.log2lin(this.max), 16));\n        this.range && g(this.max) && (this.userMin = this.min = O = Math.max(this.dataMin, this.minFromRange()), this.userMax = N = this.max, this.range = null);\n        m(this, \"foundExtremes\");\n        this.beforePadding && this.beforePadding();\n        this.adjustForMinRange();\n        !(l || this.axisPointRange || this.stacking && this.stacking.usePercentage || c) && g(this.min) && g(this.max) && (d = this.max - this.min) && (!g(O) && u && (this.min -= d * u), !g(N) && n && (this.max += d * n));\n        p(this.userMin) || (p(f.softMin) && f.softMin < this.min && (this.min = O = f.softMin), p(f.floor) && (this.min = Math.max(this.min, f.floor)));\n        p(this.userMax) || (p(f.softMax) && f.softMax > this.max && (this.max = N = f.softMax), p(f.ceiling) && (this.max = Math.min(this.max, f.ceiling)));\n        K && g(this.dataMin) && (E = E || 0, !g(O) && this.min < E && this.dataMin >= E ? this.min = this.options.minRange ? Math.min(E, this.max - this.minRange) : E : !g(N) && this.max > E && this.dataMax <= E && (this.max = this.options.minRange ? Math.max(E, this.min + this.minRange) : E));\n        p(this.min) && p(this.max) && !this.chart.polar && this.min > this.max && (g(this.options.min) ? this.max = this.min : g(this.options.max) && (this.min = this.max));\n        this.tickInterval = this.min === this.max || \"undefined\" === typeof this.min || \"undefined\" === typeof this.max ? 1 : c && this.linkedParent && !r && h === this.linkedParent.options.tickPixelInterval ? r = this.linkedParent.tickInterval : k(r, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, l ? 1 : (this.max - this.min) * h / Math.max(this.len, h));\n        if (e && !b) {\n          const b = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n          this.series.forEach(function (d) {\n            d.forceCrop = d.forceCropping && d.forceCropping();\n            d.processData(b);\n          });\n          m(this, \"postProcessData\", {\n            hasExtremesChanged: b\n          });\n        }\n        this.setAxisTranslation();\n        m(this, \"initialAxisTranslation\");\n        this.pointRange && !r && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        b = k(f.minTickInterval, this.dateTime && !this.series.some(b => b.noSharedTooltip) ? this.closestPointRange : 0);\n        !r && this.tickInterval < b && (this.tickInterval = b);\n        this.dateTime || this.logarithmic || r || (this.tickInterval = T(this, this.tickInterval));\n        this.tickAmount || (this.tickInterval = this.unsquish());\n        this.setTickPositions();\n      }\n      setTickPositions() {\n        var b = this.options;\n        const d = b.tickPositions,\n          a = b.tickPositioner;\n        var f = this.getMinorTickInterval(),\n          e = this.hasVerticalPanning(),\n          k = \"colorAxis\" === this.coll;\n        const c = (k || !e) && b.startOnTick;\n        e = (k || !e) && b.endOnTick;\n        k = [];\n        let h;\n        this.tickmarkOffset = this.categories && \"between\" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === f && this.tickInterval ? this.tickInterval / b.minorTicksPerMajor : f;\n        this.single = this.min === this.max && g(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);\n        if (d) k = d.slice();else if (p(this.min) && p(this.max)) {\n          if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {\n            if (this.dateTime) k = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) k = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (f = b = this.tickInterval; f <= 2 * b;) if (k = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && k.length > this.tickAmount) this.tickInterval = T(this, f *= 1.1);else break;\n          } else k = [this.min, this.max], x(19, !1, this.chart);\n          k.length > this.len && (k = [k[0], k[k.length - 1]], k[0] === k[1] && (k.length = 1));\n          a && (this.tickPositions = k, (h = a.apply(this, [this.min, this.max])) && (k = h));\n        }\n        this.tickPositions = k;\n        this.paddedTicks = k.slice(0);\n        this.trimTicks(k, c, e);\n        !this.isLinked && p(this.min) && p(this.max) && (this.single && 2 > k.length && !this.categories && !this.series.some(b => b.is(\"heatmap\") && \"between\" === b.options.pointPlacement) && (this.min -= .5, this.max += .5), d || h || this.adjustTickAmount());\n        m(this, \"afterSetTickPositions\");\n      }\n      trimTicks(b, d, a) {\n        const f = b[0],\n          k = b[b.length - 1],\n          e = !this.isOrdinal && this.minPointOffset || 0;\n        m(this, \"trimTicks\");\n        if (!this.isLinked) {\n          if (d && -Infinity !== f) this.min = f;else for (; this.min - e > b[0];) b.shift();\n          if (a) this.max = k;else for (; this.max + e < b[b.length - 1];) b.pop();\n          0 === b.length && g(f) && !this.options.tickPositions && b.push((k + f) / 2);\n        }\n      }\n      alignToOthers() {\n        const b = this,\n          d = [this],\n          f = b.options,\n          a = \"yAxis\" === this.coll && this.chart.options.chart.alignThresholds,\n          k = [];\n        let e;\n        b.thresholdAlignment = void 0;\n        if ((!1 !== this.chart.options.chart.alignTicks && f.alignTicks || a) && !1 !== f.startOnTick && !1 !== f.endOnTick && !b.logarithmic) {\n          const f = b => {\n              const {\n                horiz: d,\n                options: f\n              } = b;\n              return [d ? f.left : f.top, f.width, f.height, f.pane].join();\n            },\n            a = f(this);\n          this.chart[this.coll].forEach(function (k) {\n            const {\n              series: c\n            } = k;\n            c.length && c.some(b => b.visible) && k !== b && f(k) === a && (e = !0, d.push(k));\n          });\n        }\n        if (e && a) {\n          d.forEach(d => {\n            d = d.getThresholdAlignment(b);\n            p(d) && k.push(d);\n          });\n          const f = 1 < k.length ? k.reduce((b, d) => b + d, 0) / k.length : void 0;\n          d.forEach(b => {\n            b.thresholdAlignment = f;\n          });\n        }\n        return e;\n      }\n      getThresholdAlignment(b) {\n        (!p(this.dataMin) || this !== b && this.series.some(b => b.isDirty || b.isDirtyData)) && this.getSeriesExtremes();\n        if (p(this.threshold)) return b = h((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (b = 1 - b), b;\n      }\n      getTickAmount() {\n        const b = this.options,\n          d = b.tickPixelInterval;\n        let f = b.tickAmount;\n        !g(b.tickInterval) && !f && this.len < d && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (f = 2);\n        !f && this.alignToOthers() && (f = Math.ceil(this.len / d) + 1);\n        4 > f && (this.finalTickAmt = f, f = 5);\n        this.tickAmount = f;\n      }\n      adjustTickAmount() {\n        const b = this,\n          {\n            finalTickAmt: d,\n            max: f,\n            min: a,\n            options: e,\n            tickPositions: c,\n            tickAmount: m,\n            thresholdAlignment: h\n          } = b,\n          l = c && c.length;\n        var n = k(b.threshold, b.softThreshold ? 0 : null);\n        var u = b.tickInterval;\n        let r;\n        p(h) && (r = .5 > h ? Math.ceil(h * (m - 1)) : Math.floor(h * (m - 1)), e.reversed && (r = m - 1 - r));\n        if (b.hasData() && p(a) && p(f)) {\n          const k = () => {\n            b.transA *= (l - 1) / (m - 1);\n            b.min = e.startOnTick ? c[0] : Math.min(a, c[0]);\n            b.max = e.endOnTick ? c[c.length - 1] : Math.max(f, c[c.length - 1]);\n          };\n          if (p(r) && p(b.threshold)) {\n            for (; c[r] !== n || c.length !== m || c[0] > a || c[c.length - 1] < f;) {\n              c.length = 0;\n              for (c.push(b.threshold); c.length < m;) void 0 === c[r] || c[r] > b.threshold ? c.unshift(q(c[0] - u)) : c.push(q(c[c.length - 1] + u));\n              if (u > 8 * b.tickInterval) break;\n              u *= 2;\n            }\n            k();\n          } else if (l < m) {\n            for (; c.length < m;) c.length % 2 || a === n ? c.push(q(c[c.length - 1] + u)) : c.unshift(q(c[0] - u));\n            k();\n          }\n          if (g(d)) {\n            for (u = n = c.length; u--;) (3 === d && 1 === u % 2 || 2 >= d && 0 < u && u < n - 1) && c.splice(u, 1);\n            b.finalTickAmt = void 0;\n          }\n        }\n      }\n      setScale() {\n        let b = !1,\n          d = !1;\n        this.series.forEach(function (f) {\n          b = b || f.isDirtyData || f.isDirty;\n          d = d || f.xAxis && f.xAxis.isDirty || !1;\n        });\n        this.setAxisSize();\n        const f = this.len !== (this.old && this.old.len);\n        f || b || d || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = f || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();\n        b && this.panningState && (this.panningState.isDirty = !0);\n        m(this, \"afterSetScale\");\n      }\n      setExtremes(b, d, f, a, c) {\n        const p = this,\n          g = p.chart;\n        f = k(f, !0);\n        p.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        c = e(c, {\n          min: b,\n          max: d\n        });\n        m(p, \"setExtremes\", c, function () {\n          p.userMin = b;\n          p.userMax = d;\n          p.eventArgs = c;\n          f && g.redraw(a);\n        });\n      }\n      zoom(b, d) {\n        const f = this,\n          a = this.dataMin,\n          e = this.dataMax,\n          c = this.options,\n          p = Math.min(a, k(c.min, a)),\n          h = Math.max(e, k(c.max, e));\n        b = {\n          newMin: b,\n          newMax: d\n        };\n        m(this, \"zoom\", b, function (b) {\n          let d = b.newMin,\n            k = b.newMax;\n          if (d !== f.min || k !== f.max) f.allowZoomOutside || (g(a) && (d < p && (d = p), d > h && (d = h)), g(e) && (k < p && (k = p), k > h && (k = h))), f.displayBtn = \"undefined\" !== typeof d || \"undefined\" !== typeof k, f.setExtremes(d, k, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return b.zoomed;\n      }\n      setAxisSize() {\n        const b = this.chart;\n        var d = this.options;\n        const f = d.offsets || [0, 0, 0, 0],\n          a = this.horiz,\n          e = this.width = Math.round(O(k(d.width, b.plotWidth - f[3] + f[1]), b.plotWidth)),\n          c = this.height = Math.round(O(k(d.height, b.plotHeight - f[0] + f[2]), b.plotHeight)),\n          p = this.top = Math.round(O(k(d.top, b.plotTop + f[0]), b.plotHeight, b.plotTop));\n        d = this.left = Math.round(O(k(d.left, b.plotLeft + f[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - c - p;\n        this.right = b.chartWidth - e - d;\n        this.len = Math.max(a ? e : c, 0);\n        this.pos = a ? d : p;\n      }\n      getExtremes() {\n        const b = this.logarithmic;\n        return {\n          min: b ? q(b.lin2log(this.min)) : this.min,\n          max: b ? q(b.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      }\n      getThreshold(b) {\n        var d = this.logarithmic;\n        const f = d ? d.lin2log(this.min) : this.min;\n        d = d ? d.lin2log(this.max) : this.max;\n        null === b || -Infinity === b ? b = f : Infinity === b ? b = d : f > b ? b = f : d < b && (b = d);\n        return this.translate(b, 0, 1, 0, 1);\n      }\n      autoLabelAlign(b) {\n        const d = (k(b, 0) - 90 * this.side + 720) % 360;\n        b = {\n          align: \"center\"\n        };\n        m(this, \"autoLabelAlign\", b, function (b) {\n          15 < d && 165 > d ? b.align = \"right\" : 195 < d && 345 > d && (b.align = \"left\");\n        });\n        return b.align;\n      }\n      tickSize(b) {\n        const d = this.options,\n          f = k(d[\"tick\" === b ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === b && this.isXAxis && !this.categories ? 1 : 0);\n        let a = d[\"tick\" === b ? \"tickLength\" : \"minorTickLength\"],\n          e;\n        f && a && (\"inside\" === d[b + \"Position\"] && (a = -a), e = [a, f]);\n        b = {\n          tickSize: e\n        };\n        m(this, \"afterTickSize\", b);\n        return b.tickSize;\n      }\n      labelMetrics() {\n        const b = this.chart.renderer;\n        var d = this.ticks;\n        d = d[Object.keys(d)[0]] || {};\n        return this.chart.renderer.fontMetrics(d.label || d.movedLabel || b.box);\n      }\n      unsquish() {\n        const b = this.options.labels;\n        var d = this.horiz;\n        const f = this.tickInterval,\n          a = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / f),\n          e = b.rotation,\n          c = .75 * this.labelMetrics().h,\n          m = Math.max(this.max - this.min, 0),\n          g = function (b) {\n            let d = b / (a || 1);\n            d = 1 < d ? Math.ceil(d) : 1;\n            d * f > m && Infinity !== b && Infinity !== a && m && (d = Math.ceil(m / f));\n            return q(d * f);\n          };\n        let h = f,\n          l,\n          u = Number.MAX_VALUE,\n          r;\n        if (d) {\n          if (b.staggerLines || (p(e) ? r = [e] : a < b.autoRotationLimit && (r = b.autoRotation)), r) {\n            let b;\n            for (const f of r) if (f === e || f && -90 <= f && 90 >= f) d = g(Math.abs(c / Math.sin(n * f))), b = d + Math.abs(f / 360), b < u && (u = b, l = f, h = d);\n          }\n        } else h = g(c);\n        this.autoRotation = r;\n        this.labelRotation = k(l, p(e) ? e : 0);\n        return b.step ? f : h;\n      }\n      getSlotWidth(b) {\n        const d = this.chart,\n          f = this.horiz,\n          a = this.options.labels,\n          e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n          k = d.margin[3];\n        if (b && p(b.slotWidth)) return b.slotWidth;\n        if (f && 2 > a.step) return a.rotation ? 0 : (this.staggerLines || 1) * this.len / e;\n        if (!f) {\n          b = a.style.width;\n          if (void 0 !== b) return parseInt(String(b), 10);\n          if (k) return k - d.spacing[3];\n        }\n        return .33 * d.chartWidth;\n      }\n      renderUnsquish() {\n        const b = this.chart,\n          d = b.renderer,\n          f = this.tickPositions,\n          a = this.ticks,\n          e = this.options.labels,\n          k = e.style,\n          c = this.horiz,\n          p = this.getSlotWidth();\n        var m = Math.max(1, Math.round(p - 2 * e.padding));\n        const g = {},\n          h = this.labelMetrics(),\n          l = k.textOverflow;\n        let u,\n          n,\n          r = 0;\n        H(e.rotation) || (g.rotation = e.rotation || 0);\n        f.forEach(function (b) {\n          b = a[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > r && (r = b.label.textPxLength);\n        });\n        this.maxLabelLength = r;\n        if (this.autoRotation) r > m && r > h.h ? g.rotation = this.labelRotation : this.labelRotation = 0;else if (p && (u = m, !l)) for (n = \"clip\", m = f.length; !c && m--;) {\n          var q = f[m];\n          if (q = a[q].label) q.styles && \"ellipsis\" === q.styles.textOverflow ? q.css({\n            textOverflow: \"clip\"\n          }) : q.textPxLength > p && q.css({\n            width: p + \"px\"\n          }), q.getBBox().height > this.len / f.length - (h.h - h.f) && (q.specificTextOverflow = \"ellipsis\");\n        }\n        g.rotation && (u = r > .5 * b.chartHeight ? .33 * b.chartHeight : r, l || (n = \"ellipsis\"));\n        if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation)) g.align = this.labelAlign;\n        f.forEach(function (b) {\n          const d = (b = a[b]) && b.label,\n            f = k.width,\n            e = {};\n          d && (d.attr(g), b.shortenLabel ? b.shortenLabel() : u && !f && \"nowrap\" !== k.whiteSpace && (u < d.textPxLength || \"SPAN\" === d.element.tagName) ? (e.width = u + \"px\", l || (e.textOverflow = d.specificTextOverflow || n), d.css(e)) : d.styles && d.styles.width && !e.width && !f && d.css({\n            width: null\n          }), delete d.specificTextOverflow, b.rotation = g.rotation);\n        }, this);\n        this.tickRotCorr = d.rotCorr(h.b, this.labelRotation || 0, 0 !== this.side);\n      }\n      hasData() {\n        return this.series.some(function (b) {\n          return b.hasData();\n        }) || this.options.showEmpty && g(this.min) && g(this.max);\n      }\n      addTitle(d) {\n        const f = this.chart.renderer,\n          a = this.horiz,\n          e = this.opposite,\n          k = this.options.title,\n          c = this.chart.styledMode;\n        let p;\n        this.axisTitle || ((p = k.textAlign) || (p = (a ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: e ? \"right\" : \"left\",\n          middle: \"center\",\n          high: e ? \"left\" : \"right\"\n        })[k.align]), this.axisTitle = f.text(k.text || \"\", 0, 0, k.useHTML).attr({\n          zIndex: 7,\n          rotation: k.rotation,\n          align: p\n        }).addClass(\"highcharts-axis-title\"), c || this.axisTitle.css(b(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        c || k.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[d ? \"show\" : \"hide\"](d);\n      }\n      generateTick(b) {\n        const d = this.ticks;\n        d[b] ? d[b].addLabel() : d[b] = new C(this, b);\n      }\n      getOffset() {\n        const b = this,\n          {\n            chart: f,\n            horiz: a,\n            options: e,\n            side: c,\n            ticks: h,\n            tickPositions: l,\n            coll: u,\n            axisParent: n\n          } = b,\n          r = f.renderer,\n          q = f.inverted && !b.isZAxis ? [1, 0, 3, 2][c] : c;\n        var E = b.hasData();\n        const w = e.title;\n        var O = e.labels;\n        const N = p(e.crossing);\n        var H = f.axisOffset;\n        const t = f.clipOffset,\n          X = [-1, 1, 1, -1][c],\n          aa = e.className;\n        let ea,\n          J = 0,\n          v;\n        var x = 0;\n        let F = 0;\n        b.showAxis = ea = E || e.showEmpty;\n        b.staggerLines = b.horiz && O.staggerLines || void 0;\n        if (!b.axisGroup) {\n          const d = (b, d, f) => r.g(b).attr({\n            zIndex: f\n          }).addClass(`highcharts-${u.toLowerCase()}${d} ` + (this.isRadial ? `highcharts-radial-axis${d} ` : \"\") + (aa || \"\")).add(n);\n          b.gridGroup = d(\"grid\", \"-grid\", e.gridZIndex);\n          b.axisGroup = d(\"axis\", \"\", e.zIndex);\n          b.labelGroup = d(\"axis-labels\", \"-labels\", O.zIndex);\n        }\n        E || b.isLinked ? (l.forEach(function (d) {\n          b.generateTick(d);\n        }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === c || 2 === c || {\n          1: \"left\",\n          3: \"right\"\n        }[c] === b.labelAlign, k(O.reserveSpace, N ? !1 : null, \"center\" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && l.forEach(function (b) {\n          F = Math.max(h[b].getLabelSize(), F);\n        }), b.staggerLines && (F *= b.staggerLines), b.labelOffset = F * (b.opposite ? -1 : 1)) : d(h, function (b, d) {\n          b.destroy();\n          delete h[d];\n        });\n        w && w.text && !1 !== w.enabled && (b.addTitle(ea), ea && !N && !1 !== w.reserveSpace && (b.titleOffset = J = b.axisTitle.getBBox()[a ? \"height\" : \"width\"], v = w.offset, x = g(v) ? 0 : k(w.margin, a ? 5 : 10)));\n        b.renderLine();\n        b.offset = X * k(e.offset, H[c] ? H[c] + (e.margin || 0) : 0);\n        b.tickRotCorr = b.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        E = 0 === c ? -b.labelMetrics().h : 2 === c ? b.tickRotCorr.y : 0;\n        x = Math.abs(F) + x;\n        F && (x = x - E + X * (a ? k(O.y, b.tickRotCorr.y + X * O.distance) : k(O.x, X * O.distance)));\n        b.axisTitleMargin = k(v, x);\n        b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(h, l));\n        \"colorAxis\" !== u && (O = this.tickSize(\"tick\"), H[c] = Math.max(H[c], (b.axisTitleMargin || 0) + J + X * b.offset, x, l && l.length && O ? O[0] + X * b.offset : 0), H = !b.axisLine || e.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2), t[q] = Math.max(t[q], H));\n        m(this, \"afterGetOffset\");\n      }\n      getLinePath(b) {\n        const d = this.chart,\n          f = this.opposite;\n        var a = this.offset;\n        const e = this.horiz,\n          k = this.left + (f ? this.width : 0) + a;\n        a = d.chartHeight - this.bottom - (f ? this.height : 0) + a;\n        f && (b *= -1);\n        return d.renderer.crispLine([[\"M\", e ? this.left : k, e ? a : this.top], [\"L\", e ? d.chartWidth - this.right : k, e ? a : d.chartHeight - this.bottom]], b);\n      }\n      renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      }\n      getTitlePosition(b) {\n        var d = this.horiz,\n          f = this.left;\n        const a = this.top;\n        var e = this.len;\n        const k = this.options.title,\n          c = d ? f : a,\n          p = this.opposite,\n          g = this.offset,\n          h = k.x,\n          l = k.y,\n          u = this.chart.renderer.fontMetrics(b);\n        b = b ? Math.max(b.getBBox(!1, 0).height - u.h - 1, 0) : 0;\n        e = {\n          low: c + (d ? 0 : e),\n          middle: c + e / 2,\n          high: c + (d ? e : 0)\n        }[k.align];\n        f = (d ? a + this.height : f) + (d ? 1 : -1) * (p ? -1 : 1) * (this.axisTitleMargin || 0) + [-b, b, u.f, -b][this.side];\n        d = {\n          x: d ? e + h : f + (p ? this.width : 0) + g + h,\n          y: d ? f + l - (p ? this.height : 0) + g : e + l\n        };\n        m(this, \"afterGetTitlePosition\", {\n          titlePosition: d\n        });\n        return d;\n      }\n      renderMinorTick(b, d) {\n        const f = this.minorTicks;\n        f[b] || (f[b] = new C(this, b, \"minor\"));\n        d && f[b].isNew && f[b].render(null, !0);\n        f[b].render(null, !1, 1);\n      }\n      renderTick(b, d, f) {\n        const a = this.ticks;\n        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) a[b] || (a[b] = new C(this, b)), f && a[b].isNew && a[b].render(d, !0, -1), a[b].render(d);\n      }\n      render() {\n        const b = this,\n          f = b.chart,\n          a = b.logarithmic,\n          e = b.options,\n          k = b.isLinked,\n          c = b.tickPositions,\n          g = b.axisTitle,\n          h = b.ticks,\n          l = b.minorTicks,\n          u = b.alternateBands,\n          n = e.stackLabels,\n          r = e.alternateGridColor,\n          q = e.crossing,\n          E = b.tickmarkOffset,\n          w = b.axisLine,\n          O = b.showAxis,\n          H = t(f.renderer.globalAnimation);\n        let N, aa;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        [h, l, u].forEach(function (b) {\n          d(b, function (b) {\n            b.isActive = !1;\n          });\n        });\n        if (p(q)) {\n          const b = this.isXAxis ? f.yAxis[0] : f.xAxis[0],\n            d = [1, -1, -1, 1][this.side];\n          b && (this.offset = d * b.toPixels(q, !0));\n        }\n        if (b.hasData() || k) {\n          const d = b.chart.hasRendered && b.old && p(b.old.min);\n          b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (f) {\n            b.renderMinorTick(f, d);\n          });\n          c.length && (c.forEach(function (f, a) {\n            b.renderTick(f, a, d);\n          }), E && (0 === b.min || b.single) && (h[-1] || (h[-1] = new C(b, -1, null, !0)), h[-1].render(-1)));\n          r && c.forEach(function (d, e) {\n            aa = \"undefined\" !== typeof c[e + 1] ? c[e + 1] + E : b.max - E;\n            0 === e % 2 && d < b.max && aa <= b.max + (f.polar ? -E : E) && (u[d] || (u[d] = new D.PlotLineOrBand(b)), N = d + E, u[d].options = {\n              from: a ? a.lin2log(N) : N,\n              to: a ? a.lin2log(aa) : aa,\n              color: r,\n              className: \"highcharts-alternate-grid\"\n            }, u[d].render(), u[d].isActive = !0);\n          });\n          b._addedPlotLB || (b._addedPlotLB = !0, (e.plotLines || []).concat(e.plotBands || []).forEach(function (d) {\n            b.addPlotBandOrLine(d);\n          }));\n        }\n        [h, l, u].forEach(function (b) {\n          const a = [],\n            e = H.duration;\n          d(b, function (b, d) {\n            b.isActive || (b.render(d, !1, 0), b.isActive = !1, a.push(d));\n          });\n          Z(function () {\n            let d = a.length;\n            for (; d--;) b[a[d]] && !b[a[d]].isActive && (b[a[d]].destroy(), delete b[a[d]]);\n          }, b !== u && f.hasRendered && e ? e : 0);\n        });\n        w && (w[w.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(w.strokeWidth())\n        }), w.isPlaced = !0, w[O ? \"show\" : \"hide\"](O));\n        g && O && (g[g.isNew ? \"attr\" : \"animate\"](b.getTitlePosition(g)), g.isNew = !1);\n        n && n.enabled && b.stacking && b.stacking.renderStackTotals();\n        b.old = {\n          len: b.len,\n          max: b.max,\n          min: b.min,\n          transA: b.transA,\n          userMax: b.userMax,\n          userMin: b.userMin\n        };\n        b.isDirty = !1;\n        m(this, \"afterRender\");\n      }\n      redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {\n          b.render();\n        }));\n        this.series.forEach(function (b) {\n          b.isDirty = !0;\n        });\n      }\n      getKeepProps() {\n        return this.keepProps || U.keepProps;\n      }\n      destroy(b) {\n        const f = this,\n          a = f.plotLinesAndBands,\n          e = this.eventOptions;\n        m(this, \"destroy\", {\n          keepEvents: b\n        });\n        b || N(f);\n        [f.ticks, f.minorTicks, f.alternateBands].forEach(function (b) {\n          w(b);\n        });\n        if (a) for (b = a.length; b--;) a[b].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (b) {\n          f[b] && (f[b] = f[b].destroy());\n        });\n        for (const b in f.plotLinesAndBandsGroups) f.plotLinesAndBandsGroups[b] = f.plotLinesAndBandsGroups[b].destroy();\n        d(f, function (b, d) {\n          -1 === f.getKeepProps().indexOf(d) && delete f[d];\n        });\n        this.eventOptions = e;\n      }\n      drawCrosshair(b, d) {\n        const f = this.crosshair;\n        var a = k(f && f.snap, !0);\n        const c = this.chart;\n        let p,\n          h = this.cross;\n        m(this, \"drawCrosshair\", {\n          e: b,\n          point: d\n        });\n        b || (b = this.cross && this.cross.e);\n        if (f && !1 !== (g(d) || !a)) {\n          a ? g(d) && (p = k(\"colorAxis\" !== this.coll ? d.crosshairPos : null, this.isXAxis ? d.plotX : this.len - d.plotY)) : p = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);\n          if (g(p)) {\n            var l = {\n              value: d && (this.isXAxis ? d.x : k(d.stackY, d.y)),\n              translatedValue: p\n            };\n            c.polar && e(l, {\n              isCrosshair: !0,\n              chartX: b && b.chartX,\n              chartY: b && b.chartY,\n              point: d\n            });\n            l = this.getPlotLinePath(l) || null;\n          }\n          if (!g(l)) {\n            this.hideCrosshair();\n            return;\n          }\n          a = this.categories && !this.isRadial;\n          h || (this.cross = h = c.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (a ? \"category \" : \"thin \") + (f.className || \"\")).attr({\n            zIndex: k(f.zIndex, 2)\n          }).add(), c.styledMode || (h.attr({\n            stroke: f.color || (a ? G.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": k(f.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), f.dashStyle && h.attr({\n            dashstyle: f.dashStyle\n          })));\n          h.show().attr({\n            d: l\n          });\n          a && !f.width && h.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = b;\n        } else this.hideCrosshair();\n        m(this, \"afterDrawCrosshair\", {\n          e: b,\n          point: d\n        });\n      }\n      hideCrosshair() {\n        this.cross && this.cross.hide();\n        m(this, \"afterHideCrosshair\");\n      }\n      hasVerticalPanning() {\n        const b = this.chart.options.chart.panning;\n        return !!(b && b.enabled && /y/.test(b.type));\n      }\n      update(d, f) {\n        const a = this.chart;\n        d = b(this.userOptions, d);\n        this.destroy(!0);\n        this.init(a, d);\n        a.isDirtyBox = !0;\n        k(f, !0) && a.redraw();\n      }\n      remove(b) {\n        const d = this.chart,\n          f = this.coll,\n          a = this.series;\n        let e = a.length;\n        for (; e--;) a[e] && a[e].remove(!1);\n        J(d.axes, this);\n        J(d[f], this);\n        d[f].forEach(function (b, d) {\n          b.options.index = b.userOptions.index = d;\n        });\n        this.destroy();\n        d.isDirtyBox = !0;\n        k(b, !0) && d.redraw();\n      }\n      setTitle(b, d) {\n        this.update({\n          title: b\n        }, d);\n      }\n      setCategories(b, d) {\n        this.update({\n          categories: b\n        }, d);\n      }\n    }\n    U.defaultOptions = y.defaultXAxisOptions;\n    U.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n    \"\";\n    return U;\n  });\n  M(a, \"Core/Axis/DateTimeAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: x,\n      getMagnitude: G,\n      normalizeTickInterval: L,\n      timeUnits: A\n    } = a;\n    var D;\n    (function (y) {\n      function z() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function t(a) {\n        \"datetime\" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new c(this));\n      }\n      const v = [];\n      y.compose = function (c) {\n        a.pushUnique(v, c) && (c.keepProps.push(\"dateTime\"), c.prototype.getTimeTicks = z, x(c, \"init\", t));\n        return c;\n      };\n      class c {\n        constructor(a) {\n          this.axis = a;\n        }\n        normalizeTimeTickInterval(a, c) {\n          const l = c || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n          c = l[l.length - 1];\n          let h = A[c[0]],\n            n = c[1],\n            g;\n          for (g = 0; g < l.length && !(c = l[g], h = A[c[0]], n = c[1], l[g + 1] && a <= (h * n[n.length - 1] + A[l[g + 1][0]]) / 2); g++);\n          h === A.year && a < 5 * h && (n = [1, 2, 5]);\n          a = L(a / h, n, \"year\" === c[0] ? Math.max(G(a / h), 1) : 1);\n          return {\n            unitRange: h,\n            count: a,\n            unitName: c[0]\n          };\n        }\n        getXDateFormat(a, c) {\n          const {\n              axis: l\n            } = this,\n            h = l.chart.time;\n          return l.closestPointRange ? h.getDateFormat(l.closestPointRange, a, l.options.startOfWeek, c) || h.resolveDTLFormat(c.year).main : h.resolveDTLFormat(c.day).main;\n        }\n      }\n      y.Additions = c;\n    })(D || (D = {}));\n    return D;\n  });\n  M(a, \"Core/Axis/LogarithmicAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: x,\n      normalizeTickInterval: G,\n      pick: L\n    } = a;\n    var A;\n    (function (y) {\n      function C(a) {\n        let c = this.logarithmic;\n        \"logarithmic\" !== a.userOptions.type ? this.logarithmic = void 0 : c || (this.logarithmic = new v(this));\n      }\n      function z() {\n        const a = this.logarithmic;\n        a && (this.lin2val = function (c) {\n          return a.lin2log(c);\n        }, this.val2lin = function (c) {\n          return a.log2lin(c);\n        });\n      }\n      const t = [];\n      y.compose = function (c) {\n        a.pushUnique(t, c) && (c.keepProps.push(\"logarithmic\"), x(c, \"init\", C), x(c, \"afterInit\", z));\n        return c;\n      };\n      class v {\n        constructor(a) {\n          this.axis = a;\n        }\n        getLogTickPositions(a, n, r, l) {\n          const c = this.axis;\n          var q = c.len,\n            g = c.options;\n          let w = [];\n          l || (this.minorAutoInterval = void 0);\n          if (.5 <= a) a = Math.round(a), w = c.getLinearTickPositions(a, n, r);else if (.08 <= a) {\n            g = Math.floor(n);\n            let c, h, e, m, u;\n            for (q = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; g < r + 1 && !u; g++) for (h = q.length, c = 0; c < h && !u; c++) e = this.log2lin(this.lin2log(g) * q[c]), e > n && (!l || m <= r) && \"undefined\" !== typeof m && w.push(m), m > r && (u = !0), m = e;\n          } else n = this.lin2log(n), r = this.lin2log(r), a = l ? c.getMinorTickInterval() : g.tickInterval, a = L(\"auto\" === a ? null : a, this.minorAutoInterval, g.tickPixelInterval / (l ? 5 : 1) * (r - n) / ((l ? q / c.tickPositions.length : q) || 1)), a = G(a), w = c.getLinearTickPositions(a, n, r).map(this.log2lin), l || (this.minorAutoInterval = a / 5);\n          l || (c.tickInterval = a);\n          return w;\n        }\n        lin2log(a) {\n          return Math.pow(10, a);\n        }\n        log2lin(a) {\n          return Math.log(a) / Math.LN10;\n        }\n      }\n      y.Additions = v;\n    })(A || (A = {}));\n    return A;\n  });\n  M(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      erase: x,\n      extend: G,\n      isNumber: L\n    } = a;\n    var A;\n    (function (y) {\n      function C(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      }\n      function z(a, c) {\n        const g = this.userOptions;\n        let l = new h(this, a);\n        this.visible && (l = l.render());\n        if (l) {\n          this._addedPlotLB || (this._addedPlotLB = !0, (g.plotLines || []).concat(g.plotBands || []).forEach(a => {\n            this.addPlotBandOrLine(a);\n          }));\n          if (c) {\n            const h = g[c] || [];\n            h.push(a);\n            g[c] = h;\n          }\n          this.plotLinesAndBands.push(l);\n        }\n        return l;\n      }\n      function t(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      }\n      function v(a, c, h = this.options) {\n        const g = this.getPlotLinePath({\n            value: c,\n            force: !0,\n            acrossPanes: h.acrossPanes\n          }),\n          l = [],\n          e = this.horiz;\n        c = !L(this.min) || !L(this.max) || a < this.min && c < this.min || a > this.max && c > this.max;\n        a = this.getPlotLinePath({\n          value: a,\n          force: !0,\n          acrossPanes: h.acrossPanes\n        });\n        h = 1;\n        let m;\n        if (a && g) for (c && (m = a.toString() === g.toString(), h = 0), c = 0; c < a.length; c += 2) {\n          const u = a[c],\n            p = a[c + 1],\n            n = g[c],\n            b = g[c + 1];\n          \"M\" !== u[0] && \"L\" !== u[0] || \"M\" !== p[0] && \"L\" !== p[0] || \"M\" !== n[0] && \"L\" !== n[0] || \"M\" !== b[0] && \"L\" !== b[0] || (e && n[1] === u[1] ? (n[1] += h, b[1] += h) : e || n[2] !== u[2] || (n[2] += h, b[2] += h), l.push([\"M\", u[1], u[2]], [\"L\", p[1], p[2]], [\"L\", b[1], b[2]], [\"L\", n[1], n[2]], [\"Z\"]));\n          l.isFlat = m;\n        }\n        return l;\n      }\n      function c(a) {\n        this.removePlotBandOrLine(a);\n      }\n      function n(a) {\n        const c = this.plotLinesAndBands,\n          h = this.options,\n          l = this.userOptions;\n        if (c) {\n          let g = c.length;\n          for (; g--;) c[g].id === a && c[g].destroy();\n          [h.plotLines || [], l.plotLines || [], h.plotBands || [], l.plotBands || []].forEach(function (e) {\n            for (g = e.length; g--;) (e[g] || {}).id === a && x(e, e[g]);\n          });\n        }\n      }\n      function r(a) {\n        this.removePlotBandOrLine(a);\n      }\n      const l = [];\n      let h;\n      y.compose = function (q, g) {\n        h || (h = q);\n        a.pushUnique(l, g) && G(g.prototype, {\n          addPlotBand: C,\n          addPlotLine: t,\n          addPlotBandOrLine: z,\n          getPlotBandPath: v,\n          removePlotBand: c,\n          removePlotLine: r,\n          removePlotBandOrLine: n\n        });\n        return g;\n      };\n    })(A || (A = {}));\n    return A;\n  });\n  M(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [a[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n      arrayMax: x,\n      arrayMin: L,\n      defined: A,\n      destroyObjectProperties: D,\n      erase: C,\n      fireEvent: z,\n      merge: t,\n      objectEach: v,\n      pick: c\n    } = y;\n    class n {\n      static compose(c) {\n        return a.compose(n, c);\n      }\n      constructor(a, c) {\n        this.axis = a;\n        c && (this.options = c, this.id = c.id);\n      }\n      render() {\n        z(this, \"render\");\n        const a = this,\n          l = a.axis,\n          h = l.horiz;\n        var n = l.logarithmic;\n        const g = a.options,\n          w = g.color,\n          x = c(g.zIndex, 0),\n          F = g.events,\n          e = {},\n          m = l.chart.renderer;\n        let u = g.label,\n          p = a.label,\n          H = g.to,\n          b = g.from,\n          f = g.value,\n          d = a.svgElem;\n        var k = [];\n        const O = A(b) && A(H);\n        k = A(f);\n        const N = !d,\n          E = {\n            \"class\": \"highcharts-plot-\" + (O ? \"band \" : \"line \") + (g.className || \"\")\n          };\n        let Z = O ? \"bands\" : \"lines\";\n        n && (b = n.log2lin(b), H = n.log2lin(H), f = n.log2lin(f));\n        l.chart.styledMode || (k ? (E.stroke = w || \"#999999\", E[\"stroke-width\"] = c(g.width, 1), g.dashStyle && (E.dashstyle = g.dashStyle)) : O && (E.fill = w || \"#e6e9ff\", g.borderWidth && (E.stroke = g.borderColor, E[\"stroke-width\"] = g.borderWidth)));\n        e.zIndex = x;\n        Z += \"-\" + x;\n        (n = l.plotLinesAndBandsGroups[Z]) || (l.plotLinesAndBandsGroups[Z] = n = m.g(\"plot-\" + Z).attr(e).add());\n        N && (a.svgElem = d = m.path().attr(E).add(n));\n        if (k) k = l.getPlotLinePath({\n          value: f,\n          lineWidth: d.strokeWidth(),\n          acrossPanes: g.acrossPanes\n        });else if (O) k = l.getPlotBandPath(b, H, g);else return;\n        !a.eventsAdded && F && (v(F, function (b, f) {\n          d.on(f, function (b) {\n            F[f].apply(a, [b]);\n          });\n        }), a.eventsAdded = !0);\n        (N || !d.d) && k && k.length ? d.attr({\n          d: k\n        }) : d && (k ? (d.show(), d.animate({\n          d: k\n        })) : d.d && (d.hide(), p && (a.label = p = p.destroy())));\n        u && (A(u.text) || A(u.formatter)) && k && k.length && 0 < l.width && 0 < l.height && !k.isFlat ? (u = t({\n          align: h && O && \"center\",\n          x: h ? !O && 4 : 10,\n          verticalAlign: !h && O && \"middle\",\n          y: h ? O ? 16 : 10 : O ? 6 : -4,\n          rotation: h && !O && 90\n        }, u), this.renderLabel(u, k, O, x)) : p && p.hide();\n        return a;\n      }\n      renderLabel(a, c, h, n) {\n        const g = this.axis;\n        var l = g.chart.renderer;\n        let r = this.label;\n        r || (this.label = r = l.text(this.getLabelText(a), 0, 0, a.useHTML).attr({\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (h ? \"band\" : \"line\") + \"-label \" + (a.className || \"\"),\n          zIndex: n\n        }).add(), g.chart.styledMode || r.css(t({\n          fontSize: \"0.8em\",\n          textOverflow: \"ellipsis\"\n        }, a.style)));\n        n = c.xBounds || [c[0][1], c[1][1], h ? c[2][1] : c[0][1]];\n        c = c.yBounds || [c[0][2], c[1][2], h ? c[2][2] : c[0][2]];\n        h = L(n);\n        l = L(c);\n        r.align(a, !1, {\n          x: h,\n          y: l,\n          width: x(n) - h,\n          height: x(c) - l\n        });\n        r.alignValue && \"left\" !== r.alignValue || (a = a.clip ? g.width : g.chart.chartWidth, r.css({\n          width: (90 === r.rotation ? g.height - (r.alignAttr.y - g.top) : a - (r.alignAttr.x - g.left)) + \"px\"\n        }));\n        r.show(!0);\n      }\n      getLabelText(a) {\n        return A(a.formatter) ? a.formatter.call(this) : a.text;\n      }\n      destroy() {\n        C(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        D(this);\n      }\n    }\n    \"\";\n    \"\";\n    return n;\n  });\n  M(a, \"Core/Tooltip.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A) {\n    const {\n        format: x\n      } = a,\n      {\n        doc: C,\n        isSafari: z\n      } = y,\n      {\n        distribute: t\n      } = G,\n      {\n        addEvent: v,\n        clamp: c,\n        css: n,\n        discardElement: r,\n        extend: l,\n        fireEvent: h,\n        isArray: q,\n        isNumber: g,\n        isString: w,\n        merge: J,\n        pick: F,\n        splat: e,\n        syncTimeout: m\n      } = A;\n    class u {\n      constructor(a, e) {\n        this.allowShared = !0;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = a;\n        this.init(a, e);\n      }\n      bodyFormatter(a) {\n        return a.map(function (a) {\n          const b = a.series.tooltipOptions;\n          return (b[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, b[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      }\n      cleanSplit(a) {\n        this.chart.series.forEach(function (e) {\n          const b = e && e.tt;\n          b && (!b.isActive || a ? e.tt = b.destroy() : b.isActive = !1);\n        });\n      }\n      defaultFormatter(a) {\n        const c = this.points || e(this);\n        let b;\n        b = [a.tooltipFooterHeaderFormatter(c[0])];\n        b = b.concat(a.bodyFormatter(c));\n        b.push(a.tooltipFooterHeaderFormatter(c[0], !0));\n        return b;\n      }\n      destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy()));\n        this.renderer && (this.renderer = this.renderer.destroy(), r(this.container));\n        A.clearTimeout(this.hideTimer);\n        A.clearTimeout(this.tooltipTimeout);\n      }\n      getAnchor(a, c) {\n        var b = this.chart;\n        const f = b.pointer,\n          d = b.inverted,\n          k = b.plotTop;\n        b = b.plotLeft;\n        a = e(a);\n        a[0].series && a[0].series.yAxis && !a[0].series.yAxis.options.reversedStacks && (a = a.slice().reverse());\n        if (this.followPointer && c) \"undefined\" === typeof c.chartX && (c = f.normalize(c)), a = [c.chartX - b, c.chartY - k];else if (a[0].tooltipPos) a = a[0].tooltipPos;else {\n          let f = 0,\n            e = 0;\n          a.forEach(function (b) {\n            if (b = b.pos(!0)) f += b[0], e += b[1];\n          });\n          f /= a.length;\n          e /= a.length;\n          this.shared && 1 < a.length && c && (d ? f = c.chartX : e = c.chartY);\n          a = [f - b, e - k];\n        }\n        return a.map(Math.round);\n      }\n      getClassName(a, e, b) {\n        const f = a.series,\n          d = f.options;\n        return [this.options.className, \"highcharts-label\", b && \"highcharts-tooltip-header\", e ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !b && \"highcharts-color-\" + F(a.colorIndex, f.colorIndex), d && d.className].filter(w).join(\" \");\n      }\n      getLabel() {\n        const a = this,\n          e = this.chart.styledMode,\n          b = this.options,\n          f = this.split && this.allowShared,\n          d = b.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\");\n        let c,\n          m = this.chart.renderer;\n        if (this.label) {\n          var g = !this.label.hasClass(\"highcharts-label\");\n          (!f && g || f && !g) && this.destroy();\n        }\n        if (!this.label) {\n          if (this.outside) {\n            g = this.chart.options.chart.style;\n            const b = L.getRendererType();\n            this.container = c = y.doc.createElement(\"div\");\n            c.className = \"highcharts-tooltip-container\";\n            n(c, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: d,\n              zIndex: Math.max(this.options.style.zIndex || 0, (g && g.zIndex || 0) + 3)\n            });\n            y.doc.body.appendChild(c);\n            this.renderer = m = new b(c, 0, 0, g, void 0, void 0, m.styledMode);\n          }\n          f ? this.label = m.g(\"tooltip\") : (this.label = m.label(\"\", 0, 0, b.shape, void 0, void 0, b.useHTML, void 0, \"tooltip\").attr({\n            padding: b.padding,\n            r: b.borderRadius\n          }), e || this.label.attr({\n            fill: b.backgroundColor,\n            \"stroke-width\": b.borderWidth || 0\n          }).css(b.style).css({\n            pointerEvents: d\n          }));\n          if (a.outside) {\n            const b = this.label,\n              {\n                xSetter: d,\n                ySetter: f\n              } = b;\n            b.xSetter = function (f) {\n              d.call(b, a.distance);\n              c.style.left = f + \"px\";\n            };\n            b.ySetter = function (d) {\n              f.call(b, a.distance);\n              c.style.top = d + \"px\";\n            };\n          }\n          this.label.attr({\n            zIndex: 8\n          }).shadow(b.shadow).add();\n        }\n        return this.label;\n      }\n      getPlayingField() {\n        const {\n            body: a,\n            documentElement: e\n          } = C,\n          {\n            chart: b,\n            distance: f,\n            outside: d\n          } = this;\n        return {\n          width: d ? Math.max(a.scrollWidth, e.scrollWidth, a.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * f : b.chartWidth,\n          height: d ? Math.max(a.scrollHeight, e.scrollHeight, a.offsetHeight, e.offsetHeight, e.clientHeight) : b.chartHeight\n        };\n      }\n      getPosition(a, e, b) {\n        const f = this.chart,\n          d = this.distance,\n          c = {},\n          p = f.inverted && b.h || 0,\n          m = this.outside;\n        var g = this.getPlayingField();\n        const h = g.width,\n          l = g.height,\n          u = f.pointer.getChartPosition();\n        g = c => {\n          const k = \"x\" === c;\n          return [c, k ? h : l, k ? a : e].concat(m ? [k ? a * u.scaleX : e * u.scaleY, k ? u.left - d + (b.plotX + f.plotLeft) * u.scaleX : u.top - d + (b.plotY + f.plotTop) * u.scaleY, 0, k ? h : l] : [k ? a : e, k ? b.plotX + f.plotLeft : b.plotY + f.plotTop, k ? f.plotLeft : f.plotTop, k ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);\n        };\n        let n = g(\"y\"),\n          r = g(\"x\"),\n          q;\n        g = !!b.negative;\n        !f.polar && f.hoverSeries && f.hoverSeries.yAxis && f.hoverSeries.yAxis.reversed && (g = !g);\n        const w = !this.followPointer && F(b.ttBelow, !f.inverted === g),\n          H = function (b, a, f, e, k, g, h) {\n            const l = m ? \"y\" === b ? d * u.scaleY : d * u.scaleX : d,\n              n = (f - e) / 2,\n              B = e < k - d,\n              r = k + d + e < a,\n              q = k - l - f + n;\n            k = k + l - n;\n            if (w && r) c[b] = k;else if (!w && B) c[b] = q;else if (B) c[b] = Math.min(h - e, 0 > q - p ? q : q - p);else if (r) c[b] = Math.max(g, k + p + f > a ? k : k + p);else return !1;\n          },\n          B = function (b, a, f, e, k) {\n            let p;\n            k < d || k > a - d ? p = !1 : c[b] = k < f / 2 ? 1 : k > a - e / 2 ? a - e - 2 : k - f / 2;\n            return p;\n          },\n          P = function (b) {\n            const d = n;\n            n = r;\n            r = d;\n            q = b;\n          },\n          I = function () {\n            !1 !== H.apply(0, n) ? !1 !== B.apply(0, r) || q || (P(!0), I()) : q ? c.x = c.y = 0 : (P(!0), I());\n          };\n        (f.inverted || 1 < this.len) && P();\n        I();\n        return c;\n      }\n      hide(a) {\n        const e = this;\n        A.clearTimeout(this.hideTimer);\n        a = F(a, this.options.hideDelay);\n        this.isHidden || (this.hideTimer = m(function () {\n          e.getLabel().fadeOut(a ? void 0 : a);\n          e.isHidden = !0;\n        }, a));\n      }\n      init(a, e) {\n        this.chart = a;\n        this.options = e;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = e.split && !a.inverted && !a.polar;\n        this.shared = e.shared || this.split;\n        this.outside = F(e.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n      }\n      shouldStickOnContact(a) {\n        return !(this.followPointer || !this.options.stickOnContact || a && !this.chart.pointer.inClass(a.target, \"highcharts-tooltip\"));\n      }\n      move(a, e, b, f) {\n        const d = this,\n          c = d.now,\n          m = !1 !== d.options.animation && !d.isHidden && (1 < Math.abs(a - c.x) || 1 < Math.abs(e - c.y)),\n          p = d.followPointer || 1 < d.len;\n        l(c, {\n          x: m ? (2 * c.x + a) / 3 : a,\n          y: m ? (c.y + e) / 2 : e,\n          anchorX: p ? void 0 : m ? (2 * c.anchorX + b) / 3 : b,\n          anchorY: p ? void 0 : m ? (c.anchorY + f) / 2 : f\n        });\n        d.getLabel().attr(c);\n        d.drawTracker();\n        m && (A.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          d && d.move(a, e, b, f);\n        }, 32));\n      }\n      refresh(a, c) {\n        const b = this.chart,\n          f = this.options,\n          d = b.pointer,\n          k = e(a),\n          m = k[0],\n          p = [];\n        var g = f.formatter || this.defaultFormatter,\n          l = this.shared;\n        const u = b.styledMode;\n        let n = {};\n        if (f.enabled && m.series) {\n          A.clearTimeout(this.hideTimer);\n          this.allowShared = !(!q(a) && a.series && a.series.noSharedTooltip);\n          this.followPointer = !this.split && m.series.tooltipOptions.followPointer;\n          a = this.getAnchor(a, c);\n          var r = a[0],\n            w = a[1];\n          l && this.allowShared ? (d.applyInactiveState(k), k.forEach(function (b) {\n            b.setState(\"hover\");\n            p.push(b.getLabelConfig());\n          }), n = {\n            x: m.category,\n            y: m.y\n          }, n.points = p) : n = m.getLabelConfig();\n          this.len = p.length;\n          g = g.call(n, this);\n          l = m.series;\n          this.distance = F(l.tooltipOptions.distance, 16);\n          if (!1 === g) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(g, k);else {\n              let e = r,\n                p = w;\n              c && d.isDirectTouch && (e = c.chartX - b.plotLeft, p = c.chartY - b.plotTop);\n              if (b.polar || !1 === l.options.clip || k.some(b => d.isDirectTouch || b.series.shouldShowTooltip(e, p))) c = this.getLabel(), f.style.width && !u || c.css({\n                width: (this.outside ? this.getPlayingField() : b.spacingBox).width + \"px\"\n              }), c.attr({\n                text: g && g.join ? g.join(\"\") : g\n              }), c.addClass(this.getClassName(m), !0), u || c.attr({\n                stroke: f.borderColor || m.color || l.color || \"#666666\"\n              }), this.updatePosition({\n                plotX: r,\n                plotY: w,\n                negative: m.negative,\n                ttBelow: m.ttBelow,\n                h: a[2] || 0\n              });else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show();\n            this.isHidden = !1;\n          }\n          h(this, \"refresh\");\n        }\n      }\n      renderSplit(a, e) {\n        function b(b, d, a, e, k = !0) {\n          a ? (d = J ? 0 : D, b = c(b - e / 2, I.left, I.right - e - (f.outside ? W : 0))) : (d -= ca, b = k ? b - e - x : b + x, b = c(b, k ? b : I.left, I.right));\n          return {\n            x: b,\n            y: d\n          };\n        }\n        const f = this,\n          {\n            chart: d,\n            chart: {\n              chartWidth: k,\n              chartHeight: m,\n              plotHeight: g,\n              plotLeft: p,\n              plotTop: h,\n              pointer: u,\n              scrollablePixelsY: n = 0,\n              scrollablePixelsX: r,\n              scrollingContainer: {\n                scrollLeft: q,\n                scrollTop: H\n              } = {\n                scrollLeft: 0,\n                scrollTop: 0\n              },\n              styledMode: v\n            },\n            distance: x,\n            options: B,\n            options: {\n              positioner: P\n            }\n          } = f,\n          I = f.outside && \"number\" !== typeof r ? C.documentElement.getBoundingClientRect() : {\n            left: q,\n            right: q + k,\n            top: H,\n            bottom: H + m\n          },\n          V = f.getLabel(),\n          R = this.renderer || d.renderer,\n          J = !(!d.xAxis[0] || !d.xAxis[0].opposite),\n          {\n            left: W,\n            top: y\n          } = u.getChartPosition();\n        let ca = h + H,\n          A = 0,\n          D = g - n;\n        w(a) && (a = [!1, a]);\n        a = a.slice(0, e.length + 1).reduce(function (d, a, k) {\n          if (!1 !== a && \"\" !== a) {\n            k = e[k - 1] || {\n              isHeader: !0,\n              plotX: e[0].plotX,\n              plotY: g,\n              series: {}\n            };\n            const q = k.isHeader;\n            var m = q ? f : k.series,\n              l;\n            {\n              var u = k;\n              a = a.toString();\n              var n = m.tt;\n              const {\n                isHeader: b,\n                series: d\n              } = u;\n              n || (n = {\n                padding: B.padding,\n                r: B.borderRadius\n              }, v || (n.fill = B.backgroundColor, n[\"stroke-width\"] = null !== (l = B.borderWidth) && void 0 !== l ? l : 1), n = R.label(\"\", 0, 0, B[b ? \"headerShape\" : \"shape\"], void 0, void 0, B.useHTML).addClass(f.getClassName(u, !0, b)).attr(n).add(V));\n              n.isActive = !0;\n              n.attr({\n                text: a\n              });\n              v || n.css(B.style).attr({\n                stroke: B.borderColor || u.color || d.color || \"#333333\"\n              });\n              l = n;\n            }\n            l = m.tt = l;\n            u = l.getBBox();\n            m = u.width + l.strokeWidth();\n            q && (A = u.height, D += A, J && (ca -= A));\n            {\n              const {\n                isHeader: b,\n                plotX: d = 0,\n                plotY: f = 0,\n                series: e\n              } = k;\n              if (b) {\n                a = p + d;\n                var r = h + g / 2;\n              } else {\n                const {\n                  xAxis: b,\n                  yAxis: k\n                } = e;\n                a = b.pos + c(d, -x, b.len + x);\n                e.shouldShowTooltip(0, k.pos - h + f, {\n                  ignoreX: !0\n                }) && (r = k.pos + f);\n              }\n              a = c(a, I.left - x, I.right + x);\n              r = {\n                anchorX: a,\n                anchorY: r\n              };\n            }\n            const {\n              anchorX: w,\n              anchorY: E\n            } = r;\n            \"number\" === typeof E ? (r = u.height + 1, u = P ? P.call(f, m, r, k) : b(w, E, q, m), d.push({\n              align: P ? 0 : void 0,\n              anchorX: w,\n              anchorY: E,\n              boxWidth: m,\n              point: k,\n              rank: F(u.rank, q ? 1 : 0),\n              size: r,\n              target: u.y,\n              tt: l,\n              x: u.x\n            })) : l.isActive = !1;\n          }\n          return d;\n        }, []);\n        !P && a.some(b => {\n          var {\n            outside: d\n          } = f;\n          d = (d ? W : 0) + b.anchorX;\n          return d < I.left && d + b.boxWidth < I.right ? !0 : d < W - I.left + b.boxWidth && I.right - d > d;\n        }) && (a = a.map(d => {\n          const {\n            x: a,\n            y: f\n          } = b(d.anchorX, d.anchorY, d.point.isHeader, d.boxWidth, !1);\n          return l(d, {\n            target: f,\n            x: a\n          });\n        }));\n        f.cleanSplit();\n        t(a, D);\n        var G = W,\n          X = W;\n        a.forEach(function (b) {\n          const {\n            x: d,\n            boxWidth: a,\n            isHeader: e\n          } = b;\n          e || (f.outside && W + d < G && (G = W + d), !e && f.outside && G + a > X && (X = W + d));\n        });\n        a.forEach(function (b) {\n          const {\n              x: d,\n              anchorX: a,\n              anchorY: e,\n              pos: c,\n              point: {\n                isHeader: k\n              }\n            } = b,\n            m = {\n              visibility: \"undefined\" === typeof c ? \"hidden\" : \"inherit\",\n              x: d,\n              y: (c || 0) + ca,\n              anchorX: a,\n              anchorY: e\n            };\n          if (f.outside && d < a) {\n            const b = W - G;\n            0 < b && (k || (m.x = d + b, m.anchorX = a + b), k && (m.x = (X - G) / 2, m.anchorX = a + b));\n          }\n          b.tt.attr(m);\n        });\n        const {\n          container: aa,\n          outside: ea,\n          renderer: ia\n        } = f;\n        if (ea && aa && ia) {\n          const {\n            width: b,\n            height: d,\n            x: a,\n            y: f\n          } = V.getBBox();\n          ia.setSize(b + a, d + f, !1);\n          aa.style.left = G + \"px\";\n          aa.style.top = y + \"px\";\n        }\n        z && V.attr({\n          opacity: 1 === V.opacity ? .999 : 1\n        });\n      }\n      drawTracker() {\n        if (this.shouldStickOnContact()) {\n          var a = this.chart,\n            e = this.label,\n            b = this.shared ? a.hoverPoints : a.hoverPoint;\n          if (e && b) {\n            var f = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            b = this.getAnchor(b);\n            var d = e.getBBox();\n            b[0] += a.plotLeft - e.translateX;\n            b[1] += a.plotTop - e.translateY;\n            f.x = Math.min(0, b[0]);\n            f.y = Math.min(0, b[1]);\n            f.width = 0 > b[0] ? Math.max(Math.abs(b[0]), d.width - b[0]) : Math.max(Math.abs(b[0]), d.width);\n            f.height = 0 > b[1] ? Math.max(Math.abs(b[1]), d.height - Math.abs(b[1])) : Math.max(Math.abs(b[1]), d.height);\n            this.tracker ? this.tracker.attr(f) : (this.tracker = e.renderer.rect(f).addClass(\"highcharts-tracker\").add(e), a.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        } else this.tracker && (this.tracker = this.tracker.destroy());\n      }\n      styledModeFormat(a) {\n        return a.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n      }\n      tooltipFooterHeaderFormatter(a, e) {\n        const b = a.series,\n          f = b.tooltipOptions;\n        var d = b.xAxis;\n        const c = d && d.dateTime;\n        d = {\n          isFooter: e,\n          labelConfig: a\n        };\n        let m = f.xDateFormat,\n          p = f[e ? \"footerFormat\" : \"headerFormat\"];\n        h(this, \"headerFormatter\", d, function (d) {\n          c && !m && g(a.key) && (m = c.getXDateFormat(a.key, f.dateTimeLabelFormats));\n          c && m && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (b) {\n            p = p.replace(\"{point.\" + b + \"}\", \"{point.\" + b + \":\" + m + \"}\");\n          });\n          b.chart.styledMode && (p = this.styledModeFormat(p));\n          d.text = x(p, {\n            point: a,\n            series: b\n          }, this.chart);\n        });\n        return d.text;\n      }\n      update(a) {\n        this.destroy();\n        J(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, J(!0, this.options, a));\n      }\n      updatePosition(a) {\n        const {\n          chart: e,\n          distance: b,\n          options: f\n        } = this;\n        var d = e.pointer;\n        const c = this.getLabel(),\n          {\n            left: m,\n            top: g,\n            scaleX: p,\n            scaleY: h\n          } = d.getChartPosition();\n        d = (f.positioner || this.getPosition).call(this, c.width, c.height, a);\n        let l = (a.plotX || 0) + e.plotLeft;\n        a = (a.plotY || 0) + e.plotTop;\n        let u;\n        if (this.outside) {\n          f.positioner && (d.x += m - b, d.y += g - b);\n          u = (f.borderWidth || 0) + 2 * b;\n          this.renderer.setSize(c.width + u, c.height + u, !1);\n          if (1 !== p || 1 !== h) n(this.container, {\n            transform: `scale(${p}, ${h})`\n          }), l *= p, a *= h;\n          l += m - d.x;\n          a += g - d.y;\n        }\n        this.move(Math.round(d.x), Math.round(d.y || 0), l, a);\n      }\n    }\n    (function (a) {\n      const e = [];\n      a.compose = function (b) {\n        A.pushUnique(e, b) && v(b, \"afterInit\", function () {\n          const b = this.chart;\n          b.options.tooltip && (b.tooltip = new a(b, b.options.tooltip));\n        });\n      };\n    })(u || (u = {}));\n    \"\";\n    return u;\n  });\n  M(a, \"Core/Series/Point.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A) {\n    const {\n        animObject: x\n      } = y,\n      {\n        defaultOptions: C\n      } = G,\n      {\n        format: z\n      } = L,\n      {\n        addEvent: t,\n        defined: v,\n        erase: c,\n        extend: n,\n        fireEvent: r,\n        getNestedProperty: l,\n        isArray: h,\n        isFunction: q,\n        isNumber: g,\n        isObject: w,\n        merge: J,\n        objectEach: F,\n        pick: e,\n        syncTimeout: m,\n        removeEvent: u,\n        uniqueKey: p\n      } = A;\n    class H {\n      constructor() {\n        this.category = void 0;\n        this.destroyed = !1;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.shapeArgs = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n      animateBeforeDestroy() {\n        const b = this,\n          a = {\n            x: b.startXPos,\n            opacity: 0\n          },\n          d = b.getGraphicalProps();\n        d.singular.forEach(function (d) {\n          b[d] = b[d].animate(\"dataLabel\" === d ? {\n            x: b[d].startXPos,\n            y: b[d].startYPos,\n            opacity: 0\n          } : a);\n        });\n        d.plural.forEach(function (d) {\n          b[d].forEach(function (d) {\n            d.element && d.animate(n({\n              x: b.startXPos\n            }, d.startYPos ? {\n              x: d.startXPos,\n              y: d.startYPos\n            } : {}));\n          });\n        });\n      }\n      applyOptions(b, a) {\n        const d = this.series,\n          f = d.options.pointValKey || d.pointValKey;\n        b = H.prototype.optionsToObject.call(this, b);\n        n(this, b);\n        this.options = this.options ? n(this.options, b) : b;\n        b.group && delete this.group;\n        b.dataLabels && delete this.dataLabels;\n        f && (this.y = H.prototype.getNestedProperty.call(this, f));\n        this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof a && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && d ? this.x = \"undefined\" === typeof a ? d.autoIncrement() : a : g(b.x) && d.options.relativeXValue && (this.x = d.autoIncrement(b.x));\n        return this;\n      }\n      destroy() {\n        if (!this.destroyed) {\n          const a = this;\n          var b = a.series;\n          const d = b.chart;\n          b = b.options.dataSorting;\n          const e = d.hoverPoints,\n            g = x(a.series.chart.renderer.globalAnimation),\n            p = () => {\n              if (a.graphic || a.graphics || a.dataLabel || a.dataLabels) u(a), a.destroyElements();\n              for (const b in a) delete a[b];\n            };\n          a.legendItem && d.legend.destroyItem(a);\n          e && (a.setState(), c(e, a), e.length || (d.hoverPoints = null));\n          if (a === d.hoverPoint) a.onMouseOut();\n          b && b.enabled ? (this.animateBeforeDestroy(), m(p, g.duration)) : p();\n          d.pointCount--;\n        }\n        this.destroyed = !0;\n      }\n      destroyElements(b) {\n        const a = this;\n        b = a.getGraphicalProps(b);\n        b.singular.forEach(function (b) {\n          a[b] = a[b].destroy();\n        });\n        b.plural.forEach(function (b) {\n          a[b].forEach(function (b) {\n            b && b.element && b.destroy();\n          });\n          delete a[b];\n        });\n      }\n      firePointEvent(b, a, d) {\n        const f = this,\n          e = this.series.options;\n        (e.point.events[b] || f.options && f.options.events && f.options.events[b]) && f.importEvents();\n        \"click\" === b && e.allowPointSelect && (d = function (b) {\n          f.select && f.select(null, b.ctrlKey || b.metaKey || b.shiftKey);\n        });\n        r(f, b, a, d);\n      }\n      getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      }\n      getGraphicalProps(b) {\n        const a = this,\n          d = [],\n          e = {\n            singular: [],\n            plural: []\n          };\n        let c, m;\n        b = b || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        b.graphic && d.push(\"graphic\");\n        b.dataLabel && d.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\", \"connector\");\n        for (m = d.length; m--;) c = d[m], a[c] && e.singular.push(c);\n        [\"graphic\", \"dataLabel\", \"connector\"].forEach(function (d) {\n          const f = d + \"s\";\n          b[d] && a[f] && e.plural.push(f);\n        });\n        return e;\n      }\n      getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      }\n      getNestedProperty(b) {\n        if (b) return 0 === b.indexOf(\"custom.\") ? l(b, this.options) : this[b];\n      }\n      getZone() {\n        var b = this.series;\n        const a = b.zones;\n        b = b.zoneAxis || \"y\";\n        let d,\n          e = 0;\n        for (d = a[e]; this[b] >= d.value;) d = a[++e];\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = d && d.color && !this.options.color ? d.color : this.nonZonedColor;\n        return d;\n      }\n      hasNewShapeType() {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      }\n      init(b, a, d) {\n        this.series = b;\n        this.applyOptions(a, d);\n        this.id = v(this.id) ? this.id : p();\n        this.resolveColor();\n        b.chart.pointCount++;\n        r(this, \"afterInit\");\n        return this;\n      }\n      isValid() {\n        return null !== this.x && g(this.y);\n      }\n      optionsToObject(b) {\n        var a = this.series;\n        const d = a.options.keys,\n          e = d || a.pointArrayMap || [\"y\"],\n          c = e.length;\n        let m = {},\n          p = 0,\n          l = 0;\n        if (g(b) || null === b) m[e[0]] = b;else if (h(b)) for (!d && b.length > c && (a = typeof b[0], \"string\" === a ? m.name = b[0] : \"number\" === a && (m.x = b[0]), p++); l < c;) d && \"undefined\" === typeof b[p] || (0 < e[l].indexOf(\".\") ? H.prototype.setNestedProperty(m, b[p], e[l]) : m[e[l]] = b[p]), p++, l++;else \"object\" === typeof b && (m = b, b.dataLabels && (a._hasPointLabels = !0), b.marker && (a._hasPointMarkers = !0));\n        return m;\n      }\n      pos(b, a = this.plotY) {\n        if (!this.destroyed) {\n          const {\n              plotX: d,\n              series: f\n            } = this,\n            {\n              chart: e,\n              xAxis: c,\n              yAxis: m\n            } = f;\n          let p = 0,\n            h = 0;\n          if (g(d) && g(a)) return b && (p = c ? c.pos : e.plotLeft, h = m ? m.pos : e.plotTop), e.inverted && c && m ? [m.len - a + h, c.len - d + p] : [d + p, a + h];\n        }\n      }\n      resolveColor() {\n        const b = this.series;\n        var a = b.chart.styledMode;\n        let d;\n        var c = b.chart.options.chart.colorCount;\n        delete this.nonZonedColor;\n        b.options.colorByPoint ? (a || (c = b.options.colors || b.chart.options.colors, d = c[b.colorCounter], c = c.length), a = b.colorCounter, b.colorCounter++, b.colorCounter === c && (b.colorCounter = 0)) : (a || (d = b.color), a = b.colorIndex);\n        this.colorIndex = e(this.options.colorIndex, a);\n        this.color = e(this.options.color, d);\n      }\n      setNestedProperty(b, a, d) {\n        d.split(\".\").reduce(function (b, d, f, e) {\n          b[d] = e.length - 1 === f ? a : w(b[d], !0) ? b[d] : {};\n          return b[d];\n        }, b);\n        return b;\n      }\n      shouldDraw() {\n        return !this.isNull;\n      }\n      tooltipFormatter(b) {\n        const a = this.series,\n          d = a.tooltipOptions,\n          c = e(d.valueDecimals, \"\"),\n          m = d.valuePrefix || \"\",\n          g = d.valueSuffix || \"\";\n        a.chart.styledMode && (b = a.chart.tooltip.styledModeFormat(b));\n        (a.pointArrayMap || [\"y\"]).forEach(function (a) {\n          a = \"{point.\" + a;\n          if (m || g) b = b.replace(RegExp(a + \"}\", \"g\"), m + a + \"}\" + g);\n          b = b.replace(RegExp(a + \"}\", \"g\"), a + \":,.\" + c + \"f}\");\n        });\n        return z(b, {\n          point: this,\n          series: this.series\n        }, a.chart);\n      }\n      update(b, a, d, c) {\n        function f() {\n          k.applyOptions(b);\n          var f = g && k.hasMockGraphic;\n          f = null === k.y ? !f : f;\n          g && f && (k.graphic = g.destroy(), delete k.hasMockGraphic);\n          w(b, !0) && (g && g.element && b && b.marker && \"undefined\" !== typeof b.marker.symbol && (k.graphic = g.destroy()), b && b.dataLabels && k.dataLabel && (k.dataLabel = k.dataLabel.destroy()), k.connector && (k.connector = k.connector.destroy()));\n          l = k.index;\n          m.updateParallelArrays(k, l);\n          h.data[l] = w(h.data[l], !0) || w(b, !0) ? k.options : e(b, h.data[l]);\n          m.isDirty = m.isDirtyData = !0;\n          !m.fixedBox && m.hasCartesianSeries && (p.isDirtyBox = !0);\n          \"point\" === h.legendType && (p.isDirtyLegend = !0);\n          a && p.redraw(d);\n        }\n        const k = this,\n          m = k.series,\n          g = k.graphic,\n          p = m.chart,\n          h = m.options;\n        let l;\n        a = e(a, !0);\n        !1 === c ? f() : k.firePointEvent(\"update\", {\n          options: b\n        }, f);\n      }\n      remove(b, a) {\n        this.series.removePoint(this.series.data.indexOf(this), b, a);\n      }\n      select(b, a) {\n        const d = this,\n          f = d.series,\n          c = f.chart;\n        this.selectedStaging = b = e(b, !d.selected);\n        d.firePointEvent(b ? \"select\" : \"unselect\", {\n          accumulate: a\n        }, function () {\n          d.selected = d.options.selected = b;\n          f.options.data[f.data.indexOf(d)] = d.options;\n          d.setState(b && \"select\");\n          a || c.getSelectedPoints().forEach(function (b) {\n            const a = b.series;\n            b.selected && b !== d && (b.selected = b.options.selected = !1, a.options.data[a.data.indexOf(b)] = b.options, b.setState(c.hoverPoints && a.options.inactiveOtherPoints ? \"inactive\" : \"\"), b.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      }\n      onMouseOver(b) {\n        const a = this.series.chart,\n          d = a.pointer;\n        b = b ? d.normalize(b) : d.getChartCoordinatesFromPoint(this, a.inverted);\n        d.runPointActions(b, this);\n      }\n      onMouseOut() {\n        const b = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {\n          b.setState();\n        });\n        b.hoverPoints = b.hoverPoint = null;\n      }\n      importEvents() {\n        if (!this.hasImportedEvents) {\n          const b = this,\n            a = J(b.series.options.point, b.options).events;\n          b.events = a;\n          F(a, function (a, f) {\n            q(a) && t(b, f, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      }\n      setState(b, f) {\n        const d = this.series;\n        var c = this.state,\n          m = d.options.states[b || \"normal\"] || {},\n          p = C.plotOptions[d.type].marker && d.options.marker;\n        const h = p && !1 === p.enabled,\n          l = p && p.states && p.states[b || \"normal\"] || {},\n          u = !1 === l.enabled,\n          q = this.marker || {},\n          w = d.chart,\n          H = p && d.markerAttribs;\n        let t = d.halo;\n        var v;\n        let x;\n        var B = d.stateMarkerGraphic;\n        b = b || \"\";\n        if (!(b === this.state && !f || this.selected && \"select\" !== b || !1 === m.enabled || b && (u || h && !1 === l.enabled) || b && q.states && q.states[b] && !1 === q.states[b].enabled)) {\n          this.state = b;\n          H && (v = d.markerAttribs(this, b));\n          if (this.graphic && !this.hasMockGraphic) {\n            c && this.graphic.removeClass(\"highcharts-point-\" + c);\n            b && this.graphic.addClass(\"highcharts-point-\" + b);\n            if (!w.styledMode) {\n              c = d.pointAttribs(this, b);\n              x = e(w.options.chart.animation, m.animation);\n              const a = c.opacity;\n              d.options.inactiveOtherPoints && g(a) && ((this.dataLabels || []).forEach(function (b) {\n                b && !b.hasClass(\"highcharts-data-label-hidden\") && b.animate({\n                  opacity: a\n                }, x);\n              }), this.connector && this.connector.animate({\n                opacity: a\n              }, x));\n              this.graphic.animate(c, x);\n            }\n            v && this.graphic.animate(v, e(w.options.chart.animation, l.animation, p.animation));\n            B && B.hide();\n          } else {\n            if (b && l) {\n              p = q.symbol || d.symbol;\n              B && B.currentSymbol !== p && (B = B.destroy());\n              if (v) if (B) B[f ? \"animate\" : \"attr\"]({\n                x: v.x,\n                y: v.y\n              });else p && (d.stateMarkerGraphic = B = w.renderer.symbol(p, v.x, v.y, v.width, v.height).add(d.markerGroup), B.currentSymbol = p);\n              !w.styledMode && B && \"inactive\" !== this.state && B.attr(d.pointAttribs(this, b));\n            }\n            B && (B[b && this.isInside ? \"show\" : \"hide\"](), B.element.point = this, B.addClass(this.getClassName(), !0));\n          }\n          m = m.halo;\n          v = (B = this.graphic || B) && B.visibility || \"inherit\";\n          m && m.size && B && \"hidden\" !== v && !this.isCluster ? (t || (d.halo = t = w.renderer.path().add(B.parentGroup)), t.show()[f ? \"animate\" : \"attr\"]({\n            d: this.haloPath(m.size)\n          }), t.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + e(this.colorIndex, d.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: v,\n            zIndex: -1\n          }), t.point = this, w.styledMode || t.attr(n({\n            fill: this.color || d.color,\n            \"fill-opacity\": m.opacity\n          }, a.filterUserAttributes(m.attributes || {})))) : t && t.point && t.point.haloPath && t.animate({\n            d: t.point.haloPath(0)\n          }, null, t.hide);\n          r(this, \"afterSetState\", {\n            state: b\n          });\n        }\n      }\n      haloPath(b) {\n        const a = this.pos();\n        return a ? this.series.chart.renderer.symbols.circle(Math.floor(a[0]) - b, a[1] - b, 2 * b, 2 * b) : [];\n      }\n    }\n    \"\";\n    return H;\n  });\n  M(a, \"Core/Pointer.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        parse: x\n      } = a,\n      {\n        charts: A,\n        noop: D\n      } = y,\n      {\n        addEvent: C,\n        attr: z,\n        css: t,\n        defined: v,\n        extend: c,\n        find: n,\n        fireEvent: r,\n        isNumber: l,\n        isObject: h,\n        objectEach: q,\n        offset: g,\n        pick: w,\n        splat: J\n      } = G;\n    class F {\n      constructor(a, c) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.eventsToUnbind = [];\n        this.chart = a;\n        this.hasDragged = !1;\n        this.options = c;\n        this.init(a, c);\n      }\n      applyInactiveState(a) {\n        let e = [],\n          c;\n        (a || []).forEach(function (a) {\n          c = a.series;\n          e.push(c);\n          c.linkedParent && e.push(c.linkedParent);\n          c.linkedSeries && (e = e.concat(c.linkedSeries));\n          c.navigatorSeries && e.push(c.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === e.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      }\n      destroy() {\n        const a = this;\n        this.eventsToUnbind.forEach(a => a());\n        this.eventsToUnbind = [];\n        y.chartCount || (F.unbindDocumentMouseUp && (F.unbindDocumentMouseUp = F.unbindDocumentMouseUp()), F.unbindDocumentTouchEnd && (F.unbindDocumentTouchEnd = F.unbindDocumentTouchEnd()));\n        clearInterval(a.tooltipTimeout);\n        q(a, function (e, c) {\n          a[c] = void 0;\n        });\n      }\n      getSelectionMarkerAttrs(a, c) {\n        const e = {\n          args: {\n            chartX: a,\n            chartY: c\n          },\n          attrs: {},\n          shapeType: \"rect\"\n        };\n        r(this, \"getSelectionMarkerAttrs\", e, e => {\n          const {\n            chart: m,\n            mouseDownX: b = 0,\n            mouseDownY: f = 0,\n            zoomHor: d,\n            zoomVert: k\n          } = this;\n          e = e.attrs;\n          let g;\n          e.x = m.plotLeft;\n          e.y = m.plotTop;\n          e.width = d ? 1 : m.plotWidth;\n          e.height = k ? 1 : m.plotHeight;\n          d && (g = a - b, e.width = Math.abs(g), e.x = (0 < g ? 0 : g) + b);\n          k && (g = c - f, e.height = Math.abs(g), e.y = (0 < g ? 0 : g) + f);\n        });\n        return e;\n      }\n      drag(a) {\n        const e = this.chart,\n          c = e.options.chart;\n        var g = e.plotLeft;\n        const l = e.plotTop,\n          b = e.plotWidth,\n          f = e.plotHeight,\n          d = this.mouseDownX || 0,\n          k = this.mouseDownY || 0,\n          n = h(c.panning) ? c.panning && c.panning.enabled : c.panning,\n          r = c.panKey && a[c.panKey + \"Key\"];\n        let q = a.chartX,\n          w = a.chartY,\n          t = this.selectionMarker;\n        if (!t || !t.touch) if (q < g ? q = g : q > g + b && (q = g + b), w < l ? w = l : w > l + f && (w = l + f), this.hasDragged = Math.sqrt(Math.pow(d - q, 2) + Math.pow(k - w, 2)), 10 < this.hasDragged) {\n          g = e.isInsidePlot(d - g, k - l, {\n            visiblePlotOnly: !0\n          });\n          const {\n            shapeType: b,\n            attrs: f\n          } = this.getSelectionMarkerAttrs(q, w);\n          !e.hasCartesianSeries && !e.mapView || !this.zoomX && !this.zoomY || !g || r || t || (this.selectionMarker = t = e.renderer[b](), t.attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), e.styledMode || t.attr({\n            fill: c.selectionMarkerFill || x(\"#334eff\").setOpacity(.25).get()\n          }));\n          t && t.attr(f);\n          g && !t && n && e.pan(a, c.panning);\n        }\n      }\n      dragStart(a) {\n        const e = this.chart;\n        e.mouseIsDown = a.type;\n        e.cancelClick = !1;\n        e.mouseDownX = this.mouseDownX = a.chartX;\n        e.mouseDownY = this.mouseDownY = a.chartY;\n      }\n      getSelectionBox(a) {\n        const e = {\n          args: {\n            marker: a\n          },\n          result: {}\n        };\n        r(this, \"getSelectionBox\", e, e => {\n          e.result = {\n            x: a.attr ? +a.attr(\"x\") : a.x,\n            y: a.attr ? +a.attr(\"y\") : a.y,\n            width: a.attr ? a.attr(\"width\") : a.width,\n            height: a.attr ? a.attr(\"height\") : a.height\n          };\n        });\n        return e.result;\n      }\n      drop(a) {\n        const e = this,\n          g = this.chart,\n          p = this.hasPinched;\n        if (this.selectionMarker) {\n          const {\n              x: m,\n              y: b,\n              width: f,\n              height: d\n            } = this.getSelectionBox(this.selectionMarker),\n            k = {\n              originalEvent: a,\n              xAxis: [],\n              yAxis: [],\n              x: m,\n              y: b,\n              width: f,\n              height: d\n            };\n          let h = !!g.mapView;\n          if (this.hasDragged || p) g.axes.forEach(function (c) {\n            if (c.zoomEnabled && v(c.min) && (p || e[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[c.coll]]) && l(m) && l(b) && l(f) && l(d)) {\n              var g = c.horiz;\n              const e = \"touchend\" === a.type ? c.minPixelPadding : 0,\n                p = c.toValue((g ? m : b) + e);\n              g = c.toValue((g ? m + f : b + d) - e);\n              k[c.coll].push({\n                axis: c,\n                min: Math.min(p, g),\n                max: Math.max(p, g)\n              });\n              h = !0;\n            }\n          }), h && r(g, \"selection\", k, function (b) {\n            g.zoom(c(b, p ? {\n              animation: !1\n            } : null));\n          });\n          l(g.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          p && this.scaleGroups();\n        }\n        g && l(g.index) && (t(g.container, {\n          cursor: g._cursor\n        }), g.cancelClick = 10 < this.hasDragged, g.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      }\n      findNearestKDPoint(a, c, g) {\n        let e;\n        a.forEach(function (a) {\n          var b = !(a.noSharedTooltip && c) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(g, b);\n          if ((b = h(a, !0) && a.series) && !(b = !h(e, !0))) {\n            {\n              b = e.distX - a.distX;\n              const f = e.dist - a.dist,\n                d = (a.series.group && a.series.group.zIndex) - (e.series.group && e.series.group.zIndex);\n              b = 0 !== b && c ? b : 0 !== f ? f : 0 !== d ? d : e.series.index > a.series.index ? -1 : 1;\n            }\n            b = 0 < b;\n          }\n          b && (e = a);\n        });\n        return e;\n      }\n      getChartCoordinatesFromPoint(a, c) {\n        var e = a.series;\n        const g = e.xAxis;\n        e = e.yAxis;\n        const m = a.shapeArgs;\n        if (g && e) {\n          let b = w(a.clientX, a.plotX),\n            f = a.plotY || 0;\n          a.isNode && m && l(m.x) && l(m.y) && (b = m.x, f = m.y);\n          return c ? {\n            chartX: e.len + e.pos - f,\n            chartY: g.len + g.pos - b\n          } : {\n            chartX: b + g.pos,\n            chartY: f + e.pos\n          };\n        }\n        if (m && m.x && m.y) return {\n          chartX: m.x,\n          chartY: m.y\n        };\n      }\n      getChartPosition() {\n        if (this.chartPosition) return this.chartPosition;\n        var {\n          container: a\n        } = this.chart;\n        const c = g(a);\n        this.chartPosition = {\n          left: c.left,\n          top: c.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        const h = a.offsetWidth;\n        a = a.offsetHeight;\n        2 < h && 2 < a && (this.chartPosition.scaleX = c.width / h, this.chartPosition.scaleY = c.height / a);\n        return this.chartPosition;\n      }\n      getCoordinates(a) {\n        const c = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (e) {\n          c[e.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: e,\n            value: e.toValue(a[e.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return c;\n      }\n      getHoverData(a, c, g, p, l, b) {\n        const f = [];\n        p = !(!p || !a);\n        const d = function (b) {\n          return b.visible && !(!l && b.directTouch) && w(b.options.enableMouseTracking, !0);\n        };\n        let e,\n          m = {\n            chartX: b ? b.chartX : void 0,\n            chartY: b ? b.chartY : void 0,\n            shared: l\n          };\n        r(this, \"beforeGetHoverData\", m);\n        e = c && !c.stickyTracking ? [c] : g.filter(b => b.stickyTracking && (m.filter || d)(b));\n        const u = p || !b ? a : this.findNearestKDPoint(e, l, b);\n        c = u && u.series;\n        u && (l && !c.noSharedTooltip ? (e = g.filter(function (b) {\n          return m.filter ? m.filter(b) : d(b) && !b.noSharedTooltip;\n        }), e.forEach(function (b) {\n          let a = n(b.points, function (b) {\n            return b.x === u.x && !b.isNull;\n          });\n          h(a) && (b.boosted && b.boost && (a = b.boost.getPoint(a)), f.push(a));\n        })) : f.push(u));\n        m = {\n          hoverPoint: u\n        };\n        r(this, \"afterGetHoverData\", m);\n        return {\n          hoverPoint: m.hoverPoint,\n          hoverSeries: c,\n          hoverPoints: f\n        };\n      }\n      getPointFromEvent(a) {\n        a = a.target;\n        let c;\n        for (; a && !c;) c = a.point, a = a.parentNode;\n        return c;\n      }\n      onTrackerMouseOut(a) {\n        a = a.relatedTarget;\n        const c = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!c || !a || c.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + c.index) && this.inClass(a, \"highcharts-tracker\"))) c.onMouseOut();\n      }\n      inClass(a, c) {\n        let e;\n        for (; a;) {\n          if (e = z(a, \"class\")) {\n            if (-1 !== e.indexOf(c)) return !0;\n            if (-1 !== e.indexOf(\"highcharts-container\")) return !1;\n          }\n          a = a.parentElement;\n        }\n      }\n      init(a, c) {\n        this.options = c;\n        this.chart = a;\n        this.runChartClick = !(!c.chart.events || !c.chart.events.click);\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        this.setDOMEvents();\n        r(this, \"afterInit\");\n      }\n      normalize(a, g) {\n        var e = a.touches,\n          m = e ? e.length ? e.item(0) : w(e.changedTouches, a.changedTouches)[0] : a;\n        g || (g = this.getChartPosition());\n        e = m.pageX - g.left;\n        m = m.pageY - g.top;\n        e /= g.scaleX;\n        m /= g.scaleY;\n        return c(a, {\n          chartX: Math.round(e),\n          chartY: Math.round(m)\n        });\n      }\n      onContainerClick(a) {\n        const e = this.chart,\n          g = e.hoverPoint;\n        a = this.normalize(a);\n        const p = e.plotLeft,\n          h = e.plotTop;\n        e.cancelClick || (g && this.inClass(a.target, \"highcharts-tracker\") ? (r(g.series, \"click\", c(a, {\n          point: g\n        })), e.hoverPoint && g.firePointEvent(\"click\", a)) : (c(a, this.getCoordinates(a)), e.isInsidePlot(a.chartX - p, a.chartY - h, {\n          visiblePlotOnly: !0\n        }) && r(e, \"click\", a)));\n      }\n      onContainerMouseDown(a) {\n        const c = 1 === ((a.buttons || a.button) & 1);\n        a = this.normalize(a);\n        if (y.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);\n        if (\"undefined\" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);\n      }\n      onContainerMouseLeave(a) {\n        const c = A[w(F.hoverChartIndex, -1)];\n        a = this.normalize(a);\n        c && a.relatedTarget && !this.inClass(a.relatedTarget, \"highcharts-tooltip\") && (c.pointer.reset(), c.pointer.chartPosition = void 0);\n      }\n      onContainerMouseEnter(a) {\n        delete this.chartPosition;\n      }\n      onContainerMouseMove(a) {\n        const c = this.chart,\n          e = c.tooltip;\n        a = this.normalize(a);\n        this.setHoverChartIndex();\n        (\"mousedown\" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);\n        c.openMenu || !this.inClass(a.target, \"highcharts-tracker\") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {\n          visiblePlotOnly: !0\n        }) || e && e.shouldStickOnContact(a) || (this.inClass(a.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(a));\n      }\n      onDocumentTouchEnd(a) {\n        const c = A[w(F.hoverChartIndex, -1)];\n        c && c.pointer.drop(a);\n      }\n      onContainerTouchMove(a) {\n        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);\n      }\n      onContainerTouchStart(a) {\n        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);\n      }\n      onDocumentMouseMove(a) {\n        const c = this.chart,\n          e = c.tooltip,\n          g = this.chartPosition;\n        a = this.normalize(a, g);\n        !g || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {\n          visiblePlotOnly: !0\n        }) || e && e.shouldStickOnContact(a) || this.inClass(a.target, \"highcharts-tracker\") || this.reset();\n      }\n      onDocumentMouseUp(a) {\n        const c = A[w(F.hoverChartIndex, -1)];\n        c && c.pointer.drop(a);\n      }\n      pinch(a) {\n        const e = this,\n          g = e.chart,\n          p = e.pinchDown,\n          h = a.touches || [],\n          b = h.length,\n          f = e.lastValidTouch,\n          d = e.hasZoom,\n          k = {},\n          l = 1 === b && (e.inClass(a.target, \"highcharts-tracker\") && g.runTrackerClick || e.runChartClick),\n          n = {};\n        var q = e.chart.tooltip;\n        q = 1 === b && w(q && q.options.followTouchMove, !0);\n        let t = e.selectionMarker;\n        1 < b ? e.initiated = !0 : q && (e.initiated = !1);\n        d && e.initiated && !l && !1 !== a.cancelable && a.preventDefault();\n        [].map.call(h, function (b) {\n          return e.normalize(b);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(h, function (b, a) {\n          p[a] = {\n            chartX: b.chartX,\n            chartY: b.chartY\n          };\n        }), f.x = [p[0].chartX, p[1] && p[1].chartX], f.y = [p[0].chartY, p[1] && p[1].chartY], g.axes.forEach(function (b) {\n          if (b.zoomEnabled) {\n            const a = g.bounds[b.horiz ? \"h\" : \"v\"],\n              d = b.minPixelPadding,\n              f = b.toPixels(Math.min(w(b.options.min, b.dataMin), b.dataMin)),\n              c = b.toPixels(Math.max(w(b.options.max, b.dataMax), b.dataMax)),\n              e = Math.max(f, c);\n            a.min = Math.min(b.pos, Math.min(f, c) - d);\n            a.max = Math.max(b.pos + b.len, e + d);\n          }\n        }), e.res = !0) : q ? this.runPointActions(e.normalize(a)) : p.length && (r(g, \"touchpan\", {\n          originalEvent: a\n        }, () => {\n          t || (e.selectionMarker = t = c({\n            destroy: D,\n            touch: !0\n          }, g.plotBox));\n          e.pinchTranslate(p, h, k, t, n, f);\n          e.hasPinched = d;\n          e.scaleGroups(k, n);\n        }), e.res && (e.res = !1, this.reset(!1, 0)));\n      }\n      pinchTranslate(a, c, g, p, h, b) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, c, g, p, h, b);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, c, g, p, h, b);\n      }\n      pinchTranslateDirection(a, c, g, p, h, b, f, d) {\n        const e = this.chart,\n          m = a ? \"x\" : \"y\",\n          l = a ? \"X\" : \"Y\",\n          n = \"chart\" + l,\n          r = a ? \"width\" : \"height\",\n          u = e[\"plot\" + (a ? \"Left\" : \"Top\")],\n          q = e.inverted,\n          w = e.bounds[a ? \"h\" : \"v\"],\n          t = 1 === c.length,\n          v = c[0][n],\n          x = !t && c[1][n];\n        c = function () {\n          \"number\" === typeof V && 20 < Math.abs(v - x) && (P = d || Math.abs(I - V) / Math.abs(v - x));\n          B = (u - I) / P + v;\n          H = e[\"plot\" + (a ? \"Width\" : \"Height\")] / P;\n        };\n        let H,\n          B,\n          P = d || 1,\n          I = g[0][n],\n          V = !t && g[1][n],\n          R;\n        c();\n        g = B;\n        g < w.min ? (g = w.min, R = !0) : g + H > w.max && (g = w.max - H, R = !0);\n        R ? (I -= .8 * (I - f[m][0]), \"number\" === typeof V && (V -= .8 * (V - f[m][1])), c()) : f[m] = [I, V];\n        q || (b[m] = B - u, b[r] = H);\n        b = q ? 1 / P : P;\n        h[r] = H;\n        h[m] = g;\n        p[q ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + l] = P;\n        p[\"translate\" + l] = b * u + (I - b * v);\n      }\n      reset(a, c) {\n        const e = this.chart,\n          g = e.hoverSeries,\n          m = e.hoverPoint,\n          b = e.hoverPoints,\n          f = e.tooltip,\n          d = f && f.shared ? b : m;\n        a && d && J(d).forEach(function (b) {\n          b.series.isCartesian && \"undefined\" === typeof b.plotX && (a = !1);\n        });\n        if (a) f && d && J(d).length && (f.refresh(d), f.shared && b ? b.forEach(function (b) {\n          b.setState(b.state, !0);\n          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));\n        }) : m && (m.setState(m.state, !0), e.axes.forEach(function (b) {\n          b.crosshair && m.series[b.coll] === b && b.drawCrosshair(null, m);\n        })));else {\n          if (m) m.onMouseOut();\n          b && b.forEach(function (b) {\n            b.setState();\n          });\n          if (g) g.onMouseOut();\n          f && f.hide(c);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          e.axes.forEach(function (b) {\n            b.hideCrosshair();\n          });\n          this.hoverX = e.hoverPoints = e.hoverPoint = null;\n        }\n      }\n      runPointActions(a, c, g) {\n        const e = this.chart,\n          m = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,\n          b = m ? m.shared : !1;\n        let f = c || e.hoverPoint,\n          d = f && f.series || e.hoverSeries;\n        c = this.getHoverData(f, d, e.series, (!a || \"touchmove\" !== a.type) && (!!c || d && d.directTouch && this.isDirectTouch), b, a);\n        f = c.hoverPoint;\n        d = c.hoverSeries;\n        const k = c.hoverPoints;\n        c = d && d.tooltipOptions.followPointer && !d.tooltipOptions.split;\n        const h = b && d && !d.noSharedTooltip;\n        if (f && (g || f !== e.hoverPoint || m && m.isHidden)) {\n          (e.hoverPoints || []).forEach(function (b) {\n            -1 === k.indexOf(b) && b.setState();\n          });\n          if (e.hoverSeries !== d) d.onMouseOver();\n          this.applyInactiveState(k);\n          (k || []).forEach(function (b) {\n            b.setState(\"hover\");\n          });\n          e.hoverPoint && e.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!f.series) return;\n          e.hoverPoints = k;\n          e.hoverPoint = f;\n          f.firePointEvent(\"mouseOver\", void 0, () => {\n            m && f && m.refresh(h ? k : f, a);\n          });\n        } else c && m && !m.isHidden && (g = m.getAnchor([{}], a), e.isInsidePlot(g[0], g[1], {\n          visiblePlotOnly: !0\n        }) && m.updatePosition({\n          plotX: g[0],\n          plotY: g[1]\n        }));\n        this.unDocMouseMove || (this.unDocMouseMove = C(e.container.ownerDocument, \"mousemove\", function (b) {\n          const a = A[F.hoverChartIndex];\n          if (a) a.pointer.onDocumentMouseMove(b);\n        }), this.eventsToUnbind.push(this.unDocMouseMove));\n        e.axes.forEach(function (b) {\n          const d = w((b.crosshair || {}).snap, !0);\n          let f;\n          d && ((f = e.hoverPoint) && f.series[b.coll] === b || (f = n(k, a => a.series && a.series[b.coll] === b)));\n          f || !d ? b.drawCrosshair(a, f) : b.hideCrosshair();\n        });\n      }\n      scaleGroups(a, c) {\n        const e = this.chart;\n        e.series.forEach(function (g) {\n          const m = a || g.getPlotBox();\n          g.group && (g.xAxis && g.xAxis.zoomEnabled || e.mapView) && (g.group.attr(m), g.markerGroup && (g.markerGroup.attr(m), g.markerGroup.clip(c ? e.clipRect : null)), g.dataLabelsGroup && g.dataLabelsGroup.attr(m));\n        });\n        e.clipRect.attr(c || e.clipBox);\n      }\n      setDOMEvents() {\n        const a = this.chart.container,\n          c = a.ownerDocument;\n        a.onmousedown = this.onContainerMouseDown.bind(this);\n        a.onmousemove = this.onContainerMouseMove.bind(this);\n        a.onclick = this.onContainerClick.bind(this);\n        this.eventsToUnbind.push(C(a, \"mouseenter\", this.onContainerMouseEnter.bind(this)));\n        this.eventsToUnbind.push(C(a, \"mouseleave\", this.onContainerMouseLeave.bind(this)));\n        F.unbindDocumentMouseUp || (F.unbindDocumentMouseUp = C(c, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n        let g = this.chart.renderTo.parentElement;\n        for (; g && \"BODY\" !== g.tagName;) this.eventsToUnbind.push(C(g, \"scroll\", () => {\n          delete this.chartPosition;\n        })), g = g.parentElement;\n        y.hasTouch && (this.eventsToUnbind.push(C(a, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(C(a, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), F.unbindDocumentTouchEnd || (F.unbindDocumentTouchEnd = C(c, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      }\n      setHoverChartIndex() {\n        const a = this.chart,\n          c = y.charts[w(F.hoverChartIndex, -1)];\n        if (c && c !== a) c.pointer.onContainerMouseLeave({\n          relatedTarget: a.container\n        });\n        c && c.mouseIsDown || (F.hoverChartIndex = a.index);\n      }\n      touch(a, c) {\n        const e = this.chart;\n        let g, m;\n        this.setHoverChartIndex();\n        1 === a.touches.length ? (a = this.normalize(a), (m = e.isInsidePlot(a.chartX - e.plotLeft, a.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        })) && !e.openMenu ? (c && this.runPointActions(a), \"touchmove\" === a.type && (c = this.pinchDown, g = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - a.chartX, 2) + Math.pow(c[0].chartY - a.chartY, 2)) : !1), w(g, !0) && this.pinch(a)) : c && this.reset()) : 2 === a.touches.length && this.pinch(a);\n      }\n      touchSelect(a) {\n        return !(!this.chart.options.chart.zooming.singleTouch || !a.touches || 1 !== a.touches.length);\n      }\n      zoomOption(a) {\n        var c = this.chart,\n          e = c.options.chart;\n        c = c.inverted;\n        let g = e.zooming.type || \"\";\n        /touch/.test(a.type) && (g = w(e.zooming.pinchType, g));\n        this.zoomX = a = /x/.test(g);\n        this.zoomY = e = /y/.test(g);\n        this.zoomHor = a && !c || e && c;\n        this.zoomVert = e && !c || a && c;\n        this.hasZoom = a || e;\n      }\n    }\n    (function (a) {\n      const c = [],\n        e = [];\n      a.compose = function (c) {\n        G.pushUnique(e, c) && C(c, \"beforeRender\", function () {\n          this.pointer = new a(this, this.options);\n        });\n      };\n      a.dissolve = function () {\n        for (let a = 0, e = c.length; a < e; ++a) c[a]();\n        c.length = 0;\n      };\n    })(F || (F = {}));\n    \"\";\n    return F;\n  });\n  M(a, \"Core/Legend/Legend.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D) {\n    const {\n        animObject: x,\n        setAnimation: z\n      } = a,\n      {\n        format: t\n      } = y,\n      {\n        marginNames: v\n      } = G,\n      {\n        distribute: c\n      } = A,\n      {\n        addEvent: n,\n        createElement: r,\n        css: l,\n        defined: h,\n        discardElement: q,\n        find: g,\n        fireEvent: w,\n        isNumber: J,\n        merge: F,\n        pick: e,\n        relativeLength: m,\n        stableSort: u,\n        syncTimeout: p\n      } = D;\n    class H {\n      constructor(b, a) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = void 0;\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = b;\n        this.init(b, a);\n      }\n      init(b, a) {\n        this.chart = b;\n        this.setOptions(a);\n        a.enabled && (this.render(), n(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), n(this.chart, \"render\", () => {\n          this.proximate && (this.proximatePositions(), this.positionItems());\n        }));\n      }\n      setOptions(b) {\n        const a = e(b.padding, 8);\n        this.options = b;\n        this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = F(this.itemStyle, b.itemHiddenStyle));\n        this.itemMarginTop = b.itemMarginTop;\n        this.itemMarginBottom = b.itemMarginBottom;\n        this.padding = a;\n        this.initialItemY = a - 5;\n        this.symbolWidth = e(b.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === b.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      }\n      update(b, a) {\n        const d = this.chart;\n        this.setOptions(F(!0, this.options, b));\n        this.destroy();\n        d.isDirtyLegend = d.isDirtyBox = !0;\n        e(a, !0) && d.redraw();\n        w(this, \"afterUpdate\");\n      }\n      colorizeItem(b, a) {\n        const {\n          group: d,\n          label: c,\n          line: f,\n          symbol: e\n        } = b.legendItem || {};\n        if (d) d[a ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n        if (!this.chart.styledMode) {\n          var g = this.options;\n          const d = this.itemHiddenStyle.color;\n          g = a ? g.itemStyle.color : d;\n          const k = a ? b.color || d : d,\n            m = b.options && b.options.marker;\n          let h = {\n            fill: k\n          };\n          c && c.css({\n            fill: g\n          });\n          f && f.attr({\n            stroke: k\n          });\n          e && (m && e.isMarker && (h = b.pointAttribs(), a || (h.stroke = h.fill = d)), e.attr(h));\n        }\n        w(this, \"afterColorizeItem\", {\n          item: b,\n          visible: a\n        });\n      }\n      positionItems() {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      }\n      positionItem(b) {\n        const {\n          group: a,\n          x: d = 0,\n          y: c = 0\n        } = b.legendItem || {};\n        var e = this.options,\n          g = e.symbolPadding;\n        const m = !e.rtl;\n        e = b.checkbox;\n        a && a.element && (g = {\n          translateX: m ? d : this.legendWidth - d - 2 * g - 4,\n          translateY: c\n        }, a[h(a.translateY) ? \"animate\" : \"attr\"](g, void 0, () => {\n          w(this, \"afterPositionItem\", {\n            item: b\n          });\n        }));\n        e && (e.x = d, e.y = c);\n      }\n      destroyItem(b) {\n        const a = b.checkbox,\n          d = b.legendItem || {};\n        for (const b of [\"group\", \"label\", \"line\", \"symbol\"]) d[b] && (d[b] = d[b].destroy());\n        a && q(a);\n        b.legendItem = void 0;\n      }\n      destroy() {\n        for (const b of this.getAllItems()) this.destroyItem(b);\n        for (const b of \"clipRect up down pager nav box title group\".split(\" \")) this[b] && (this[b] = this[b].destroy());\n        this.display = null;\n      }\n      positionCheckboxes() {\n        const b = this.group && this.group.alignAttr,\n          a = this.clipHeight || this.legendHeight,\n          d = this.titleHeight;\n        let c;\n        b && (c = b.translateY, this.allItems.forEach(function (f) {\n          const e = f.checkbox;\n          let k;\n          e && (k = c + d + e.y + (this.scrollOffset || 0) + 3, l(e, {\n            left: b.translateX + f.checkboxOffset + e.x - 20 + \"px\",\n            top: k + \"px\",\n            display: this.proximate || k > c - 6 && k < c + a - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      }\n      renderTitle() {\n        var b = this.options;\n        const a = this.padding,\n          d = b.title;\n        let c = 0;\n        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, a - 3, a - 4, void 0, void 0, void 0, b.useHTML, void 0, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), b = this.title.getBBox(), c = b.height, this.offsetWidth = b.width, this.contentGroup.attr({\n          translateY: c\n        }));\n        this.titleHeight = c;\n      }\n      setText(b) {\n        const a = this.options;\n        b.legendItem.label.attr({\n          text: a.labelFormat ? t(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)\n        });\n      }\n      renderItem(b) {\n        const a = b.legendItem = b.legendItem || {};\n        var d = this.chart,\n          c = d.renderer;\n        const g = this.options,\n          m = this.symbolWidth,\n          h = g.symbolPadding || 0,\n          p = this.itemStyle,\n          l = this.itemHiddenStyle,\n          n = \"horizontal\" === g.layout ? e(g.itemDistance, 20) : 0,\n          r = !g.rtl,\n          q = !b.series,\n          u = !q && b.series.drawLegendSymbol ? b.series : b;\n        var w = u.options;\n        const t = this.createCheckboxForItem && w && w.showCheckbox,\n          B = g.useHTML,\n          P = b.options.className;\n        let I = a.label;\n        w = m + h + n + (t ? 20 : 0);\n        I || (a.group = c.g(\"legend-item\").addClass(\"highcharts-\" + u.type + \"-series highcharts-color-\" + b.colorIndex + (P ? \" \" + P : \"\") + (q ? \" highcharts-series-\" + b.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.label = I = c.text(\"\", r ? m + h : -h, this.baseline || 0, B), d.styledMode || I.css(F(b.visible ? p : l)), I.attr({\n          align: r ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.group), this.baseline || (this.fontMetrics = c.fontMetrics(I), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, I.attr(\"y\", this.baseline), this.symbolHeight = e(g.symbolHeight, this.fontMetrics.f), g.squareSymbol && (this.symbolWidth = e(g.symbolWidth, Math.max(this.symbolHeight, 16)), w = this.symbolWidth + h + n + (t ? 20 : 0), r && I.attr(\"x\", this.symbolWidth + h))), u.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, I, B));\n        t && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);\n        this.colorizeItem(b, b.visible);\n        !d.styledMode && p.width || I.css({\n          width: (g.itemWidth || this.widthOption || d.spacingBox.width) - w + \"px\"\n        });\n        this.setText(b);\n        d = I.getBBox();\n        c = this.fontMetrics && this.fontMetrics.h || 0;\n        b.itemWidth = b.checkboxOffset = g.itemWidth || a.labelWidth || d.width + w;\n        this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);\n        this.totalItemWidth += b.itemWidth;\n        this.itemHeight = b.itemHeight = Math.round(a.labelHeight || (d.height > 1.5 * c ? d.height : c));\n      }\n      layoutItem(b) {\n        var a = this.options;\n        const d = this.padding,\n          c = \"horizontal\" === a.layout,\n          g = b.itemHeight,\n          m = this.itemMarginBottom,\n          h = this.itemMarginTop,\n          p = c ? e(a.itemDistance, 20) : 0,\n          l = this.maxLegendWidth;\n        a = a.alignColumns && this.totalItemWidth > l ? this.maxItemWidth : b.itemWidth;\n        const n = b.legendItem || {};\n        c && this.itemX - d + a > l && (this.itemX = d, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + m), this.lastLineHeight = 0);\n        this.lastItemY = h + this.itemY + m;\n        this.lastLineHeight = Math.max(g, this.lastLineHeight);\n        n.x = this.itemX;\n        n.y = this.itemY;\n        c ? this.itemX += a : (this.itemY += h + g + m, this.lastLineHeight = g);\n        this.offsetWidth = this.widthOption || Math.max((c ? this.itemX - d - (b.checkbox ? 0 : p) : a) + d, this.offsetWidth);\n      }\n      getAllItems() {\n        let b = [];\n        this.chart.series.forEach(function (a) {\n          const d = a && a.options;\n          a && e(d.showInLegend, h(d.linkedTo) ? !1 : void 0, !0) && (b = b.concat((a.legendItem || {}).labels || (\"point\" === d.legendType ? a.data : a)));\n        });\n        w(this, \"afterGetAllItems\", {\n          allItems: b\n        });\n        return b;\n      }\n      getAlignment() {\n        const b = this.options;\n        return this.proximate ? b.align.charAt(0) + \"tv\" : b.floating ? \"\" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);\n      }\n      adjustMargins(b, a) {\n        const d = this.chart,\n          c = this.options,\n          f = this.getAlignment();\n        f && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (g, k) {\n          g.test(f) && !h(b[k]) && (d[v[k]] = Math.max(d[v[k]], d.legend[(k + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][k] * c[k % 2 ? \"x\" : \"y\"] + e(c.margin, 12) + a[k] + (d.titleOffset[k] || 0)));\n        });\n      }\n      proximatePositions() {\n        const b = this.chart,\n          a = [],\n          d = \"left\" === this.options.align;\n        this.allItems.forEach(function (c) {\n          var f;\n          var e = d;\n          let k;\n          c.yAxis && (c.xAxis.options.reversed && (e = !e), c.points && (f = g(e ? c.points : c.points.slice(0).reverse(), function (b) {\n            return J(b.plotY);\n          })), e = this.itemMarginTop + c.legendItem.label.getBBox().height + this.itemMarginBottom, k = c.yAxis.top - b.plotTop, c.visible ? (f = f ? f.plotY : c.yAxis.height, f += k - .3 * e) : f = k + c.yAxis.height, a.push({\n            target: f,\n            size: e,\n            item: c\n          }));\n        }, this);\n        let e;\n        for (const d of c(a, b.plotHeight)) e = d.item.legendItem || {}, J(d.pos) && (e.y = b.plotTop - b.spacing[0] + d.pos);\n      }\n      render() {\n        const b = this.chart,\n          a = b.renderer,\n          d = this.options,\n          c = this.padding;\n        var e = this.getAllItems();\n        let g,\n          h = this.group,\n          p = this.box;\n        this.itemX = c;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = m(d.width, b.spacingBox.width - c);\n        var l = b.spacingBox.width - 2 * c - d.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (l /= 2);\n        this.maxLegendWidth = this.widthOption || l;\n        h || (this.group = h = a.g(\"legend\").addClass(d.className || \"\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = a.g().attr({\n          zIndex: 1\n        }).add(h), this.scrollGroup = a.g().add(this.contentGroup));\n        this.renderTitle();\n        u(e, (b, a) => (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0));\n        d.reversed && e.reverse();\n        this.allItems = e;\n        this.display = l = !!e.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        e.forEach(this.renderItem, this);\n        e.forEach(this.layoutItem, this);\n        e = (this.widthOption || this.offsetWidth) + c;\n        g = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        g = this.handleOverflow(g);\n        g += c;\n        p || (this.box = p = a.rect().addClass(\"highcharts-legend-box\").attr({\n          r: d.borderRadius\n        }).add(h));\n        b.styledMode || p.attr({\n          stroke: d.borderColor,\n          \"stroke-width\": d.borderWidth || 0,\n          fill: d.backgroundColor || \"none\"\n        }).shadow(d.shadow);\n        if (0 < e && 0 < g) p[p.placed ? \"animate\" : \"attr\"](p.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: e,\n          height: g\n        }, p.strokeWidth()));\n        h[l ? \"show\" : \"hide\"]();\n        b.styledMode && \"none\" === h.getStyle(\"display\") && (e = g = 0);\n        this.legendWidth = e;\n        this.legendHeight = g;\n        l && this.align();\n        this.proximate || this.positionItems();\n        w(this, \"afterRender\");\n      }\n      align(b = this.chart.spacingBox) {\n        const a = this.chart,\n          d = this.options;\n        let c = b.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? c += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (c -= a.titleOffset[2]);\n        c !== b.y && (b = F(b, {\n          y: c\n        }));\n        a.hasRendered || (this.group.placed = !1);\n        this.group.align(F(d, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : d.verticalAlign\n        }), !0, b);\n      }\n      handleOverflow(b) {\n        const a = this,\n          d = this.chart,\n          c = d.renderer,\n          g = this.options;\n        var m = g.y;\n        const h = \"top\" === g.verticalAlign,\n          p = this.padding,\n          l = g.maxHeight,\n          n = g.navigation,\n          r = e(n.animation, !0),\n          q = n.arrowSize || 12,\n          u = this.pages,\n          w = this.allItems,\n          t = function (b) {\n            \"number\" === typeof b ? J.attr({\n              height: b\n            }) : J && (a.clipRect = J.destroy(), a.contentGroup.clip());\n            a.contentGroup.div && (a.contentGroup.div.style.clip = b ? \"rect(\" + p + \"px,9999px,\" + (p + b) + \"px,0)\" : \"auto\");\n          },\n          B = function (b) {\n            a[b] = c.circle(0, 0, 1.3 * q).translate(q / 2, q / 2).add(x);\n            d.styledMode || a[b].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n            return a[b];\n          };\n        let P, I, v;\n        m = d.spacingBox.height + (h ? -m : m) - p;\n        let x = this.nav,\n          J = this.clipRect;\n        \"horizontal\" !== g.layout || \"middle\" === g.verticalAlign || g.floating || (m /= 2);\n        l && (m = Math.min(m, l));\n        u.length = 0;\n        b && 0 < m && b > m && !1 !== n.enabled ? (this.clipHeight = P = Math.max(m - 20 - this.titleHeight - p, 0), this.currentPage = e(this.currentPage, 1), this.fullHeight = b, w.forEach((b, a) => {\n          v = b.legendItem || {};\n          b = v.y || 0;\n          const d = Math.round(v.label.getBBox().height);\n          let c = u.length;\n          if (!c || b - u[c - 1] > P && (I || b) !== u[c - 1]) u.push(I || b), c++;\n          v.pageIx = c - 1;\n          I && ((w[a - 1].legendItem || {}).pageIx = c - 1);\n          a === w.length - 1 && b + d - u[c - 1] > P && b > u[c - 1] && (u.push(b), v.pageIx = c);\n          b !== I && (I = b);\n        }), J || (J = a.clipRect = c.clipRect(0, p - 2, 9999, 0), a.contentGroup.clip(J)), t(P), x || (this.nav = x = c.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = c.symbol(\"triangle\", 0, 0, q, q).add(x), B(\"upTracker\").on(\"click\", function () {\n          a.scroll(-1, r);\n        }), this.pager = c.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !d.styledMode && n.style && this.pager.css(n.style), this.pager.add(x), this.down = c.symbol(\"triangle-down\", 0, 0, q, q).add(x), B(\"downTracker\").on(\"click\", function () {\n          a.scroll(1, r);\n        })), a.scroll(0), b = m) : x && (t(), this.nav = x.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return b;\n      }\n      scroll(b, a) {\n        const d = this.chart,\n          c = this.pages,\n          f = c.length,\n          g = this.clipHeight,\n          m = this.options.navigation,\n          h = this.pager,\n          l = this.padding;\n        let n = this.currentPage + b;\n        n > f && (n = f);\n        0 < n && (\"undefined\" !== typeof a && z(a, d), this.nav.attr({\n          translateX: l,\n          translateY: g + this.padding + 7 + this.titleHeight,\n          visibility: \"inherit\"\n        }), [this.up, this.upTracker].forEach(function (b) {\n          b.attr({\n            \"class\": 1 === n ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), h.attr({\n          text: n + \"/\" + f\n        }), [this.down, this.downTracker].forEach(function (b) {\n          b.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": n === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), d.styledMode || (this.up.attr({\n          fill: 1 === n ? m.inactiveColor : m.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === n ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: n === f ? m.inactiveColor : m.activeColor\n        }), this.downTracker.css({\n          cursor: n === f ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -c[n - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = n, this.positionCheckboxes(), b = x(e(a, d.renderer.globalAnimation, !0)), p(() => {\n          w(this, \"afterScroll\", {\n            currentPage: n\n          });\n        }, b.duration));\n      }\n      setItemEvents(b, a, d) {\n        const c = this,\n          f = b.legendItem || {},\n          e = c.chart.renderer.boxWrapper,\n          g = b instanceof L,\n          m = \"highcharts-legend-\" + (g ? \"point\" : \"series\") + \"-active\",\n          h = c.chart.styledMode;\n        d = d ? [a, f.symbol] : [f.group];\n        const p = a => {\n          c.allItems.forEach(d => {\n            b !== d && [d].concat(d.linkedSeries || []).forEach(b => {\n              b.setState(a, !g);\n            });\n          });\n        };\n        for (const f of d) if (f) f.on(\"mouseover\", function () {\n          b.visible && p(\"inactive\");\n          b.setState(\"hover\");\n          b.visible && e.addClass(m);\n          h || a.css(c.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          c.chart.styledMode || a.css(F(b.visible ? c.itemStyle : c.itemHiddenStyle));\n          p(\"\");\n          e.removeClass(m);\n          b.setState();\n        }).on(\"click\", function (a) {\n          const d = function () {\n            b.setVisible && b.setVisible();\n            p(b.visible ? \"inactive\" : \"\");\n          };\n          e.removeClass(m);\n          a = {\n            browserEvent: a\n          };\n          b.firePointEvent ? b.firePointEvent(\"legendItemClick\", a, d) : w(b, \"legendItemClick\", a, d);\n        });\n      }\n      createCheckboxForItem(b) {\n        b.checkbox = r(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: b.selected,\n          defaultChecked: b.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        n(b.checkbox, \"click\", function (a) {\n          w(b.series || b, \"checkboxClick\", {\n            checked: a.target.checked,\n            item: b\n          }, function () {\n            b.select();\n          });\n        });\n      }\n    }\n    (function (b) {\n      const a = [];\n      b.compose = function (d) {\n        D.pushUnique(a, d) && n(d, \"beforeMargins\", function () {\n          this.legend = new b(this, this.options.legend);\n        });\n      };\n    })(H || (H = {}));\n    \"\";\n    return H;\n  });\n  M(a, \"Core/Series/SeriesRegistry.js\", [a[\"Core/Globals.js\"], a[\"Core/Defaults.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L) {\n    const {\n        defaultOptions: x\n      } = y,\n      {\n        extendClass: D,\n        merge: C\n      } = L;\n    var z;\n    (function (t) {\n      function v(a, n) {\n        const c = x.plotOptions || {},\n          l = n.defaultOptions,\n          h = n.prototype;\n        h.type = a;\n        h.pointClass || (h.pointClass = G);\n        l && (c[a] = l);\n        t.seriesTypes[a] = n;\n      }\n      t.seriesTypes = a.seriesTypes;\n      t.registerSeriesType = v;\n      t.seriesType = function (a, n, r, l, h) {\n        const c = x.plotOptions || {};\n        n = n || \"\";\n        c[a] = C(c[n], r);\n        v(a, D(t.seriesTypes[n] || function () {}, l));\n        t.seriesTypes[a].prototype.type = a;\n        h && (t.seriesTypes[a].prototype.pointClass = D(G, h));\n        return t.seriesTypes[a];\n      };\n    })(z || (z = {}));\n    return z;\n  });\n  M(a, \"Core/Chart/Chart.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"], a[\"Core/Renderer/HTML/AST.js\"]], function (a, y, G, L, A, D, C, z, t, v, c, n) {\n    const {\n        animate: r,\n        animObject: l,\n        setAnimation: h\n      } = a,\n      {\n        defaultOptions: q,\n        defaultTime: g\n      } = G,\n      {\n        numberFormat: w\n      } = L,\n      {\n        registerEventOptions: x\n      } = A,\n      {\n        charts: F,\n        doc: e,\n        marginNames: m,\n        svg: u,\n        win: p\n      } = D,\n      {\n        seriesTypes: H\n      } = z,\n      {\n        addEvent: b,\n        attr: f,\n        cleanRecursively: d,\n        createElement: k,\n        css: O,\n        defined: N,\n        discardElement: E,\n        erase: Z,\n        error: T,\n        extend: U,\n        find: K,\n        fireEvent: Q,\n        getStyle: M,\n        isArray: fa,\n        isNumber: Y,\n        isObject: B,\n        isString: P,\n        merge: I,\n        objectEach: V,\n        pick: R,\n        pInt: ja,\n        relativeLength: W,\n        removeEvent: ba,\n        splat: ca,\n        syncTimeout: ha,\n        uniqueKey: ka\n      } = c;\n    class da {\n      static chart(b, a, d) {\n        return new da(b, a, d);\n      }\n      constructor(b, a, d) {\n        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.sharedClips = {};\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;\n        this.getArgs(b, a, d);\n      }\n      getArgs(b, a, d) {\n        P(b) || b.nodeName ? (this.renderTo = b, this.init(a, d)) : this.init(b, a);\n      }\n      init(b, a) {\n        const d = b.plotOptions || {};\n        Q(this, \"init\", {\n          args: arguments\n        }, function () {\n          const c = I(q, b),\n            f = c.chart;\n          V(c.plotOptions, function (b, a) {\n            B(b) && (b.tooltip = d[a] && I(d[a].tooltip) || void 0);\n          });\n          c.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;\n          this.userOptions = b;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = a;\n          this.isResizing = 0;\n          const e = f.zooming = f.zooming || {};\n          b.chart && !b.chart.zooming && (e.resetButton = f.resetZoomButton);\n          e.key = R(e.key, f.zoomKey);\n          e.pinchType = R(e.pinchType, f.pinchType);\n          e.singleTouch = R(e.singleTouch, f.zoomBySingleTouch);\n          e.type = R(e.type, f.zoomType);\n          this.options = c;\n          this.axes = [];\n          this.series = [];\n          this.time = b.time && Object.keys(b.time).length ? new v(b.time) : D.time;\n          this.numberFormatter = f.numberFormatter || w;\n          this.styledMode = f.styledMode;\n          this.hasCartesianSeries = f.showAxes;\n          this.index = F.length;\n          F.push(this);\n          D.chartCount++;\n          x(this, f);\n          this.xAxis = [];\n          this.yAxis = [];\n          this.pointCount = this.colorCounter = this.symbolCounter = 0;\n          Q(this, \"afterInit\");\n          this.firstRender();\n        });\n      }\n      initSeries(b) {\n        var a = this.options.chart;\n        a = b.type || a.type;\n        const d = H[a];\n        d || T(17, !0, this, {\n          missingModuleFor: a\n        });\n        a = new d();\n        \"function\" === typeof a.init && a.init(this, b);\n        return a;\n      }\n      setSeriesData() {\n        this.getSeriesOrderByLinks().forEach(function (b) {\n          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);\n        });\n      }\n      getSeriesOrderByLinks() {\n        return this.series.concat().sort(function (b, a) {\n          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;\n        });\n      }\n      orderSeries(b) {\n        const a = this.series;\n        for (let d = b || 0, c = a.length; d < c; ++d) a[d] && (a[d].index = d, a[d].name = a[d].getName());\n      }\n      isInsidePlot(b, a, d = {}) {\n        const {\n          inverted: c,\n          plotBox: f,\n          plotLeft: e,\n          plotTop: g,\n          scrollablePlotBox: k\n        } = this;\n        var m = 0;\n        let h = 0;\n        d.visiblePlotOnly && this.scrollingContainer && ({\n          scrollLeft: m,\n          scrollTop: h\n        } = this.scrollingContainer);\n        const p = d.series,\n          l = d.visiblePlotOnly && k || f;\n        var n = d.inverted ? a : b;\n        a = d.inverted ? b : a;\n        b = {\n          x: n,\n          y: a,\n          isInsidePlot: !0,\n          options: d\n        };\n        if (!d.ignoreX) {\n          const a = p && (c && !this.polar ? p.yAxis : p.xAxis) || {\n            pos: e,\n            len: Infinity\n          };\n          n = d.paneCoordinates ? a.pos + n : e + n;\n          n >= Math.max(m + e, a.pos) && n <= Math.min(m + e + l.width, a.pos + a.len) || (b.isInsidePlot = !1);\n        }\n        !d.ignoreY && b.isInsidePlot && (m = !c && d.axis && !d.axis.isXAxis && d.axis || p && (c ? p.xAxis : p.yAxis) || {\n          pos: g,\n          len: Infinity\n        }, d = d.paneCoordinates ? m.pos + a : g + a, d >= Math.max(h + g, m.pos) && d <= Math.min(h + g + l.height, m.pos + m.len) || (b.isInsidePlot = !1));\n        Q(this, \"afterIsInsidePlot\", b);\n        return b.isInsidePlot;\n      }\n      redraw(b) {\n        Q(this, \"beforeRedraw\");\n        const a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n          d = this.series,\n          c = this.pointer,\n          f = this.legend,\n          e = this.userOptions.legend,\n          g = this.renderer,\n          k = g.isHidden(),\n          m = [];\n        let p,\n          l,\n          n = this.isDirtyBox,\n          B = this.isDirtyLegend,\n          r;\n        g.rootFontSize = g.boxWrapper.getStyle(\"font-size\");\n        this.setResponsive && this.setResponsive(!1);\n        h(this.hasRendered ? b : !1, this);\n        k && this.temporaryDisplay();\n        this.layOutTitles();\n        for (b = d.length; b--;) if (r = d[b], r.options.stacking || r.options.centerInCategory) if (l = !0, r.isDirty) {\n          p = !0;\n          break;\n        }\n        if (p) for (b = d.length; b--;) r = d[b], r.options.stacking && (r.isDirty = !0);\n        d.forEach(function (b) {\n          b.isDirty && (\"point\" === b.options.legendType ? (\"function\" === typeof b.updateTotals && b.updateTotals(), B = !0) : e && (e.labelFormatter || e.labelFormat) && (B = !0));\n          b.isDirtyData && Q(b, \"updatedData\");\n        });\n        B && f && f.options.enabled && (f.render(), this.isDirtyLegend = !1);\n        l && this.getStacks();\n        a.forEach(function (b) {\n          b.updateNames();\n          b.setScale();\n        });\n        this.getMargins();\n        a.forEach(function (b) {\n          b.isDirty && (n = !0);\n        });\n        a.forEach(function (b) {\n          const a = b.min + \",\" + b.max;\n          b.extKey !== a && (b.extKey = a, m.push(function () {\n            Q(b, \"afterSetExtremes\", U(b.eventArgs, b.getExtremes()));\n            delete b.eventArgs;\n          }));\n          (n || l) && b.redraw();\n        });\n        n && this.drawChartBox();\n        Q(this, \"predraw\");\n        d.forEach(function (b) {\n          (n || b.isDirty) && b.visible && b.redraw();\n          b.isDirtyData = !1;\n        });\n        c && c.reset(!0);\n        g.draw();\n        Q(this, \"redraw\");\n        Q(this, \"render\");\n        k && this.temporaryDisplay(!0);\n        m.forEach(function (b) {\n          b.call();\n        });\n      }\n      get(b) {\n        function a(a) {\n          return a.id === b || a.options && a.options.id === b;\n        }\n        const d = this.series;\n        let c = K(this.axes, a) || K(this.series, a);\n        for (let b = 0; !c && b < d.length; b++) c = K(d[b].points || [], a);\n        return c;\n      }\n      getAxes() {\n        const b = this;\n        var a = this.options;\n        const d = a.xAxis = ca(a.xAxis || {});\n        a = a.yAxis = ca(a.yAxis || {});\n        Q(this, \"getAxes\");\n        d.forEach(function (b, a) {\n          b.index = a;\n          b.isX = !0;\n        });\n        a.forEach(function (b, a) {\n          b.index = a;\n        });\n        d.concat(a).forEach(function (a) {\n          new y(b, a);\n        });\n        Q(this, \"afterGetAxes\");\n      }\n      getSelectedPoints() {\n        return this.series.reduce((b, a) => {\n          a.getPointsCollection().forEach(a => {\n            R(a.selectedStaging, a.selected) && b.push(a);\n          });\n          return b;\n        }, []);\n      }\n      getSelectedSeries() {\n        return this.series.filter(function (b) {\n          return b.selected;\n        });\n      }\n      setTitle(b, a, d) {\n        this.applyDescription(\"title\", b);\n        this.applyDescription(\"subtitle\", a);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(d);\n      }\n      applyDescription(b, a) {\n        const d = this;\n        var c = \"title\" === b ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"1em\" : \"1.2em\",\n          fontWeight: \"bold\"\n        } : {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        };\n        c = this.options[b] = I(!this.styledMode && {\n          style: c\n        }, this.options[b], a);\n        let f = this[b];\n        f && a && (this[b] = f = f.destroy());\n        c && !f && (f = this.renderer.text(c.text, 0, 0, c.useHTML).attr({\n          align: c.align,\n          \"class\": \"highcharts-\" + b,\n          zIndex: c.zIndex || 4\n        }).add(), f.update = function (a) {\n          d[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[b]](a);\n        }, this.styledMode || f.css(c.style), this[b] = f);\n      }\n      layOutTitles(b) {\n        const a = [0, 0, 0],\n          d = this.renderer,\n          c = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (b) {\n          const f = this[b],\n            e = this.options[b],\n            g = e.verticalAlign || \"top\";\n          b = \"title\" === b ? \"top\" === g ? -3 : 0 : \"top\" === g ? a[0] + 2 : 0;\n          if (f) {\n            f.css({\n              width: (e.width || c.width + (e.widthAdjust || 0)) + \"px\"\n            });\n            const k = d.fontMetrics(f).b,\n              m = Math.round(f.getBBox(e.useHTML).height);\n            f.align(U({\n              y: \"bottom\" === g ? k : b + k,\n              height: m\n            }, e), !1, \"spacingBox\");\n            e.floating || (\"top\" === g ? a[0] = Math.ceil(a[0] + m) : \"bottom\" === g && (a[2] = Math.ceil(a[2] + m)));\n          }\n        }, this);\n        a[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (a[0] += this.options.title.margin);\n        a[2] && \"bottom\" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);\n        const f = !this.titleOffset || this.titleOffset.join(\",\") !== a.join(\",\");\n        this.titleOffset = a;\n        Q(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && f && (this.isDirtyBox = this.isDirtyLegend = f, this.hasRendered && R(b, !0) && this.isDirtyBox && this.redraw());\n      }\n      getContainerBox() {\n        return {\n          width: M(this.renderTo, \"width\", !0) || 0,\n          height: M(this.renderTo, \"height\", !0) || 0\n        };\n      }\n      getChartSize() {\n        var b = this.options.chart;\n        const a = b.width;\n        b = b.height;\n        const d = this.getContainerBox();\n        this.chartWidth = Math.max(0, a || d.width || 600);\n        this.chartHeight = Math.max(0, W(b, this.chartWidth) || (1 < d.height ? d.height : 400));\n        this.containerBox = d;\n      }\n      temporaryDisplay(b) {\n        let a = this.renderTo;\n        if (b) for (; a && a.style;) a.hcOrigStyle && (O(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (e.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {\n          e.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, e.body.appendChild(a));\n          if (\"none\" === M(a, \"display\", !1) || a.hcOricDetached) a.hcOrigStyle = {\n            display: a.style.display,\n            height: a.style.height,\n            overflow: a.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, a !== this.renderTo && (b.height = 0), O(a, b), a.offsetWidth || a.style.setProperty(\"display\", \"block\", \"important\");\n          a = a.parentNode;\n          if (a === e.body) break;\n        }\n      }\n      setClassName(b) {\n        this.container.className = \"highcharts-container \" + (b || \"\");\n      }\n      getContainer() {\n        const b = this.options,\n          a = b.chart;\n        var d = ka();\n        let c,\n          g = this.renderTo;\n        g || (this.renderTo = g = a.renderTo);\n        P(g) && (this.renderTo = g = e.getElementById(g));\n        g || T(13, !0, this);\n        var m = ja(f(g, \"data-highcharts-chart\"));\n        Y(m) && F[m] && F[m].hasRendered && F[m].destroy();\n        f(g, \"data-highcharts-chart\", this.index);\n        g.innerHTML = n.emptyHTML;\n        a.skipClone || g.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        m = this.chartWidth;\n        const p = this.chartHeight;\n        O(g, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (c = U({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: m + \"px\",\n          height: p + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\",\n          \"touch-action\": \"manipulation\",\n          outline: \"none\"\n        }, a.style || {}));\n        this.container = d = k(\"div\", {\n          id: d\n        }, c, g);\n        this._cursor = d.style.cursor;\n        this.renderer = new (a.renderer || !u ? C.getRendererType(a.renderer) : t)(d, m, p, void 0, a.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n        this.containerBox = this.getContainerBox();\n        h(void 0, this);\n        this.setClassName(a.className);\n        if (this.styledMode) for (const a in b.defs) this.renderer.definition(b.defs[a]);else this.renderer.setStyle(a.style);\n        this.renderer.chartIndex = this.index;\n        Q(this, \"afterGetContainer\");\n      }\n      getMargins(b) {\n        const {\n          spacing: a,\n          margin: d,\n          titleOffset: c\n        } = this;\n        this.resetMargins();\n        c[0] && !N(d[0]) && (this.plotTop = Math.max(this.plotTop, c[0] + a[0]));\n        c[2] && !N(d[2]) && (this.marginBottom = Math.max(this.marginBottom, c[2] + a[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(d, a);\n        Q(this, \"getMargins\");\n        b || this.getAxisMargins();\n      }\n      getAxisMargins() {\n        const b = this,\n          a = b.axisOffset = [0, 0, 0, 0],\n          d = b.colorAxis,\n          c = b.margin,\n          f = function (b) {\n            b.forEach(function (b) {\n              b.visible && b.getOffset();\n            });\n          };\n        b.hasCartesianSeries ? f(b.axes) : d && d.length && f(d);\n        m.forEach(function (d, f) {\n          N(c[f]) || (b[d] += a[f]);\n        });\n        b.setChartSize();\n      }\n      reflow(b) {\n        const a = this;\n        var d = a.options.chart;\n        d = N(d.width) && N(d.height);\n        const f = a.containerBox,\n          e = a.getContainerBox();\n        delete a.pointer.chartPosition;\n        if (!d && !a.isPrinting && f && e.width) {\n          if (e.width !== f.width || e.height !== f.height) c.clearTimeout(a.reflowTimeout), a.reflowTimeout = ha(function () {\n            a.container && a.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          a.containerBox = e;\n        }\n      }\n      setReflow() {\n        const a = this;\n        var d = b => {\n          var d;\n          (null === (d = a.options) || void 0 === d ? 0 : d.chart.reflow) && a.hasLoaded && a.reflow(b);\n        };\n        \"function\" === typeof ResizeObserver ? new ResizeObserver(d).observe(a.renderTo) : (d = b(p, \"resize\", d), b(this, \"destroy\", d));\n      }\n      setSize(b, a, d) {\n        const c = this,\n          f = c.renderer;\n        c.isResizing += 1;\n        h(d, c);\n        d = f.globalAnimation;\n        c.oldChartHeight = c.chartHeight;\n        c.oldChartWidth = c.chartWidth;\n        \"undefined\" !== typeof b && (c.options.chart.width = b);\n        \"undefined\" !== typeof a && (c.options.chart.height = a);\n        c.getChartSize();\n        c.styledMode || (d ? r : O)(c.container, {\n          width: c.chartWidth + \"px\",\n          height: c.chartHeight + \"px\"\n        }, d);\n        c.setChartSize(!0);\n        f.setSize(c.chartWidth, c.chartHeight, d);\n        c.axes.forEach(function (b) {\n          b.isDirty = !0;\n          b.setScale();\n        });\n        c.isDirtyLegend = !0;\n        c.isDirtyBox = !0;\n        c.layOutTitles();\n        c.getMargins();\n        c.redraw(d);\n        c.oldChartHeight = null;\n        Q(c, \"resize\");\n        ha(function () {\n          c && Q(c, \"endResize\", null, function () {\n            --c.isResizing;\n          });\n        }, l(d).duration);\n      }\n      setChartSize(b) {\n        var a = this.inverted;\n        const d = this.renderer;\n        var c = this.chartWidth,\n          f = this.chartHeight;\n        const e = this.options.chart,\n          g = this.spacing,\n          k = this.clipOffset;\n        let m, h, p, l;\n        this.plotLeft = m = Math.round(this.plotLeft);\n        this.plotTop = h = Math.round(this.plotTop);\n        this.plotWidth = p = Math.max(0, Math.round(c - m - this.marginRight));\n        this.plotHeight = l = Math.max(0, Math.round(f - h - this.marginBottom));\n        this.plotSizeX = a ? l : p;\n        this.plotSizeY = a ? p : l;\n        this.plotBorderWidth = e.plotBorderWidth || 0;\n        this.spacingBox = d.spacingBox = {\n          x: g[3],\n          y: g[0],\n          width: c - g[3] - g[1],\n          height: f - g[0] - g[2]\n        };\n        this.plotBox = d.plotBox = {\n          x: m,\n          y: h,\n          width: p,\n          height: l\n        };\n        a = 2 * Math.floor(this.plotBorderWidth / 2);\n        c = Math.ceil(Math.max(a, k[3]) / 2);\n        f = Math.ceil(Math.max(a, k[0]) / 2);\n        this.clipBox = {\n          x: c,\n          y: f,\n          width: Math.floor(this.plotSizeX - Math.max(a, k[1]) / 2 - c),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, k[2]) / 2 - f))\n        };\n        b || (this.axes.forEach(function (b) {\n          b.setAxisSize();\n          b.setAxisTranslation();\n        }), d.alignElements());\n        Q(this, \"afterSetChartSize\", {\n          skipAxes: b\n        });\n      }\n      resetMargins() {\n        Q(this, \"resetMargins\");\n        const b = this,\n          a = b.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (d) {\n          const c = a[d],\n            f = B(c) ? c : [c, c, c, c];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (c, e) {\n            b[d][e] = R(a[d + c], f[e]);\n          });\n        });\n        m.forEach(function (a, d) {\n          b[a] = R(b.margin[d], b.spacing[d]);\n        });\n        b.axisOffset = [0, 0, 0, 0];\n        b.clipOffset = [0, 0, 0, 0];\n      }\n      drawChartBox() {\n        const b = this.options.chart,\n          a = this.renderer,\n          d = this.chartWidth,\n          c = this.chartHeight,\n          f = this.styledMode,\n          e = this.plotBGImage;\n        var g = b.backgroundColor;\n        const k = b.plotBackgroundColor,\n          m = b.plotBackgroundImage,\n          h = this.plotLeft,\n          p = this.plotTop,\n          l = this.plotWidth,\n          n = this.plotHeight,\n          B = this.plotBox,\n          r = this.clipRect,\n          q = this.clipBox;\n        let u = this.chartBackground,\n          I = this.plotBackground,\n          w = this.plotBorder,\n          t,\n          P,\n          v = \"animate\";\n        u || (this.chartBackground = u = a.rect().addClass(\"highcharts-background\").add(), v = \"attr\");\n        if (f) t = P = u.strokeWidth();else {\n          t = b.borderWidth || 0;\n          P = t + (b.shadow ? 8 : 0);\n          g = {\n            fill: g || \"none\"\n          };\n          if (t || u[\"stroke-width\"]) g.stroke = b.borderColor, g[\"stroke-width\"] = t;\n          u.attr(g).shadow(b.shadow);\n        }\n        u[v]({\n          x: P / 2,\n          y: P / 2,\n          width: d - P - t % 2,\n          height: c - P - t % 2,\n          r: b.borderRadius\n        });\n        v = \"animate\";\n        I || (v = \"attr\", this.plotBackground = I = a.rect().addClass(\"highcharts-plot-background\").add());\n        I[v](B);\n        f || (I.attr({\n          fill: k || \"none\"\n        }).shadow(b.plotShadow), m && (e ? (m !== e.attr(\"href\") && e.attr(\"href\", m), e.animate(B)) : this.plotBGImage = a.image(m, h, p, l, n).add()));\n        r ? r.animate({\n          width: q.width,\n          height: q.height\n        }) : this.clipRect = a.clipRect(q);\n        v = \"animate\";\n        w || (v = \"attr\", this.plotBorder = w = a.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        f || w.attr({\n          stroke: b.plotBorderColor,\n          \"stroke-width\": b.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        w[v](w.crisp({\n          x: h,\n          y: p,\n          width: l,\n          height: n\n        }, -w.strokeWidth()));\n        this.isDirtyBox = !1;\n        Q(this, \"afterDrawChartBox\");\n      }\n      propFromSeries() {\n        const b = this,\n          a = b.options.chart,\n          d = b.options.series;\n        let c, f, e;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (g) {\n          f = H[a.type];\n          e = a[g] || f && f.prototype[g];\n          for (c = d && d.length; !e && c--;) (f = H[d[c].type]) && f.prototype[g] && (e = !0);\n          b[g] = e;\n        });\n      }\n      linkSeries(b) {\n        const a = this,\n          d = a.series;\n        d.forEach(function (b) {\n          b.linkedSeries.length = 0;\n        });\n        d.forEach(function (b) {\n          let d = b.options.linkedTo;\n          P(d) && (d = \":previous\" === d ? a.series[b.index - 1] : a.get(d)) && d.linkedParent !== b && (d.linkedSeries.push(b), b.linkedParent = d, d.enabledDataSorting && b.setDataSortingOptions(), b.visible = R(b.options.visible, d.options.visible, b.visible));\n        });\n        Q(this, \"afterLinkSeries\", {\n          isUpdating: b\n        });\n      }\n      renderSeries() {\n        this.series.forEach(function (b) {\n          b.translate();\n          b.render();\n        });\n      }\n      render() {\n        const b = this.axes,\n          a = this.colorAxis,\n          d = this.renderer,\n          c = function (b) {\n            b.forEach(function (b) {\n              b.visible && b.render();\n            });\n          };\n        let f = 0;\n        this.setTitle();\n        Q(this, \"beforeMargins\");\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        const e = this.plotWidth;\n        b.some(function (b) {\n          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;\n        });\n        const g = this.plotHeight = Math.max(this.plotHeight - f, 0);\n        b.forEach(function (b) {\n          b.setScale();\n        });\n        this.getAxisMargins();\n        const k = 1.1 < e / this.plotWidth,\n          m = 1.05 < g / this.plotHeight;\n        if (k || m) b.forEach(function (b) {\n          (b.horiz && k || !b.horiz && m) && b.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? c(b) : a && a.length && c(a);\n        this.seriesGroup || (this.seriesGroup = d.g(\"series-group\").attr({\n          zIndex: 3\n        }).shadow(this.options.chart.seriesGroupShadow).add());\n        this.renderSeries();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      }\n      addCredits(b) {\n        const a = this,\n          d = I(!0, this.options.credits, b);\n        d.enabled && !this.credits && (this.credits = this.renderer.text(d.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          d.href && (p.location.href = d.href);\n        }).attr({\n          align: d.position.align,\n          zIndex: 8\n        }), a.styledMode || this.credits.css(d.style), this.credits.add().align(d.position), this.credits.update = function (b) {\n          a.credits = a.credits.destroy();\n          a.addCredits(b);\n        });\n      }\n      destroy() {\n        const b = this,\n          a = b.axes,\n          d = b.series,\n          c = b.container,\n          f = c && c.parentNode;\n        let e;\n        Q(b, \"destroy\");\n        b.renderer.forExport ? Z(F, b) : F[b.index] = void 0;\n        D.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        ba(b);\n        for (e = a.length; e--;) a[e] = a[e].destroy();\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n        for (e = d.length; e--;) d[e] = d[e].destroy();\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          const d = b[a];\n          d && d.destroy && (b[a] = d.destroy());\n        });\n        c && (c.innerHTML = n.emptyHTML, ba(c), f && E(c));\n        V(b, function (a, d) {\n          delete b[d];\n        });\n      }\n      firstRender() {\n        const b = this,\n          a = b.options;\n        b.getContainer();\n        b.resetMargins();\n        b.setChartSize();\n        b.propFromSeries();\n        b.getAxes();\n        (fa(a.series) ? a.series : []).forEach(function (a) {\n          b.initSeries(a);\n        });\n        b.linkSeries();\n        b.setSeriesData();\n        Q(b, \"beforeRender\");\n        b.render();\n        b.pointer.getChartPosition();\n        if (!b.renderer.imgCount && !b.hasLoaded) b.onload();\n        b.temporaryDisplay(!0);\n      }\n      onload() {\n        this.callbacks.concat([this.callback]).forEach(function (b) {\n          b && \"undefined\" !== typeof this.index && b.apply(this, [this]);\n        }, this);\n        Q(this, \"load\");\n        Q(this, \"render\");\n        N(this.index) && this.setReflow();\n        this.warnIfA11yModuleNotLoaded();\n        this.hasLoaded = !0;\n      }\n      warnIfA11yModuleNotLoaded() {\n        const {\n          options: b,\n          title: a\n        } = this;\n        b && !this.accessibility && (this.renderer.boxWrapper.attr({\n          role: \"img\",\n          \"aria-label\": (a && a.element.textContent || \"\").replace(/</g, \"&lt;\")\n        }), b.accessibility && !1 === b.accessibility.enabled || T('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n      }\n      addSeries(b, a, d) {\n        const c = this;\n        let f;\n        b && (a = R(a, !0), Q(c, \"addSeries\", {\n          options: b\n        }, function () {\n          f = c.initSeries(b);\n          c.isDirtyLegend = !0;\n          c.linkSeries();\n          f.enabledDataSorting && f.setData(b.data, !1);\n          Q(c, \"afterAddSeries\", {\n            series: f\n          });\n          a && c.redraw(d);\n        }));\n        return f;\n      }\n      addAxis(b, a, d, c) {\n        return this.createAxis(a ? \"xAxis\" : \"yAxis\", {\n          axis: b,\n          redraw: d,\n          animation: c\n        });\n      }\n      addColorAxis(b, a, d) {\n        return this.createAxis(\"colorAxis\", {\n          axis: b,\n          redraw: a,\n          animation: d\n        });\n      }\n      createAxis(b, a) {\n        b = new y(this, I(a.axis, {\n          index: this[b].length,\n          isX: \"xAxis\" === b\n        }));\n        R(a.redraw, !0) && this.redraw(a.animation);\n        return b;\n      }\n      showLoading(a) {\n        const d = this,\n          c = d.options,\n          f = c.loading,\n          e = function () {\n            g && O(g, {\n              left: d.plotLeft + \"px\",\n              top: d.plotTop + \"px\",\n              width: d.plotWidth + \"px\",\n              height: d.plotHeight + \"px\"\n            });\n          };\n        let g = d.loadingDiv,\n          m = d.loadingSpan;\n        g || (d.loadingDiv = g = k(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, d.container));\n        m || (d.loadingSpan = m = k(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, g), b(d, \"redraw\", e));\n        g.className = \"highcharts-loading\";\n        n.setElementHTML(m, R(a, c.lang.loading, \"\"));\n        d.styledMode || (O(g, U(f.style, {\n          zIndex: 10\n        })), O(m, f.labelStyle), d.loadingShown || (O(g, {\n          opacity: 0,\n          display: \"\"\n        }), r(g, {\n          opacity: f.style.opacity || .5\n        }, {\n          duration: f.showDuration || 0\n        })));\n        d.loadingShown = !0;\n        e();\n      }\n      hideLoading() {\n        const b = this.options,\n          a = this.loadingDiv;\n        a && (a.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || r(a, {\n          opacity: 0\n        }, {\n          duration: b.loading.hideDuration || 100,\n          complete: function () {\n            O(a, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      }\n      update(b, a, c, f) {\n        const e = this,\n          k = {\n            credits: \"addCredits\",\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          },\n          m = b.isResponsiveOptions,\n          h = [];\n        let p, l;\n        Q(e, \"update\", {\n          options: b\n        });\n        m || e.setResponsive(!1, !0);\n        b = d(b, e.options);\n        e.userOptions = I(e.userOptions, b);\n        var n = b.chart;\n        if (n) {\n          I(!0, e.options.chart, n);\n          \"className\" in n && e.setClassName(n.className);\n          if (\"inverted\" in n || \"polar\" in n || \"type\" in n) {\n            e.propFromSeries();\n            var B = !0;\n          }\n          \"alignTicks\" in n && (B = !0);\n          \"events\" in n && x(this, n);\n          V(n, function (b, a) {\n            -1 !== e.propsRequireUpdateSeries.indexOf(\"chart.\" + a) && (p = !0);\n            -1 !== e.propsRequireDirtyBox.indexOf(a) && (e.isDirtyBox = !0);\n            -1 !== e.propsRequireReflow.indexOf(a) && (m ? e.isDirtyBox = !0 : l = !0);\n          });\n          !e.styledMode && n.style && e.renderer.setStyle(e.options.chart.style || {});\n        }\n        !e.styledMode && b.colors && (this.options.colors = b.colors);\n        b.time && (this.time === g && (this.time = new v(b.time)), I(!0, e.options.time, b.time));\n        V(b, function (a, d) {\n          if (e[d] && \"function\" === typeof e[d].update) e[d].update(a, !1);else if (\"function\" === typeof e[k[d]]) e[k[d]](a);else \"colors\" !== d && -1 === e.collectionsWithUpdate.indexOf(d) && I(!0, e.options[d], b[d]);\n          \"chart\" !== d && -1 !== e.propsRequireUpdateSeries.indexOf(d) && (p = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          let d;\n          b[a] && (d = [], e[a].forEach(function (b, a) {\n            b.options.isInternal || d.push(R(b.options.index, a));\n          }), ca(b[a]).forEach(function (b, f) {\n            const g = N(b.id);\n            let k;\n            g && (k = e.get(b.id));\n            !k && e[a] && (k = e[a][d ? d[f] : f]) && g && N(k.options.id) && (k = void 0);\n            k && k.coll === a && (k.update(b, !1), c && (k.touched = !0));\n            !k && c && e.collectionsWithInit[a] && (e.collectionsWithInit[a][0].apply(e, [b].concat(e.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);\n          }), c && e[a].forEach(function (b) {\n            b.touched || b.options.isInternal ? delete b.touched : h.push(b);\n          }));\n        });\n        h.forEach(function (b) {\n          b.chart && b.remove && b.remove(!1);\n        });\n        B && e.axes.forEach(function (b) {\n          b.update({}, !1);\n        });\n        p && e.getSeriesOrderByLinks().forEach(function (b) {\n          b.chart && b.update({}, !1);\n        }, this);\n        B = n && n.width;\n        n = n && (P(n.height) ? W(n.height, B || e.chartWidth) : n.height);\n        l || Y(B) && B !== e.chartWidth || Y(n) && n !== e.chartHeight ? e.setSize(B, n, f) : R(a, !0) && e.redraw(f);\n        Q(e, \"afterUpdate\", {\n          options: b,\n          redraw: a,\n          animation: f\n        });\n      }\n      setSubtitle(b, a) {\n        this.applyDescription(\"subtitle\", b);\n        this.layOutTitles(a);\n      }\n      setCaption(b, a) {\n        this.applyDescription(\"caption\", b);\n        this.layOutTitles(a);\n      }\n      showResetZoom() {\n        function b() {\n          a.zoomOut();\n        }\n        const a = this,\n          d = q.lang,\n          c = a.options.chart.zooming.resetButton,\n          f = c.theme,\n          e = \"chart\" === c.relativeTo || \"spacingBox\" === c.relativeTo ? null : \"scrollablePlotBox\";\n        Q(this, \"beforeShowResetZoom\", null, function () {\n          a.resetZoomButton = a.renderer.button(d.resetZoom, null, null, b, f).attr({\n            align: c.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(c.position, !1, e);\n        });\n        Q(this, \"afterShowResetZoom\");\n      }\n      zoomOut() {\n        Q(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      }\n      zoom(b) {\n        const a = this,\n          d = a.pointer;\n        let c = !1,\n          f;\n        !b || b.resetSelection ? (a.axes.forEach(function (b) {\n          f = b.zoom();\n        }), d.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {\n          const e = b.axis;\n          if (d[e.isXAxis ? \"zoomX\" : \"zoomY\"] && N(d.mouseDownX) && N(d.mouseDownY) && a.isInsidePlot(d.mouseDownX - a.plotLeft, d.mouseDownY - a.plotTop, {\n            axis: e\n          }) || !N(a.inverted ? d.mouseDownX : d.mouseDownY)) f = e.zoom(b.min, b.max), e.displayBtn && (c = !0);\n        });\n        const e = a.resetZoomButton;\n        c && !e ? a.showResetZoom() : !c && B(e) && (a.resetZoomButton = e.destroy());\n        f && a.redraw(R(a.options.chart.animation, b && b.animation, 100 > a.pointCount));\n      }\n      pan(b, a) {\n        const d = this,\n          c = d.hoverPoints;\n        a = \"object\" === typeof a ? a : {\n          enabled: a,\n          type: \"x\"\n        };\n        const f = d.options.chart;\n        f && f.panning && (f.panning = a);\n        const e = a.type;\n        let g;\n        Q(this, \"pan\", {\n          originalEvent: b\n        }, function () {\n          c && c.forEach(function (b) {\n            b.setState();\n          });\n          let a = d.xAxis;\n          \"xy\" === e ? a = a.concat(d.yAxis) : \"y\" === e && (a = d.yAxis);\n          const f = {};\n          a.forEach(function (a) {\n            if (a.options.panningEnabled && !a.options.isInternal) {\n              var c = a.horiz,\n                k = b[c ? \"chartX\" : \"chartY\"];\n              c = c ? \"mouseDownX\" : \"mouseDownY\";\n              var m = d[c],\n                h = a.minPointOffset || 0,\n                p = a.reversed && !d.inverted || !a.reversed && d.inverted ? -1 : 1,\n                l = a.getExtremes(),\n                n = a.toValue(m - k, !0) + h * p,\n                B = a.toValue(m + a.len - k, !0) - (h * p || a.isXAxis && a.pointRangePadding || 0),\n                r = B < n;\n              p = a.hasVerticalPanning();\n              m = r ? B : n;\n              n = r ? n : B;\n              var q = a.panningState;\n              !p || a.isXAxis || q && !q.isDirty || a.series.forEach(function (b) {\n                var a = b.getProcessedData(!0);\n                a = b.getExtremes(a.yData, !0);\n                q || (q = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                Y(a.dataMin) && Y(a.dataMax) && (q.startMin = Math.min(R(b.options.threshold, Infinity), a.dataMin, q.startMin), q.startMax = Math.max(R(b.options.threshold, -Infinity), a.dataMax, q.startMax));\n              });\n              p = Math.min(R(q && q.startMin, l.dataMin), h ? l.min : a.toValue(a.toPixels(l.min) - a.minPixelPadding));\n              B = Math.max(R(q && q.startMax, l.dataMax), h ? l.max : a.toValue(a.toPixels(l.max) + a.minPixelPadding));\n              a.panningState = q;\n              a.isOrdinal || (h = p - m, 0 < h && (n += h, m = p), h = n - B, 0 < h && (n = B, m -= h), a.series.length && m !== l.min && n !== l.max && m >= p && n <= B && (a.setExtremes(m, n, !1, !1, {\n                trigger: \"pan\"\n              }), !d.resetZoomButton && m !== p && n !== B && e.match(\"y\") && (d.showResetZoom(), a.displayBtn = !1), g = !0), f[c] = k);\n            }\n          });\n          V(f, (b, a) => {\n            d[a] = b;\n          });\n          g && d.redraw(!1);\n          O(d.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    }\n    U(da.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [da.prototype.addAxis, [!0]],\n        yAxis: [da.prototype.addAxis, [!1]],\n        series: [da.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n    \"\";\n    return da;\n  });\n  M(a, \"Core/Legend/LegendSymbol.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      extend: x,\n      merge: G,\n      pick: L\n    } = a;\n    var A = /*#__PURE__*/(() => {\n      (function (a) {\n        a.lineMarker = function (a, z) {\n          z = this.legendItem = this.legendItem || {};\n          var t = this.options;\n          const v = a.symbolWidth,\n            c = a.symbolHeight,\n            n = c / 2,\n            r = this.chart.renderer,\n            l = z.group;\n          a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n          let h = {},\n            q = t.marker,\n            g = 0;\n          this.chart.styledMode || (h = {\n            \"stroke-width\": Math.min(t.lineWidth || 0, 24)\n          }, t.dashStyle ? h.dashstyle = t.dashStyle : \"square\" !== t.linecap && (h[\"stroke-linecap\"] = \"round\"));\n          z.line = r.path().addClass(\"highcharts-graph\").attr(h).add(l);\n          h[\"stroke-linecap\"] && (g = Math.min(z.line.strokeWidth(), v) / 2);\n          v && z.line.attr({\n            d: [[\"M\", g, a], [\"L\", v - g, a]]\n          });\n          q && !1 !== q.enabled && v && (t = Math.min(L(q.radius, n), n), 0 === this.symbol.indexOf(\"url\") && (q = G(q, {\n            width: c,\n            height: c\n          }), t = 0), z.symbol = z = r.symbol(this.symbol, v / 2 - t, a - t, 2 * t, 2 * t, x({\n            context: \"legend\"\n          }, q)).addClass(\"highcharts-point\").add(l), z.isMarker = !0);\n        };\n        a.rectangle = function (a, x) {\n          x = x.legendItem || {};\n          const t = a.symbolHeight,\n            v = a.options.squareSymbol;\n          x.symbol = this.chart.renderer.rect(v ? (a.symbolWidth - t) / 2 : 0, a.baseline - t + 1, v ? t : a.symbolWidth, t, L(a.options.symbolRadius, t / 2)).addClass(\"highcharts-point\").attr({\n            zIndex: 3\n          }).add(x.group);\n        };\n      })(A || (A = {}));\n      return A;\n    })();\n    return A;\n  });\n  M(a, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 1,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function () {\n          const {\n            numberFormatter: a\n          } = this.series.chart;\n          return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    };\n  });\n  M(a, \"Core/Series/Series.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Legend/LegendSymbol.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/SeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D, C, z, t, v) {\n    const {\n        animObject: c,\n        setAnimation: n\n      } = a,\n      {\n        defaultOptions: r\n      } = y,\n      {\n        registerEventOptions: l\n      } = G,\n      {\n        hasTouch: h,\n        svg: q,\n        win: g\n      } = L,\n      {\n        seriesTypes: w\n      } = z,\n      {\n        arrayMax: x,\n        arrayMin: F,\n        clamp: e,\n        cleanRecursively: m,\n        correctFloat: u,\n        defined: p,\n        erase: H,\n        error: b,\n        extend: f,\n        find: d,\n        fireEvent: k,\n        getNestedProperty: O,\n        isArray: N,\n        isNumber: E,\n        isString: Z,\n        merge: T,\n        objectEach: U,\n        pick: K,\n        removeEvent: Q,\n        splat: M,\n        syncTimeout: fa\n      } = v;\n    class Y {\n      constructor() {\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n      init(b, a) {\n        k(this, \"init\", {\n          options: a\n        });\n        const d = this,\n          c = b.series;\n        this.eventsToUnbind = [];\n        d.chart = b;\n        d.options = d.setOptions(a);\n        a = d.options;\n        d.linkedSeries = [];\n        d.bindAxes();\n        f(d, {\n          name: a.name,\n          state: \"\",\n          visible: !1 !== a.visible,\n          selected: !0 === a.selected\n        });\n        l(this, a);\n        const e = a.events;\n        if (e && e.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;\n        d.getColor();\n        d.getSymbol();\n        d.parallelArrays.forEach(function (b) {\n          d[b + \"Data\"] || (d[b + \"Data\"] = []);\n        });\n        d.isCartesian && (b.hasCartesianSeries = !0);\n        let g;\n        c.length && (g = c[c.length - 1]);\n        d._i = K(g && g._i, -1) + 1;\n        d.opacity = d.options.opacity;\n        b.orderSeries(this.insert(c));\n        a.dataSorting && a.dataSorting.enabled ? d.setDataSortingOptions() : d.points || d.data || d.setData(a.data, !1);\n        k(this, \"afterInit\");\n      }\n      is(b) {\n        return w[b] && this instanceof w[b];\n      }\n      insert(b) {\n        const a = this.options.index;\n        let d;\n        if (E(a)) {\n          for (d = b.length; d--;) if (a >= K(b[d].options.index, b[d]._i)) {\n            b.splice(d + 1, 0, this);\n            break;\n          }\n          -1 === d && b.unshift(this);\n          d += 1;\n        } else b.push(this);\n        return K(d, b.length - 1);\n      }\n      bindAxes() {\n        const a = this,\n          d = a.options,\n          c = a.chart;\n        let f;\n        k(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (e) {\n            let g = 0;\n            c[e].forEach(function (b) {\n              f = b.options;\n              if (d[e] === g && !f.isInternal || \"undefined\" !== typeof d[e] && d[e] === f.id || \"undefined\" === typeof d[e] && 0 === f.index) a.insert(b.series), a[e] = b, b.isDirty = !0;\n              f.isInternal || g++;\n            });\n            a[e] || a.optionalAxis === e || b(18, !0, c);\n          });\n        });\n        k(this, \"afterBindAxes\");\n      }\n      updateParallelArrays(b, a, d) {\n        const c = b.series,\n          f = E(a) ? function (d) {\n            const f = \"y\" === d && c.toYData ? c.toYData(b) : b[d];\n            c[d + \"Data\"][a] = f;\n          } : function (b) {\n            Array.prototype[a].apply(c[b + \"Data\"], d);\n          };\n        c.parallelArrays.forEach(f);\n      }\n      hasData() {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      }\n      autoIncrement(b) {\n        var a = this.options;\n        const d = a.pointIntervalUnit,\n          c = a.relativeXValue,\n          f = this.chart.time;\n        let e = this.xIncrement,\n          g;\n        e = K(e, a.pointStart, 0);\n        this.pointInterval = g = K(this.pointInterval, a.pointInterval, 1);\n        c && E(b) && (g *= b);\n        d && (a = new f.Date(e), \"day\" === d ? f.set(\"Date\", a, f.get(\"Date\", a) + g) : \"month\" === d ? f.set(\"Month\", a, f.get(\"Month\", a) + g) : \"year\" === d && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + g), g = a.getTime() - e);\n        if (c && E(b)) return e + g;\n        this.xIncrement = e + g;\n        return e;\n      }\n      setDataSortingOptions() {\n        const b = this.options;\n        f(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        p(b.pointRange) || (b.pointRange = 1);\n      }\n      setOptions(b) {\n        var a = this.chart,\n          d = a.options,\n          c = d.plotOptions,\n          f = a.userOptions || {};\n        b = T(b);\n        a = a.styledMode;\n        const e = {\n          plotOptions: c,\n          userOptions: b\n        };\n        k(this, \"setOptions\", e);\n        const g = e.plotOptions[this.type],\n          m = f.plotOptions || {};\n        this.userOptions = e.userOptions;\n        f = T(g, c.series, f.plotOptions && f.plotOptions[this.type], b);\n        this.tooltipOptions = T(r.tooltip, r.plotOptions.series && r.plotOptions.series.tooltip, r.plotOptions[this.type].tooltip, d.tooltip.userOptions, c.series && c.series.tooltip, c[this.type].tooltip, b.tooltip);\n        this.stickyTracking = K(b.stickyTracking, m[this.type] && m[this.type].stickyTracking, m.series && m.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);\n        null === g.marker && delete f.marker;\n        this.zoneAxis = f.zoneAxis;\n        c = this.zones = (f.zones || []).slice();\n        !f.negativeColor && !f.negativeFillColor || f.zones || (d = {\n          value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n          className: \"highcharts-negative\"\n        }, a || (d.color = f.negativeColor, d.fillColor = f.negativeFillColor), c.push(d));\n        c.length && p(c[c.length - 1].value) && c.push(a ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        k(this, \"afterSetOptions\", {\n          options: f\n        });\n        return f;\n      }\n      getName() {\n        return K(this.options.name, \"Series \" + (this.index + 1));\n      }\n      getCyclic(b, a, d) {\n        const c = this.chart,\n          f = this.userOptions,\n          e = b + \"Index\",\n          g = b + \"Counter\",\n          k = d ? d.length : K(c.options.chart[b + \"Count\"], c[b + \"Count\"]);\n        if (!a) {\n          var m = K(f[e], f[\"_\" + e]);\n          p(m) || (c.series.length || (c[g] = 0), f[\"_\" + e] = m = c[g] % k, c[g] += 1);\n          d && (a = d[m]);\n        }\n        \"undefined\" !== typeof m && (this[e] = m);\n        this[b] = a;\n      }\n      getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || r.plotOptions[this.type].color, this.chart.options.colors);\n      }\n      getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      }\n      getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      }\n      findPointIndex(b, a) {\n        const c = b.id,\n          f = b.x,\n          e = this.points;\n        var g = this.options.dataSorting,\n          k;\n        let m, h;\n        if (c) g = this.chart.get(c), g instanceof D && (k = g);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (k = a => !a.touched && a.index === b.index, g && g.matchByName ? k = a => !a.touched && a.name === b.name : this.options.relativeXValue && (k = a => !a.touched && a.options.x === b.x), k = d(e, k), !k) return;\n        k && (h = k && k.index, \"undefined\" !== typeof h && (m = !0));\n        \"undefined\" === typeof h && E(f) && (h = this.xData.indexOf(f, a));\n        -1 !== h && \"undefined\" !== typeof h && this.cropped && (h = h >= this.cropStart ? h - this.cropStart : h);\n        !m && E(h) && e[h] && e[h].touched && (h = void 0);\n        return h;\n      }\n      updateData(b, a) {\n        const d = this.options,\n          c = d.dataSorting,\n          f = this.points,\n          e = [],\n          g = this.requireSorting,\n          k = b.length === f.length;\n        let m,\n          h,\n          l,\n          n = !0;\n        this.xIncrement = null;\n        b.forEach(function (b, a) {\n          var h = p(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b) || {};\n          const n = h.x;\n          if (h.id || E(n)) {\n            if (h = this.findPointIndex(h, l), -1 === h || \"undefined\" === typeof h ? e.push(b) : f[h] && b !== d.data[h] ? (f[h].update(b, !1, null, !1), f[h].touched = !0, g && (l = h + 1)) : f[h] && (f[h].touched = !0), !k || a !== h || c && c.enabled || this.hasDerivedData) m = !0;\n          } else e.push(b);\n        }, this);\n        if (m) for (b = f.length; b--;) (h = f[b]) && !h.touched && h.remove && h.remove(!1, a);else !k || c && c.enabled ? n = !1 : (b.forEach(function (b, a) {\n          b === f[a].y || f[a].destroyed || f[a].update(b, !1, null, !1);\n        }), e.length = 0);\n        f.forEach(function (b) {\n          b && (b.touched = !1);\n        });\n        if (!n) return !1;\n        e.forEach(function (b) {\n          this.addPoint(b, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement());\n        return !0;\n      }\n      setData(a, d = !0, c, f) {\n        var e;\n        const g = this,\n          k = g.points,\n          m = k && k.length || 0,\n          h = g.options,\n          p = g.chart,\n          l = h.dataSorting,\n          n = g.xAxis,\n          r = h.turboThreshold,\n          q = this.xData,\n          u = this.yData;\n        var B = g.pointArrayMap;\n        B = B && B.length;\n        const w = h.keys;\n        let t,\n          I = 0,\n          v = 1,\n          x = null;\n        if (!p.options.chart.allowMutatingData) {\n          h.data && delete g.options.data;\n          g.userOptions.data && delete g.userOptions.data;\n          var P = T(!0, a);\n        }\n        a = P || a || [];\n        P = a.length;\n        l && l.enabled && (a = this.sortData(a));\n        p.options.chart.allowMutatingData && !1 !== f && P && m && !g.cropped && !g.hasGroupedData && g.visible && !g.boosted && (t = this.updateData(a, c));\n        if (!t) {\n          g.xIncrement = null;\n          g.colorCounter = 0;\n          this.parallelArrays.forEach(function (b) {\n            g[b + \"Data\"].length = 0;\n          });\n          if (r && P > r) {\n            if (x = g.getFirstValidPoint(a), E(x)) for (c = 0; c < P; c++) q[c] = this.autoIncrement(), u[c] = a[c];else if (N(x)) {\n              if (B) {\n                if (x.length === B) for (c = 0; c < P; c++) q[c] = this.autoIncrement(), u[c] = a[c];else for (c = 0; c < P; c++) f = a[c], q[c] = f[0], u[c] = f.slice(1, B + 1);\n              } else if (w && (I = w.indexOf(\"x\"), v = w.indexOf(\"y\"), I = 0 <= I ? I : 0, v = 0 <= v ? v : 1), 1 === x.length && (v = 0), I === v) for (c = 0; c < P; c++) q[c] = this.autoIncrement(), u[c] = a[c][v];else for (c = 0; c < P; c++) f = a[c], q[c] = f[I], u[c] = f[v];\n            } else b(12, !1, p);\n          } else for (c = 0; c < P; c++) f = {\n            series: g\n          }, g.pointClass.prototype.applyOptions.apply(f, [a[c]]), g.updateParallelArrays(f, c);\n          u && Z(u[0]) && b(14, !0, p);\n          g.data = [];\n          g.options.data = g.userOptions.data = a;\n          for (c = m; c--;) null === (e = k[c]) || void 0 === e ? void 0 : e.destroy();\n          n && (n.minRange = n.userMinRange);\n          g.isDirty = p.isDirtyBox = !0;\n          g.isDirtyData = !!k;\n          c = !1;\n        }\n        \"point\" === h.legendType && (this.processData(), this.generatePoints());\n        d && p.redraw(c);\n      }\n      sortData(b) {\n        const a = this,\n          d = a.options.dataSorting.sortKey || \"y\",\n          c = function (b, a) {\n            return p(a) && b.pointClass.prototype.optionsToObject.call({\n              series: b\n            }, a) || {};\n          };\n        b.forEach(function (d, f) {\n          b[f] = c(a, d);\n          b[f].index = f;\n        }, this);\n        b.concat().sort((b, a) => {\n          b = O(d, b);\n          a = O(d, a);\n          return a < b ? -1 : a > b ? 1 : 0;\n        }).forEach(function (b, a) {\n          b.x = a;\n        }, this);\n        a.linkedSeries && a.linkedSeries.forEach(function (a) {\n          const d = a.options,\n            f = d.data;\n          d.dataSorting && d.dataSorting.enabled || !f || (f.forEach(function (d, e) {\n            f[e] = c(a, d);\n            b[e] && (f[e].x = b[e].x, f[e].index = e);\n          }), a.setData(f, !1));\n        });\n        return b;\n      }\n      getProcessedData(a) {\n        var d = this.xAxis,\n          c = this.options,\n          f = c.cropThreshold;\n        const e = a || this.getExtremesFromAll || c.getExtremesFromAll,\n          g = this.isCartesian;\n        a = d && d.val2lin;\n        c = !(!d || !d.logarithmic);\n        let k = 0,\n          m;\n        let h,\n          p,\n          l = this.xData,\n          n = this.yData,\n          q = this.requireSorting;\n        var r = !1;\n        const u = l.length;\n        d && (r = d.getExtremes(), h = r.min, p = r.max, r = !(!d.categories || d.names.length));\n        if (g && this.sorted && !e && (!f || u > f || this.forceCrop)) if (l[u - 1] < h || l[0] > p) l = [], n = [];else if (this.yData && (l[0] < h || l[u - 1] > p)) {\n          var B = this.cropData(this.xData, this.yData, h, p);\n          l = B.xData;\n          n = B.yData;\n          k = B.start;\n          B = !0;\n        }\n        for (f = l.length || 1; --f;) d = c ? a(l[f]) - a(l[f - 1]) : l[f] - l[f - 1], 0 < d && (\"undefined\" === typeof m || d < m) ? m = d : 0 > d && q && !r && (b(15, !1, this.chart), q = !1);\n        return {\n          xData: l,\n          yData: n,\n          cropped: B,\n          cropStart: k,\n          closestPointRange: m\n        };\n      }\n      processData(b) {\n        const a = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;\n        b = this.getProcessedData();\n        this.cropped = b.cropped;\n        this.cropStart = b.cropStart;\n        this.processedXData = b.xData;\n        this.processedYData = b.yData;\n        this.closestPointRange = this.basePointRange = b.closestPointRange;\n        k(this, \"afterProcessData\");\n      }\n      cropData(b, a, d, c, f) {\n        const e = b.length;\n        let g,\n          k = 0,\n          m = e;\n        f = K(f, this.cropShoulder);\n        for (g = 0; g < e; g++) if (b[g] >= d) {\n          k = Math.max(0, g - f);\n          break;\n        }\n        for (d = g; d < e; d++) if (b[d] > c) {\n          m = d + f;\n          break;\n        }\n        return {\n          xData: b.slice(k, m),\n          yData: a.slice(k, m),\n          start: k,\n          end: m\n        };\n      }\n      generatePoints() {\n        var b = this.options;\n        const a = this.processedData || b.data,\n          d = this.processedXData,\n          c = this.processedYData,\n          e = this.pointClass,\n          g = d.length,\n          m = this.cropStart || 0,\n          h = this.hasGroupedData,\n          p = b.keys,\n          l = [];\n        b = b.dataGrouping && b.dataGrouping.groupAll ? m : 0;\n        let n;\n        let r,\n          q,\n          u = this.data;\n        if (!u && !h) {\n          var w = [];\n          w.length = a.length;\n          u = this.data = w;\n        }\n        p && h && (this.options.keys = !1);\n        for (q = 0; q < g; q++) w = m + q, h ? (r = new e().init(this, [d[q]].concat(M(c[q]))), r.dataGroup = this.groupMap[b + q], r.dataGroup.options && (r.options = r.dataGroup.options, f(r, r.dataGroup.options), delete r.dataLabels)) : (r = u[w]) || \"undefined\" === typeof a[w] || (u[w] = r = new e().init(this, a[w], d[q])), r && (r.index = h ? b + q : w, l[q] = r);\n        this.options.keys = p;\n        if (u && (g !== (n = u.length) || h)) for (q = 0; q < n; q++) q !== m || h || (q += g), u[q] && (u[q].destroyElements(), u[q].plotX = void 0);\n        this.data = u;\n        this.points = l;\n        k(this, \"afterGeneratePoints\");\n      }\n      getXExtremes(b) {\n        return {\n          min: F(b),\n          max: x(b)\n        };\n      }\n      getExtremes(b, a) {\n        const d = this.xAxis;\n        var c = this.yAxis;\n        const f = this.processedXData || this.xData,\n          e = [],\n          g = this.requireSorting ? this.cropShoulder : 0;\n        c = c ? c.positiveValuesOnly : !1;\n        let m,\n          h = 0,\n          p = 0,\n          l = 0;\n        b = b || this.stackedYData || this.processedYData || [];\n        const n = b.length;\n        if (d) {\n          var q = d.getExtremes();\n          h = q.min;\n          p = q.max;\n        }\n        for (m = 0; m < n; m++) {\n          var r = f[m];\n          q = b[m];\n          var u = (E(q) || N(q)) && (q.length || 0 < q || !c);\n          r = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !d || (f[m + g] || r) >= h && (f[m - g] || r) <= p;\n          if (u && r) if (u = q.length) for (; u--;) E(q[u]) && (e[l++] = q[u]);else e[l++] = q;\n        }\n        b = {\n          activeYData: e,\n          dataMin: F(e),\n          dataMax: x(e)\n        };\n        k(this, \"afterGetExtremes\", {\n          dataExtremes: b\n        });\n        return b;\n      }\n      applyExtremes() {\n        const b = this.getExtremes();\n        this.dataMin = b.dataMin;\n        this.dataMax = b.dataMax;\n        return b;\n      }\n      getFirstValidPoint(b) {\n        const a = b.length;\n        let d = 0,\n          c = null;\n        for (; null === c && d < a;) c = b[d], d++;\n        return c;\n      }\n      translate() {\n        var b;\n        this.processedXData || this.processData();\n        this.generatePoints();\n        const a = this.options,\n          d = a.stacking,\n          c = this.xAxis,\n          f = c.categories,\n          g = this.enabledDataSorting,\n          m = this.yAxis,\n          h = this.points,\n          l = h.length,\n          n = this.pointPlacementToXValue(),\n          q = !!n,\n          r = a.threshold,\n          w = a.startFromThreshold ? r : 0,\n          t = this.zoneAxis || \"y\";\n        let v,\n          x,\n          J,\n          F,\n          H = Number.MAX_VALUE;\n        for (v = 0; v < l; v++) {\n          const k = h[v],\n            l = k.x;\n          let B,\n            I,\n            P = k.y,\n            O = k.low;\n          const z = d && (null === (b = m.stacking) || void 0 === b ? void 0 : b.stacks[(this.negStacks && P < (w ? 0 : r) ? \"-\" : \"\") + this.stackKey]);\n          x = c.translate(l, !1, !1, !1, !0, n);\n          k.plotX = E(x) ? u(e(x, -1E5, 1E5)) : void 0;\n          d && this.visible && z && z[l] && (F = this.getStackIndicator(F, l, this.index), !k.isNull && F.key && (B = z[l], I = B.points[F.key]), B && N(I) && (O = I[0], P = I[1], O === w && F.key === z[l].base && (O = K(E(r) ? r : m.min)), m.positiveValuesOnly && p(O) && 0 >= O && (O = void 0), k.total = k.stackTotal = K(B.total), k.percentage = p(k.y) && B.total ? k.y / B.total * 100 : void 0, k.stackY = P, this.irregularWidths || B.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));\n          k.yBottom = p(O) ? e(m.translate(O, !1, !0, !1, !0), -1E5, 1E5) : void 0;\n          this.dataModify && (P = this.dataModify.modifyValue(P, v));\n          let y;\n          E(P) && void 0 !== k.plotX && (y = m.translate(P, !1, !0, !1, !0), y = E(y) ? e(y, -1E5, 1E5) : void 0);\n          k.plotY = y;\n          k.isInside = this.isPointInside(k);\n          k.clientX = q ? u(c.translate(l, !1, !1, !1, !0, n)) : x;\n          k.negative = k[t] < (a[t + \"Threshold\"] || r || 0);\n          k.category = K(f && f[k.x], k.x);\n          k.isNull || !1 === k.visible || (\"undefined\" !== typeof J && (H = Math.min(H, Math.abs(x - J))), J = x);\n          k.zone = this.zones.length ? k.getZone() : void 0;\n          !k.graphic && this.group && g && (k.isNew = !0);\n        }\n        this.closestPointRangePx = H;\n        k(this, \"afterTranslate\");\n      }\n      getValidPoints(b, a, d) {\n        const c = this.chart;\n        return (b || this.points || []).filter(function (b) {\n          const {\n            plotX: f,\n            plotY: e\n          } = b;\n          return !d && (b.isNull || !E(e)) || a && !c.isInsidePlot(f, e, {\n            inverted: c.inverted\n          }) ? !1 : !1 !== b.visible;\n        });\n      }\n      getClipBox() {\n        const {\n            chart: b,\n            xAxis: a,\n            yAxis: d\n          } = this,\n          c = T(b.clipBox);\n        a && a.len !== b.plotSizeX && (c.width = a.len);\n        d && d.len !== b.plotSizeY && (c.height = d.len);\n        return c;\n      }\n      getSharedClipKey() {\n        return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0);\n      }\n      setClip() {\n        const {\n            chart: b,\n            group: a,\n            markerGroup: d\n          } = this,\n          c = b.sharedClips,\n          f = b.renderer,\n          e = this.getClipBox(),\n          g = this.getSharedClipKey();\n        let k = c[g];\n        k ? k.animate(e) : c[g] = k = f.clipRect(e);\n        a && a.clip(!1 === this.options.clip ? void 0 : k);\n        d && d.clip();\n      }\n      animate(b) {\n        const {\n            chart: a,\n            group: d,\n            markerGroup: f\n          } = this,\n          e = a.inverted;\n        var g = c(this.options.animation),\n          k = [this.getSharedClipKey(), g.duration, g.easing, g.defer].join();\n        let m = a.sharedClips[k],\n          h = a.sharedClips[k + \"m\"];\n        if (b && d) g = this.getClipBox(), m ? m.attr(\"height\", g.height) : (g.width = 0, e && (g.x = a.plotHeight), m = a.renderer.clipRect(g), a.sharedClips[k] = m, h = a.renderer.clipRect({\n          x: -99,\n          y: -99,\n          width: e ? a.plotWidth + 199 : 99,\n          height: e ? 99 : a.plotHeight + 199\n        }), a.sharedClips[k + \"m\"] = h), d.clip(m), f && f.clip(h);else if (m && !m.hasClass(\"highcharts-animating\")) {\n          k = this.getClipBox();\n          const b = g.step;\n          f && f.element.childNodes.length && (g.step = function (a, d) {\n            b && b.apply(d, arguments);\n            \"width\" === d.prop && h && h.element && h.attr(e ? \"height\" : \"width\", a + 99);\n          });\n          m.addClass(\"highcharts-animating\").animate(k, g);\n        }\n      }\n      afterAnimate() {\n        this.setClip();\n        U(this.chart.sharedClips, (b, a, d) => {\n          b && !this.chart.container.querySelector(`[clip-path=\"url(#${b.id})\"]`) && (b.destroy(), delete d[a]);\n        });\n        this.finishedAnimating = !0;\n        k(this, \"afterAnimate\");\n      }\n      drawPoints(b = this.points) {\n        const a = this.chart,\n          d = a.styledMode,\n          {\n            colorAxis: c,\n            options: f\n          } = this,\n          e = f.marker,\n          g = this[this.specialGroup || \"markerGroup\"],\n          k = this.xAxis,\n          m = K(e.enabled, !k || k.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);\n        let h, p, l, n;\n        let q, r;\n        if (!1 !== e.enabled || this._hasPointMarkers) for (h = 0; h < b.length; h++) {\n          p = b[h];\n          n = (l = p.graphic) ? \"animate\" : \"attr\";\n          var u = p.marker || {};\n          q = !!p.marker;\n          if ((m && \"undefined\" === typeof u.enabled || u.enabled) && !p.isNull && !1 !== p.visible) {\n            const b = K(u.symbol, this.symbol, \"rect\");\n            r = this.markerAttribs(p, p.selected && \"select\");\n            this.enabledDataSorting && (p.startXPos = k.reversed ? -(r.width || 0) : k.width);\n            const f = !1 !== p.isInside;\n            !l && f && (0 < (r.width || 0) || p.hasImage) && (p.graphic = l = a.renderer.symbol(b, r.x, r.y, r.width, r.height, q ? u : e).add(g), this.enabledDataSorting && a.hasRendered && (l.attr({\n              x: p.startXPos\n            }), n = \"animate\"));\n            l && \"animate\" === n && l[f ? \"show\" : \"hide\"](f).animate(r);\n            if (l) if (u = this.pointAttribs(p, d || !p.selected ? void 0 : \"select\"), d) c && l.css({\n              fill: u.fill\n            });else l[n](u);\n            l && l.addClass(p.getClassName(), !0);\n          } else l && (p.graphic = l.destroy());\n        }\n      }\n      markerAttribs(b, a) {\n        const d = this.options;\n        var c = d.marker;\n        const f = b.marker || {},\n          e = f.symbol || c.symbol,\n          g = {};\n        let k = K(f.radius, c && c.radius);\n        a && (c = c.states[a], a = f.states && f.states[a], k = K(a && a.radius, c && c.radius, k && k + (c && c.radiusPlus || 0)));\n        b.hasImage = e && 0 === e.indexOf(\"url\");\n        b.hasImage && (k = 0);\n        b = b.pos();\n        E(k) && b && (g.x = b[0] - k, g.y = b[1] - k, d.crisp && (g.x = Math.floor(g.x)));\n        k && (g.width = g.height = 2 * k);\n        return g;\n      }\n      pointAttribs(b, a) {\n        var d = this.options.marker,\n          c = b && b.options;\n        const f = c && c.marker || {};\n        var e = c && c.color,\n          g = b && b.color;\n        const k = b && b.zone && b.zone.color;\n        let m = this.color;\n        b = K(f.lineWidth, d.lineWidth);\n        c = 1;\n        m = e || k || g || m;\n        e = f.fillColor || d.fillColor || m;\n        g = f.lineColor || d.lineColor || m;\n        a = a || \"normal\";\n        d = d.states[a] || {};\n        a = f.states && f.states[a] || {};\n        b = K(a.lineWidth, d.lineWidth, b + K(a.lineWidthPlus, d.lineWidthPlus, 0));\n        e = a.fillColor || d.fillColor || e;\n        g = a.lineColor || d.lineColor || g;\n        c = K(a.opacity, d.opacity, c);\n        return {\n          stroke: g,\n          \"stroke-width\": b,\n          fill: e,\n          opacity: c\n        };\n      }\n      destroy(b) {\n        const a = this,\n          d = a.chart,\n          c = /AppleWebKit\\/533/.test(g.navigator.userAgent),\n          f = a.data || [];\n        let e, m, h, p;\n        k(a, \"destroy\", {\n          keepEventsForUpdate: b\n        });\n        this.removeEvents(b);\n        (a.axisTypes || []).forEach(function (b) {\n          (p = a[b]) && p.series && (H(p.series, a), p.isDirty = p.forceRedraw = !0);\n        });\n        a.legendItem && a.chart.legend.destroyItem(a);\n        for (m = f.length; m--;) (h = f[m]) && h.destroy && h.destroy();\n        a.clips && a.clips.forEach(b => b.destroy());\n        v.clearTimeout(a.animationTimeout);\n        U(a, function (b, a) {\n          b instanceof t && !b.survive && (e = c && \"group\" === a ? \"hide\" : \"destroy\", b[e]());\n        });\n        d.hoverSeries === a && (d.hoverSeries = void 0);\n        H(d.series, a);\n        d.orderSeries();\n        U(a, function (d, c) {\n          b && \"hcEvents\" === c || delete a[c];\n        });\n      }\n      applyZones() {\n        const b = this,\n          a = this.chart,\n          d = a.renderer,\n          c = this.zones,\n          f = this.clips || [],\n          g = this.graph,\n          k = this.area,\n          m = Math.max(a.plotWidth, a.plotHeight),\n          h = this[(this.zoneAxis || \"y\") + \"Axis\"],\n          p = a.inverted;\n        let l,\n          n,\n          r,\n          q,\n          u,\n          w,\n          t,\n          v,\n          x,\n          J,\n          E,\n          F = !1;\n        c.length && (g || k) && h && \"undefined\" !== typeof h.min ? (u = h.reversed, w = h.horiz, g && !this.showLine && g.hide(), k && k.hide(), q = h.getExtremes(), c.forEach(function (c, B) {\n          l = u ? w ? a.plotWidth : 0 : w ? 0 : h.toPixels(q.min) || 0;\n          l = e(K(n, l), 0, m);\n          n = e(Math.round(h.toPixels(K(c.value, q.max), !0) || 0), 0, m);\n          F && (l = n = h.toPixels(q.max));\n          t = Math.abs(l - n);\n          v = Math.min(l, n);\n          x = Math.max(l, n);\n          h.isXAxis ? (r = {\n            x: p ? x : v,\n            y: 0,\n            width: t,\n            height: m\n          }, w || (r.x = a.plotHeight - r.x)) : (r = {\n            x: 0,\n            y: p ? x : v,\n            width: m,\n            height: t\n          }, w && (r.y = a.plotWidth - r.y));\n          f[B] ? f[B].animate(r) : f[B] = d.clipRect(r);\n          J = b[\"zone-area-\" + B];\n          E = b[\"zone-graph-\" + B];\n          g && E && E.clip(f[B]);\n          k && J && J.clip(f[B]);\n          F = c.value > q.max;\n          b.resetZones && 0 === n && (n = void 0);\n        }), this.clips = f) : b.visible && (g && g.show(), k && k.show());\n      }\n      plotGroup(b, a, d, c, f) {\n        let e = this[b];\n        const g = !e;\n        d = {\n          visibility: d,\n          zIndex: c || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (d.opacity = this.opacity);\n        g && (this[b] = e = this.chart.renderer.g().add(f));\n        e.addClass(\"highcharts-\" + a + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (p(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        e.attr(d)[g ? \"attr\" : \"animate\"](this.getPlotBox(a));\n        return e;\n      }\n      getPlotBox(b) {\n        let a = this.xAxis,\n          d = this.yAxis;\n        const c = this.chart;\n        b = c.inverted && !c.polar && a && !1 !== this.invertible && \"series\" === b;\n        c.inverted && (a = d, d = this.xAxis);\n        return {\n          translateX: a ? a.left : c.plotLeft,\n          translateY: d ? d.top : c.plotTop,\n          rotation: b ? 90 : 0,\n          rotationOriginX: b ? (a.len - d.len) / 2 : 0,\n          rotationOriginY: b ? (a.len + d.len) / 2 : 0,\n          scaleX: b ? -1 : 1,\n          scaleY: 1\n        };\n      }\n      removeEvents(b) {\n        b || Q(this);\n        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {\n          b();\n        }), this.eventsToUnbind.length = 0);\n      }\n      render() {\n        const b = this;\n        var a = b.chart;\n        const d = b.options,\n          f = c(d.animation),\n          e = b.visible ? \"inherit\" : \"hidden\",\n          g = d.zIndex,\n          m = b.hasRendered;\n        a = a.seriesGroup;\n        let h = b.finishedAnimating ? 0 : f.duration;\n        k(this, \"render\");\n        b.plotGroup(\"group\", \"series\", e, g, a);\n        b.markerGroup = b.plotGroup(\"markerGroup\", \"markers\", e, g, a);\n        !1 !== d.clip && b.setClip();\n        b.animate && h && b.animate(!0);\n        b.drawGraph && (b.drawGraph(), b.applyZones());\n        b.visible && b.drawPoints();\n        b.drawDataLabels && b.drawDataLabels();\n        b.redrawPoints && b.redrawPoints();\n        b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();\n        b.animate && h && b.animate();\n        m || (h && f.defer && (h += f.defer), b.animationTimeout = fa(function () {\n          b.afterAnimate();\n        }, h || 0));\n        b.isDirty = !1;\n        b.hasRendered = !0;\n        k(b, \"afterRender\");\n      }\n      redraw() {\n        const b = this.isDirty || this.isDirtyData;\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      }\n      searchPoint(b, a) {\n        const d = this.xAxis,\n          c = this.yAxis,\n          f = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: f ? d.len - b.chartY + d.pos : b.chartX - d.pos,\n          plotY: f ? c.len - b.chartX + c.pos : b.chartY - c.pos\n        }, a, b);\n      }\n      buildKDTree(b) {\n        function a(b, c, f) {\n          var e = b && b.length;\n          let g;\n          if (e) return g = d.kdAxisArray[c % f], b.sort(function (b, a) {\n            return b[g] - a[g];\n          }), e = Math.floor(e / 2), {\n            point: b[e],\n            left: a(b.slice(0, e), c + 1, f),\n            right: a(b.slice(e + 1), c + 1, f)\n          };\n        }\n        this.buildingKdTree = !0;\n        const d = this,\n          c = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete d.kdTree;\n        fa(function () {\n          d.kdTree = a(d.getValidPoints(null, !d.directTouch), c, c);\n          d.buildingKdTree = !1;\n        }, d.options.kdNow || b && \"touchstart\" === b.type ? 0 : 1);\n      }\n      searchKDTree(b, a, d) {\n        function c(b, a, d, m) {\n          const h = a.point;\n          var l = f.kdAxisArray[d % m];\n          let n = h;\n          var r = p(b[e]) && p(h[e]) ? Math.pow(b[e] - h[e], 2) : null;\n          var q = p(b[g]) && p(h[g]) ? Math.pow(b[g] - h[g], 2) : null;\n          q = (r || 0) + (q || 0);\n          h.dist = p(q) ? Math.sqrt(q) : Number.MAX_VALUE;\n          h.distX = p(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n          l = b[l] - h[l];\n          q = 0 > l ? \"left\" : \"right\";\n          r = 0 > l ? \"right\" : \"left\";\n          a[q] && (q = c(b, a[q], d + 1, m), n = q[k] < n[k] ? q : h);\n          a[r] && Math.sqrt(l * l) < n[k] && (b = c(b, a[r], d + 1, m), n = b[k] < n[k] ? b : n);\n          return n;\n        }\n        const f = this,\n          e = this.kdAxisArray[0],\n          g = this.kdAxisArray[1],\n          k = a ? \"distX\" : \"dist\";\n        a = -1 < f.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(d);\n        if (this.kdTree) return c(b, this.kdTree, a, a);\n      }\n      pointPlacementToXValue() {\n        const {\n          options: {\n            pointPlacement: b,\n            pointRange: a\n          },\n          xAxis: d\n        } = this;\n        let c = b;\n        \"between\" === c && (c = d.reversed ? -.5 : .5);\n        return E(c) ? c * (a || d.pointRange) : 0;\n      }\n      isPointInside(b) {\n        const {\n          chart: a,\n          xAxis: d,\n          yAxis: c\n        } = this;\n        return \"undefined\" !== typeof b.plotY && \"undefined\" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (c ? c.len : a.plotHeight) && 0 <= b.plotX && b.plotX <= (d ? d.len : a.plotWidth);\n      }\n      drawTracker() {\n        const b = this,\n          a = b.options,\n          d = a.trackByArea,\n          c = [].concat(d ? b.areaPath : b.graphPath),\n          f = b.chart,\n          e = f.pointer,\n          g = f.renderer,\n          m = f.options.tooltip.snap,\n          p = b.tracker,\n          l = function (a) {\n            if (f.hoverSeries !== b) b.onMouseOver();\n          },\n          n = \"rgba(192,192,192,\" + (q ? .0001 : .002) + \")\";\n        p ? p.attr({\n          d: c\n        }) : b.graph && (b.tracker = g.path(c).attr({\n          visibility: b.visible ? \"inherit\" : \"hidden\",\n          zIndex: 2\n        }).addClass(d ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(b.group), f.styledMode || b.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: n,\n          fill: d ? n : \"none\",\n          \"stroke-width\": b.graph.strokeWidth() + (d ? 0 : 2 * m)\n        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {\n          if (b && (b.addClass(\"highcharts-tracker\").on(\"mouseover\", l).on(\"mouseout\", function (b) {\n            e.onTrackerMouseOut(b);\n          }), a.cursor && !f.styledMode && b.css({\n            cursor: a.cursor\n          }), h)) b.on(\"touchstart\", l);\n        }));\n        k(this, \"afterDrawTracker\");\n      }\n      addPoint(b, a, d, c, f) {\n        const e = this.options,\n          g = this.data,\n          m = this.chart;\n        var h = this.xAxis;\n        h = h && h.hasNames && h.names;\n        const p = e.data,\n          l = this.xData;\n        let n, q;\n        a = K(a, !0);\n        const r = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(r, [b]);\n        const u = r.x;\n        q = l.length;\n        if (this.requireSorting && u < l[q - 1]) for (n = !0; q && l[q - 1] > u;) q--;\n        this.updateParallelArrays(r, \"splice\", [q, 0, 0]);\n        this.updateParallelArrays(r, q);\n        h && r.name && (h[u] = r.name);\n        p.splice(q, 0, b);\n        if (n || this.processedData) this.data.splice(q, 0, null), this.processData();\n        \"point\" === e.legendType && this.generatePoints();\n        d && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(r, \"shift\"), p.shift()));\n        !1 !== f && k(this, \"addPoint\", {\n          point: r\n        });\n        this.isDirtyData = this.isDirty = !0;\n        a && m.redraw(c);\n      }\n      removePoint(b, a, d) {\n        const c = this,\n          f = c.data,\n          e = f[b],\n          g = c.points,\n          k = c.chart,\n          m = function () {\n            g && g.length === f.length && g.splice(b, 1);\n            f.splice(b, 1);\n            c.options.data.splice(b, 1);\n            c.updateParallelArrays(e || {\n              series: c\n            }, \"splice\", [b, 1]);\n            e && e.destroy();\n            c.isDirty = !0;\n            c.isDirtyData = !0;\n            a && k.redraw();\n          };\n        n(d, k);\n        a = K(a, !0);\n        e ? e.firePointEvent(\"remove\", null, m) : m();\n      }\n      remove(b, a, d, c) {\n        function f() {\n          e.destroy(c);\n          g.isDirtyLegend = g.isDirtyBox = !0;\n          g.linkSeries(c);\n          K(b, !0) && g.redraw(a);\n        }\n        const e = this,\n          g = e.chart;\n        !1 !== d ? k(e, \"remove\", null, f) : f();\n      }\n      update(a, d) {\n        a = m(a, this.userOptions);\n        k(this, \"update\", {\n          options: a\n        });\n        const c = this,\n          e = c.chart;\n        var g = c.userOptions;\n        const h = c.initialType || c.type;\n        var p = e.options.plotOptions;\n        const l = w[h].prototype;\n        var n = c.finishedAnimating && {\n          animation: !1\n        };\n        const q = {};\n        let r,\n          u = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n          t = a.type || g.type || e.options.chart.type;\n        const v = !(this.hasDerivedData || t && t !== this.type || \"undefined\" !== typeof a.pointStart || \"undefined\" !== typeof a.pointInterval || \"undefined\" !== typeof a.relativeXValue || a.joinBy || a.mapData || c.hasOptionChanged(\"dataGrouping\") || c.hasOptionChanged(\"pointStart\") || c.hasOptionChanged(\"pointInterval\") || c.hasOptionChanged(\"pointIntervalUnit\") || c.hasOptionChanged(\"keys\"));\n        t = t || h;\n        v && (u.push(\"data\", \"isDirtyData\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"clips\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && u.push(\"area\", \"graph\"), c.parallelArrays.forEach(function (b) {\n          u.push(b + \"Data\");\n        }), a.data && (a.dataSorting && f(c.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n        a = T(g, n, {\n          index: \"undefined\" === typeof g.index ? c.index : g.index,\n          pointStart: K(p && p.series && p.series.pointStart, g.pointStart, c.xData[0])\n        }, !v && {\n          data: c.options.data\n        }, a);\n        v && a.data && (a.data = c.options.data);\n        u = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(u);\n        u.forEach(function (b) {\n          u[b] = c[b];\n          delete c[b];\n        });\n        p = !1;\n        if (w[t]) {\n          if (p = t !== c.type, c.remove(!1, !1, !1, !0), p) if (Object.setPrototypeOf) Object.setPrototypeOf(c, w[t].prototype);else {\n            n = Object.hasOwnProperty.call(c, \"hcEvents\") && c.hcEvents;\n            for (r in l) c[r] = void 0;\n            f(c, w[t].prototype);\n            n ? c.hcEvents = n : delete c.hcEvents;\n          }\n        } else b(17, !0, e, {\n          missingModuleFor: t\n        });\n        u.forEach(function (b) {\n          c[b] = u[b];\n        });\n        c.init(e, a);\n        if (v && this.points) {\n          a = c.options;\n          if (!1 === a.visible) q.graphic = 1, q.dataLabel = 1;else if (!c._hasPointLabels) {\n            const {\n              marker: b,\n              dataLabels: d\n            } = a;\n            g = g.marker || {};\n            !b || !1 !== b.enabled && g.symbol === b.symbol && g.height === b.height && g.width === b.width || (q.graphic = 1);\n            d && !1 === d.enabled && (q.dataLabel = 1);\n          }\n          for (const b of this.points) b && b.series && (b.resolveColor(), Object.keys(q).length && b.destroyElements(q), !1 === a.showInLegend && b.legendItem && e.legend.destroyItem(b));\n        }\n        c.initialType = h;\n        e.linkSeries();\n        p && c.linkedSeries.length && (c.isDirtyData = !0);\n        k(this, \"afterUpdate\");\n        K(d, !0) && e.redraw(v ? void 0 : !1);\n      }\n      setName(b) {\n        this.name = this.options.name = this.userOptions.name = b;\n        this.chart.isDirtyLegend = !0;\n      }\n      hasOptionChanged(b) {\n        const a = this.options[b],\n          d = this.chart.options.plotOptions,\n          c = this.userOptions[b];\n        return c ? a !== c : a !== K(d && d[this.type] && d[this.type][b], d && d.series && d.series[b], a);\n      }\n      onMouseOver() {\n        const b = this.chart,\n          a = b.hoverSeries;\n        b.pointer.setHoverChartIndex();\n        if (a && a !== this) a.onMouseOut();\n        this.options.events.mouseOver && k(this, \"mouseOver\");\n        this.setState(\"hover\");\n        b.hoverSeries = this;\n      }\n      onMouseOut() {\n        const b = this.options,\n          a = this.chart,\n          d = a.tooltip,\n          c = a.hoverPoint;\n        a.hoverSeries = null;\n        if (c) c.onMouseOut();\n        this && b.events.mouseOut && k(this, \"mouseOut\");\n        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();\n        a.series.forEach(function (b) {\n          b.setState(\"\", !0);\n        });\n      }\n      setState(b, a) {\n        const d = this;\n        var c = d.options;\n        const f = d.graph,\n          e = c.inactiveOtherPoints,\n          g = c.states,\n          k = K(g[b || \"normal\"] && g[b || \"normal\"].animation, d.chart.options.chart.animation);\n        let m = c.lineWidth,\n          h = 0,\n          p = c.opacity;\n        b = b || \"\";\n        if (d.state !== b && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (a) {\n          a && (d.state && a.removeClass(\"highcharts-series-\" + d.state), b && a.addClass(\"highcharts-series-\" + b));\n        }), d.state = b, !d.chart.styledMode)) {\n          if (g[b] && !1 === g[b].enabled) return;\n          b && (m = g[b].lineWidth || m + (g[b].lineWidthPlus || 0), p = K(g[b].opacity, p));\n          if (f && !f.dashstyle && E(m)) for (c = {\n            \"stroke-width\": m\n          }, f.animate(c, k); d[\"zone-graph-\" + h];) d[\"zone-graph-\" + h].animate(c, k), h += 1;\n          e || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (b) {\n            b && b.animate({\n              opacity: p\n            }, k);\n          });\n        }\n        a && e && d.points && d.setAllPointsToState(b || void 0);\n      }\n      setAllPointsToState(b) {\n        this.points.forEach(function (a) {\n          a.setState && a.setState(b);\n        });\n      }\n      setVisible(b, a) {\n        const d = this,\n          c = d.chart,\n          f = c.options.chart.ignoreHiddenSeries,\n          e = d.visible,\n          g = (d.visible = b = d.options.visible = d.userOptions.visible = \"undefined\" === typeof b ? !e : b) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (b) {\n          if (d[b]) d[b][g]();\n        });\n        if (c.hoverSeries === d || (c.hoverPoint && c.hoverPoint.series) === d) d.onMouseOut();\n        d.legendItem && c.legend.colorizeItem(d, b);\n        d.isDirty = !0;\n        d.options.stacking && c.series.forEach(function (b) {\n          b.options.stacking && b.visible && (b.isDirty = !0);\n        });\n        d.linkedSeries.forEach(function (a) {\n          a.setVisible(b, !1);\n        });\n        f && (c.isDirtyBox = !0);\n        k(d, g);\n        !1 !== a && c.redraw();\n      }\n      show() {\n        this.setVisible(!0);\n      }\n      hide() {\n        this.setVisible(!1);\n      }\n      select(b) {\n        this.selected = b = this.options.selected = \"undefined\" === typeof b ? !this.selected : b;\n        this.checkbox && (this.checkbox.checked = b);\n        k(this, b ? \"select\" : \"unselect\");\n      }\n      shouldShowTooltip(b, a, d = {}) {\n        d.series = this;\n        d.visiblePlotOnly = !0;\n        return this.chart.isInsidePlot(b, a, d);\n      }\n      drawLegendSymbol(b, a) {\n        var d;\n        null === (d = A[this.options.legendSymbol || \"rectangle\"]) || void 0 === d ? void 0 : d.call(this, b, a);\n      }\n    }\n    Y.defaultOptions = C;\n    Y.types = z.seriesTypes;\n    Y.registerType = z.registerSeriesType;\n    f(Y.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: D,\n      requireSorting: !0,\n      sorted: !0\n    });\n    z.series = Y;\n    \"\";\n    \"\";\n    return Y;\n  });\n  M(a, \"Extensions/ScrollablePlotArea.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D) {\n    const {\n        stop: x\n      } = a,\n      {\n        addEvent: z,\n        createElement: t,\n        defined: v,\n        merge: c,\n        pick: n\n      } = D;\n    z(G, \"afterSetChartSize\", function (a) {\n      var l = this.options.chart.scrollablePlotArea,\n        h = l && l.minWidth;\n      l = l && l.minHeight;\n      let n;\n      if (!this.renderer.forExport) {\n        if (h) {\n          if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth)) this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.width = this.plotWidth += h, this.inverted ? this.clipBox.height += h : this.clipBox.width += h, n = {\n            1: {\n              name: \"right\",\n              value: h\n            }\n          };\n        } else l && (this.scrollablePixelsY = h = Math.max(0, l - this.chartHeight), v(h) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = c(this.plotBox), this.plotBox.height = this.plotHeight += h, this.inverted ? this.clipBox.width += h : this.clipBox.height += h, n = {\n          2: {\n            name: \"bottom\",\n            value: h\n          }\n        }));\n        n && !a.skipAxes && this.axes.forEach(function (a) {\n          n[a.side] ? a.getPlotLinePath = function () {\n            let c = n[a.side].name,\n              g = this[c],\n              h;\n            this[c] = g - n[a.side].value;\n            h = y.prototype.getPlotLinePath.apply(this, arguments);\n            this[c] = g;\n            return h;\n          } : (a.setAxisSize(), a.setAxisTranslation());\n        });\n      }\n    });\n    z(G, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n    G.prototype.setUpScrolling = function () {\n      const a = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (a.overflowX = \"auto\");\n      this.scrollablePixelsY && (a.overflowY = \"auto\");\n      this.scrollingParent = t(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = t(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, a, this.scrollingParent);\n      let c;\n      z(this.scrollingContainer, \"scroll\", () => {\n        this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (c = this.hoverPoint), this.pointer.runPointActions(void 0, c, !0));\n      });\n      this.innerContainer = t(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n    G.prototype.moveFixedElements = function () {\n      let a = this.container,\n        c = this.fixedRenderer,\n        h = \".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n        n;\n      this.scrollablePixelsX && !this.inverted ? n = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? n = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? n = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (n = \".highcharts-yaxis\");\n      n && h.push(`${n}:not(.highcharts-radial-axis)`, `${n}-labels:not(.highcharts-radial-axis-labels)`);\n      h.forEach(function (g) {\n        [].forEach.call(a.querySelectorAll(g), function (a) {\n          (a.namespaceURI === c.SVG_NS ? c.box : c.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n    G.prototype.applyFixed = function () {\n      var a = !this.fixedDiv,\n        c = this.options.chart,\n        h = c.scrollablePlotArea,\n        q = A.getRendererType();\n      a ? (this.fixedDiv = t(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (c.style && c.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = c = new q(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = c.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": n(h.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), z(this, \"afterShowResetZoom\", this.moveFixedElements), z(this, \"afterApplyDrilldown\", this.moveFixedElements), z(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();\n      c = this.chartWidth + (this.scrollablePixelsX || 0);\n      q = this.chartHeight + (this.scrollablePixelsY || 0);\n      x(this.container);\n      this.container.style.width = c + \"px\";\n      this.container.style.height = q + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: c,\n        height: q,\n        viewBox: [0, 0, c, q].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: c,\n        height: q\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      a && (h.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * h.scrollPositionX), h.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * h.scrollPositionY));\n      q = this.axisOffset;\n      a = this.plotTop - q[0] - 1;\n      h = this.plotLeft - q[3] - 1;\n      c = this.plotTop + this.plotHeight + q[2] + 1;\n      q = this.plotLeft + this.plotWidth + q[1] + 1;\n      let g = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n        w = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      a = this.scrollablePixelsX ? [[\"M\", 0, a], [\"L\", this.plotLeft - 1, a], [\"L\", this.plotLeft - 1, c], [\"L\", 0, c], [\"Z\"], [\"M\", g, a], [\"L\", this.chartWidth, a], [\"L\", this.chartWidth, c], [\"L\", g, c], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", h, 0], [\"L\", h, this.plotTop - 1], [\"L\", q, this.plotTop - 1], [\"L\", q, 0], [\"Z\"], [\"M\", h, w], [\"L\", h, this.chartHeight], [\"L\", q, this.chartHeight], [\"L\", q, w], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: a\n      });\n    };\n    z(y, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    z(L, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    \"\";\n  });\n  M(a, \"Core/Axis/Stacking/StackItem.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        format: x\n      } = a,\n      {\n        series: A\n      } = y,\n      {\n        destroyObjectProperties: D,\n        fireEvent: C,\n        isNumber: z,\n        pick: t\n      } = G;\n    class v {\n      constructor(a, n, r, l, h) {\n        const c = a.chart.inverted,\n          g = a.reversed;\n        this.axis = a;\n        a = this.isNegative = !!r !== !!g;\n        this.options = n = n || {};\n        this.x = l;\n        this.cumulative = this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = h;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: n.align || (c ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: n.verticalAlign || (c ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: n.y,\n          x: n.x\n        };\n        this.textAlign = n.textAlign || (c ? a ? \"right\" : \"left\" : \"center\");\n      }\n      destroy() {\n        D(this, this.axis);\n      }\n      render(a) {\n        const c = this.axis.chart,\n          r = this.options;\n        var l = r.format;\n        l = l ? x(l, this, c) : r.formatter.call(this);\n        this.label ? this.label.attr({\n          text: l,\n          visibility: \"hidden\"\n        }) : (this.label = c.renderer.label(l, null, void 0, r.shape, void 0, void 0, r.useHTML, !1, \"stack-labels\"), l = {\n          r: r.borderRadius || 0,\n          text: l,\n          padding: t(r.padding, 5),\n          visibility: \"hidden\"\n        }, c.styledMode || (l.fill = r.backgroundColor, l.stroke = r.borderColor, l[\"stroke-width\"] = r.borderWidth, this.label.css(r.style || {})), this.label.attr(l), this.label.added || this.label.add(a));\n        this.label.labelrank = c.plotSizeY;\n        C(this, \"afterRender\");\n      }\n      setOffset(a, n, r, l, h, q) {\n        const {\n            alignOptions: c,\n            axis: w,\n            label: v,\n            options: x,\n            textAlign: e\n          } = this,\n          m = w.chart;\n        r = this.getStackBox({\n          xOffset: a,\n          width: n,\n          boxBottom: r,\n          boxTop: l,\n          defaultX: h,\n          xAxis: q\n        });\n        var {\n          verticalAlign: u\n        } = c;\n        if (v && r) {\n          l = v.getBBox();\n          h = v.padding;\n          q = \"justify\" === t(x.overflow, \"justify\");\n          c.x = x.x || 0;\n          c.y = x.y || 0;\n          const {\n            x: a,\n            y: g\n          } = this.adjustStackPosition({\n            labelBox: l,\n            verticalAlign: u,\n            textAlign: e\n          });\n          r.x -= a;\n          r.y -= g;\n          v.align(c, !1, r);\n          (u = m.isInsidePlot(v.alignAttr.x + c.x + a, v.alignAttr.y + c.y + g)) || (q = !1);\n          q && A.prototype.justifyDataLabel.call(w, v, c, v.alignAttr, l, r);\n          v.attr({\n            x: v.alignAttr.x,\n            y: v.alignAttr.y,\n            rotation: x.rotation,\n            rotationOriginX: l.width / 2,\n            rotationOriginY: l.height / 2\n          });\n          t(!q && x.crop, !0) && (u = z(v.x) && z(v.y) && m.isInsidePlot(v.x - h + v.width, v.y) && m.isInsidePlot(v.x + h, v.y));\n          v[u ? \"show\" : \"hide\"]();\n        }\n        C(this, \"afterSetOffset\", {\n          xOffset: a,\n          width: n\n        });\n      }\n      adjustStackPosition({\n        labelBox: a,\n        verticalAlign: n,\n        textAlign: r\n      }) {\n        const c = {\n          bottom: 0,\n          middle: 1,\n          top: 2,\n          right: 1,\n          center: 0,\n          left: -1\n        };\n        return {\n          x: a.width / 2 + a.width / 2 * c[r],\n          y: a.height / 2 * c[n]\n        };\n      }\n      getStackBox(a) {\n        var c = this.axis;\n        const r = c.chart,\n          {\n            boxTop: l,\n            defaultX: h,\n            xOffset: q,\n            width: g,\n            boxBottom: w\n          } = a;\n        var v = c.stacking.usePercentage ? 100 : t(l, this.total, 0);\n        v = c.toPixels(v);\n        a = a.xAxis || r.xAxis[0];\n        const x = t(h, a.translate(this.x)) + q;\n        c = c.toPixels(w || z(c.min) && c.logarithmic && c.logarithmic.lin2log(c.min) || 0);\n        c = Math.abs(v - c);\n        const e = this.isNegative;\n        return r.inverted ? {\n          x: (e ? v : v - c) - r.plotLeft,\n          y: a.height - x - g,\n          width: c,\n          height: g\n        } : {\n          x: x + a.transB - r.plotLeft,\n          y: (e ? v - c : v) - r.plotTop,\n          width: g,\n          height: c\n        };\n      }\n    }\n    \"\";\n    return v;\n  });\n  M(a, \"Core/Axis/Stacking/StackingAxis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A) {\n    function x() {\n      const b = this,\n        a = b.inverted;\n      b.yAxis.forEach(b => {\n        b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);\n      });\n      b.series.forEach(d => {\n        const c = d.xAxis && d.xAxis.options || {};\n        !d.options.stacking || !0 !== d.visible && !1 !== b.options.chart.ignoreHiddenSeries || (d.stackKey = [d.type, p(d.options.stack, \"\"), a ? c.top : c.left, a ? c.height : c.width].join());\n      });\n    }\n    function C() {\n      const b = this.stacking;\n      if (b) {\n        var a = b.stacks;\n        u(a, function (b, d) {\n          J(b);\n          a[d] = null;\n        });\n        b && b.stackTotalGroup && b.stackTotalGroup.destroy();\n      }\n    }\n    function z() {\n      \"yAxis\" !== this.coll || this.stacking || (this.stacking = new H(this));\n    }\n    function t(b, a, c, e) {\n      !w(b) || b.x !== a || e && b.stackKey !== e ? b = {\n        x: a,\n        index: 0,\n        key: e,\n        stackKey: e\n      } : b.index++;\n      b.key = [c, a, b.index].join();\n      return b;\n    }\n    function v() {\n      const b = this,\n        a = b.stackKey,\n        c = b.yAxis.stacking.stacks,\n        e = b.processedXData,\n        g = b[b.options.stacking + \"Stacker\"];\n      let m;\n      g && [a, \"-\" + a].forEach(a => {\n        let d = e.length;\n        let f;\n        for (; d--;) {\n          var k = e[d];\n          m = b.getStackIndicator(m, k, b.index, a);\n          (f = (k = c[a] && c[a][k]) && k.points[m.key]) && g.call(b, f, k, d);\n        }\n      });\n    }\n    function c(b, a, c) {\n      a = a.total ? 100 / a.total : 0;\n      b[0] = g(b[0] * a);\n      b[1] = g(b[1] * a);\n      this.stackedYData[c] = b[1];\n    }\n    function n() {\n      const b = this.yAxis.stacking;\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length ? h.setStackedPoints.call(this, \"group\") : b && u(b.stacks, (a, c) => {\n        \"group\" === c.slice(-5) && (u(a, b => b.destroy()), delete b.stacks[c]);\n      });\n    }\n    function r(b) {\n      var a = this.chart;\n      const c = b || this.options.stacking;\n      if (c && (!0 === this.visible || !1 === a.options.chart.ignoreHiddenSeries)) {\n        var f = this.processedXData,\n          m = this.processedYData,\n          h = [],\n          l = m.length,\n          n = this.options,\n          q = n.threshold,\n          r = p(n.startFromThreshold && q, 0);\n        n = n.stack;\n        b = b ? `${this.type},${c}` : this.stackKey;\n        var u = \"-\" + b,\n          v = this.negStacks;\n        a = \"group\" === c ? a.yAxis[0] : this.yAxis;\n        var t = a.stacking.stacks,\n          x = a.stacking.oldStacks,\n          F,\n          H;\n        a.stacking.stacksTouched += 1;\n        for (H = 0; H < l; H++) {\n          var J = f[H];\n          var z = m[H];\n          var y = this.getStackIndicator(y, J, this.index);\n          var A = y.key;\n          var C = (F = v && z < (r ? 0 : q)) ? u : b;\n          t[C] || (t[C] = {});\n          t[C][J] || (x[C] && x[C][J] ? (t[C][J] = x[C][J], t[C][J].total = null) : t[C][J] = new L(a, a.options.stackLabels, !!F, J, n));\n          C = t[C][J];\n          null !== z ? (C.points[A] = C.points[this.index] = [p(C.cumulative, r)], w(C.cumulative) || (C.base = A), C.touched = a.stacking.stacksTouched, 0 < y.index && !1 === this.singleStacks && (C.points[A][0] = C.points[this.index + \",\" + J + \",0\"][0])) : C.points[A] = C.points[this.index] = null;\n          \"percent\" === c ? (F = F ? b : u, v && t[F] && t[F][J] ? (F = t[F][J], C.total = F.total = Math.max(F.total, C.total) + Math.abs(z) || 0) : C.total = g(C.total + (Math.abs(z) || 0))) : \"group\" === c ? (e(z) && (z = z[0]), null !== z && (C.total = (C.total || 0) + 1)) : C.total = g(C.total + (z || 0));\n          C.cumulative = \"group\" === c ? (C.total || 1) - 1 : g(p(C.cumulative, r) + (z || 0));\n          null !== z && (C.points[A].push(C.cumulative), h[H] = C.cumulative, C.hasValidPoints = !0);\n        }\n        \"percent\" === c && (a.stacking.usePercentage = !0);\n        \"group\" !== c && (this.stackedYData = h);\n        a.stacking.oldStacks = {};\n      }\n    }\n    const {\n        getDeferredAnimation: l\n      } = a,\n      {\n        series: {\n          prototype: h\n        }\n      } = G,\n      {\n        addEvent: q,\n        correctFloat: g,\n        defined: w,\n        destroyObjectProperties: J,\n        fireEvent: F,\n        isArray: e,\n        isNumber: m,\n        objectEach: u,\n        pick: p\n      } = A;\n    class H {\n      constructor(b) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = b;\n      }\n      buildStacks() {\n        const b = this.axis,\n          a = b.series,\n          c = b.options.reversedStacks,\n          e = a.length;\n        let g, m;\n        this.usePercentage = !1;\n        for (m = e; m--;) g = a[c ? m : e - m - 1], g.setStackedPoints(), g.setGroupedPoints();\n        for (m = 0; m < e; m++) a[m].modifyStacks();\n        F(b, \"afterBuildStacks\");\n      }\n      cleanStacks() {\n        let b;\n        this.oldStacks && (b = this.stacks = this.oldStacks);\n        u(b, function (b) {\n          u(b, function (b) {\n            b.cumulative = b.total;\n          });\n        });\n      }\n      resetStacks() {\n        u(this.stacks, b => {\n          u(b, (a, c) => {\n            m(a.touched) && a.touched < this.stacksTouched ? (a.destroy(), delete b[c]) : (a.total = null, a.cumulative = null);\n          });\n        });\n      }\n      renderStackTotals() {\n        var b = this.axis;\n        const a = b.chart,\n          c = a.renderer,\n          e = this.stacks;\n        b = l(a, b.options.stackLabels && b.options.stackLabels.animation || !1);\n        const g = this.stackTotalGroup = this.stackTotalGroup || c.g(\"stack-labels\").attr({\n          zIndex: 6,\n          opacity: 0\n        }).add();\n        g.translate(a.plotLeft, a.plotTop);\n        u(e, function (b) {\n          u(b, function (b) {\n            b.render(g);\n          });\n        });\n        g.animate({\n          opacity: 1\n        }, b);\n      }\n    }\n    var b;\n    (function (b) {\n      const a = [];\n      b.compose = function (b, d, e) {\n        A.pushUnique(a, b) && (q(b, \"init\", z), q(b, \"destroy\", C));\n        A.pushUnique(a, d) && (d.prototype.getStacks = x);\n        A.pushUnique(a, e) && (b = e.prototype, b.getStackIndicator = t, b.modifyStacks = v, b.percentStacker = c, b.setGroupedPoints = n, b.setStackedPoints = r);\n      };\n    })(b || (b = {}));\n    return b;\n  });\n  M(a, \"Series/Line/LineSeries.js\", [a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n      defined: x,\n      merge: A\n    } = G;\n    class D extends a {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawGraph() {\n        const a = this,\n          x = this.options,\n          t = (this.gappedPath || this.getGraphPath).call(this),\n          v = this.chart.styledMode;\n        let c = [[\"graph\", \"highcharts-graph\"]];\n        v || c[0].push(x.lineColor || this.color || \"#cccccc\", x.dashStyle);\n        c = a.getZonesGraphs(c);\n        c.forEach(function (c, r) {\n          var l = c[0];\n          let h = a[l];\n          const n = h ? \"animate\" : \"attr\";\n          h ? (h.endX = a.preventGraphAnimation ? null : t.xMap, h.animate({\n            d: t\n          })) : t.length && (a[l] = h = a.chart.renderer.path(t).addClass(c[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          h && !v && (l = {\n            stroke: c[2],\n            \"stroke-width\": x.lineWidth || 0,\n            fill: a.fillGraph && a.color || \"none\"\n          }, c[3] ? l.dashstyle = c[3] : \"square\" !== x.linecap && (l[\"stroke-linecap\"] = l[\"stroke-linejoin\"] = \"round\"), h[n](l).shadow(2 > r && x.shadow));\n          h && (h.startX = t.xMap, h.isArea = t.isArea);\n        });\n      }\n      getGraphPath(a, z, t) {\n        const v = this,\n          c = v.options,\n          n = [],\n          r = [];\n        let l,\n          h = c.step;\n        a = a || v.points;\n        const q = a.reversed;\n        q && a.reverse();\n        (h = {\n          right: 1,\n          center: 2\n        }[h] || h && 3) && q && (h = 4 - h);\n        a = this.getValidPoints(a, !1, !(c.connectNulls && !z && !t));\n        a.forEach(function (g, q) {\n          const w = g.plotX,\n            F = g.plotY,\n            e = a[q - 1],\n            m = g.isNull || \"number\" !== typeof F;\n          (g.leftCliff || e && e.rightCliff) && !t && (l = !0);\n          m && !x(z) && 0 < q ? l = !c.connectNulls : m && !z ? l = !0 : (0 === q || l ? q = [[\"M\", g.plotX, g.plotY]] : v.getPointSpline ? q = [v.getPointSpline(a, g, q)] : h ? (q = 1 === h ? [[\"L\", e.plotX, F]] : 2 === h ? [[\"L\", (e.plotX + w) / 2, e.plotY], [\"L\", (e.plotX + w) / 2, F]] : [[\"L\", w, e.plotY]], q.push([\"L\", w, F])) : q = [[\"L\", w, F]], r.push(g.x), h && (r.push(g.x), 2 === h && r.push(g.x)), n.push.apply(n, q), l = !1);\n        });\n        n.xMap = r;\n        return v.graphPath = n;\n      }\n      getZonesGraphs(a) {\n        this.zones.forEach(function (x, t) {\n          t = [\"zone-graph-\" + t, \"highcharts-graph highcharts-zone-graph-\" + t + \" \" + (x.className || \"\")];\n          this.chart.styledMode || t.push(x.color || this.color, x.dashStyle || this.options.dashStyle);\n          a.push(t);\n        }, this);\n        return a;\n      }\n    }\n    D.defaultOptions = A(a.defaultOptions, {\n      legendSymbol: \"lineMarker\"\n    });\n    y.registerSeriesType(\"line\", D);\n    \"\";\n    return D;\n  });\n  M(a, \"Series/Area/AreaSeries.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        parse: x\n      } = a,\n      {\n        seriesTypes: {\n          line: A\n        }\n      } = y,\n      {\n        extend: D,\n        merge: C,\n        objectEach: z,\n        pick: t\n      } = G;\n    class v extends A {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawGraph() {\n        this.areaPath = [];\n        super.drawGraph.apply(this);\n        const a = this,\n          n = this.areaPath,\n          r = this.options,\n          l = [[\"area\", \"highcharts-area\", this.color, r.fillColor]];\n        this.zones.forEach(function (c, n) {\n          l.push([\"zone-area-\" + n, \"highcharts-area highcharts-zone-area-\" + n + \" \" + c.className, c.color || a.color, c.fillColor || r.fillColor]);\n        });\n        l.forEach(function (c) {\n          const h = c[0],\n            g = {};\n          let l = a[h];\n          const v = l ? \"animate\" : \"attr\";\n          l ? (l.endX = a.preventGraphAnimation ? null : n.xMap, l.animate({\n            d: n\n          })) : (g.zIndex = 0, l = a[h] = a.chart.renderer.path(n).addClass(c[1]).add(a.group), l.isArea = !0);\n          a.chart.styledMode || (g.fill = t(c[3], x(c[2]).setOpacity(t(r.fillOpacity, .75)).get()));\n          l[v](g);\n          l.startX = n.xMap;\n          l.shiftUnit = r.step ? 2 : 1;\n        });\n      }\n      getGraphPath(a) {\n        var c = A.prototype.getGraphPath,\n          r = this.options;\n        const l = r.stacking,\n          h = this.yAxis,\n          q = [],\n          g = [],\n          w = this.index,\n          v = h.stacking.stacks[this.stackKey],\n          x = r.threshold,\n          e = Math.round(h.getThreshold(r.threshold));\n        r = t(r.connectNulls, \"percent\" === l);\n        var m = function (b, c, d) {\n          var f = a[b];\n          b = l && v[f.x].points[w];\n          const m = f[d + \"Null\"] || 0;\n          d = f[d + \"Cliff\"] || 0;\n          let p, n;\n          f = !0;\n          d || m ? (p = (m ? b[0] : b[1]) + d, n = b[0] + d, f = !!m) : !l && a[c] && a[c].isNull && (p = n = x);\n          \"undefined\" !== typeof p && (g.push({\n            plotX: u,\n            plotY: null === p ? e : h.getThreshold(p),\n            isNull: f,\n            isCliff: !0\n          }), q.push({\n            plotX: u,\n            plotY: null === n ? e : h.getThreshold(n),\n            doCurve: !1\n          }));\n        };\n        let u;\n        a = a || this.points;\n        l && (a = this.getStackPoints(a));\n        for (let b = 0, c = a.length; b < c; ++b) {\n          l || (a[b].leftCliff = a[b].rightCliff = a[b].leftNull = a[b].rightNull = void 0);\n          var p = a[b].isNull;\n          u = t(a[b].rectPlotX, a[b].plotX);\n          var H = l ? t(a[b].yBottom, e) : e;\n          if (!p || r) r || m(b, b - 1, \"left\"), p && !l && r || (g.push(a[b]), q.push({\n            x: b,\n            plotX: u,\n            plotY: H\n          })), r || m(b, b + 1, \"right\");\n        }\n        m = c.call(this, g, !0, !0);\n        q.reversed = !0;\n        p = c.call(this, q, !0, !0);\n        (H = p[0]) && \"M\" === H[0] && (p[0] = [\"L\", H[1], H[2]]);\n        p = m.concat(p);\n        p.length && p.push([\"Z\"]);\n        c = c.call(this, g, !1, r);\n        p.xMap = m.xMap;\n        this.areaPath = p;\n        return c;\n      }\n      getStackPoints(a) {\n        const c = this,\n          r = [],\n          l = [],\n          h = this.xAxis,\n          q = this.yAxis,\n          g = q.stacking.stacks[this.stackKey],\n          w = {},\n          v = q.series,\n          x = v.length,\n          e = q.options.reversedStacks ? 1 : -1,\n          m = v.indexOf(c);\n        a = a || this.points;\n        if (this.options.stacking) {\n          for (let c = 0; c < a.length; c++) a[c].leftNull = a[c].rightNull = void 0, w[a[c].x] = a[c];\n          z(g, function (a, c) {\n            null !== a.total && l.push(c);\n          });\n          l.sort(function (a, c) {\n            return a - c;\n          });\n          const n = v.map(a => a.visible);\n          l.forEach(function (a, u) {\n            let b = 0,\n              f,\n              d;\n            if (w[a] && !w[a].isNull) r.push(w[a]), [-1, 1].forEach(function (b) {\n              const k = 1 === b ? \"rightNull\" : \"leftNull\",\n                h = g[l[u + b]];\n              let p = 0;\n              if (h) {\n                let b = m;\n                for (; 0 <= b && b < x;) {\n                  const m = v[b].index;\n                  f = h.points[m];\n                  f || (m === c.index ? w[a][k] = !0 : n[b] && (d = g[a].points[m]) && (p -= d[1] - d[0]));\n                  b += e;\n                }\n              }\n              w[a][1 === b ? \"rightCliff\" : \"leftCliff\"] = p;\n            });else {\n              let d = m;\n              for (; 0 <= d && d < x;) {\n                if (f = g[a].points[v[d].index]) {\n                  b = f[1];\n                  break;\n                }\n                d += e;\n              }\n              b = t(b, 0);\n              b = q.translate(b, 0, 1, 0, 1);\n              r.push({\n                isNull: !0,\n                plotX: h.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: b,\n                yBottom: b\n              });\n            }\n          });\n        }\n        return r;\n      }\n    }\n    v.defaultOptions = C(A.defaultOptions, {\n      threshold: 0,\n      legendSymbol: \"rectangle\"\n    });\n    D(v.prototype, {\n      singleStacks: !1\n    });\n    y.registerSeriesType(\"area\", v);\n    \"\";\n    return v;\n  });\n  M(a, \"Series/Spline/SplineSeries.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n        line: x\n      } = a.seriesTypes,\n      {\n        merge: L,\n        pick: A\n      } = y;\n    class D extends x {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      getPointSpline(a, x, t) {\n        const v = x.plotX || 0,\n          c = x.plotY || 0,\n          n = a[t - 1];\n        t = a[t + 1];\n        let r, l;\n        let h;\n        if (n && !n.isNull && !1 !== n.doCurve && !x.isCliff && t && !t.isNull && !1 !== t.doCurve && !x.isCliff) {\n          a = n.plotY || 0;\n          var q = t.plotX || 0;\n          t = t.plotY || 0;\n          let g = 0;\n          r = (1.5 * v + (n.plotX || 0)) / 2.5;\n          l = (1.5 * c + a) / 2.5;\n          q = (1.5 * v + q) / 2.5;\n          h = (1.5 * c + t) / 2.5;\n          q !== r && (g = (h - l) * (q - v) / (q - r) + c - h);\n          l += g;\n          h += g;\n          l > a && l > c ? (l = Math.max(a, c), h = 2 * c - l) : l < a && l < c && (l = Math.min(a, c), h = 2 * c - l);\n          h > t && h > c ? (h = Math.max(t, c), l = 2 * c - h) : h < t && h < c && (h = Math.min(t, c), l = 2 * c - h);\n          x.rightContX = q;\n          x.rightContY = h;\n        }\n        x = [\"C\", A(n.rightContX, n.plotX, 0), A(n.rightContY, n.plotY, 0), A(r, v, 0), A(l, c, 0), v, c];\n        n.rightContX = n.rightContY = void 0;\n        return x;\n      }\n    }\n    D.defaultOptions = L(x.defaultOptions);\n    a.registerSeriesType(\"spline\", D);\n    \"\";\n    return D;\n  });\n  M(a, \"Series/AreaSpline/AreaSplineSeries.js\", [a[\"Series/Spline/SplineSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        area: x,\n        area: {\n          prototype: A\n        }\n      } = y.seriesTypes,\n      {\n        extend: D,\n        merge: C\n      } = G;\n    class z extends a {\n      constructor() {\n        super(...arguments);\n        this.options = this.points = this.data = void 0;\n      }\n    }\n    z.defaultOptions = C(a.defaultOptions, x.defaultOptions);\n    D(z.prototype, {\n      getGraphPath: A.getGraphPath,\n      getStackPoints: A.getStackPoints,\n      drawGraph: A.drawGraph\n    });\n    y.registerSeriesType(\"areaspline\", z);\n    \"\";\n    return z;\n  });\n  M(a, \"Series/Column/ColumnSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    };\n  });\n  M(a, \"Series/Column/ColumnSeries.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Series/Column/ColumnSeriesDefaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D, C) {\n    const {\n        animObject: x\n      } = a,\n      {\n        parse: t\n      } = y,\n      {\n        hasTouch: v,\n        noop: c\n      } = L,\n      {\n        clamp: n,\n        defined: r,\n        extend: l,\n        fireEvent: h,\n        isArray: q,\n        isNumber: g,\n        merge: w,\n        pick: J,\n        objectEach: F\n      } = C;\n    class e extends A {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.group = this.data = this.borderWidth = void 0;\n      }\n      animate(a) {\n        const c = this,\n          e = this.yAxis,\n          g = e.pos,\n          b = c.options,\n          f = this.chart.inverted,\n          d = {},\n          k = f ? \"translateX\" : \"translateY\";\n        let m;\n        a ? (d.scaleY = .001, a = n(e.toPixels(b.threshold), g, g + e.len), f ? d.translateX = a - e.len : d.translateY = a, c.clipBox && c.setClip(), c.group.attr(d)) : (m = Number(c.group.attr(k)), c.group.animate({\n          scaleY: 1\n        }, l(x(c.options.animation), {\n          step: function (b, a) {\n            c.group && (d[k] = m + a.pos * (g - m), c.group.attr(d));\n          }\n        })));\n      }\n      init(a, c) {\n        super.init.apply(this, arguments);\n        const e = this;\n        a = e.chart;\n        a.hasRendered && a.series.forEach(function (a) {\n          a.type === e.type && (a.isDirty = !0);\n        });\n      }\n      getColumnMetrics() {\n        const a = this;\n        var c = a.options;\n        const e = a.xAxis,\n          g = a.yAxis;\n        var b = e.options.reversedStacks;\n        b = e.reversed && !b || !e.reversed && b;\n        const f = {};\n        let d,\n          k = 0;\n        !1 === c.grouping ? k = 1 : a.chart.series.forEach(function (b) {\n          const c = b.yAxis,\n            e = b.options;\n          let m;\n          b.type !== a.type || !b.visible && a.chart.options.chart.ignoreHiddenSeries || g.len !== c.len || g.pos !== c.pos || (e.stacking && \"group\" !== e.stacking ? (d = b.stackKey, \"undefined\" === typeof f[d] && (f[d] = k++), m = f[d]) : !1 !== e.grouping && (m = k++), b.columnIndex = m);\n        });\n        const h = Math.min(Math.abs(e.transA) * (e.ordinal && e.ordinal.slope || c.pointRange || e.closestPointRange || e.tickInterval || 1), e.len),\n          l = h * c.groupPadding,\n          n = (h - 2 * l) / (k || 1);\n        c = Math.min(c.maxPointWidth || e.len, J(c.pointWidth, n * (1 - 2 * c.pointPadding)));\n        a.columnMetrics = {\n          width: c,\n          offset: (n - c) / 2 + (l + ((a.columnIndex || 0) + (b ? 1 : 0)) * n - h / 2) * (b ? -1 : 1),\n          paddedWidth: n,\n          columnCount: k\n        };\n        return a.columnMetrics;\n      }\n      crispCol(a, c, e, g) {\n        var b = this.borderWidth,\n          f = -(b % 2 ? .5 : 0);\n        b = b % 2 ? .5 : 1;\n        this.options.crisp && (e = Math.round(a + e) + f, a = Math.round(a) + f, e -= a);\n        g = Math.round(c + g) + b;\n        f = .5 >= Math.abs(c) && .5 < g;\n        c = Math.round(c) + b;\n        g -= c;\n        f && g && (--c, g += 1);\n        return {\n          x: a,\n          y: c,\n          width: e,\n          height: g\n        };\n      }\n      adjustForMissingColumns(a, c, e, g) {\n        const b = this.options.stacking;\n        if (!e.isNull && 1 < g.columnCount) {\n          const f = this.yAxis.options.reversedStacks;\n          let d = 0,\n            k = f ? 0 : -g.columnCount;\n          F(this.yAxis.stacking && this.yAxis.stacking.stacks, a => {\n            if (\"number\" === typeof e.x) {\n              const c = a[e.x.toString()];\n              c && (a = c.points[this.index], b ? (a && (d = k), c.hasValidPoints && (f ? k++ : k--)) : q(a) && (a = Object.keys(c.points).filter(b => !b.match(\",\") && c.points[b] && 1 < c.points[b].length).map(parseFloat).sort((b, a) => a - b), d = a.indexOf(this.index), k = a.length));\n            }\n          });\n          a = (e.plotX || 0) + ((k - 1) * g.paddedWidth + c) / 2 - c - d * g.paddedWidth;\n        }\n        return a;\n      }\n      translate() {\n        const a = this,\n          c = a.chart,\n          e = a.options;\n        var l = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        l = a.borderWidth = J(e.borderWidth, l ? 0 : 1);\n        const b = a.xAxis,\n          f = a.yAxis,\n          d = e.threshold,\n          k = J(e.minPointLength, 5),\n          q = a.getColumnMetrics(),\n          w = q.width,\n          v = a.pointXOffset = q.offset,\n          t = a.dataMin,\n          x = a.dataMax;\n        let F = a.barW = Math.max(w, 1 + 2 * l),\n          y = a.translatedThreshold = f.getThreshold(d);\n        c.inverted && (y -= .5);\n        e.pointPadding && (F = Math.ceil(F));\n        A.prototype.translate.apply(a);\n        a.points.forEach(function (m) {\n          const h = J(m.yBottom, y);\n          var l = 999 + Math.abs(h),\n            p = m.plotX || 0;\n          l = n(m.plotY, -l, f.len + l);\n          let u = Math.min(l, h),\n            E = Math.max(l, h) - u,\n            H = w,\n            z = p + v,\n            A = F;\n          k && Math.abs(E) < k && (E = k, p = !f.reversed && !m.negative || f.reversed && m.negative, g(d) && g(x) && m.y === d && x <= d && (f.min || 0) < d && (t !== x || (f.max || 0) <= d) && (p = !p), u = Math.abs(u - y) > k ? h - k : y - (p ? k : 0));\n          r(m.options.pointWidth) && (H = A = Math.ceil(m.options.pointWidth), z -= Math.round((H - w) / 2));\n          e.centerInCategory && (z = a.adjustForMissingColumns(z, H, m, q));\n          m.barX = z;\n          m.pointWidth = H;\n          m.tooltipPos = c.inverted ? [n(f.len + f.pos - c.plotLeft - l, f.pos - c.plotLeft, f.len + f.pos - c.plotLeft), b.len + b.pos - c.plotTop - z - A / 2, E] : [b.left - c.plotLeft + z + A / 2, n(l + f.pos - c.plotTop, f.pos - c.plotTop, f.len + f.pos - c.plotTop), E];\n          m.shapeType = a.pointClass.prototype.shapeType || \"roundedRect\";\n          m.shapeArgs = a.crispCol(z, m.isNull ? y : u, A, m.isNull ? 0 : E);\n        });\n        h(this, \"afterColumnTranslate\");\n      }\n      drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      }\n      pointAttribs(a, c) {\n        const e = this.options;\n        var g = this.pointAttrToOptions || {},\n          b = g.stroke || \"borderColor\";\n        const f = g[\"stroke-width\"] || \"borderWidth\";\n        let d,\n          k = a && a.color || this.color,\n          m = a && a[b] || e[b] || k;\n        g = a && a.options.dashStyle || e.dashStyle;\n        let h = a && a[f] || e[f] || this[f] || 0,\n          l = J(a && a.opacity, e.opacity, 1);\n        a && this.zones.length && (d = a.getZone(), k = a.options.color || d && (d.color || a.nonZonedColor) || this.color, d && (m = d.borderColor || m, g = d.dashStyle || g, h = d.borderWidth || h));\n        c && a && (a = w(e.states[c], a.options.states && a.options.states[c] || {}), c = a.brightness, k = a.color || \"undefined\" !== typeof c && t(k).brighten(a.brightness).get() || k, m = a[b] || m, h = a[f] || h, g = a.dashStyle || g, l = J(a.opacity, l));\n        b = {\n          fill: k,\n          stroke: m,\n          \"stroke-width\": h,\n          opacity: l\n        };\n        g && (b.dashstyle = g);\n        return b;\n      }\n      drawPoints(a = this.points) {\n        const c = this,\n          e = this.chart,\n          m = c.options,\n          b = e.renderer,\n          f = m.animationLimit || 250;\n        let d;\n        a.forEach(function (a) {\n          let k = a.graphic,\n            h = !!k,\n            l = k && e.pointCount < f ? \"animate\" : \"attr\";\n          if (g(a.plotY) && null !== a.y) {\n            d = a.shapeArgs;\n            k && a.hasNewShapeType() && (k = k.destroy());\n            c.enabledDataSorting && (a.startXPos = c.xAxis.reversed ? -(d ? d.width || 0 : 0) : c.xAxis.width);\n            k || (a.graphic = k = b[a.shapeType](d).add(a.group || c.group)) && c.enabledDataSorting && e.hasRendered && e.pointCount < f && (k.attr({\n              x: a.startXPos\n            }), h = !0, l = \"animate\");\n            if (k && h) k[l](w(d));\n            e.styledMode || k[l](c.pointAttribs(a, a.selected && \"select\")).shadow(!1 !== a.allowShadow && m.shadow);\n            k && (k.addClass(a.getClassName(), !0), k.attr({\n              visibility: a.visible ? \"inherit\" : \"hidden\"\n            }));\n          } else k && (a.graphic = k.destroy());\n        });\n      }\n      drawTracker(a = this.points) {\n        const c = this,\n          e = c.chart,\n          g = e.pointer,\n          b = function (b) {\n            const a = g.getPointFromEvent(b);\n            \"undefined\" !== typeof a && (g.isDirectTouch = !0, a.onMouseOver(b));\n          };\n        let f;\n        a.forEach(function (b) {\n          f = q(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];\n          b.graphic && (b.graphic.element.point = b);\n          f.forEach(function (a) {\n            a.div ? a.div.point = b : a.element.point = b;\n          });\n        });\n        c._hasTracking || (c.trackerGroups.forEach(function (a) {\n          if (c[a]) {\n            c[a].addClass(\"highcharts-tracker\").on(\"mouseover\", b).on(\"mouseout\", function (b) {\n              g.onTrackerMouseOut(b);\n            });\n            if (v) c[a].on(\"touchstart\", b);\n            !e.styledMode && c.options.cursor && c[a].css({\n              cursor: c.options.cursor\n            });\n          }\n        }), c._hasTracking = !0);\n        h(this, \"afterDrawTracker\");\n      }\n      remove() {\n        const a = this,\n          c = a.chart;\n        c.hasRendered && c.series.forEach(function (c) {\n          c.type === a.type && (c.isDirty = !0);\n        });\n        A.prototype.remove.apply(a, arguments);\n      }\n    }\n    e.defaultOptions = w(A.defaultOptions, G);\n    l(e.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      getSymbol: c,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    D.registerSeriesType(\"column\", e);\n    \"\";\n    return e;\n  });\n  M(a, \"Core/Series/DataLabel.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        getDeferredAnimation: x\n      } = a,\n      {\n        format: A\n      } = y,\n      {\n        defined: D,\n        extend: C,\n        fireEvent: z,\n        isArray: t,\n        isString: v,\n        merge: c,\n        objectEach: n,\n        pick: r,\n        splat: l\n      } = G;\n    var h;\n    (function (a) {\n      function g(b, a, d, c, e) {\n        const f = this.chart;\n        var g = this.isCartesian && f.inverted;\n        const k = this.enabledDataSorting;\n        var m = b.plotX,\n          h = b.plotY;\n        const l = d.rotation;\n        var n = d.align;\n        h = D(m) && D(h) && f.isInsidePlot(m, Math.round(h), {\n          inverted: g,\n          paneCoordinates: !0,\n          series: this\n        });\n        let p = \"justify\" === r(d.overflow, k ? \"none\" : \"justify\");\n        g = this.visible && !1 !== b.visible && D(m) && (b.series.forceDL || k && !p || h || r(d.inside, !!this.options.stacking) && c && f.isInsidePlot(m, g ? c.x + 1 : c.y + c.height - 1, {\n          inverted: g,\n          paneCoordinates: !0,\n          series: this\n        }));\n        m = b.pos();\n        if (g && m) {\n          l && a.attr({\n            align: n\n          });\n          n = a.getBBox(!0);\n          var q = [0, 0];\n          var u = f.renderer.fontMetrics(a).b;\n          c = C({\n            x: m[0],\n            y: Math.round(m[1]),\n            width: 0,\n            height: 0\n          }, c);\n          C(d, {\n            width: n.width,\n            height: n.height\n          });\n          l ? (p = !1, q = f.renderer.rotCorr(u, l), u = {\n            x: c.x + (d.x || 0) + c.width / 2 + q.x,\n            y: c.y + (d.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[d.verticalAlign] * c.height\n          }, q = [n.x - Number(a.attr(\"x\")), n.y - Number(a.attr(\"y\"))], k && this.xAxis && !p && this.setDataLabelStartPos(b, a, e, h, u), a[e ? \"attr\" : \"animate\"](u)) : (k && this.xAxis && !p && this.setDataLabelStartPos(b, a, e, h, c), a.align(d, void 0, c), u = a.alignAttr);\n          if (p && 0 <= c.height) this.justifyDataLabel(a, d, u, n, c, e);else if (r(d.crop, !0)) {\n            let {\n              x: b,\n              y: a\n            } = u;\n            b += q[0];\n            a += q[1];\n            g = f.isInsidePlot(b, a, {\n              paneCoordinates: !0,\n              series: this\n            }) && f.isInsidePlot(b + n.width, a + n.height, {\n              paneCoordinates: !0,\n              series: this\n            });\n          }\n          if (d.shape && !l) a[e ? \"attr\" : \"animate\"]({\n            anchorX: m[0],\n            anchorY: m[1]\n          });\n        }\n        e && k && (a.placed = !1);\n        g || k && !p ? a.show() : (a.hide(), a.placed = !1);\n      }\n      function h(b, a) {\n        var d = a.filter;\n        return d ? (a = d.operator, b = b[d.property], d = d.value, \">\" === a && b > d || \"<\" === a && b < d || \">=\" === a && b >= d || \"<=\" === a && b <= d || \"==\" === a && b == d || \"===\" === a && b === d ? !0 : !1) : !0;\n      }\n      function q() {\n        return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n      }\n      function F(b) {\n        const a = this.hasRendered || 0,\n          d = this.initDataLabelsGroup().attr({\n            opacity: +a\n          });\n        !a && d && (this.visible && d.show(), this.options.animation ? d.animate({\n          opacity: 1\n        }, b) : d.attr({\n          opacity: 1\n        }));\n        return d;\n      }\n      function e(b = this.points) {\n        const a = this,\n          d = a.chart,\n          c = a.options,\n          e = d.renderer,\n          {\n            backgroundColor: g,\n            plotBackgroundColor: m\n          } = d.options.chart,\n          p = e.getContrast(v(m) && m || v(g) && g || \"#000000\");\n        let q = c.dataLabels,\n          w,\n          F;\n        var J = l(q)[0];\n        const y = J.animation;\n        J = J.defer ? x(d, y, a) : {\n          defer: 0,\n          duration: 0\n        };\n        q = u(u(d.options.plotOptions && d.options.plotOptions.series && d.options.plotOptions.series.dataLabels, d.options.plotOptions && d.options.plotOptions[a.type] && d.options.plotOptions[a.type].dataLabels), q);\n        z(this, \"drawDataLabels\");\n        if (t(q) || q.enabled || a._hasPointLabels) F = this.initDataLabels(J), b.forEach(b => {\n          w = l(u(q, b.dlOptions || b.options && b.options.dataLabels));\n          w.forEach((f, g) => {\n            const k = f.enabled && (!b.isNull || b.dataLabelOnNull) && h(b, f),\n              m = b.connectors ? b.connectors[g] : b.connector;\n            let l,\n              q,\n              u = b.dataLabels ? b.dataLabels[g] : b.dataLabel,\n              w = !u;\n            const v = r(f.distance, b.labelDistance);\n            if (k) {\n              var t = b.getLabelConfig();\n              var x = r(f[b.formatPrefix + \"Format\"], f.format);\n              t = D(x) ? A(x, t, d) : (f[b.formatPrefix + \"Formatter\"] || f.formatter).call(t, f);\n              x = f.style;\n              l = f.rotation;\n              d.styledMode || (x.color = r(f.color, x.color, a.color, \"#000000\"), \"contrast\" === x.color ? (b.contrastColor = e.getContrast(b.color || a.color), x.color = !D(v) && f.inside || 0 > v || c.stacking ? b.contrastColor : p) : delete b.contrastColor, c.cursor && (x.cursor = c.cursor));\n              q = {\n                r: f.borderRadius || 0,\n                rotation: l,\n                padding: f.padding,\n                zIndex: 1\n              };\n              if (!d.styledMode) {\n                const {\n                  backgroundColor: a,\n                  borderColor: d\n                } = f;\n                q.fill = \"auto\" === a ? b.color : a;\n                q.stroke = \"auto\" === d ? b.color : d;\n                q[\"stroke-width\"] = f.borderWidth;\n              }\n              n(q, function (b, a) {\n                \"undefined\" === typeof b && delete q[a];\n              });\n            }\n            !u || k && D(t) && !!u.div === !!f.useHTML && (u.rotation && f.rotation || u.rotation === f.rotation) || (w = !0, b.dataLabel = u = b.dataLabel && b.dataLabel.destroy(), b.dataLabels && (1 === b.dataLabels.length ? delete b.dataLabels : delete b.dataLabels[g]), g || delete b.dataLabel, m && (b.connector = b.connector.destroy(), b.connectors && (1 === b.connectors.length ? delete b.connectors : delete b.connectors[g])));\n            k && D(t) ? (u ? q.text = t : (b.dataLabels = b.dataLabels || [], u = b.dataLabels[g] = l ? e.text(t, 0, 0, f.useHTML).addClass(\"highcharts-data-label\") : e.label(t, 0, 0, f.shape, null, null, f.useHTML, null, \"data-label\"), g || (b.dataLabel = u), u.addClass(\" highcharts-data-label-color-\" + b.colorIndex + \" \" + (f.className || \"\") + (f.useHTML ? \" highcharts-tracker\" : \"\"))), u.options = f, u.attr(q), d.styledMode || u.css(x).shadow(f.shadow), (g = f[b.formatPrefix + \"TextPath\"] || f.textPath) && !f.useHTML && (u.setTextPath(b.getDataLabelPath && b.getDataLabelPath(u) || b.graphic, g), b.dataLabelPath && !g.enabled && (b.dataLabelPath = b.dataLabelPath.destroy())), u.added || u.add(F), a.alignDataLabel(b, u, f, null, w)) : u && u.hide();\n          });\n        });\n        z(this, \"afterDrawDataLabels\");\n      }\n      function m(b, a, d, c, e, g) {\n        const f = this.chart,\n          k = a.align,\n          m = a.verticalAlign,\n          h = b.box ? 0 : b.padding || 0;\n        let {\n            x: l = 0,\n            y: n = 0\n          } = a,\n          p,\n          q;\n        p = (d.x || 0) + h;\n        0 > p && (\"right\" === k && 0 <= l ? (a.align = \"left\", a.inside = !0) : l -= p, q = !0);\n        p = (d.x || 0) + c.width - h;\n        p > f.plotWidth && (\"left\" === k && 0 >= l ? (a.align = \"right\", a.inside = !0) : l += f.plotWidth - p, q = !0);\n        p = d.y + h;\n        0 > p && (\"bottom\" === m && 0 <= n ? (a.verticalAlign = \"top\", a.inside = !0) : n -= p, q = !0);\n        p = (d.y || 0) + c.height - h;\n        p > f.plotHeight && (\"top\" === m && 0 >= n ? (a.verticalAlign = \"bottom\", a.inside = !0) : n += f.plotHeight - p, q = !0);\n        q && (a.x = l, a.y = n, b.placed = !g, b.align(a, void 0, e));\n        return q;\n      }\n      function u(b, a) {\n        let d = [],\n          e;\n        if (t(b) && !t(a)) d = b.map(function (b) {\n          return c(b, a);\n        });else if (t(a) && !t(b)) d = a.map(function (a) {\n          return c(b, a);\n        });else if (t(b) || t(a)) for (e = Math.max(b.length, a.length); e--;) d[e] = c(b[e], a[e]);else d = c(b, a);\n        return d;\n      }\n      function p(b, a, d, c, e) {\n        const f = this.chart,\n          g = f.inverted,\n          k = this.xAxis,\n          m = k.reversed,\n          h = g ? a.height / 2 : a.width / 2;\n        b = (b = b.pointWidth) ? b / 2 : 0;\n        a.startXPos = g ? e.x : m ? -h - b : k.width - h + b;\n        a.startYPos = g ? m ? this.yAxis.height - h + b : -h - b : e.y;\n        c ? \"hidden\" === a.visibility && (a.show(), a.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : a.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, a.hide);\n        f.hasRendered && (d && a.attr({\n          x: a.startXPos,\n          y: a.startYPos\n        }), a.placed = !0);\n      }\n      const y = [];\n      a.compose = function (b) {\n        G.pushUnique(y, b) && (b = b.prototype, b.initDataLabelsGroup = q, b.initDataLabels = F, b.alignDataLabel = g, b.drawDataLabels = e, b.justifyDataLabel = m, b.setDataLabelStartPos = p);\n      };\n    })(h || (h = {}));\n    \"\";\n    return h;\n  });\n  M(a, \"Series/Column/ColumnDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        series: x\n      } = y,\n      {\n        merge: A,\n        pick: D\n      } = G;\n    var C;\n    (function (y) {\n      function t(a, n, r, l, h) {\n        let c = this.chart.inverted;\n        var g = a.series;\n        let w = (g.xAxis ? g.xAxis.len : this.chart.plotSizeX) || 0;\n        g = (g.yAxis ? g.yAxis.len : this.chart.plotSizeY) || 0;\n        var v = a.dlBox || a.shapeArgs;\n        let t = D(a.below, a.plotY > D(this.translatedThreshold, g)),\n          e = D(r.inside, !!this.options.stacking);\n        v && (l = A(v), 0 > l.y && (l.height += l.y, l.y = 0), v = l.y + l.height - g, 0 < v && v < l.height && (l.height -= v), c && (l = {\n          x: g - l.y - l.height,\n          y: w - l.x - l.width,\n          width: l.height,\n          height: l.width\n        }), e || (c ? (l.x += t ? 0 : l.width, l.width = 0) : (l.y += t ? l.height : 0, l.height = 0)));\n        r.align = D(r.align, !c || e ? \"center\" : t ? \"right\" : \"left\");\n        r.verticalAlign = D(r.verticalAlign, c || e ? \"middle\" : t ? \"top\" : \"bottom\");\n        x.prototype.alignDataLabel.call(this, a, n, r, l, h);\n        r.inside && a.contrastColor && n.css({\n          color: a.contrastColor\n        });\n      }\n      const v = [];\n      y.compose = function (c) {\n        a.compose(x);\n        G.pushUnique(v, c) && (c.prototype.alignDataLabel = t);\n      };\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Series/Bar/BarSeries.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n      extend: x,\n      merge: A\n    } = G;\n    class D extends a {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n    }\n    D.defaultOptions = A(a.defaultOptions, {});\n    x(D.prototype, {\n      inverted: !0\n    });\n    y.registerSeriesType(\"bar\", D);\n    \"\";\n    return D;\n  });\n  M(a, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    };\n  });\n  M(a, \"Series/Scatter/ScatterSeries.js\", [a[\"Series/Scatter/ScatterSeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        column: x,\n        line: A\n      } = y.seriesTypes,\n      {\n        addEvent: D,\n        extend: C,\n        merge: z\n      } = G;\n    class t extends A {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      applyJitter() {\n        const a = this,\n          c = this.options.jitter,\n          n = this.points.length;\n        c && this.points.forEach(function (r, l) {\n          [\"x\", \"y\"].forEach(function (h, q) {\n            let g = \"plot\" + h.toUpperCase(),\n              w,\n              v;\n            if (c[h] && !r.isNull) {\n              var t = a[h + \"Axis\"];\n              v = c[h] * t.transA;\n              t && !t.isLog && (w = Math.max(0, r[g] - v), t = Math.min(t.len, r[g] + v), q = 1E4 * Math.sin(l + q * n), q -= Math.floor(q), r[g] = w + (t - w) * q, \"x\" === h && (r.clientX = r.plotX));\n            }\n          });\n        });\n      }\n      drawGraph() {\n        this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());\n      }\n    }\n    t.defaultOptions = z(A.defaultOptions, a);\n    C(t.prototype, {\n      drawTracker: x.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    D(t, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    y.registerSeriesType(\"scatter\", t);\n    return t;\n  });\n  M(a, \"Series/CenteredUtilities.js\", [a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        deg2rad: x\n      } = a,\n      {\n        fireEvent: A,\n        isNumber: D,\n        pick: C,\n        relativeLength: z\n      } = G;\n    var t = /*#__PURE__*/(() => {\n      (function (a) {\n        a.getCenter = function () {\n          var a = this.options,\n            n = this.chart;\n          const r = 2 * (a.slicedOffset || 0),\n            l = n.plotWidth - 2 * r,\n            h = n.plotHeight - 2 * r;\n          var q = a.center;\n          const g = Math.min(l, h),\n            w = a.thickness;\n          var t = a.size;\n          let v = a.innerSize || 0;\n          \"string\" === typeof t && (t = parseFloat(t));\n          \"string\" === typeof v && (v = parseFloat(v));\n          a = [C(q[0], \"50%\"), C(q[1], \"50%\"), C(t && 0 > t ? void 0 : a.size, \"100%\"), C(v && 0 > v ? void 0 : a.innerSize || 0, \"0%\")];\n          !n.angular || this instanceof y || (a[3] = 0);\n          for (q = 0; 4 > q; ++q) t = a[q], n = 2 > q || 2 === q && /%$/.test(t), a[q] = z(t, [l, h, g, a[2]][q]) + (n ? r : 0);\n          a[3] > a[2] && (a[3] = a[2]);\n          D(w) && 2 * w < a[2] && 0 < w && (a[3] = a[2] - 2 * w);\n          A(this, \"afterGetCenter\", {\n            positions: a\n          });\n          return a;\n        };\n        a.getStartAndEndRadians = function (a, n) {\n          a = D(a) ? a : 0;\n          n = D(n) && n > a && 360 > n - a ? n : a + 360;\n          return {\n            start: x * (a + -90),\n            end: x * (n + -90)\n          };\n        };\n      })(t || (t = {}));\n      return t;\n    })();\n    \"\";\n    return t;\n  });\n  M(a, \"Series/Pie/PiePoint.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, y, G) {\n    const {\n        setAnimation: x\n      } = a,\n      {\n        addEvent: A,\n        defined: D,\n        extend: C,\n        isNumber: z,\n        pick: t,\n        relativeLength: v\n      } = G;\n    class c extends y {\n      constructor() {\n        super(...arguments);\n        this.series = this.options = this.labelDistance = void 0;\n      }\n      getConnectorPath() {\n        const a = this.labelPosition,\n          c = this.series.options.dataLabels,\n          l = this.connectorShapes;\n        let h = c.connectorShape;\n        l[h] && (h = l[h]);\n        return h.call(this, {\n          x: a.computed.x,\n          y: a.computed.y,\n          alignment: a.alignment\n        }, a.connectorPosition, c);\n      }\n      getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      }\n      haloPath(a) {\n        const c = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {\n          innerR: c.r - 1,\n          start: c.start,\n          end: c.end,\n          borderRadius: c.borderRadius\n        });\n      }\n      init() {\n        super.init.apply(this, arguments);\n        this.name = t(this.name, \"Slice\");\n        const a = a => {\n          this.slice(\"select\" === a.type);\n        };\n        A(this, \"select\", a);\n        A(this, \"unselect\", a);\n        return this;\n      }\n      isValid() {\n        return z(this.y) && 0 <= this.y;\n      }\n      setVisible(a, c) {\n        const l = this.series,\n          h = l.chart,\n          n = l.options.ignoreHiddenPoint;\n        c = t(c, n);\n        a !== this.visible && (this.visible = this.options.visible = a = \"undefined\" === typeof a ? !this.visible : a, l.options.data[l.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\"].forEach(c => {\n          if (this[c]) this[c][a ? \"show\" : \"hide\"](a);\n        }), this.legendItem && h.legend.colorizeItem(this, a), a || \"hover\" !== this.state || this.setState(\"\"), n && (l.isDirty = !0), c && h.redraw());\n      }\n      slice(a, c, l) {\n        const h = this.series;\n        x(l, h.chart);\n        t(c, !0);\n        this.sliced = this.options.sliced = D(a) ? a : !this.sliced;\n        h.options.data[h.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n      }\n    }\n    C(c.prototype, {\n      connectorShapes: {\n        fixedOffset: function (a, c, l) {\n          const h = c.breakAt;\n          c = c.touchingSliceAt;\n          return [[\"M\", a.x, a.y], l.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * h.x - c.x, 2 * h.y - c.y, h.x, h.y] : [\"L\", h.x, h.y], [\"L\", c.x, c.y]];\n        },\n        straight: function (a, c) {\n          c = c.touchingSliceAt;\n          return [[\"M\", a.x, a.y], [\"L\", c.x, c.y]];\n        },\n        crookedLine: function (a, c, l) {\n          const {\n            breakAt: h,\n            touchingSliceAt: n\n          } = c;\n          ({\n            series: c\n          } = this);\n          const [g, r, t] = c.center,\n            x = t / 2,\n            e = c.chart.plotWidth,\n            m = c.chart.plotLeft;\n          c = \"left\" === a.alignment;\n          const {\n            x: u,\n            y: p\n          } = a;\n          l.crookDistance ? (a = v(l.crookDistance, 1), a = c ? g + x + (e + m - g - x) * (1 - a) : m + (g - x) * a) : a = g + (r - p) * Math.tan((this.angle || 0) - Math.PI / 2);\n          l = [[\"M\", u, p]];\n          (c ? a <= u && a >= h.x : a >= u && a <= h.x) && l.push([\"L\", a, p]);\n          l.push([\"L\", h.x, h.y], [\"L\", n.x, n.y]);\n          return l;\n        }\n      }\n    });\n    return c;\n  });\n  M(a, \"Series/Pie/PieSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"crookedLine\",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  });\n  M(a, \"Series/Pie/PieSeries.js\", [a[\"Series/CenteredUtilities.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Globals.js\"], a[\"Series/Pie/PiePoint.js\"], a[\"Series/Pie/PieSeriesDefaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D, C, z, t) {\n    const {\n      getStartAndEndRadians: v\n    } = a;\n    ({\n      noop: G\n    } = G);\n    const {\n      clamp: c,\n      extend: n,\n      fireEvent: r,\n      merge: l,\n      pick: h,\n      relativeLength: q\n    } = t;\n    class g extends D {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.maxLabelDistance = this.data = this.center = void 0;\n      }\n      animate(a) {\n        const c = this,\n          g = c.points,\n          e = c.startAngleRad;\n        a || g.forEach(function (a) {\n          const g = a.graphic,\n            m = a.shapeArgs;\n          g && m && (g.attr({\n            r: h(a.startR, c.center && c.center[3] / 2),\n            start: e,\n            end: e\n          }), g.animate({\n            r: m.r,\n            start: m.start,\n            end: m.end\n          }, c.options.animation));\n        });\n      }\n      drawEmpty() {\n        const a = this.startAngleRad,\n          c = this.endAngleRad,\n          g = this.options;\n        let e, m;\n        0 === this.total && this.center ? (e = this.center[0], m = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(e, m, this.center[1] / 2, 0, a, c).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n          d: z.arc(e, m, this.center[2] / 2, 0, {\n            start: a,\n            end: c,\n            innerR: this.center[3] / 2\n          })\n        }), this.chart.styledMode || this.graph.attr({\n          \"stroke-width\": g.borderWidth,\n          fill: g.fillColor || \"none\",\n          stroke: g.color || \"#cccccc\"\n        })) : this.graph && (this.graph = this.graph.destroy());\n      }\n      drawPoints() {\n        const a = this.chart.renderer;\n        this.points.forEach(function (c) {\n          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());\n          c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);\n        });\n      }\n      generatePoints() {\n        super.generatePoints();\n        this.updateTotals();\n      }\n      getX(a, g, h) {\n        const e = this.center,\n          m = this.radii ? this.radii[h.index] || 0 : e[2] / 2;\n        a = Math.asin(c((a - e[1]) / (m + h.labelDistance), -1, 1));\n        return e[0] + (g ? -1 : 1) * Math.cos(a) * (m + h.labelDistance) + (0 < h.labelDistance ? (g ? -1 : 1) * this.options.dataLabels.padding : 0);\n      }\n      hasData() {\n        return !!this.processedXData.length;\n      }\n      redrawPoints() {\n        const a = this,\n          c = a.chart;\n        let g, e, m, h;\n        this.drawEmpty();\n        a.group && !c.styledMode && a.group.shadow(a.options.shadow);\n        a.points.forEach(function (p) {\n          const n = {};\n          e = p.graphic;\n          !p.isNull && e ? (h = p.shapeArgs, g = p.getTranslate(), c.styledMode || (m = a.pointAttribs(p, p.selected && \"select\")), p.delayedRendering ? (e.setRadialReference(a.center).attr(h).attr(g), c.styledMode || e.attr(m).attr({\n            \"stroke-linejoin\": \"round\"\n          }), p.delayedRendering = !1) : (e.setRadialReference(a.center), c.styledMode || l(!0, n, m), l(!0, n, h, g), e.animate(n)), e.attr({\n            visibility: p.visible ? \"inherit\" : \"hidden\"\n          }), e.addClass(p.getClassName(), !0)) : e && (p.graphic = e.destroy());\n        });\n      }\n      sortByAngle(a, c) {\n        a.sort(function (a, e) {\n          return \"undefined\" !== typeof a.angle && (e.angle - a.angle) * c;\n        });\n      }\n      translate(a) {\n        r(this, \"translate\");\n        this.generatePoints();\n        var c = this.options;\n        const g = c.slicedOffset,\n          e = g + (c.borderWidth || 0);\n        var m = v(c.startAngle, c.endAngle);\n        const l = this.startAngleRad = m.start;\n        m = (this.endAngleRad = m.end) - l;\n        const p = this.points,\n          n = c.dataLabels.distance;\n        c = c.ignoreHiddenPoint;\n        const b = p.length;\n        let f,\n          d,\n          k,\n          t = 0;\n        a || (this.center = a = this.getCenter());\n        for (d = 0; d < b; d++) {\n          k = p[d];\n          var w = l + t * m;\n          !k.isValid() || c && !k.visible || (t += k.percentage / 100);\n          var x = l + t * m;\n          var y = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * w) / 1E3,\n            end: Math.round(1E3 * x) / 1E3\n          };\n          k.shapeType = \"arc\";\n          k.shapeArgs = y;\n          k.labelDistance = h(k.options.dataLabels && k.options.dataLabels.distance, n);\n          k.labelDistance = q(k.labelDistance, y.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, k.labelDistance);\n          x = (x + w) / 2;\n          x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);\n          k.slicedTranslation = {\n            translateX: Math.round(Math.cos(x) * g),\n            translateY: Math.round(Math.sin(x) * g)\n          };\n          y = Math.cos(x) * a[2] / 2;\n          f = Math.sin(x) * a[2] / 2;\n          k.tooltipPos = [a[0] + .7 * y, a[1] + .7 * f];\n          k.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;\n          k.angle = x;\n          w = Math.min(e, k.labelDistance / 5);\n          k.labelPosition = {\n            natural: {\n              x: a[0] + y + Math.cos(x) * k.labelDistance,\n              y: a[1] + f + Math.sin(x) * k.labelDistance\n            },\n            computed: {},\n            alignment: 0 > k.labelDistance ? \"center\" : k.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + y + Math.cos(x) * w,\n                y: a[1] + f + Math.sin(x) * w\n              },\n              touchingSliceAt: {\n                x: a[0] + y,\n                y: a[1] + f\n              }\n            }\n          };\n        }\n        r(this, \"afterTranslate\");\n      }\n      updateTotals() {\n        const a = this.points,\n          c = a.length,\n          g = this.options.ignoreHiddenPoint;\n        let e,\n          m,\n          h = 0;\n        for (e = 0; e < c; e++) m = a[e], !m.isValid() || g && !m.visible || (h += m.y);\n        this.total = h;\n        for (e = 0; e < c; e++) m = a[e], m.percentage = 0 < h && (m.visible || !g) ? m.y / h * 100 : 0, m.total = h;\n      }\n    }\n    g.defaultOptions = l(D.defaultOptions, A);\n    n(g.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: y.prototype.drawTracker,\n      getCenter: a.getCenter,\n      getSymbol: G,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: y.prototype.pointAttribs,\n      pointClass: L,\n      requireSorting: !1,\n      searchPoint: G,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    C.registerSeriesType(\"pie\", g);\n    return g;\n  });\n  M(a, \"Series/Pie/PieDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A) {\n    const {\n        noop: x\n      } = y,\n      {\n        distribute: C\n      } = G,\n      {\n        series: z\n      } = L,\n      {\n        arrayMax: t,\n        clamp: v,\n        defined: c,\n        merge: n,\n        pick: r,\n        relativeLength: l\n      } = A;\n    var h;\n    (function (h) {\n      function g() {\n        const a = this,\n          e = a.data,\n          g = a.chart,\n          h = a.options.dataLabels || {},\n          b = h.connectorPadding,\n          f = g.plotWidth,\n          d = g.plotHeight,\n          k = g.plotLeft,\n          l = Math.round(g.chartWidth / 3),\n          q = a.center,\n          w = q[2] / 2,\n          v = q[1],\n          x = [[], []],\n          y = [0, 0, 0, 0],\n          F = a.dataLabelPositioners;\n        let A, J, D, G, B, L, I, M, R, S, W, ba;\n        a.visible && (h.enabled || a._hasPointLabels) && (e.forEach(function (a) {\n          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), a.dataLabel.shortened = !1);\n        }), z.prototype.drawDataLabels.apply(a), e.forEach(function (a) {\n          a.dataLabel && (a.visible ? (x[a.half].push(a), a.dataLabel._pos = null, !c(h.style.width) && !c(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > l && (a.dataLabel.css({\n            width: Math.round(.7 * l) + \"px\"\n          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n        }), x.forEach((e, m) => {\n          const l = e.length,\n            p = [];\n          let n,\n            u = 0;\n          if (l) {\n            a.sortByAngle(e, m - .5);\n            if (0 < a.maxLabelDistance) {\n              var t = Math.max(0, v - w - a.maxLabelDistance);\n              n = Math.min(v + w + a.maxLabelDistance, g.plotHeight);\n              e.forEach(function (a) {\n                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, v - w - a.labelDistance), a.bottom = Math.min(v + w + a.labelDistance, g.plotHeight), u = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                  target: a.labelPosition.natural.y - a.top + u / 2,\n                  size: u,\n                  rank: a.y\n                }, p.push(a.distributeBox));\n              });\n              t = n + u - t;\n              C(p, t, t / 5);\n            }\n            for (W = 0; W < l; W++) {\n              A = e[W];\n              L = A.labelPosition;\n              G = A.dataLabel;\n              S = !1 === A.visible ? \"hidden\" : \"inherit\";\n              R = t = L.natural.y;\n              p && c(A.distributeBox) && (\"undefined\" === typeof A.distributeBox.pos ? S = \"hidden\" : (I = A.distributeBox.size, R = F.radialDistributionY(A)));\n              delete A.positionIndex;\n              if (h.justify) M = F.justify(A, w, q);else switch (h.alignTo) {\n                case \"connectors\":\n                  M = F.alignToConnectors(e, m, f, k);\n                  break;\n                case \"plotEdges\":\n                  M = F.alignToPlotEdges(G, m, f, k);\n                  break;\n                default:\n                  M = F.radialDistributionX(a, A, R, t);\n              }\n              G._attr = {\n                visibility: S,\n                align: L.alignment\n              };\n              ba = A.options.dataLabels || {};\n              G._pos = {\n                x: M + r(ba.x, h.x) + ({\n                  left: b,\n                  right: -b\n                }[L.alignment] || 0),\n                y: R + r(ba.y, h.y) - G.getBBox().height / 2\n              };\n              L && (L.computed.x = M, L.computed.y = R);\n              r(h.crop, !0) && (B = G.getBBox().width, t = null, M - B < b && 1 === m ? (t = Math.round(B - M + b), y[3] = Math.max(t, y[3])) : M + B > f - b && 0 === m && (t = Math.round(M + B - f + b), y[1] = Math.max(t, y[1])), 0 > R - I / 2 ? y[0] = Math.max(Math.round(-R + I / 2), y[0]) : R + I / 2 > d && (y[2] = Math.max(Math.round(R + I / 2 - d), y[2])), G.sideOverflow = t);\n            }\n          }\n        }), 0 === t(y) || this.verifyDataLabelOverflow(y)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n          ba = n(h, b.options.dataLabels);\n          if (J = r(ba.connectorWidth, 1)) {\n            let d;\n            D = b.connector;\n            if ((G = b.dataLabel) && G._pos && b.visible && 0 < b.labelDistance) {\n              S = G._attr.visibility;\n              if (d = !D) b.connector = D = g.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(a.dataLabelsGroup), g.styledMode || D.attr({\n                \"stroke-width\": J,\n                stroke: ba.connectorColor || b.color || \"#666666\"\n              });\n              D[d ? \"attr\" : \"animate\"]({\n                d: b.getConnectorPath()\n              });\n              D.attr(\"visibility\", S);\n            } else D && (b.connector = D.destroy());\n          }\n        }));\n      }\n      function q() {\n        this.points.forEach(function (a) {\n          let c = a.dataLabel,\n            e;\n          c && a.visible && ((e = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({\n            width: c._attr.width + \"px\",\n            textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n          }), c.shortened = !0), c.attr(c._attr), c[c.moved ? \"animate\" : \"attr\"](e), c.moved = !0) : c && c.attr({\n            y: -9999\n          }));\n          delete a.distributeBox;\n        }, this);\n      }\n      function y(a) {\n        let c = this.center,\n          e = this.options,\n          g = e.center,\n          b = e.minSize || 80,\n          f,\n          d = null !== e.size;\n        d || (null !== g[0] ? f = Math.max(c[2] - Math.max(a[1], a[3]), b) : (f = Math.max(c[2] - a[1] - a[3], b), c[0] += (a[3] - a[1]) / 2), null !== g[1] ? f = v(f, b, c[2] - Math.max(a[0], a[2])) : (f = v(f, b, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2), f < c[2] ? (c[2] = f, c[3] = Math.min(e.thickness ? Math.max(0, f - 2 * e.thickness) : Math.max(0, l(e.innerSize || 0, f)), f), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : d = !0);\n        return d;\n      }\n      const F = [],\n        e = {\n          radialDistributionY: function (a) {\n            return a.top + a.distributeBox.pos;\n          },\n          radialDistributionX: function (a, c, e, g) {\n            return a.getX(e < c.top + 2 || e > c.bottom - 2 ? g : e, c.half, c);\n          },\n          justify: function (a, c, e) {\n            return e[0] + (a.half ? -1 : 1) * (c + a.labelDistance);\n          },\n          alignToPlotEdges: function (a, c, e, g) {\n            a = a.getBBox().width;\n            return c ? a + g : e - a - g;\n          },\n          alignToConnectors: function (a, c, e, g) {\n            let b = 0,\n              f;\n            a.forEach(function (a) {\n              f = a.dataLabel.getBBox().width;\n              f > b && (b = f);\n            });\n            return c ? b + g : e - b - g;\n          }\n        };\n      h.compose = function (c) {\n        a.compose(z);\n        A.pushUnique(F, c) && (c = c.prototype, c.dataLabelPositioners = e, c.alignDataLabel = x, c.drawDataLabels = g, c.placeDataLabels = q, c.verifyDataLabelOverflow = y);\n      };\n    })(h || (h = {}));\n    return h;\n  });\n  M(a, \"Extensions/OverlappingDataLabels.js\", [a[\"Core/Chart/Chart.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x(a, c) {\n      let n,\n        r = !1;\n      a && (n = a.newOpacity, a.oldOpacity !== n && (a.alignAttr && a.placed ? (a[n ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), r = !0, a.alignAttr.opacity = n, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, function () {\n        c.styledMode || a.css({\n          pointerEvents: n ? \"auto\" : \"none\"\n        });\n      }), A(c, \"afterHideOverlappingLabel\")) : a.attr({\n        opacity: n\n      })), a.isOld = !0);\n      return r;\n    }\n    const {\n      addEvent: L,\n      fireEvent: A,\n      isArray: D,\n      isNumber: C,\n      objectEach: z,\n      pick: t\n    } = y;\n    L(a, \"render\", function () {\n      let a = this,\n        c = [];\n      (this.labelCollectors || []).forEach(function (a) {\n        c = c.concat(a());\n      });\n      (this.yAxis || []).forEach(function (a) {\n        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && z(a.stacking.stacks, function (a) {\n          z(a, function (a) {\n            a.label && c.push(a.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (n) {\n        var r = n.options.dataLabels;\n        n.visible && (!1 !== r.enabled || n._hasPointLabels) && (r = l => l.forEach(h => {\n          h.visible && (D(h.dataLabels) ? h.dataLabels : h.dataLabel ? [h.dataLabel] : []).forEach(function (l) {\n            const g = l.options;\n            l.labelrank = t(g.labelrank, h.labelrank, h.shapeArgs && h.shapeArgs.height);\n            g.allowOverlap ? (l.oldOpacity = l.opacity, l.newOpacity = 1, x(l, a)) : c.push(l);\n          });\n        }), r(n.nodes || []), r(n.points));\n      });\n      this.hideOverlappingLabels(c);\n    });\n    a.prototype.hideOverlappingLabels = function (a) {\n      let c = this,\n        n = a.length,\n        r = c.renderer;\n      var l;\n      let h;\n      let q,\n        g,\n        t,\n        v = !1;\n      var y = function (a) {\n        let c, e;\n        var g;\n        let h = a.box ? 0 : a.padding || 0,\n          b = g = 0,\n          f,\n          d;\n        if (a && (!a.alignAttr || a.placed)) return c = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, e = a.parentGroup, a.width || (g = a.getBBox(), a.width = g.width, a.height = g.height, g = r.fontMetrics(a.element).h), f = a.width - 2 * h, (d = {\n          left: \"0\",\n          center: \"0.5\",\n          right: \"1\"\n        }[a.alignValue]) ? b = +d * f : C(a.x) && Math.round(a.x) !== a.translateX && (b = a.x - a.translateX), {\n          x: c.x + (e.translateX || 0) + h - (b || 0),\n          y: c.y + (e.translateY || 0) + h - g,\n          width: a.width - 2 * h,\n          height: a.height - 2 * h\n        };\n      };\n      for (h = 0; h < n; h++) if (l = a[h]) l.oldOpacity = l.opacity, l.newOpacity = 1, l.absoluteBox = y(l);\n      a.sort(function (a, c) {\n        return (c.labelrank || 0) - (a.labelrank || 0);\n      });\n      for (h = 0; h < n; h++) for (g = (y = a[h]) && y.absoluteBox, l = h + 1; l < n; ++l) t = (q = a[l]) && q.absoluteBox, !g || !t || y === q || 0 === y.newOpacity || 0 === q.newOpacity || \"hidden\" === y.visibility || \"hidden\" === q.visibility || t.x >= g.x + g.width || t.x + t.width <= g.x || t.y >= g.y + g.height || t.y + t.height <= g.y || ((y.labelrank < q.labelrank ? y : q).newOpacity = 0);\n      a.forEach(function (a) {\n        x(a, c) && (v = !0);\n      });\n      v && A(c, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  M(a, \"Extensions/BorderRadius.js\", [a[\"Core/Defaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, y, G, L, A, D) {\n    const {\n      defaultOptions: x\n    } = a;\n    ({\n      seriesTypes: a\n    } = G);\n    const {\n        addEvent: z,\n        extend: t,\n        isObject: v,\n        merge: c,\n        relativeLength: n\n      } = D,\n      r = {\n        radius: 0,\n        scope: \"stack\",\n        where: void 0\n      },\n      l = (a, l) => {\n        v(a) || (a = {\n          radius: a || 0\n        });\n        return c(r, l, a);\n      };\n    if (-1 === L.symbolCustomAttribs.indexOf(\"borderRadius\")) {\n      L.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\");\n      const c = A.prototype.symbols.arc;\n      A.prototype.symbols.arc = function (a, h, l, q, e = {}) {\n        a = c(a, h, l, q, e);\n        const {\n          innerR: g = 0,\n          r = l,\n          start: p = 0,\n          end: t = 0\n        } = e;\n        if (e.open || !e.borderRadius) return a;\n        l = t - p;\n        h = Math.sin(l / 2);\n        e = Math.max(Math.min(n(e.borderRadius || 0, r - g), (r - g) / 2, r * h / (1 + h)), 0);\n        l = Math.min(e, l / Math.PI * 2 * g);\n        for (h = a.length - 1; h--;) {\n          {\n            let c = void 0,\n              g = void 0,\n              m = void 0;\n            q = a;\n            var b = h,\n              f = 1 < h ? l : e,\n              d = q[b],\n              k = q[b + 1];\n            \"Z\" === k[0] && (k = q[0]);\n            \"M\" !== d[0] && \"L\" !== d[0] || \"A\" !== k[0] ? \"A\" !== d[0] || \"M\" !== k[0] && \"L\" !== k[0] || (m = k, g = d) : (m = d, g = k, c = !0);\n            if (m && g && g.params) {\n              d = g[1];\n              var x = g[5];\n              k = g.params;\n              const {\n                start: a,\n                end: e,\n                cx: h,\n                cy: l\n              } = k;\n              var w = x ? d - f : d + f;\n              const n = w ? Math.asin(f / w) : 0;\n              x = x ? n : -n;\n              w *= Math.cos(n);\n              c ? (k.start = a + x, m[1] = h + w * Math.cos(a), m[2] = l + w * Math.sin(a), q.splice(b + 1, 0, [\"A\", f, f, 0, 0, 1, h + d * Math.cos(k.start), l + d * Math.sin(k.start)])) : (k.end = e - x, g[6] = h + d * Math.cos(k.end), g[7] = l + d * Math.sin(k.end), q.splice(b + 1, 0, [\"A\", f, f, 0, 0, 1, h + w * Math.cos(e), l + w * Math.sin(e)]));\n              g[4] = Math.abs(k.end - k.start) < Math.PI ? 0 : 1;\n            }\n          }\n        }\n        return a;\n      };\n      const q = A.prototype.symbols.roundedRect;\n      A.prototype.symbols.roundedRect = function (a, c, h, l, e = {}) {\n        const g = q(a, c, h, l, e),\n          {\n            r: n = 0,\n            brBoxHeight: p = l,\n            brBoxY: r = c\n          } = e;\n        var b = c - r,\n          f = r + p - (c + l);\n        e = -.1 < b - n ? 0 : n;\n        const d = -.1 < f - n ? 0 : n;\n        var k = Math.max(e && b, 0);\n        const t = Math.max(d && f, 0);\n        f = [a + e, c];\n        b = [a + h - e, c];\n        const x = [a + h, c + e],\n          v = [a + h, c + l - d],\n          w = [a + h - d, c + l],\n          y = [a + d, c + l],\n          z = [a, c + l - d],\n          A = [a, c + e];\n        if (k) {\n          const a = Math.sqrt(Math.pow(e, 2) - Math.pow(e - k, 2));\n          f[0] -= a;\n          b[0] += a;\n          x[1] = A[1] = c + e - k;\n        }\n        l < e - k && (k = Math.sqrt(Math.pow(e, 2) - Math.pow(e - k - l, 2)), x[0] = v[0] = a + h - e + k, w[0] = Math.min(x[0], w[0]), y[0] = Math.max(v[0], y[0]), z[0] = A[0] = a + e - k, x[1] = A[1] = c + l);\n        t && (k = Math.sqrt(Math.pow(d, 2) - Math.pow(d - t, 2)), w[0] += k, y[0] -= k, v[1] = z[1] = c + l - d + t);\n        l < d - t && (l = Math.sqrt(Math.pow(d, 2) - Math.pow(d - t - l, 2)), x[0] = v[0] = a + h - d + l, b[0] = Math.min(x[0], b[0]), f[0] = Math.max(v[0], f[0]), z[0] = A[0] = a + d - l, v[1] = z[1] = c);\n        g.length = 0;\n        g.push([\"M\", ...f], [\"L\", ...b], [\"A\", e, e, 0, 0, 1, ...x], [\"L\", ...v], [\"A\", d, d, 0, 0, 1, ...w], [\"L\", ...y], [\"A\", d, d, 0, 0, 1, ...z], [\"L\", ...A], [\"A\", e, e, 0, 0, 1, ...f], [\"Z\"]);\n        return g;\n      };\n      z(a.pie, \"afterTranslate\", function () {\n        const a = l(this.options.borderRadius);\n        for (const c of this.points) {\n          const g = c.shapeArgs;\n          g && (g.borderRadius = n(a.radius, (g.r || 0) - (g.innerR || 0)));\n        }\n      });\n      z(y, \"afterColumnTranslate\", function () {\n        var a, c;\n        if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {\n          const {\n              options: g,\n              yAxis: r\n            } = this,\n            p = \"percent\" === g.stacking;\n          var h = null === (c = null === (a = x.plotOptions) || void 0 === a ? void 0 : a[this.type]) || void 0 === c ? void 0 : c.borderRadius;\n          a = l(g.borderRadius, v(h) ? h : {});\n          c = r.options.reversed;\n          for (const l of this.points) if (({\n            shapeArgs: h\n          } = l), \"roundedRect\" === l.shapeType && h) {\n            const {\n              width: b = 0,\n              height: f = 0,\n              y: d = 0\n            } = h;\n            var q = d,\n              e = f;\n            \"stack\" === a.scope && l.stackTotal && (q = r.translate(p ? 100 : l.stackTotal, !1, !0, !1, !0), e = r.translate(g.threshold || 0, !1, !0, !1, !0), e = this.crispCol(0, Math.min(q, e), 0, Math.abs(q - e)), q = e.y, e = e.height);\n            const k = -1 === (l.negative ? -1 : 1) * (c ? -1 : 1);\n            let m = a.where;\n            !m && this.is(\"waterfall\") && Math.abs((l.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (m = \"all\");\n            m || (m = \"end\");\n            const u = Math.min(n(a.radius, b), b / 2, \"all\" === m ? f / 2 : Infinity) || 0;\n            \"end\" === m && (k && (q -= u), e += u);\n            t(h, {\n              brBoxHeight: e,\n              brBoxY: q,\n              r: u\n            });\n          }\n        }\n      }, {\n        order: 9\n      });\n    }\n    y = {\n      optionsToObject: l\n    };\n    \"\";\n    return y;\n  });\n  M(a, \"Core/Responsive.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      extend: x,\n      find: G,\n      isArray: L,\n      isObject: A,\n      merge: D,\n      objectEach: C,\n      pick: z,\n      splat: t,\n      uniqueKey: v\n    } = a;\n    var c;\n    (function (c) {\n      function n(a) {\n        function c(a, h, l, n) {\n          let e;\n          C(a, function (a, f) {\n            if (!n && -1 < g.collectionsWithUpdate.indexOf(f) && h[f]) for (a = t(a), l[f] = [], e = 0; e < Math.max(a.length, h[f].length); e++) h[f][e] && (void 0 === a[e] ? l[f][e] = h[f][e] : (l[f][e] = {}, c(a[e], h[f][e], l[f][e], n + 1)));else A(a) ? (l[f] = L(a) ? [] : {}, c(a, h[f] || {}, l[f], n + 1)) : l[f] = \"undefined\" === typeof h[f] ? null : h[f];\n          });\n        }\n        const g = this,\n          h = {};\n        c(a, this.options, h, 0);\n        return h;\n      }\n      function l(a, c) {\n        const g = a.condition;\n        (g.callback || function () {\n          return this.chartWidth <= z(g.maxWidth, Number.MAX_VALUE) && this.chartHeight <= z(g.maxHeight, Number.MAX_VALUE) && this.chartWidth >= z(g.minWidth, 0) && this.chartHeight >= z(g.minHeight, 0);\n        }).call(this) && c.push(a._id);\n      }\n      function h(a, c) {\n        const g = this.options.responsive;\n        var h = this.currentResponsive;\n        let e = [];\n        !c && g && g.rules && g.rules.forEach(a => {\n          \"undefined\" === typeof a._id && (a._id = v());\n          this.matchResponsiveRule(a, e);\n        }, this);\n        c = D(...e.map(a => G((g || {}).rules || [], c => c._id === a)).map(a => a && a.chartOptions));\n        c.isResponsiveOptions = !0;\n        e = e.toString() || void 0;\n        e !== (h && h.ruleIds) && (h && this.update(h.undoOptions, a, !0), e ? (h = this.currentOptions(c), h.isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: e,\n          mergedOptions: c,\n          undoOptions: h\n        }, this.update(c, a, !0)) : this.currentResponsive = void 0);\n      }\n      const q = [];\n      c.compose = function (c) {\n        a.pushUnique(q, c) && x(c.prototype, {\n          currentOptions: n,\n          matchResponsiveRule: l,\n          setResponsive: h\n        });\n        return c;\n      };\n    })(c || (c = {}));\n    \"\";\n    \"\";\n    return c;\n  });\n  M(a, \"masters/highcharts.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Animation/Fx.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Renderer/HTML/HTMLElement.js\"], a[\"Core/Renderer/HTML/HTMLRenderer.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Axis/DateTimeAxis.js\"], a[\"Core/Axis/LogarithmicAxis.js\"], a[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Tooltip.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Pointer.js\"], a[\"Core/Legend/Legend.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Axis/Stacking/StackingAxis.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Series/Column/ColumnDataLabel.js\"], a[\"Series/Pie/PieSeries.js\"], a[\"Series/Pie/PieDataLabel.js\"], a[\"Core/Series/DataLabel.js\"], a[\"Core/Responsive.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Time.js\"]], function (a, y, G, L, A, D, C, z, t, v, c, n, r, l, h, q, g, w, J, F, e, m, u, p, H, b, f, d, k, M, N, E, S, T) {\n    a.animate = A.animate;\n    a.animObject = A.animObject;\n    a.getDeferredAnimation = A.getDeferredAnimation;\n    a.setAnimation = A.setAnimation;\n    a.stop = A.stop;\n    a.timers = L.timers;\n    a.AST = D;\n    a.Axis = r;\n    a.Chart = m;\n    a.chart = m.chart;\n    a.Fx = L;\n    a.Legend = e;\n    a.PlotLineOrBand = q;\n    a.Point = J;\n    a.Pointer = F;\n    a.Series = H;\n    a.StackItem = p;\n    a.SVGElement = t;\n    a.SVGRenderer = v;\n    a.Tick = g;\n    a.Time = T;\n    a.Tooltip = w;\n    a.Color = S;\n    a.color = S.parse;\n    n.compose(v);\n    c.compose(t);\n    F.compose(m);\n    e.compose(m);\n    a.defaultOptions = G.defaultOptions;\n    a.getOptions = G.getOptions;\n    a.time = G.defaultTime;\n    a.setOptions = G.setOptions;\n    a.dateFormat = C.dateFormat;\n    a.format = C.format;\n    a.numberFormat = C.numberFormat;\n    a.addEvent = y.addEvent;\n    a.arrayMax = y.arrayMax;\n    a.arrayMin = y.arrayMin;\n    a.attr = y.attr;\n    a.clearTimeout = y.clearTimeout;\n    a.correctFloat = y.correctFloat;\n    a.createElement = y.createElement;\n    a.css = y.css;\n    a.defined = y.defined;\n    a.destroyObjectProperties = y.destroyObjectProperties;\n    a.discardElement = y.discardElement;\n    a.distribute = z.distribute;\n    a.erase = y.erase;\n    a.error = y.error;\n    a.extend = y.extend;\n    a.extendClass = y.extendClass;\n    a.find = y.find;\n    a.fireEvent = y.fireEvent;\n    a.getMagnitude = y.getMagnitude;\n    a.getStyle = y.getStyle;\n    a.inArray = y.inArray;\n    a.isArray = y.isArray;\n    a.isClass = y.isClass;\n    a.isDOMElement = y.isDOMElement;\n    a.isFunction = y.isFunction;\n    a.isNumber = y.isNumber;\n    a.isObject = y.isObject;\n    a.isString = y.isString;\n    a.keys = y.keys;\n    a.merge = y.merge;\n    a.normalizeTickInterval = y.normalizeTickInterval;\n    a.objectEach = y.objectEach;\n    a.offset = y.offset;\n    a.pad = y.pad;\n    a.pick = y.pick;\n    a.pInt = y.pInt;\n    a.relativeLength = y.relativeLength;\n    a.removeEvent = y.removeEvent;\n    a.seriesType = b.seriesType;\n    a.splat = y.splat;\n    a.stableSort = y.stableSort;\n    a.syncTimeout = y.syncTimeout;\n    a.timeUnits = y.timeUnits;\n    a.uniqueKey = y.uniqueKey;\n    a.useSerialIds = y.useSerialIds;\n    a.wrap = y.wrap;\n    d.compose(f);\n    N.compose(H);\n    l.compose(r);\n    h.compose(r);\n    M.compose(k);\n    q.compose(r);\n    E.compose(m);\n    u.compose(r, m, H);\n    w.compose(F);\n    return a;\n  });\n  a[\"masters/highcharts.src.js\"]._modules = a;\n  return a[\"masters/highcharts.src.js\"];\n});\n//# sourceMappingURL=highcharts.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
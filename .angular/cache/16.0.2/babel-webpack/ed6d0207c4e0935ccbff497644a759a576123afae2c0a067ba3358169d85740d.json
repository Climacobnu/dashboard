{"ast":null,"code":"/*\n Highcharts Gantt JS v11.0.1 (2023-05-08)\n\n (c) 2017-2021 Lars Cabrera, Torstein Honsi, Jon Arild Nygard & Oystein Moseng\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (W, L) {\n  \"object\" === typeof module && module.exports ? (L[\"default\"] = L, module.exports = W.document ? L(W) : L) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-gantt\", function () {\n    return L(W);\n  }) : (W.Highcharts && W.Highcharts.error(16, !0), W.Highcharts = L(W));\n})(\"undefined\" !== typeof window ? window : this, function (W) {\n  function L(a, z, F, H) {\n    a.hasOwnProperty(z) || (a[z] = H.apply(null, F), \"function\" === typeof CustomEvent && W.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: z,\n        module: a[z]\n      }\n    })));\n  }\n  var a = {};\n  L(a, \"Core/Globals.js\", [], function () {\n    var a;\n    (function (a) {\n      a.SVG_NS = \"http://www.w3.org/2000/svg\";\n      a.product = \"Highcharts\";\n      a.version = \"11.0.1\";\n      a.win = \"undefined\" !== typeof W ? W : {};\n      a.doc = a.win.document;\n      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, \"svg\").createSVGRect;\n      a.userAgent = a.win.navigator && a.win.navigator.userAgent || \"\";\n      a.isChrome = -1 !== a.userAgent.indexOf(\"Chrome\");\n      a.isFirefox = -1 !== a.userAgent.indexOf(\"Firefox\");\n      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;\n      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf(\"Safari\");\n      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);\n      a.isWebKit = -1 !== a.userAgent.indexOf(\"AppleWebKit\");\n      a.deg2rad = 2 * Math.PI / 360;\n      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split(\"Firefox/\")[1], 10);\n      a.hasTouch = !!a.win.TouchEvent;\n      a.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"];\n      a.noop = function () {};\n      a.supportsPassiveEvents = function () {\n        let y = !1;\n        if (!a.isMS) {\n          const z = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              y = !0;\n            }\n          });\n          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener(\"testPassive\", a.noop, z), a.win.removeEventListener(\"testPassive\", a.noop, z));\n        }\n        return y;\n      }();\n      a.charts = [];\n      a.dateFormats = {};\n      a.seriesTypes = {};\n      a.symbolSizes = {};\n      a.chartCount = 0;\n    })(a || (a = {}));\n    \"\";\n    return a;\n  });\n  L(a, \"Core/Utilities.js\", [a[\"Core/Globals.js\"]], function (a) {\n    function y(c, b, d, h) {\n      const n = b ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === c && (c = `${n}: Deprecated member`);\n      const G = r(c);\n      let u = G ? `${n} #${c}: www.highcharts.com/errors/${c}/` : c.toString();\n      if (\"undefined\" !== typeof h) {\n        let c = \"\";\n        G && (u += \"?\");\n        J(h, function (b, n) {\n          c += `\\n - ${n}: ${b}`;\n          G && (u += encodeURI(n) + \"=\" + encodeURI(b));\n        });\n        u += c;\n      }\n      e(a, \"displayError\", {\n        chart: d,\n        code: c,\n        message: u,\n        params: h\n      }, function () {\n        if (b) throw Error(u);\n        q.console && -1 === y.messages.indexOf(u) && console.warn(u);\n      });\n      y.messages.push(u);\n    }\n    function F(c, b) {\n      const n = {};\n      J(c, function (d, h) {\n        if (E(c[h], !0) && !c.nodeType && b[h]) d = F(c[h], b[h]), Object.keys(d).length && (n[h] = d);else if (E(c[h]) || c[h] !== b[h] || h in c && !(h in b)) n[h] = c[h];\n      });\n      return n;\n    }\n    function H(c, b) {\n      return parseInt(c, b || 10);\n    }\n    function A(c) {\n      return \"string\" === typeof c;\n    }\n    function D(c) {\n      c = Object.prototype.toString.call(c);\n      return \"[object Array]\" === c || \"[object Array Iterator]\" === c;\n    }\n    function E(c, b) {\n      return !!c && \"object\" === typeof c && (!b || !D(c));\n    }\n    function B(c) {\n      return E(c) && \"number\" === typeof c.nodeType;\n    }\n    function t(c) {\n      const b = c && c.constructor;\n      return !(!E(c, !0) || B(c) || !b || !b.name || \"Object\" === b.name);\n    }\n    function r(c) {\n      return \"number\" === typeof c && !isNaN(c) && Infinity > c && -Infinity < c;\n    }\n    function g(c) {\n      return \"undefined\" !== typeof c && null !== c;\n    }\n    function p(c, b, d) {\n      const n = A(b) && !g(d);\n      let h;\n      const e = (b, d) => {\n        g(b) ? c.setAttribute(d, b) : n ? (h = c.getAttribute(d)) || \"class\" !== d || (h = c.getAttribute(d + \"Name\")) : c.removeAttribute(d);\n      };\n      A(b) ? e(d, b) : J(b, e);\n      return h;\n    }\n    function v(c, b) {\n      let n;\n      c || (c = {});\n      for (n in b) c[n] = b[n];\n      return c;\n    }\n    function l() {\n      const c = arguments,\n        b = c.length;\n      for (let n = 0; n < b; n++) {\n        const b = c[n];\n        if (\"undefined\" !== typeof b && null !== b) return b;\n      }\n    }\n    function m(c, b) {\n      a.isMS && !a.svg && b && g(b.opacity) && (b.filter = `alpha(opacity=${100 * b.opacity})`);\n      v(c.style, b);\n    }\n    function f(c) {\n      return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));\n    }\n    function k(c, b) {\n      return 1E14 < c ? c : parseFloat(c.toPrecision(b || 14));\n    }\n    function x(c, b, d) {\n      let n;\n      if (\"width\" === b) return b = Math.min(c.offsetWidth, c.scrollWidth), d = c.getBoundingClientRect && c.getBoundingClientRect().width, d < b && d >= b - 1 && (b = Math.floor(d)), Math.max(0, b - (x(c, \"padding-left\", !0) || 0) - (x(c, \"padding-right\", !0) || 0));\n      if (\"height\" === b) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (x(c, \"padding-top\", !0) || 0) - (x(c, \"padding-bottom\", !0) || 0));\n      if (c = q.getComputedStyle(c, void 0)) n = c.getPropertyValue(b), l(d, \"opacity\" !== b) && (n = H(n));\n      return n;\n    }\n    function J(c, b, d) {\n      for (const n in c) Object.hasOwnProperty.call(c, n) && b.call(d || c[n], c[n], n, c);\n    }\n    function C(c, b, d) {\n      function n(b, d) {\n        const n = c.removeEventListener;\n        n && n.call(c, b, d, !1);\n      }\n      function h(d) {\n        let h, e;\n        c.nodeName && (b ? (h = {}, h[b] = !0) : h = d, J(h, function (c, b) {\n          if (d[b]) for (e = d[b].length; e--;) n(b, d[b][e].fn);\n        }));\n      }\n      var e = \"function\" === typeof c && c.prototype || c;\n      if (Object.hasOwnProperty.call(e, \"hcEvents\")) {\n        const c = e.hcEvents;\n        b ? (e = c[b] || [], d ? (c[b] = e.filter(function (c) {\n          return d !== c.fn;\n        }), n(b, d)) : (h(c), c[b] = [])) : (h(c), delete e.hcEvents);\n      }\n    }\n    function e(c, b, d, h) {\n      d = d || {};\n      if (w.createEvent && (c.dispatchEvent || c.fireEvent && c !== a)) {\n        var n = w.createEvent(\"Events\");\n        n.initEvent(b, !0, !0);\n        d = v(n, d);\n        c.dispatchEvent ? c.dispatchEvent(d) : c.fireEvent(b, d);\n      } else if (c.hcEvents) {\n        d.target || v(d, {\n          preventDefault: function () {\n            d.defaultPrevented = !0;\n          },\n          target: c,\n          type: b\n        });\n        n = [];\n        let h = c,\n          e = !1;\n        for (; h.hcEvents;) Object.hasOwnProperty.call(h, \"hcEvents\") && h.hcEvents[b] && (n.length && (e = !0), n.unshift.apply(n, h.hcEvents[b])), h = Object.getPrototypeOf(h);\n        e && n.sort((c, b) => c.order - b.order);\n        n.forEach(b => {\n          !1 === b.fn.call(c, d) && d.preventDefault();\n        });\n      }\n      h && !d.defaultPrevented && h.call(c, d);\n    }\n    const {\n      charts: h,\n      doc: w,\n      win: q\n    } = a;\n    (y || (y = {})).messages = [];\n    Math.easeInOutSine = function (c) {\n      return -.5 * (Math.cos(Math.PI * c) - 1);\n    };\n    var u = Array.prototype.find ? function (c, b) {\n      return c.find(b);\n    } : function (c, b) {\n      let d;\n      const n = c.length;\n      for (d = 0; d < n; d++) if (b(c[d], d)) return c[d];\n    };\n    J({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (c, b) {\n      a[b] = function (d) {\n        y(32, !1, void 0, {\n          [`Highcharts.${b}`]: `use Array.${c}`\n        });\n        return Array.prototype[c].apply(d, [].slice.call(arguments, 1));\n      };\n    });\n    let d;\n    const b = function () {\n      const c = Math.random().toString(36).substring(2, 9) + \"-\";\n      let b = 0;\n      return function () {\n        return \"highcharts-\" + (d ? \"\" : c) + b++;\n      };\n    }();\n    q.jQuery && (q.jQuery.fn.highcharts = function () {\n      const c = [].slice.call(arguments);\n      if (this[0]) return c[0] ? (new a[A(c[0]) ? c.shift() : \"Chart\"](this[0], c[0], c[1]), this) : h[p(this[0], \"data-highcharts-chart\")];\n    });\n    u = {\n      addEvent: function (c, b, d, h = {}) {\n        var n = \"function\" === typeof c && c.prototype || c;\n        Object.hasOwnProperty.call(n, \"hcEvents\") || (n.hcEvents = {});\n        n = n.hcEvents;\n        a.Point && c instanceof a.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = !0);\n        const e = c.addEventListener;\n        e && e.call(c, b, d, a.supportsPassiveEvents ? {\n          passive: void 0 === h.passive ? -1 !== b.indexOf(\"touch\") : h.passive,\n          capture: !1\n        } : !1);\n        n[b] || (n[b] = []);\n        n[b].push({\n          fn: d,\n          order: \"number\" === typeof h.order ? h.order : Infinity\n        });\n        n[b].sort((c, b) => c.order - b.order);\n        return function () {\n          C(c, b, d);\n        };\n      },\n      arrayMax: function (c) {\n        let b = c.length,\n          d = c[0];\n        for (; b--;) c[b] > d && (d = c[b]);\n        return d;\n      },\n      arrayMin: function (c) {\n        let b = c.length,\n          d = c[0];\n        for (; b--;) c[b] < d && (d = c[b]);\n        return d;\n      },\n      attr: p,\n      clamp: function (c, b, d) {\n        return c > b ? c < d ? c : d : b;\n      },\n      cleanRecursively: F,\n      clearTimeout: function (c) {\n        g(c) && clearTimeout(c);\n      },\n      correctFloat: k,\n      createElement: function (c, b, d, h, e) {\n        c = w.createElement(c);\n        b && v(c, b);\n        e && m(c, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        });\n        d && m(c, d);\n        h && h.appendChild(c);\n        return c;\n      },\n      css: m,\n      defined: g,\n      destroyObjectProperties: function (c, b) {\n        J(c, function (d, n) {\n          d && d !== b && d.destroy && d.destroy();\n          delete c[n];\n        });\n      },\n      discardElement: function (c) {\n        c && c.parentElement && c.parentElement.removeChild(c);\n      },\n      erase: function (c, b) {\n        let d = c.length;\n        for (; d--;) if (c[d] === b) {\n          c.splice(d, 1);\n          break;\n        }\n      },\n      error: y,\n      extend: v,\n      extendClass: function (c, b) {\n        const d = function () {};\n        d.prototype = new c();\n        v(d.prototype, b);\n        return d;\n      },\n      find: u,\n      fireEvent: e,\n      getMagnitude: f,\n      getNestedProperty: function (c, b) {\n        for (c = c.split(\".\"); c.length && g(b);) {\n          const d = c.shift();\n          if (\"undefined\" === typeof d || \"__proto__\" === d) return;\n          b = b[d];\n          if (!g(b) || \"function\" === typeof b || \"number\" === typeof b.nodeType || b === q) return;\n        }\n        return b;\n      },\n      getStyle: x,\n      inArray: function (c, b, d) {\n        y(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return b.indexOf(c, d);\n      },\n      isArray: D,\n      isClass: t,\n      isDOMElement: B,\n      isFunction: function (b) {\n        return \"function\" === typeof b;\n      },\n      isNumber: r,\n      isObject: E,\n      isString: A,\n      keys: function (b) {\n        y(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(b);\n      },\n      merge: function () {\n        let b,\n          d = arguments,\n          h = {};\n        const e = function (b, c) {\n          \"object\" !== typeof b && (b = {});\n          J(c, function (d, n) {\n            \"__proto__\" !== n && \"constructor\" !== n && (!E(d, !0) || t(d) || B(d) ? b[n] = c[n] : b[n] = e(b[n] || {}, d));\n          });\n          return b;\n        };\n        !0 === d[0] && (h = d[1], d = Array.prototype.slice.call(d, 2));\n        const q = d.length;\n        for (b = 0; b < q; b++) h = e(h, d[b]);\n        return h;\n      },\n      normalizeTickInterval: function (b, d, h, e, q) {\n        let c = b;\n        h = l(h, f(b));\n        const n = b / h;\n        d || (d = q ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === e && (1 === h ? d = d.filter(function (b) {\n          return 0 === b % 1;\n        }) : .1 >= h && (d = [1 / h])));\n        for (e = 0; e < d.length && !(c = d[e], q && c * h >= b || !q && n <= (d[e] + (d[e + 1] || d[e])) / 2); e++);\n        return c = k(c * h, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: J,\n      offset: function (b) {\n        const c = w.documentElement;\n        b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: b.top + (q.pageYOffset || c.scrollTop) - (c.clientTop || 0),\n          left: b.left + (q.pageXOffset || c.scrollLeft) - (c.clientLeft || 0),\n          width: b.width,\n          height: b.height\n        };\n      },\n      pad: function (b, d, h) {\n        return Array((d || 2) + 1 - String(b).replace(\"-\", \"\").length).join(h || \"0\") + b;\n      },\n      pick: l,\n      pInt: H,\n      pushUnique: function (b, d) {\n        return 0 > b.indexOf(d) && !!b.push(d);\n      },\n      relativeLength: function (b, d, h) {\n        return /%$/.test(b) ? d * parseFloat(b) / 100 + (h || 0) : parseFloat(b);\n      },\n      removeEvent: C,\n      splat: function (b) {\n        return D(b) ? b : [b];\n      },\n      stableSort: function (b, d) {\n        const c = b.length;\n        let n, h;\n        for (h = 0; h < c; h++) b[h].safeI = h;\n        b.sort(function (b, c) {\n          n = d(b, c);\n          return 0 === n ? b.safeI - c.safeI : n;\n        });\n        for (h = 0; h < c; h++) delete b[h].safeI;\n      },\n      syncTimeout: function (b, d, h) {\n        if (0 < d) return setTimeout(b, d, h);\n        b.call(0, h);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: b,\n      useSerialIds: function (b) {\n        return d = l(b, d);\n      },\n      wrap: function (b, d, h) {\n        const c = b[d];\n        b[d] = function () {\n          const b = arguments,\n            d = this;\n          return h.apply(this, [function () {\n            return c.apply(d, arguments.length ? arguments : b);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n    \"\";\n    return u;\n  });\n  L(a, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {\n          zIndex: 6\n        },\n        position: {\n          align: \"right\",\n          x: -10,\n          y: 10\n        }\n      },\n      reflow: !0,\n      type: \"line\",\n      zoomBySingleTouch: !1,\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#334eff\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  });\n  L(a, \"Core/Color/Color.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    const {\n      isNumber: y,\n      merge: H,\n      pInt: A\n    } = z;\n    class D {\n      static parse(a) {\n        return a ? new D(a) : D.None;\n      }\n      constructor(E) {\n        this.rgba = [NaN, NaN, NaN, NaN];\n        this.input = E;\n        const B = a.Color;\n        if (B && B !== D) return new B(E);\n        this.init(E);\n      }\n      init(a) {\n        let B;\n        let t;\n        if (\"object\" === typeof a && \"undefined\" !== typeof a.stops) this.stops = a.stops.map(g => new D(g[1]));else if (\"string\" === typeof a) {\n          this.input = a = D.names[a.toLowerCase()] || a;\n          if (\"#\" === a.charAt(0)) {\n            var r = a.length;\n            var g = parseInt(a.substr(1), 16);\n            7 === r ? B = [(g & 16711680) >> 16, (g & 65280) >> 8, g & 255, 1] : 4 === r && (B = [(g & 3840) >> 4 | (g & 3840) >> 8, (g & 240) >> 4 | g & 240, (g & 15) << 4 | g & 15, 1]);\n          }\n          if (!B) for (g = D.parsers.length; g-- && !B;) t = D.parsers[g], (r = t.regex.exec(a)) && (B = t.parse(r));\n        }\n        B && (this.rgba = B);\n      }\n      get(a) {\n        const B = this.input,\n          t = this.rgba;\n        if (\"object\" === typeof B && \"undefined\" !== typeof this.stops) {\n          const r = H(B);\n          r.stops = [].slice.call(r.stops);\n          this.stops.forEach((g, p) => {\n            r.stops[p] = [r.stops[p][0], g.get(a)];\n          });\n          return r;\n        }\n        return t && y(t[0]) ? \"rgb\" === a || !a && 1 === t[3] ? \"rgb(\" + t[0] + \",\" + t[1] + \",\" + t[2] + \")\" : \"a\" === a ? `${t[3]}` : \"rgba(\" + t.join(\",\") + \")\" : B;\n      }\n      brighten(a) {\n        const B = this.rgba;\n        if (this.stops) this.stops.forEach(function (t) {\n          t.brighten(a);\n        });else if (y(a) && 0 !== a) for (let t = 0; 3 > t; t++) B[t] += A(255 * a), 0 > B[t] && (B[t] = 0), 255 < B[t] && (B[t] = 255);\n        return this;\n      }\n      setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      }\n      tweenTo(a, B) {\n        const t = this.rgba,\n          r = a.rgba;\n        if (!y(t[0]) || !y(r[0])) return a.input || \"none\";\n        a = 1 !== r[3] || 1 !== t[3];\n        return (a ? \"rgba(\" : \"rgb(\") + Math.round(r[0] + (t[0] - r[0]) * (1 - B)) + \",\" + Math.round(r[1] + (t[1] - r[1]) * (1 - B)) + \",\" + Math.round(r[2] + (t[2] - r[2]) * (1 - B)) + (a ? \",\" + (r[3] + (t[3] - r[3]) * (1 - B)) : \"\") + \")\";\n      }\n    }\n    D.names = {\n      white: \"#ffffff\",\n      black: \"#000000\"\n    };\n    D.parsers = [{\n      regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n      parse: function (a) {\n        return [A(a[1]), A(a[2]), A(a[3]), parseFloat(a[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n      parse: function (a) {\n        return [A(a[1]), A(a[2]), A(a[3]), 1];\n      }\n    }];\n    D.None = new D(\"\");\n    \"\";\n    return D;\n  });\n  L(a, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: \"#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1\".split(\" \")\n    };\n  });\n  L(a, \"Core/Time.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    const {\n        win: y\n      } = a,\n      {\n        defined: H,\n        error: A,\n        extend: D,\n        isObject: E,\n        merge: B,\n        objectEach: t,\n        pad: r,\n        pick: g,\n        splat: p,\n        timeUnits: v\n      } = z,\n      l = a.isSafari && y.Intl && y.Intl.DateTimeFormat.prototype.formatRange,\n      m = a.isSafari && y.Intl && !y.Intl.DateTimeFormat.prototype.formatRange;\n    class f {\n      constructor(k) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = y.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(k);\n      }\n      get(k, f) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          const x = f.getTime(),\n            g = x - this.getTimezoneOffset(f);\n          f.setTime(g);\n          k = f[\"getUTC\" + k]();\n          f.setTime(x);\n          return k;\n        }\n        return this.useUTC ? f[\"getUTC\" + k]() : f[\"get\" + k]();\n      }\n      set(k, f, g) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === k || \"Seconds\" === k || \"Minutes\" === k && 0 === this.getTimezoneOffset(f) % 36E5) return f[\"setUTC\" + k](g);\n          var x = this.getTimezoneOffset(f);\n          x = f.getTime() - x;\n          f.setTime(x);\n          f[\"setUTC\" + k](g);\n          k = this.getTimezoneOffset(f);\n          x = f.getTime() + k;\n          return f.setTime(x);\n        }\n        return this.useUTC || l && \"FullYear\" === k ? f[\"setUTC\" + k](g) : f[\"set\" + k](g);\n      }\n      update(k = {}) {\n        const f = g(k.useUTC, !0);\n        this.options = k = B(!0, this.options, k);\n        this.Date = k.Date || y.Date || Date;\n        this.timezoneOffset = (this.useUTC = f) && k.timezoneOffset || void 0;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = f && !(!k.getTimezoneOffset && !k.timezone);\n      }\n      makeTime(k, f, l, p, e, h) {\n        let w, q, u;\n        this.useUTC ? (w = this.Date.UTC.apply(0, arguments), q = this.getTimezoneOffset(w), w += q, u = this.getTimezoneOffset(w), q !== u ? w += u - q : q - 36E5 !== this.getTimezoneOffset(w - 36E5) || m || (w -= 36E5)) : w = new this.Date(k, f, g(l, 1), g(p, 0), g(e, 0), g(h, 0)).getTime();\n        return w;\n      }\n      timezoneOffsetFunction() {\n        const k = this,\n          f = this.options,\n          g = f.getTimezoneOffset,\n          l = f.moment || y.moment;\n        if (!this.useUTC) return function (e) {\n          return 6E4 * new Date(e.toString()).getTimezoneOffset();\n        };\n        if (f.timezone) {\n          if (l) return function (e) {\n            return 6E4 * -l.tz(e, f.timezone).utcOffset();\n          };\n          A(25);\n        }\n        return this.useUTC && g ? function (e) {\n          return 6E4 * g(e.valueOf());\n        } : function () {\n          return 6E4 * (k.timezoneOffset || 0);\n        };\n      }\n      dateFormat(k, f, l) {\n        if (!H(f) || isNaN(f)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || \"\";\n        k = g(k, \"%Y-%m-%d %H:%M:%S\");\n        const x = this;\n        var e = new this.Date(f);\n        const h = this.get(\"Hours\", e),\n          w = this.get(\"Day\", e),\n          q = this.get(\"Date\", e),\n          u = this.get(\"Month\", e),\n          d = this.get(\"FullYear\", e),\n          b = a.defaultOptions.lang,\n          c = b && b.weekdays,\n          n = b && b.shortWeekdays;\n        e = D({\n          a: n ? n[w] : c[w].substr(0, 3),\n          A: c[w],\n          d: r(q),\n          e: r(q, 2, \" \"),\n          w,\n          b: b.shortMonths[u],\n          B: b.months[u],\n          m: r(u + 1),\n          o: u + 1,\n          y: d.toString().substr(2, 2),\n          Y: d,\n          H: r(h),\n          k: h,\n          I: r(h % 12 || 12),\n          l: h % 12 || 12,\n          M: r(this.get(\"Minutes\", e)),\n          p: 12 > h ? \"AM\" : \"PM\",\n          P: 12 > h ? \"am\" : \"pm\",\n          S: r(e.getSeconds()),\n          L: r(Math.floor(f % 1E3), 3)\n        }, a.dateFormats);\n        t(e, function (b, c) {\n          for (; -1 !== k.indexOf(\"%\" + c);) k = k.replace(\"%\" + c, \"function\" === typeof b ? b.call(x, f) : b);\n        });\n        return l ? k.substr(0, 1).toUpperCase() + k.substr(1) : k;\n      }\n      resolveDTLFormat(k) {\n        return E(k, !0) ? k : (k = p(k), {\n          main: k[0],\n          from: k[1],\n          to: k[2]\n        });\n      }\n      getTimeTicks(k, f, l, m) {\n        const e = this,\n          h = [],\n          w = {};\n        var q = new e.Date(f);\n        const u = k.unitRange,\n          d = k.count || 1;\n        let b;\n        m = g(m, 1);\n        if (H(f)) {\n          e.set(\"Milliseconds\", q, u >= v.second ? 0 : d * Math.floor(e.get(\"Milliseconds\", q) / d));\n          u >= v.second && e.set(\"Seconds\", q, u >= v.minute ? 0 : d * Math.floor(e.get(\"Seconds\", q) / d));\n          u >= v.minute && e.set(\"Minutes\", q, u >= v.hour ? 0 : d * Math.floor(e.get(\"Minutes\", q) / d));\n          u >= v.hour && e.set(\"Hours\", q, u >= v.day ? 0 : d * Math.floor(e.get(\"Hours\", q) / d));\n          u >= v.day && e.set(\"Date\", q, u >= v.month ? 1 : Math.max(1, d * Math.floor(e.get(\"Date\", q) / d)));\n          if (u >= v.month) {\n            e.set(\"Month\", q, u >= v.year ? 0 : d * Math.floor(e.get(\"Month\", q) / d));\n            var c = e.get(\"FullYear\", q);\n          }\n          u >= v.year && e.set(\"FullYear\", q, c - c % d);\n          u === v.week && (c = e.get(\"Day\", q), e.set(\"Date\", q, e.get(\"Date\", q) - c + m + (c < m ? -7 : 0)));\n          c = e.get(\"FullYear\", q);\n          m = e.get(\"Month\", q);\n          const n = e.get(\"Date\", q),\n            k = e.get(\"Hours\", q);\n          f = q.getTime();\n          !e.variableTimezone && e.useUTC || !H(l) || (b = l - f > 4 * v.month || e.getTimezoneOffset(f) !== e.getTimezoneOffset(l));\n          f = q.getTime();\n          for (q = 1; f < l;) h.push(f), f = u === v.year ? e.makeTime(c + q * d, 0) : u === v.month ? e.makeTime(c, m + q * d) : !b || u !== v.day && u !== v.week ? b && u === v.hour && 1 < d ? e.makeTime(c, m, n, k + q * d) : f + u * d : e.makeTime(c, m, n + q * d * (u === v.day ? 1 : 7)), q++;\n          h.push(f);\n          u <= v.hour && 1E4 > h.length && h.forEach(function (b) {\n            0 === b % 18E5 && \"000000000\" === e.dateFormat(\"%H%M%S%L\", b) && (w[b] = \"day\");\n          });\n        }\n        h.info = D(k, {\n          higherRanks: w,\n          totalRange: u * d\n        });\n        return h;\n      }\n      getDateFormat(f, g, l, m) {\n        const e = this.dateFormat(\"%m-%d %H:%M:%S.%L\", g),\n          h = {\n            millisecond: 15,\n            second: 12,\n            minute: 9,\n            hour: 6,\n            day: 3\n          };\n        let k,\n          q = \"millisecond\";\n        for (k in v) {\n          if (f === v.week && +this.dateFormat(\"%w\", g) === l && \"00:00:00.000\" === e.substr(6)) {\n            k = \"week\";\n            break;\n          }\n          if (v[k] > f) {\n            k = q;\n            break;\n          }\n          if (h[k] && e.substr(h[k]) !== \"01-01 00:00:00.000\".substr(h[k])) break;\n          \"week\" !== k && (q = k);\n        }\n        return this.resolveDTLFormat(m[k]).main;\n      }\n    }\n    \"\";\n    return f;\n  });\n  L(a, \"Core/Defaults.js\", [a[\"Core/Chart/ChartDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Color/Palettes.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D) {\n    const {\n        isTouchDevice: y,\n        svg: B\n      } = F,\n      {\n        merge: t\n      } = D,\n      r = {\n        colors: H.colors,\n        symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n        lang: {\n          loading: \"Loading...\",\n          months: \"January February March April May June July August September October November December\".split(\" \"),\n          shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n          weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n          decimalPoint: \".\",\n          numericSymbols: \"kMGTPE\".split(\"\"),\n          resetZoom: \"Reset zoom\",\n          resetZoomTitle: \"Reset zoom level 1:1\",\n          thousandsSep: \" \"\n        },\n        global: {},\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: a,\n        title: {\n          text: \"Chart title\",\n          align: \"center\",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          text: \"\",\n          align: \"center\",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          text: \"\",\n          align: \"left\",\n          verticalAlign: \"bottom\"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: \"center\",\n          alignColumns: !0,\n          className: \"highcharts-no-tooltip\",\n          layout: \"horizontal\",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function () {\n            return this.name;\n          },\n          borderColor: \"#999999\",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: \"0.8em\"\n            },\n            activeColor: \"#0022ff\",\n            inactiveColor: \"#cccccc\"\n          },\n          itemStyle: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            textDecoration: \"none\",\n            textOverflow: \"ellipsis\"\n          },\n          itemHoverStyle: {\n            color: \"#000000\"\n          },\n          itemHiddenStyle: {\n            color: \"#666666\",\n            textDecoration: \"line-through\"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: \"absolute\",\n            width: \"13px\",\n            height: \"13px\"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: \"0.8em\",\n              fontWeight: \"bold\"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: \"bold\",\n            position: \"relative\",\n            top: \"45%\"\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#ffffff\",\n            opacity: .5,\n            textAlign: \"center\"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: B,\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n            second: \"%A, %e %b, %H:%M:%S\",\n            minute: \"%A, %e %b, %H:%M\",\n            hour: \"%A, %e %b, %H:%M\",\n            day: \"%A, %e %b %Y\",\n            week: \"Week from %A, %e %b %Y\",\n            month: \"%B %Y\",\n            year: \"%Y\"\n          },\n          footerFormat: \"\",\n          headerShape: \"callout\",\n          hideDelay: 500,\n          padding: 8,\n          shape: \"callout\",\n          shared: !1,\n          snap: y ? 25 : 10,\n          headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n          backgroundColor: \"#ffffff\",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: \"https://www.highcharts.com?credits\",\n          position: {\n            align: \"right\",\n            x: -10,\n            verticalAlign: \"bottom\",\n            y: -5\n          },\n          style: {\n            cursor: \"pointer\",\n            color: \"#999999\",\n            fontSize: \"0.6em\"\n          },\n          text: \"Highcharts.com\"\n        }\n      };\n    r.chart.styledMode = !1;\n    \"\";\n    const g = new A(r.time);\n    a = {\n      defaultOptions: r,\n      defaultTime: g,\n      getOptions: function () {\n        return r;\n      },\n      setOptions: function (p) {\n        t(!0, r, p);\n        if (p.time || p.global) F.time ? F.time.update(t(r.global, r.time, p.global, p.time)) : F.time = g;\n        return r;\n      }\n    };\n    \"\";\n    return a;\n  });\n  L(a, \"Core/Animation/Fx.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        parse: y\n      } = a,\n      {\n        win: A\n      } = z,\n      {\n        isNumber: D,\n        objectEach: E\n      } = F;\n    let B = /*#__PURE__*/(() => {\n      class B {\n        constructor(a, r, g) {\n          this.pos = NaN;\n          this.options = r;\n          this.elem = a;\n          this.prop = g;\n        }\n        dSetter() {\n          var a = this.paths;\n          const r = a && a[0];\n          a = a && a[1];\n          const g = this.now || 0;\n          let p = [];\n          if (1 !== g && r && a) {\n            if (r.length === a.length && 1 > g) for (let v = 0; v < a.length; v++) {\n              const l = r[v],\n                m = a[v],\n                f = [];\n              for (let k = 0; k < m.length; k++) {\n                const x = l[k],\n                  p = m[k];\n                D(x) && D(p) && (\"A\" !== m[0] || 4 !== k && 5 !== k) ? f[k] = x + g * (p - x) : f[k] = p;\n              }\n              p.push(f);\n            } else p = a;\n          } else p = this.toD || [];\n          this.elem.attr(\"d\", p, void 0, !0);\n        }\n        update() {\n          const a = this.elem,\n            r = this.prop,\n            g = this.now,\n            p = this.options.step;\n          if (this[r + \"Setter\"]) this[r + \"Setter\"]();else a.attr ? a.element && a.attr(r, g, null, !0) : a.style[r] = g + this.unit;\n          p && p.call(a, g, this);\n        }\n        run(a, r, g) {\n          const p = this,\n            v = p.options,\n            l = function (k) {\n              return l.stopped ? !1 : p.step(k);\n            },\n            m = A.requestAnimationFrame || function (k) {\n              setTimeout(k, 13);\n            },\n            f = function () {\n              for (let k = 0; k < B.timers.length; k++) B.timers[k]() || B.timers.splice(k--, 1);\n              B.timers.length && m(f);\n            };\n          a !== r || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = a, this.end = r, this.unit = g, this.now = this.start, this.pos = 0, l.elem = this.elem, l.prop = this.prop, l() && 1 === B.timers.push(l) && m(f)) : (delete v.curAnim[this.prop], v.complete && 0 === Object.keys(v.curAnim).length && v.complete.call(this.elem));\n        }\n        step(a) {\n          const r = +new Date(),\n            g = this.options,\n            p = this.elem,\n            v = g.complete,\n            l = g.duration,\n            m = g.curAnim;\n          let f;\n          p.attr && !p.element ? a = !1 : a || r >= l + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), f = m[this.prop] = !0, E(m, function (k) {\n            !0 !== k && (f = !1);\n          }), f && v && v.call(p), a = !1) : (this.pos = g.easing((r - this.startTime) / l), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0);\n          return a;\n        }\n        initPath(a, r, g) {\n          function p(e, h) {\n            for (; e.length < J;) {\n              var k = e[0];\n              const q = h[J - e.length];\n              q && \"M\" === k[0] && (e[0] = \"C\" === q[0] ? [\"C\", k[1], k[2], k[1], k[2], k[1], k[2]] : [\"L\", k[1], k[2]]);\n              e.unshift(k);\n              f && (k = e.pop(), e.push(e[e.length - 1], k));\n            }\n          }\n          function v(e, h) {\n            for (; e.length < J;) if (h = e[Math.floor(e.length / k) - 1].slice(), \"C\" === h[0] && (h[1] = h[5], h[2] = h[6]), f) {\n              const f = e[Math.floor(e.length / k)].slice();\n              e.splice(e.length / 2, 0, h, f);\n            } else e.push(h);\n          }\n          const l = a.startX,\n            m = a.endX;\n          g = g.slice();\n          const f = a.isArea,\n            k = f ? 2 : 1;\n          let x, J, C;\n          r = r && r.slice();\n          if (!r) return [g, g];\n          if (l && m && m.length) {\n            for (a = 0; a < l.length; a++) if (l[a] === m[0]) {\n              x = a;\n              break;\n            } else if (l[0] === m[m.length - l.length + a]) {\n              x = a;\n              C = !0;\n              break;\n            } else if (l[l.length - 1] === m[m.length - l.length + a]) {\n              x = l.length - a;\n              break;\n            }\n            \"undefined\" === typeof x && (r = []);\n          }\n          r.length && D(x) && (J = g.length + x * k, C ? (p(r, g), v(g, r)) : (p(g, r), v(r, g)));\n          return [r, g];\n        }\n        fillSetter() {\n          B.prototype.strokeSetter.apply(this, arguments);\n        }\n        strokeSetter() {\n          this.elem.attr(this.prop, y(this.start).tweenTo(y(this.end), this.pos), void 0, !0);\n        }\n      }\n      B.timers = [];\n      return B;\n    })();\n    return B;\n  });\n  L(a, \"Core/Animation/AnimationUtilities.js\", [a[\"Core/Animation/Fx.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    function y(g) {\n      return t(g) ? r({\n        duration: 500,\n        defer: 0\n      }, g) : {\n        duration: g ? 500 : 0,\n        defer: 0\n      };\n    }\n    function H(g, l) {\n      let m = a.timers.length;\n      for (; m--;) a.timers[m].elem !== g || l && l !== a.timers[m].prop || (a.timers[m].stopped = !0);\n    }\n    const {\n      defined: A,\n      getStyle: D,\n      isArray: E,\n      isNumber: B,\n      isObject: t,\n      merge: r,\n      objectEach: g,\n      pick: p\n    } = z;\n    return {\n      animate: function (p, l, m) {\n        let f,\n          k = \"\",\n          x,\n          v,\n          C;\n        t(m) || (C = arguments, m = {\n          duration: C[2],\n          easing: C[3],\n          complete: C[4]\n        });\n        B(m.duration) || (m.duration = 400);\n        m.easing = \"function\" === typeof m.easing ? m.easing : Math[m.easing] || Math.easeInOutSine;\n        m.curAnim = r(l);\n        g(l, function (e, h) {\n          H(p, h);\n          v = new a(p, m, h);\n          x = void 0;\n          \"d\" === h && E(l.d) ? (v.paths = v.initPath(p, p.pathArray, l.d), v.toD = l.d, f = 0, x = 1) : p.attr ? f = p.attr(h) : (f = parseFloat(D(p, h)) || 0, \"opacity\" !== h && (k = \"px\"));\n          x || (x = e);\n          \"string\" === typeof x && x.match(\"px\") && (x = x.replace(/px/g, \"\"));\n          v.run(f, x, k);\n        });\n      },\n      animObject: y,\n      getDeferredAnimation: function (g, l, m) {\n        const f = y(l);\n        let k = 0,\n          x = 0;\n        (m ? [m] : g.series).forEach(g => {\n          g = y(g.options.animation);\n          k = l && A(l.defer) ? f.defer : Math.max(k, g.duration + g.defer);\n          x = Math.min(f.duration, g.duration);\n        });\n        g.renderer.forExport && (k = 0);\n        return {\n          defer: Math.max(0, k - x),\n          duration: Math.min(k, x)\n        };\n      },\n      setAnimation: function (g, l) {\n        l.renderer.globalAnimation = p(g, l.options.chart.animation, !0);\n      },\n      stop: H\n    };\n  });\n  L(a, \"Core/Renderer/HTML/AST.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    const {\n        SVG_NS: y,\n        win: H\n      } = a,\n      {\n        attr: A,\n        createElement: D,\n        css: E,\n        error: B,\n        isFunction: t,\n        isString: r,\n        objectEach: g,\n        splat: p\n      } = z;\n    ({\n      trustedTypes: z\n    } = H);\n    const v = z && t(z.createPolicy) && z.createPolicy(\"highcharts\", {\n      createHTML: k => k\n    });\n    z = v ? v.createHTML(\"\") : \"\";\n    try {\n      var l = !!new DOMParser().parseFromString(z, \"text/html\");\n    } catch (k) {\n      l = !1;\n    }\n    const m = l;\n    class f {\n      static filterUserAttributes(k) {\n        g(k, (g, l) => {\n          let x = !0;\n          -1 === f.allowedAttributes.indexOf(l) && (x = !1);\n          -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(l) && (x = r(g) && f.allowedReferences.some(e => 0 === g.indexOf(e)));\n          x || (B(33, !1, void 0, {\n            \"Invalid attribute in config\": `${l}`\n          }), delete k[l]);\n          r(g) && k[l] && (k[l] = g.replace(/</g, \"&lt;\"));\n        });\n        return k;\n      }\n      static parseStyle(k) {\n        return k.split(\";\").reduce((k, f) => {\n          f = f.split(\":\").map(e => e.trim());\n          const g = f.shift();\n          g && f.length && (k[g.replace(/-([a-z])/g, e => e[1].toUpperCase())] = f.join(\":\"));\n          return k;\n        }, {});\n      }\n      static setElementHTML(k, g) {\n        k.innerHTML = f.emptyHTML;\n        g && new f(g).addToDOM(k);\n      }\n      constructor(k) {\n        this.nodes = \"string\" === typeof k ? this.parseMarkup(k) : k;\n      }\n      addToDOM(k) {\n        function l(k, x) {\n          let e;\n          p(k).forEach(function (h) {\n            var k = h.tagName;\n            const q = h.textContent ? a.doc.createTextNode(h.textContent) : void 0,\n              u = f.bypassHTMLFiltering;\n            let d;\n            if (k) if (\"#text\" === k) d = q;else if (-1 !== f.allowedTags.indexOf(k) || u) {\n              k = a.doc.createElementNS(\"svg\" === k ? y : x.namespaceURI || y, k);\n              const b = h.attributes || {};\n              g(h, function (c, d) {\n                \"tagName\" !== d && \"attributes\" !== d && \"children\" !== d && \"style\" !== d && \"textContent\" !== d && (b[d] = c);\n              });\n              A(k, u ? b : f.filterUserAttributes(b));\n              h.style && E(k, h.style);\n              q && k.appendChild(q);\n              l(h.children || [], k);\n              d = k;\n            } else B(33, !1, void 0, {\n              \"Invalid tagName in config\": k\n            });\n            d && x.appendChild(d);\n            e = d;\n          });\n          return e;\n        }\n        return l(this.nodes, k);\n      }\n      parseMarkup(k) {\n        const g = [];\n        k = k.trim().replace(/ style=([\"'])/g, \" data-style=$1\");\n        if (m) k = new DOMParser().parseFromString(v ? v.createHTML(k) : k, \"text/html\");else {\n          const f = D(\"div\");\n          f.innerHTML = k;\n          k = {\n            body: f\n          };\n        }\n        const l = (k, e) => {\n          var h = k.nodeName.toLowerCase();\n          const g = {\n            tagName: h\n          };\n          \"#text\" === h && (g.textContent = k.textContent || \"\");\n          if (h = k.attributes) {\n            const e = {};\n            [].forEach.call(h, h => {\n              \"data-style\" === h.name ? g.style = f.parseStyle(h.value) : e[h.name] = h.value;\n            });\n            g.attributes = e;\n          }\n          if (k.childNodes.length) {\n            const h = [];\n            [].forEach.call(k.childNodes, e => {\n              l(e, h);\n            });\n            h.length && (g.children = h);\n          }\n          e.push(g);\n        };\n        [].forEach.call(k.body.childNodes, k => l(k, g));\n        return g;\n      }\n    }\n    f.allowedAttributes = \"alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex\".split(\" \");\n    f.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n    f.allowedTags = \"a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text\".split(\" \");\n    f.emptyHTML = z;\n    f.bypassHTMLFiltering = !1;\n    \"\";\n    return f;\n  });\n  L(a, \"Core/FormatUtilities.js\", [a[\"Core/Defaults.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    function y(a, g, p, v) {\n      a = +a || 0;\n      g = +g;\n      const l = H.lang;\n      var m = (a.toString().split(\".\")[1] || \"\").split(\"e\")[0].length;\n      const f = a.toString().split(\"e\"),\n        k = g;\n      if (-1 === g) g = Math.min(m, 20);else if (!E(g)) g = 2;else if (g && f[1] && 0 > f[1]) {\n        var x = g + +f[1];\n        0 <= x ? (f[0] = (+f[0]).toExponential(x).split(\"e\")[0], g = x) : (f[0] = f[0].split(\".\")[0] || 0, a = 20 > g ? (f[0] * Math.pow(10, f[1])).toFixed(g) : 0, f[1] = 0);\n      }\n      x = (Math.abs(f[1] ? f[0] : a) + Math.pow(10, -Math.max(g, m) - 1)).toFixed(g);\n      m = String(t(x));\n      const r = 3 < m.length ? m.length % 3 : 0;\n      p = B(p, l.decimalPoint);\n      v = B(v, l.thousandsSep);\n      a = (0 > a ? \"-\" : \"\") + (r ? m.substr(0, r) + v : \"\");\n      a = 0 > +f[1] && !k ? \"0\" : a + m.substr(r).replace(/(\\d{3})(?=\\d)/g, \"$1\" + v);\n      g && (a += p + x.slice(-g));\n      f[1] && 0 !== +a && (a += \"e\" + f[1]);\n      return a;\n    }\n    const {\n        defaultOptions: H,\n        defaultTime: A\n      } = a,\n      {\n        getNestedProperty: D,\n        isNumber: E,\n        pick: B,\n        pInt: t\n      } = z;\n    return {\n      dateFormat: function (a, g, p) {\n        return A.dateFormat(a, g, p);\n      },\n      format: function (a, g, p) {\n        var v = \"{\";\n        let l = !1;\n        let m;\n        const f = /f$/,\n          k = /\\.([0-9])/,\n          x = H.lang,\n          r = p && p.time || A;\n        p = p && p.numberFormatter || y;\n        const C = [];\n        for (; a;) {\n          m = a.indexOf(v);\n          if (-1 === m) break;\n          var e = a.slice(0, m);\n          if (l) {\n            e = e.split(\":\");\n            v = D(e.shift() || \"\", g);\n            if (e.length && \"number\" === typeof v) if (e = e.join(\":\"), f.test(e)) {\n              const h = parseInt((e.match(k) || [\"\", \"-1\"])[1], 10);\n              null !== v && (v = p(v, h, x.decimalPoint, -1 < e.indexOf(\",\") ? x.thousandsSep : \"\"));\n            } else v = r.dateFormat(e, v);\n            C.push(v);\n          } else C.push(e);\n          a = a.slice(m + 1);\n          v = (l = !l) ? \"}\" : \"{\";\n        }\n        C.push(a);\n        return C.join(\"\");\n      },\n      numberFormat: y\n    };\n  });\n  L(a, \"Core/Renderer/RendererUtilities.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      clamp: y,\n      pick: F,\n      stableSort: H\n    } = a;\n    var A;\n    (function (a) {\n      function E(a, t, r) {\n        const g = a;\n        var p = g.reducedLen || t,\n          v = (k, f) => (f.rank || 0) - (k.rank || 0);\n        const l = (k, f) => k.target - f.target;\n        let m,\n          f = !0,\n          k = [],\n          x = 0;\n        for (m = a.length; m--;) x += a[m].size;\n        if (x > p) {\n          H(a, v);\n          for (x = m = 0; x <= p;) x += a[m].size, m++;\n          k = a.splice(m - 1, a.length);\n        }\n        H(a, l);\n        for (a = a.map(k => ({\n          size: k.size,\n          targets: [k.target],\n          align: F(k.align, .5)\n        })); f;) {\n          for (m = a.length; m--;) p = a[m], v = (Math.min.apply(0, p.targets) + Math.max.apply(0, p.targets)) / 2, p.pos = y(v - p.size * p.align, 0, t - p.size);\n          m = a.length;\n          for (f = !1; m--;) 0 < m && a[m - 1].pos + a[m - 1].size > a[m].pos && (a[m - 1].size += a[m].size, a[m - 1].targets = a[m - 1].targets.concat(a[m].targets), a[m - 1].align = .5, a[m - 1].pos + a[m - 1].size > t && (a[m - 1].pos = t - a[m - 1].size), a.splice(m, 1), f = !0);\n        }\n        g.push.apply(g, k);\n        m = 0;\n        a.some(k => {\n          let f = 0;\n          return (k.targets || []).some(() => {\n            g[m].pos = k.pos + f;\n            if (\"undefined\" !== typeof r && Math.abs(g[m].pos - g[m].target) > r) return g.slice(0, m + 1).forEach(e => delete e.pos), g.reducedLen = (g.reducedLen || t) - .1 * t, g.reducedLen > .1 * t && E(g, t, r), !0;\n            f += g[m].size;\n            m++;\n            return !1;\n          });\n        });\n        H(g, l);\n        return g;\n      }\n      a.distribute = E;\n    })(A || (A = {}));\n    return A;\n  });\n  L(a, \"Core/Renderer/SVG/SVGElement.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H) {\n    const {\n        animate: y,\n        animObject: D,\n        stop: E\n      } = a,\n      {\n        deg2rad: B,\n        doc: t,\n        svg: r,\n        SVG_NS: g,\n        win: p\n      } = F,\n      {\n        addEvent: v,\n        attr: l,\n        createElement: m,\n        css: f,\n        defined: k,\n        erase: x,\n        extend: J,\n        fireEvent: C,\n        isArray: e,\n        isFunction: h,\n        isObject: w,\n        isString: q,\n        merge: u,\n        objectEach: d,\n        pick: b,\n        pInt: c,\n        syncTimeout: n,\n        uniqueKey: G\n      } = H;\n    class I {\n      constructor() {\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = g;\n      }\n      _defaultGetter(c) {\n        c = b(this[c + \"Value\"], this[c], this.element ? this.element.getAttribute(c) : null, 0);\n        /^[\\-0-9\\.]+$/.test(c) && (c = parseFloat(c));\n        return c;\n      }\n      _defaultSetter(b, c, d) {\n        d.setAttribute(c, b);\n      }\n      add(b) {\n        const c = this.renderer,\n          d = this.element;\n        let n;\n        b && (this.parentGroup = b);\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && c.buildText(this);\n        this.added = !0;\n        if (!b || b.handleZ || this.zIndex) n = this.zIndexSetter();\n        n || (b ? b.element : c.box).appendChild(d);\n        if (this.onAdd) this.onAdd();\n        return this;\n      }\n      addClass(b, c) {\n        const d = c ? \"\" : this.attr(\"class\") || \"\";\n        b = (b || \"\").split(/ /g).reduce(function (b, c) {\n          -1 === d.indexOf(c) && b.push(c);\n          return b;\n        }, d ? [d] : []).join(\" \");\n        b !== d && this.attr(\"class\", b);\n        return this;\n      }\n      afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      }\n      align(c, d, n) {\n        const h = {};\n        var e = this.renderer,\n          k = e.alignedObjects,\n          f;\n        let K, u;\n        if (c) {\n          if (this.alignOptions = c, this.alignByTranslate = d, !n || q(n)) this.alignTo = f = n || \"renderer\", x(k, this), k.push(this), n = void 0;\n        } else c = this.alignOptions, d = this.alignByTranslate, f = this.alignTo;\n        n = b(n, e[f], \"scrollablePlotBox\" === f ? e.plotBox : void 0, e);\n        f = c.align;\n        const M = c.verticalAlign;\n        e = (n.x || 0) + (c.x || 0);\n        k = (n.y || 0) + (c.y || 0);\n        \"right\" === f ? K = 1 : \"center\" === f && (K = 2);\n        K && (e += (n.width - (c.width || 0)) / K);\n        h[d ? \"translateX\" : \"x\"] = Math.round(e);\n        \"bottom\" === M ? u = 1 : \"middle\" === M && (u = 2);\n        u && (k += (n.height - (c.height || 0)) / u);\n        h[d ? \"translateY\" : \"y\"] = Math.round(k);\n        this[this.placed ? \"animate\" : \"attr\"](h);\n        this.placed = !0;\n        this.alignAttr = h;\n        return this;\n      }\n      alignSetter(b) {\n        const c = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        c[b] && (this.alignValue = b, this.element.setAttribute(\"text-anchor\", c[b]));\n      }\n      animate(c, h, e) {\n        const q = D(b(h, this.renderer.globalAnimation, !0));\n        h = q.defer;\n        t.hidden && (q.duration = 0);\n        0 !== q.duration ? (e && (q.complete = e), n(() => {\n          this.element && y(this, c, q);\n        }, h)) : (this.attr(c, void 0, e || q.complete), d(c, function (b, c) {\n          q.step && q.step.call(this, b, {\n            prop: c,\n            pos: 1,\n            elem: this\n          });\n        }, this));\n        return this;\n      }\n      applyTextOutline(b) {\n        const c = this.element;\n        -1 !== b.indexOf(\"contrast\") && (b = b.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));\n        var d = b.split(\" \");\n        b = d[d.length - 1];\n        if ((d = d[0]) && \"none\" !== d && F.svg) {\n          this.fakeTS = !0;\n          d = d.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, c, d) {\n            return 2 * Number(c) + d;\n          });\n          this.removeTextOutline();\n          const n = t.createElementNS(g, \"tspan\");\n          l(n, {\n            \"class\": \"highcharts-text-outline\",\n            fill: b,\n            stroke: b,\n            \"stroke-width\": d,\n            \"stroke-linejoin\": \"round\"\n          });\n          b = c.querySelector(\"textPath\") || c;\n          [].forEach.call(b.childNodes, b => {\n            const c = b.cloneNode(!0);\n            c.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(b => c.removeAttribute(b));\n            n.appendChild(c);\n          });\n          let h = 0;\n          [].forEach.call(b.querySelectorAll(\"text tspan\"), b => {\n            h += Number(b.getAttribute(\"dy\"));\n          });\n          d = t.createElementNS(g, \"tspan\");\n          d.textContent = \"\\u200b\";\n          l(d, {\n            x: Number(c.getAttribute(\"x\")),\n            dy: -h\n          });\n          n.appendChild(d);\n          b.insertBefore(n, b.firstChild);\n        }\n      }\n      attr(b, c, n, h) {\n        const e = this.element,\n          q = I.symbolCustomAttribs;\n        let k,\n          f,\n          u = this,\n          K,\n          G;\n        \"string\" === typeof b && \"undefined\" !== typeof c && (k = b, b = {}, b[k] = c);\n        \"string\" === typeof b ? u = (this[b + \"Getter\"] || this._defaultGetter).call(this, b, e) : (d(b, function (c, d) {\n          K = !1;\n          h || E(this, d);\n          this.symbolName && -1 !== q.indexOf(d) && (f || (this.symbolAttr(b), f = !0), K = !0);\n          !this.rotation || \"x\" !== d && \"y\" !== d || (this.doTransform = !0);\n          K || (G = this[d + \"Setter\"] || this._defaultSetter, G.call(this, c, d, e));\n        }, this), this.afterSetters());\n        n && n.call(this);\n        return u;\n      }\n      clip(b) {\n        return this.attr(\"clip-path\", b ? \"url(\" + this.renderer.url + \"#\" + b.id + \")\" : \"none\");\n      }\n      crisp(b, c) {\n        c = c || b.strokeWidth || 0;\n        const d = Math.round(c) % 2 / 2;\n        b.x = Math.floor(b.x || this.x || 0) + d;\n        b.y = Math.floor(b.y || this.y || 0) + d;\n        b.width = Math.floor((b.width || this.width || 0) - 2 * d);\n        b.height = Math.floor((b.height || this.height || 0) - 2 * d);\n        k(b.strokeWidth) && (b.strokeWidth = c);\n        return b;\n      }\n      complexColor(b, c, n) {\n        const h = this.renderer;\n        let q,\n          O,\n          f,\n          K,\n          g,\n          M,\n          w,\n          l,\n          a,\n          x,\n          m = [],\n          I;\n        C(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          b.radialGradient ? O = \"radialGradient\" : b.linearGradient && (O = \"linearGradient\");\n          if (O) {\n            f = b[O];\n            g = h.gradients;\n            M = b.stops;\n            a = n.radialReference;\n            e(f) && (b[O] = f = {\n              x1: f[0],\n              y1: f[1],\n              x2: f[2],\n              y2: f[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === O && a && !k(f.gradientUnits) && (K = f, f = u(f, h.getRadialAttr(a, K), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            d(f, function (b, c) {\n              \"id\" !== c && m.push(c, b);\n            });\n            d(M, function (b) {\n              m.push(b);\n            });\n            m = m.join(\",\");\n            if (g[m]) x = g[m].attr(\"id\");else {\n              f.id = x = G();\n              const b = g[m] = h.createElement(O).attr(f).add(h.defs);\n              b.radAttr = K;\n              b.stops = [];\n              M.forEach(function (c) {\n                0 === c[1].indexOf(\"rgba\") ? (q = z.parse(c[1]), w = q.get(\"rgb\"), l = q.get(\"a\")) : (w = c[1], l = 1);\n                c = h.createElement(\"stop\").attr({\n                  offset: c[0],\n                  \"stop-color\": w,\n                  \"stop-opacity\": l\n                }).add(b);\n                b.stops.push(c);\n              });\n            }\n            I = \"url(\" + h.url + \"#\" + x + \")\";\n            n.setAttribute(c, I);\n            n.gradient = m;\n            b.toString = function () {\n              return I;\n            };\n          }\n        });\n      }\n      css(b) {\n        const n = this.styles,\n          h = {},\n          e = this.element;\n        let q,\n          k = !n;\n        b.color && (b.fill = b.color);\n        n && d(b, function (b, c) {\n          n && n[c] !== b && (h[c] = b, k = !0);\n        });\n        if (k) {\n          n && (b = J(n, h));\n          null === b.width || \"auto\" === b.width ? delete this.textWidth : \"text\" === e.nodeName.toLowerCase() && b.width && (q = this.textWidth = c(b.width));\n          this.styles = b;\n          q && !r && this.renderer.forExport && delete b.width;\n          const d = u(b);\n          e.namespaceURI === this.SVG_NS && [\"textOutline\", \"textOverflow\", \"width\"].forEach(b => d && delete d[b]);\n          f(e, d);\n        }\n        this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), b.textOutline && this.applyTextOutline(b.textOutline));\n        return this;\n      }\n      dashstyleSetter(d) {\n        let n = this[\"stroke-width\"];\n        \"inherit\" === n && (n = 1);\n        if (d = d && d.toLowerCase()) {\n          const h = d.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n          for (d = h.length; d--;) h[d] = \"\" + c(h[d]) * b(n, NaN);\n          d = h.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", d);\n        }\n      }\n      destroy() {\n        const b = this;\n        var c = b.element || {};\n        const n = b.renderer;\n        var h = c.ownerSVGElement;\n        let e = \"SPAN\" === c.nodeName && b.parentGroup || void 0;\n        c.onclick = c.onmouseout = c.onmouseover = c.onmousemove = c.point = null;\n        E(b);\n        if (b.clipPath && h) {\n          const c = b.clipPath;\n          [].forEach.call(h.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (b) {\n            -1 < b.getAttribute(\"clip-path\").indexOf(c.element.id) && b.removeAttribute(\"clip-path\");\n          });\n          b.clipPath = c.destroy();\n        }\n        if (b.stops) {\n          for (h = 0; h < b.stops.length; h++) b.stops[h].destroy();\n          b.stops.length = 0;\n          b.stops = void 0;\n        }\n        for (b.safeRemoveChild(c); e && e.div && 0 === e.div.childNodes.length;) c = e.parentGroup, b.safeRemoveChild(e.div), delete e.div, e = c;\n        b.alignTo && x(n.alignedObjects, b);\n        d(b, function (c, d) {\n          b[d] && b[d].parentGroup === b && b[d].destroy && b[d].destroy();\n          delete b[d];\n        });\n      }\n      dSetter(b, c, d) {\n        e(b) && (\"string\" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce((b, c, d) => c && c.join ? (d ? b + \" \" : \"\") + c.join(\" \") : (c || \"\").toString(), \"\"));\n        /(NaN| {2}|^$)/.test(b) && (b = \"M 0 0\");\n        this[c] !== b && (d.setAttribute(c, b), this[c] = b);\n      }\n      fadeOut(c) {\n        const d = this;\n        d.animate({\n          opacity: 0\n        }, {\n          duration: b(c, 150),\n          complete: function () {\n            d.hide();\n          }\n        });\n      }\n      fillSetter(b, c, d) {\n        \"string\" === typeof b ? d.setAttribute(c, b) : b && this.complexColor(b, c, d);\n      }\n      getBBox(c, d) {\n        const {\n            alignValue: n,\n            element: e,\n            renderer: q,\n            styles: O,\n            textStr: u\n          } = this,\n          {\n            cache: G,\n            cacheKeys: g\n          } = q;\n        var M = e.namespaceURI === this.SVG_NS;\n        d = b(d, this.rotation, 0);\n        var w = q.styledMode ? e && I.prototype.getStyle.call(e, \"font-size\") : O && O.fontSize;\n        let l;\n        let K;\n        k(u) && (K = u.toString(), -1 === K.indexOf(\"<\") && (K = K.replace(/[0-9]/g, \"0\")), K += [\"\", q.rootFontSize, w, d, this.textWidth, n, O && O.textOverflow, O && O.fontWeight].join());\n        K && !c && (l = G[K]);\n        if (!l) {\n          if (M || q.forExport) {\n            try {\n              var a = this.fakeTS && function (b) {\n                const c = e.querySelector(\".highcharts-text-outline\");\n                c && f(c, {\n                  display: b\n                });\n              };\n              h(a) && a(\"none\");\n              l = e.getBBox ? J({}, e.getBBox()) : {\n                width: e.offsetWidth,\n                height: e.offsetHeight,\n                x: 0,\n                y: 0\n              };\n              h(a) && a(\"\");\n            } catch (fa) {\n              \"\";\n            }\n            if (!l || 0 > l.width) l = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n          } else l = this.htmlGetBBox();\n          a = l.width;\n          c = l.height;\n          M && (l.height = c = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[`${w || \"\"},${Math.round(c)}`] || c);\n          if (d) {\n            M = Number(e.getAttribute(\"y\") || 0) - l.y;\n            w = {\n              right: 1,\n              center: .5\n            }[n || 0] || 0;\n            var x = d * B,\n              m = (d - 90) * B,\n              p = a * Math.cos(x);\n            d = a * Math.sin(x);\n            var v = Math.cos(m);\n            x = Math.sin(m);\n            a = l.x + w * (a - p) + M * v;\n            m = a + p;\n            v = m - c * v;\n            p = v - p;\n            M = l.y + M - w * d + M * x;\n            w = M + d;\n            c = w - c * x;\n            d = c - d;\n            l.x = Math.min(a, m, v, p);\n            l.y = Math.min(M, w, c, d);\n            l.width = Math.max(a, m, v, p) - l.x;\n            l.height = Math.max(M, w, c, d) - l.y;\n          }\n        }\n        if (K && (\"\" === u || 0 < l.height)) {\n          for (; 250 < g.length;) delete G[g.shift()];\n          G[K] || g.push(K);\n          G[K] = l;\n        }\n        return l;\n      }\n      getStyle(b) {\n        return p.getComputedStyle(this.element || this, \"\").getPropertyValue(b);\n      }\n      hasClass(b) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(b);\n      }\n      hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      }\n      htmlGetBBox() {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      }\n      init(b, c) {\n        this.element = \"span\" === c ? m(c) : t.createElementNS(this.SVG_NS, c);\n        this.renderer = b;\n        C(this, \"afterInit\");\n      }\n      on(b, c) {\n        const {\n          onEvents: d\n        } = this;\n        if (d[b]) d[b]();\n        d[b] = v(this.element, b, c);\n        return this;\n      }\n      opacitySetter(b, c, d) {\n        this.opacity = b = Number(Number(b).toFixed(3));\n        d.setAttribute(c, b);\n      }\n      removeClass(b) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(q(b) ? new RegExp(`(^| )${b}( |$)`) : b, \" \").replace(/ +/g, \" \").trim());\n      }\n      removeTextOutline() {\n        const b = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        b && this.safeRemoveChild(b);\n      }\n      safeRemoveChild(b) {\n        const c = b.parentNode;\n        c && c.removeChild(b);\n      }\n      setRadialReference(b) {\n        const c = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = b;\n        c && c.radAttr && c.animate(this.renderer.getRadialAttr(b, c.radAttr));\n        return this;\n      }\n      setTextPath(b, c) {\n        c = u(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, c);\n        const d = this.renderer.url,\n          n = this.text || this,\n          h = n.textPath,\n          {\n            attributes: e,\n            enabled: q\n          } = c;\n        b = b || h && h.path;\n        h && h.undo();\n        b && q ? (c = v(n, \"afterModifyTree\", c => {\n          if (b && q) {\n            let q = b.attr(\"id\");\n            q || b.attr(\"id\", q = G());\n            var h = {\n              x: 0,\n              y: 0\n            };\n            k(e.dx) && (h.dx = e.dx, delete e.dx);\n            k(e.dy) && (h.dy = e.dy, delete e.dy);\n            n.attr(h);\n            this.attr({\n              transform: \"\"\n            });\n            this.box && (this.box = this.box.destroy());\n            h = c.nodes.slice(0);\n            c.nodes.length = 0;\n            c.nodes[0] = {\n              tagName: \"textPath\",\n              attributes: J(e, {\n                \"text-anchor\": e.textAnchor,\n                href: `${d}#${q}`\n              }),\n              children: h\n            };\n          }\n        }), n.textPath = {\n          path: b,\n          undo: c\n        }) : (n.attr({\n          dx: 0,\n          dy: 0\n        }), delete n.textPath);\n        this.added && (n.textCache = \"\", this.renderer.buildText(n));\n        return this;\n      }\n      shadow(b) {\n        var c;\n        const {\n            renderer: d\n          } = this,\n          n = u(90 === (null === (c = this.parentGroup) || void 0 === c ? void 0 : c.rotation) ? {\n            offsetX: -1,\n            offsetY: -1\n          } : {}, w(b) ? b : {});\n        c = d.shadowDefinition(n);\n        return this.attr({\n          filter: b ? `url(${d.url}#${c})` : \"none\"\n        });\n      }\n      show(b = !0) {\n        return this.attr({\n          visibility: b ? \"inherit\" : \"visible\"\n        });\n      }\n      [\"stroke-widthSetter\"](b, c, d) {\n        this[c] = b;\n        d.setAttribute(c, b);\n      }\n      strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        const b = this.getStyle(\"stroke-width\");\n        let d = 0,\n          n;\n        b.indexOf(\"px\") === b.length - 2 ? d = c(b) : \"\" !== b && (n = t.createElementNS(g, \"rect\"), l(n, {\n          width: b,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(n), d = n.getBBox().width, n.parentNode.removeChild(n));\n        return d;\n      }\n      symbolAttr(c) {\n        const d = this;\n        I.symbolCustomAttribs.forEach(function (n) {\n          d[n] = b(c[n], d[n]);\n        });\n        d.attr({\n          d: d.renderer.symbols[d.symbolName](d.x, d.y, d.width, d.height, d)\n        });\n      }\n      textSetter(b) {\n        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));\n      }\n      titleSetter(c) {\n        const d = this.element,\n          n = d.getElementsByTagName(\"title\")[0] || t.createElementNS(this.SVG_NS, \"title\");\n        d.insertBefore ? d.insertBefore(n, d.firstChild) : d.appendChild(n);\n        n.textContent = String(b(c, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      }\n      toFront() {\n        const b = this.element;\n        b.parentNode.appendChild(b);\n        return this;\n      }\n      translate(b, c) {\n        return this.attr({\n          translateX: b,\n          translateY: c\n        });\n      }\n      updateTransform() {\n        const {\n            element: c,\n            matrix: d,\n            rotation: n = 0,\n            scaleX: h,\n            scaleY: e,\n            translateX: q = 0,\n            translateY: f = 0\n          } = this,\n          u = [\"translate(\" + q + \",\" + f + \")\"];\n        k(d) && u.push(\"matrix(\" + d.join(\",\") + \")\");\n        n && u.push(\"rotate(\" + n + \" \" + b(this.rotationOriginX, c.getAttribute(\"x\"), 0) + \" \" + b(this.rotationOriginY, c.getAttribute(\"y\") || 0) + \")\");\n        (k(h) || k(e)) && u.push(\"scale(\" + b(h, 1) + \" \" + b(e, 1) + \")\");\n        u.length && !(this.text || this).textPath && c.setAttribute(\"transform\", u.join(\" \"));\n      }\n      visibilitySetter(b, c, d) {\n        \"inherit\" === b ? d.removeAttribute(c) : this[c] !== b && d.setAttribute(c, b);\n        this[c] = b;\n      }\n      xGetter(b) {\n        \"circle\" === this.element.nodeName && (\"x\" === b ? b = \"cx\" : \"y\" === b && (b = \"cy\"));\n        return this._defaultGetter(b);\n      }\n      zIndexSetter(b, d) {\n        var n = this.renderer,\n          h = this.parentGroup;\n        const e = (h || n).element || n.box,\n          q = this.element;\n        n = e === n.box;\n        let f = !1,\n          u;\n        var G = this.added;\n        let M;\n        k(b) ? (q.setAttribute(\"data-z-index\", b), b = +b, this[d] === b && (G = !1)) : k(this[d]) && q.removeAttribute(\"data-z-index\");\n        this[d] = b;\n        if (G) {\n          (b = this.zIndex) && h && (h.handleZ = !0);\n          d = e.childNodes;\n          for (M = d.length - 1; 0 <= M && !f; M--) if (h = d[M], G = h.getAttribute(\"data-z-index\"), u = !k(G), h !== q) if (0 > b && u && !n && !M) e.insertBefore(q, d[M]), f = !0;else if (c(G) <= b || u && (!k(b) || 0 <= b)) e.insertBefore(q, d[M + 1]), f = !0;\n          f || (e.insertBefore(q, d[n ? 3 : 0]), f = !0);\n        }\n        return f;\n      }\n    }\n    I.symbolCustomAttribs = \"anchorX anchorY clockwise end height innerR r start width x y\".split(\" \");\n    I.prototype.strokeSetter = I.prototype.fillSetter;\n    I.prototype.yGetter = I.prototype.xGetter;\n    I.prototype.matrixSetter = I.prototype.rotationOriginXSetter = I.prototype.rotationOriginYSetter = I.prototype.rotationSetter = I.prototype.scaleXSetter = I.prototype.scaleYSetter = I.prototype.translateXSetter = I.prototype.translateYSetter = I.prototype.verticalAlignSetter = function (b, c) {\n      this[c] = b;\n      this.doTransform = !0;\n    };\n    \"\";\n    return I;\n  });\n  L(a, \"Core/Renderer/RendererRegistry.js\", [a[\"Core/Globals.js\"]], function (a) {\n    var y;\n    (function (y) {\n      y.rendererTypes = {};\n      let z;\n      y.getRendererType = function (a = z) {\n        return y.rendererTypes[a] || y.rendererTypes[z];\n      };\n      y.registerRendererType = function (A, D, E) {\n        y.rendererTypes[A] = D;\n        if (!z || E) z = A, a.Renderer = D;\n      };\n    })(y || (y = {}));\n    return y;\n  });\n  L(a, \"Core/Renderer/SVG/SVGLabel.js\", [a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    const {\n      defined: y,\n      extend: H,\n      isNumber: A,\n      merge: D,\n      pick: E,\n      removeEvent: B\n    } = z;\n    class t extends a {\n      constructor(a, g, p, v, l, m, f, k, x, J) {\n        super();\n        this.paddingRightSetter = this.paddingLeftSetter = this.paddingSetter;\n        this.init(a, \"g\");\n        this.textStr = g;\n        this.x = p;\n        this.y = v;\n        this.anchorX = m;\n        this.anchorY = f;\n        this.baseline = x;\n        this.className = J;\n        this.addClass(\"button\" === J ? \"highcharts-no-tooltip\" : \"highcharts-label\");\n        J && this.addClass(\"highcharts-\" + J);\n        this.text = a.text(void 0, 0, 0, k).attr({\n          zIndex: 1\n        });\n        let r;\n        \"string\" === typeof l && ((r = /^url\\((.*?)\\)$/.test(l)) || this.renderer.symbols[l]) && (this.symbolKey = l);\n        this.bBox = t.emptyBBox;\n        this.padding = 3;\n        this.baselineOffset = 0;\n        this.needsBox = a.styledMode || r;\n        this.deferredAttr = {};\n        this.alignFactor = 0;\n      }\n      alignSetter(a) {\n        a = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[a];\n        a !== this.alignFactor && (this.alignFactor = a, this.bBox && A(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      }\n      anchorXSetter(a, g) {\n        this.anchorX = a;\n        this.boxAttr(g, Math.round(a) - this.getCrispAdjust() - this.xSetting);\n      }\n      anchorYSetter(a, g) {\n        this.anchorY = a;\n        this.boxAttr(g, a - this.ySetting);\n      }\n      boxAttr(a, g) {\n        this.box ? this.box.attr(a, g) : this.deferredAttr[a] = g;\n      }\n      css(r) {\n        if (r) {\n          const g = {};\n          r = D(r);\n          t.textProps.forEach(a => {\n            \"undefined\" !== typeof r[a] && (g[a] = r[a], delete r[a]);\n          });\n          this.text.css(g);\n          \"fontSize\" in g || \"fontWeight\" in g ? this.updateTextPadding() : (\"width\" in g || \"textOverflow\" in g) && this.updateBoxSize();\n        }\n        return a.prototype.css.call(this, r);\n      }\n      destroy() {\n        B(this.element, \"mouseenter\");\n        B(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        a.prototype.destroy.call(this);\n      }\n      fillSetter(a, g) {\n        a && (this.needsBox = !0);\n        this.fill = a;\n        this.boxAttr(g, a);\n      }\n      getBBox() {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        const a = this.padding,\n          g = E(this.paddingLeft, a);\n        return {\n          width: this.width,\n          height: this.height,\n          x: this.bBox.x - g,\n          y: this.bBox.y - a\n        };\n      }\n      getCrispAdjust() {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      }\n      heightSetter(a) {\n        this.heightSetting = a;\n      }\n      onAdd() {\n        this.text.add(this);\n        this.attr({\n          text: E(this.textStr, \"\"),\n          x: this.x || 0,\n          y: this.y || 0\n        });\n        this.box && y(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      }\n      paddingSetter(a, g) {\n        A(a) ? a !== this[g] && (this[g] = a, this.updateTextPadding()) : this[g] = void 0;\n      }\n      rSetter(a, g) {\n        this.boxAttr(g, a);\n      }\n      strokeSetter(a, g) {\n        this.stroke = a;\n        this.boxAttr(g, a);\n      }\n      [\"stroke-widthSetter\"](a, g) {\n        a && (this.needsBox = !0);\n        this[\"stroke-width\"] = a;\n        this.boxAttr(g, a);\n      }\n      [\"text-alignSetter\"](a) {\n        this.textAlign = a;\n      }\n      textSetter(a) {\n        \"undefined\" !== typeof a && this.text.attr({\n          text: a\n        });\n        this.updateTextPadding();\n      }\n      updateBoxSize() {\n        var a = this.text;\n        const g = {},\n          p = this.padding,\n          v = this.bBox = A(this.widthSetting) && A(this.heightSetting) && !this.textAlign || !y(a.textStr) ? t.emptyBBox : a.getBBox();\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || v.height || 0) + 2 * p;\n        const l = this.renderer.fontMetrics(a);\n        this.baselineOffset = p + Math.min((this.text.firstLineMetrics || l).b, v.height || Infinity);\n        this.heightSetting && (this.baselineOffset += (this.heightSetting - l.h) / 2);\n        this.needsBox && !a.textPath && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), a.add(this)), a = this.getCrispAdjust(), g.x = a, g.y = (this.baseline ? -this.baselineOffset : 0) + a, g.width = Math.round(this.width), g.height = Math.round(this.height), this.box.attr(H(g, this.deferredAttr)), this.deferredAttr = {});\n      }\n      updateTextPadding() {\n        const a = this.text;\n        if (!a.textPath) {\n          this.updateBoxSize();\n          const g = this.baseline ? 0 : this.baselineOffset;\n          let p = E(this.paddingLeft, this.padding);\n          y(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (p += {\n            center: .5,\n            right: 1\n          }[this.textAlign] * (this.widthSetting - this.bBox.width));\n          if (p !== a.x || g !== a.y) a.attr(\"x\", p), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)), \"undefined\" !== typeof g && a.attr(\"y\", g);\n          a.x = p;\n          a.y = g;\n        }\n      }\n      widthSetter(a) {\n        this.widthSetting = A(a) ? a : void 0;\n      }\n      getPaddedWidth() {\n        var a = this.padding;\n        const g = E(this.paddingLeft, a);\n        a = E(this.paddingRight, a);\n        return (this.widthSetting || this.bBox.width || 0) + g + a;\n      }\n      xSetter(a) {\n        this.x = a;\n        this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(a);\n        this.attr(\"translateX\", this.xSetting);\n      }\n      ySetter(a) {\n        this.ySetting = this.y = Math.round(a);\n        this.attr(\"translateY\", this.ySetting);\n      }\n    }\n    t.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n    t.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width\".split(\" \");\n    return t;\n  });\n  L(a, \"Core/Renderer/SVG/Symbols.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function y(a, t, r, g, p) {\n      const v = [];\n      if (p) {\n        const l = p.start || 0,\n          m = E(p.r, r);\n        r = E(p.r, g || r);\n        g = (p.end || 0) - .001;\n        const f = p.innerR,\n          k = E(p.open, .001 > Math.abs((p.end || 0) - l - 2 * Math.PI)),\n          x = Math.cos(l),\n          J = Math.sin(l),\n          C = Math.cos(g),\n          e = Math.sin(g),\n          h = E(p.longArc, .001 > g - l - Math.PI ? 0 : 1);\n        let w = [\"A\", m, r, 0, h, E(p.clockwise, 1), a + m * C, t + r * e];\n        w.params = {\n          start: l,\n          end: g,\n          cx: a,\n          cy: t\n        };\n        v.push([\"M\", a + m * x, t + r * J], w);\n        A(f) && (w = [\"A\", f, f, 0, h, A(p.clockwise) ? 1 - p.clockwise : 0, a + f * x, t + f * J], w.params = {\n          start: g,\n          end: l,\n          cx: a,\n          cy: t\n        }, v.push(k ? [\"M\", a + f * C, t + f * e] : [\"L\", a + f * C, t + f * e], w));\n        k || v.push([\"Z\"]);\n      }\n      return v;\n    }\n    function F(a, t, r, g, p) {\n      return p && p.r ? H(a, t, r, g, p) : [[\"M\", a, t], [\"L\", a + r, t], [\"L\", a + r, t + g], [\"L\", a, t + g], [\"Z\"]];\n    }\n    function H(a, t, r, g, p) {\n      p = (null === p || void 0 === p ? void 0 : p.r) || 0;\n      return [[\"M\", a + p, t], [\"L\", a + r - p, t], [\"A\", p, p, 0, 0, 1, a + r, t + p], [\"L\", a + r, t + g - p], [\"A\", p, p, 0, 0, 1, a + r - p, t + g], [\"L\", a + p, t + g], [\"A\", p, p, 0, 0, 1, a, t + g - p], [\"L\", a, t + p], [\"A\", p, p, 0, 0, 1, a + p, t], [\"Z\"]];\n    }\n    const {\n      defined: A,\n      isNumber: D,\n      pick: E\n    } = a;\n    return {\n      arc: y,\n      callout: function (a, t, r, g, p) {\n        const v = Math.min(p && p.r || 0, r, g),\n          l = v + 6,\n          m = p && p.anchorX;\n        p = p && p.anchorY || 0;\n        const f = H(a, t, r, g, {\n          r: v\n        });\n        if (!D(m)) return f;\n        a + m >= r ? p > t + l && p < t + g - l ? f.splice(3, 1, [\"L\", a + r, p - 6], [\"L\", a + r + 6, p], [\"L\", a + r, p + 6], [\"L\", a + r, t + g - v]) : f.splice(3, 1, [\"L\", a + r, g / 2], [\"L\", m, p], [\"L\", a + r, g / 2], [\"L\", a + r, t + g - v]) : 0 >= a + m ? p > t + l && p < t + g - l ? f.splice(7, 1, [\"L\", a, p + 6], [\"L\", a - 6, p], [\"L\", a, p - 6], [\"L\", a, t + v]) : f.splice(7, 1, [\"L\", a, g / 2], [\"L\", m, p], [\"L\", a, g / 2], [\"L\", a, t + v]) : p && p > g && m > a + l && m < a + r - l ? f.splice(5, 1, [\"L\", m + 6, t + g], [\"L\", m, t + g + 6], [\"L\", m - 6, t + g], [\"L\", a + v, t + g]) : p && 0 > p && m > a + l && m < a + r - l && f.splice(1, 1, [\"L\", m - 6, t], [\"L\", m, t - 6], [\"L\", m + 6, t], [\"L\", r - v, t]);\n        return f;\n      },\n      circle: function (a, t, r, g) {\n        return y(a + r / 2, t + g / 2, r / 2, g / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (a, t, r, g) {\n        return [[\"M\", a + r / 2, t], [\"L\", a + r, t + g / 2], [\"L\", a + r / 2, t + g], [\"L\", a, t + g / 2], [\"Z\"]];\n      },\n      rect: F,\n      roundedRect: H,\n      square: F,\n      triangle: function (a, t, r, g) {\n        return [[\"M\", a + r / 2, t], [\"L\", a + r, t + g], [\"L\", a, t + g], [\"Z\"]];\n      },\n      \"triangle-down\": function (a, t, r, g) {\n        return [[\"M\", a, t], [\"L\", a + r, t], [\"L\", a + r / 2, t + g], [\"Z\"]];\n      }\n    };\n  });\n  L(a, \"Core/Renderer/SVG/TextBuilder.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        doc: y,\n        SVG_NS: A,\n        win: D\n      } = z,\n      {\n        attr: E,\n        extend: B,\n        fireEvent: t,\n        isString: r,\n        objectEach: g,\n        pick: p\n      } = F;\n    class v {\n      constructor(a) {\n        const g = a.styles;\n        this.renderer = a.renderer;\n        this.svgElement = a;\n        this.width = a.textWidth;\n        this.textLineHeight = g && g.lineHeight;\n        this.textOutline = g && g.textOutline;\n        this.ellipsis = !(!g || \"ellipsis\" !== g.textOverflow);\n        this.noWrap = !(!g || \"nowrap\" !== g.whiteSpace);\n      }\n      buildSVG() {\n        const g = this.svgElement,\n          m = g.element;\n        var f = g.renderer,\n          k = p(g.textStr, \"\").toString();\n        const x = -1 !== k.indexOf(\"<\"),\n          v = m.childNodes;\n        f = !g.added && f.box;\n        const C = /<br.*?>/g;\n        var e = [k, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, g.getStyle(\"font-size\"), this.width].join();\n        if (e !== g.textCache) {\n          g.textCache = e;\n          delete g.actualWidth;\n          for (e = v.length; e--;) m.removeChild(v[e]);\n          x || this.ellipsis || this.width || g.textPath || -1 !== k.indexOf(\" \") && (!this.noWrap || C.test(k)) ? \"\" !== k && (f && f.appendChild(m), k = new a(k), this.modifyTree(k.nodes), k.addToDOM(m), this.modifyDOM(), this.ellipsis && -1 !== (m.textContent || \"\").indexOf(\"\\u2026\") && g.attr(\"title\", this.unescapeEntities(g.textStr || \"\", [\"&lt;\", \"&gt;\"])), f && f.removeChild(m)) : m.appendChild(y.createTextNode(this.unescapeEntities(k)));\n          r(this.textOutline) && g.applyTextOutline && g.applyTextOutline(this.textOutline);\n        }\n      }\n      modifyDOM() {\n        const a = this.svgElement,\n          g = E(a.element, \"x\");\n        a.firstLineMetrics = void 0;\n        let f;\n        for (; f = a.element.firstChild;) if (/^[\\s\\u200B]*$/.test(f.textContent || \" \")) a.element.removeChild(f);else break;\n        [].forEach.call(a.element.querySelectorAll(\"tspan.highcharts-br\"), (k, e) => {\n          k.nextSibling && k.previousSibling && (0 === e && 1 === k.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(k.previousSibling)), E(k, {\n            dy: this.getLineHeight(k.nextSibling),\n            x: g\n          }));\n        });\n        const k = this.width || 0;\n        if (k) {\n          var x = (f, e) => {\n              var h = f.textContent || \"\";\n              const w = h.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n              var q = !this.noWrap && (1 < w.length || 1 < a.element.childNodes.length);\n              const u = this.getLineHeight(e);\n              let d = 0,\n                b = a.actualWidth;\n              if (this.ellipsis) h && this.truncate(f, h, void 0, 0, Math.max(0, k - .8 * u), (b, d) => b.substring(0, d) + \"\\u2026\");else if (q) {\n                h = [];\n                for (q = []; e.firstChild && e.firstChild !== f;) q.push(e.firstChild), e.removeChild(e.firstChild);\n                for (; w.length;) w.length && !this.noWrap && 0 < d && (h.push(f.textContent || \"\"), f.textContent = w.join(\" \").replace(/- /g, \"-\")), this.truncate(f, void 0, w, 0 === d ? b || 0 : 0, k, (b, d) => w.slice(0, d).join(\" \").replace(/- /g, \"-\")), b = a.actualWidth, d++;\n                q.forEach(b => {\n                  e.insertBefore(b, f);\n                });\n                h.forEach(b => {\n                  e.insertBefore(y.createTextNode(b), f);\n                  b = y.createElementNS(A, \"tspan\");\n                  b.textContent = \"\\u200b\";\n                  E(b, {\n                    dy: u,\n                    x: g\n                  });\n                  e.insertBefore(b, f);\n                });\n              }\n            },\n            p = k => {\n              [].slice.call(k.childNodes).forEach(e => {\n                e.nodeType === D.Node.TEXT_NODE ? x(e, k) : (-1 !== e.className.baseVal.indexOf(\"highcharts-br\") && (a.actualWidth = 0), p(e));\n              });\n            };\n          p(a.element);\n        }\n      }\n      getLineHeight(a) {\n        a = a.nodeType === D.Node.TEXT_NODE ? a.parentElement : a;\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a || this.svgElement.element).h;\n      }\n      modifyTree(a) {\n        const g = (f, k) => {\n          const {\n              attributes: l = {},\n              children: m,\n              style: p = {},\n              tagName: e\n            } = f,\n            h = this.renderer.styledMode;\n          if (\"b\" === e || \"strong\" === e) h ? l[\"class\"] = \"highcharts-strong\" : p.fontWeight = \"bold\";else if (\"i\" === e || \"em\" === e) h ? l[\"class\"] = \"highcharts-emphasized\" : p.fontStyle = \"italic\";\n          p && p.color && (p.fill = p.color);\n          \"br\" === e ? (l[\"class\"] = \"highcharts-br\", f.textContent = \"\\u200b\", (k = a[k + 1]) && k.textContent && (k.textContent = k.textContent.replace(/^ +/gm, \"\"))) : \"a\" === e && m && m.some(h => \"#text\" === h.tagName) && (f.children = [{\n            children: m,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== e && \"a\" !== e && (f.tagName = \"tspan\");\n          B(f, {\n            attributes: l,\n            style: p\n          });\n          m && m.filter(h => \"#text\" !== h.tagName).forEach(g);\n        };\n        a.forEach(g);\n        t(this.svgElement, \"afterModifyTree\", {\n          nodes: a\n        });\n      }\n      truncate(a, g, f, k, x, p) {\n        const l = this.svgElement,\n          {\n            rotation: e\n          } = l,\n          h = [];\n        let w = f ? 1 : 0,\n          q = (g || f || \"\").length,\n          u = q,\n          d,\n          b;\n        const c = function (b, c) {\n          b = c || b;\n          if ((c = a.parentNode) && \"undefined\" === typeof h[b] && c.getSubStringLength) try {\n            h[b] = k + c.getSubStringLength(0, f ? b + 1 : b);\n          } catch (I) {\n            \"\";\n          }\n          return h[b];\n        };\n        l.rotation = 0;\n        b = c(a.textContent.length);\n        if (k + b > x) {\n          for (; w <= q;) u = Math.ceil((w + q) / 2), f && (d = p(f, u)), b = c(u, d && d.length - 1), w === q ? w = q + 1 : b > x ? q = u - 1 : w = u;\n          0 === q ? a.textContent = \"\" : g && q === g.length - 1 || (a.textContent = d || p(g || f, u));\n        }\n        f && f.splice(0, u);\n        l.actualWidth = b;\n        l.rotation = e;\n      }\n      unescapeEntities(a, m) {\n        g(this.renderer.escapes, function (f, k) {\n          m && -1 !== m.indexOf(f) || (a = a.toString().replace(new RegExp(f, \"g\"), k));\n        });\n        return a;\n      }\n    }\n    return v;\n  });\n  L(a, \"Core/Renderer/SVG/SVGRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGLabel.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Renderer/SVG/TextBuilder.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D, E, B, t) {\n    const {\n        charts: r,\n        deg2rad: g,\n        doc: p,\n        isFirefox: v,\n        isMS: l,\n        isWebKit: m,\n        noop: f,\n        SVG_NS: k,\n        symbolSizes: x,\n        win: J\n      } = F,\n      {\n        addEvent: C,\n        attr: e,\n        createElement: h,\n        css: w,\n        defined: q,\n        destroyObjectProperties: u,\n        extend: d,\n        isArray: b,\n        isNumber: c,\n        isObject: n,\n        isString: G,\n        merge: I,\n        pick: K,\n        pInt: T,\n        uniqueKey: R\n      } = t;\n    let P;\n    class N {\n      constructor(b, c, d, n, h, e, q) {\n        this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, c, d, n, h, e, q);\n      }\n      init(b, c, d, n, h, q, a) {\n        const k = this.createElement(\"svg\").attr({\n            version: \"1.1\",\n            \"class\": \"highcharts-root\"\n          }),\n          N = k.element;\n        a || k.css(this.getStyle(n));\n        b.appendChild(N);\n        e(b, \"dir\", \"ltr\");\n        -1 === b.innerHTML.indexOf(\"xmlns\") && e(N, \"xmlns\", this.SVG_NS);\n        this.box = N;\n        this.boxWrapper = k;\n        this.alignedObjects = [];\n        this.url = this.getReferenceURL();\n        this.createElement(\"desc\").add().element.appendChild(p.createTextNode(\"Created with Highcharts 11.0.1\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = q;\n        this.forExport = h;\n        this.styledMode = a;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.rootFontSize = k.getStyle(\"font-size\");\n        this.setSize(c, d, !1);\n        let f;\n        v && b.getBoundingClientRect && (c = function () {\n          w(b, {\n            left: 0,\n            top: 0\n          });\n          f = b.getBoundingClientRect();\n          w(b, {\n            left: Math.ceil(f.left) - f.left + \"px\",\n            top: Math.ceil(f.top) - f.top + \"px\"\n          });\n        }, c(), this.unSubPixelFix = C(J, \"resize\", c));\n      }\n      definition(b) {\n        return new a([b]).addToDOM(this.defs.element);\n      }\n      getReferenceURL() {\n        if ((v || m) && p.getElementsByTagName(\"base\").length) {\n          if (!q(P)) {\n            var b = R();\n            b = new a([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: b\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": `url(#${b})`,\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(p.body);\n            w(b, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9E5\n            });\n            const c = p.elementFromPoint(6, 6);\n            P = \"hitme\" === (c && c.id);\n            p.body.removeChild(b);\n          }\n          if (P) return J.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n        return \"\";\n      }\n      getStyle(b) {\n        return this.style = d({\n          fontFamily: \"Helvetica, Arial, sans-serif\",\n          fontSize: \"1rem\"\n        }, b);\n      }\n      setStyle(b) {\n        this.boxWrapper.css(this.getStyle(b));\n      }\n      isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      }\n      destroy() {\n        const b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        u(this.gradients || {});\n        this.gradients = null;\n        this.defs = b.destroy();\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      }\n      createElement(b) {\n        const c = new this.Element();\n        c.init(this, b);\n        return c;\n      }\n      getRadialAttr(b, c) {\n        return {\n          cx: b[0] - b[2] / 2 + (c.cx || 0) * b[2],\n          cy: b[1] - b[2] / 2 + (c.cy || 0) * b[2],\n          r: (c.r || 0) * b[2]\n        };\n      }\n      shadowDefinition(b) {\n        const c = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(b).map(c => b[c])].join(\"-\").replace(/[^a-z0-9\\-]/g, \"\"),\n          d = I({\n            color: \"#000000\",\n            offsetX: 1,\n            offsetY: 1,\n            opacity: .15,\n            width: 5\n          }, b);\n        this.defs.element.querySelector(`#${c}`) || this.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: c\n          },\n          children: [{\n            tagName: \"feDropShadow\",\n            attributes: {\n              dx: d.offsetX,\n              dy: d.offsetY,\n              \"flood-color\": d.color,\n              \"flood-opacity\": Math.min(5 * d.opacity, 1),\n              stdDeviation: d.width / 2\n            }\n          }]\n        });\n        return c;\n      }\n      buildText(b) {\n        new B(b).buildSVG();\n      }\n      getContrast(b) {\n        b = z.parse(b).rgba.map(b => {\n          b /= 255;\n          return .03928 >= b ? b / 12.92 : Math.pow((b + .055) / 1.055, 2.4);\n        });\n        b = .2126 * b[0] + .7152 * b[1] + .0722 * b[2];\n        return 1.05 / (b + .05) > (b + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n      }\n      button(b, c, h, e, q = {}, k, N, f, u, g) {\n        const M = this.label(b, c, h, u, void 0, void 0, g, void 0, \"button\"),\n          O = this.styledMode;\n        b = q.states || {};\n        let G = 0;\n        q = I(q);\n        delete q.states;\n        const w = I({\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\",\n          fontWeight: \"normal\"\n        }, q.style);\n        delete q.style;\n        let x = a.filterUserAttributes(q);\n        M.attr(I({\n          padding: 8,\n          r: 2\n        }, x));\n        let m, p, K;\n        O || (x = I({\n          fill: \"#f7f7f7\",\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1\n        }, x), k = I(x, {\n          fill: \"#e6e6e6\"\n        }, a.filterUserAttributes(k || b.hover || {})), m = k.style, delete k.style, N = I(x, {\n          fill: \"#e6e9ff\",\n          style: {\n            color: \"#000000\",\n            fontWeight: \"bold\"\n          }\n        }, a.filterUserAttributes(N || b.select || {})), p = N.style, delete N.style, f = I(x, {\n          style: {\n            color: \"#cccccc\"\n          }\n        }, a.filterUserAttributes(f || b.disabled || {})), K = f.style, delete f.style);\n        C(M.element, l ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== G && M.setState(1);\n        });\n        C(M.element, l ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== G && M.setState(G);\n        });\n        M.setState = function (b) {\n          1 !== b && (M.state = G = b);\n          M.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          O || (M.attr([x, k, N, f][b || 0]), b = [w, m, p, K][b || 0], n(b) && M.css(b));\n        };\n        O || (M.attr(x).css(d({\n          cursor: \"default\"\n        }, w)), g && M.text.css({\n          pointerEvents: \"none\"\n        }));\n        return M.on(\"touchstart\", b => b.stopPropagation()).on(\"click\", function (b) {\n          3 !== G && e.call(M, b);\n        });\n      }\n      crispLine(b, c, d = \"round\") {\n        const n = b[0],\n          h = b[1];\n        q(n[1]) && n[1] === h[1] && (n[1] = h[1] = Math[d](n[1]) - c % 2 / 2);\n        q(n[2]) && n[2] === h[2] && (n[2] = h[2] = Math[d](n[2]) + c % 2 / 2);\n        return b;\n      }\n      path(c) {\n        const h = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        b(c) ? h.d = c : n(c) && d(h, c);\n        return this.createElement(\"path\").attr(h);\n      }\n      circle(b, c, d) {\n        b = n(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: c,\n          r: d\n        };\n        c = this.createElement(\"circle\");\n        c.xSetter = c.ySetter = function (b, c, d) {\n          d.setAttribute(\"c\" + c, b);\n        };\n        return c.attr(b);\n      }\n      arc(b, c, d, h, e, q) {\n        n(b) ? (h = b, c = h.y, d = h.r, b = h.x) : h = {\n          innerR: h,\n          start: e,\n          end: q\n        };\n        b = this.symbol(\"arc\", b, c, d, d, h);\n        b.r = d;\n        return b;\n      }\n      rect(b, c, h, q, a, k) {\n        b = n(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: c,\n          r: a,\n          width: Math.max(h || 0, 0),\n          height: Math.max(q || 0, 0)\n        };\n        const N = this.createElement(\"rect\");\n        this.styledMode || (\"undefined\" !== typeof k && (b[\"stroke-width\"] = k, d(b, N.crisp(b))), b.fill = \"none\");\n        N.rSetter = function (b, c, d) {\n          N.r = b;\n          e(d, {\n            rx: b,\n            ry: b\n          });\n        };\n        N.rGetter = function () {\n          return N.r || 0;\n        };\n        return N.attr(b);\n      }\n      roundedRect(b) {\n        return this.symbol(\"roundedRect\").attr(b);\n      }\n      setSize(b, c, d) {\n        this.width = b;\n        this.height = c;\n        this.boxWrapper.animate({\n          width: b,\n          height: c\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: K(d, !0) ? void 0 : 0\n        });\n        this.alignElements();\n      }\n      g(b) {\n        const c = this.createElement(\"g\");\n        return b ? c.attr({\n          \"class\": \"highcharts-\" + b\n        }) : c;\n      }\n      image(b, d, n, h, e, q) {\n        const a = {\n            preserveAspectRatio: \"none\"\n          },\n          k = function (b, c) {\n            b.setAttributeNS ? b.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", c) : b.setAttribute(\"hc-svg-href\", c);\n          };\n        c(d) && (a.x = d);\n        c(n) && (a.y = n);\n        c(h) && (a.width = h);\n        c(e) && (a.height = e);\n        const N = this.createElement(\"image\").attr(a);\n        d = function (c) {\n          k(N.element, b);\n          q.call(N, c);\n        };\n        q ? (k(N.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), n = new J.Image(), C(n, \"load\", d), n.src = b, n.complete && d({})) : k(N.element, b);\n        return N;\n      }\n      symbol(b, c, n, a, k, N) {\n        const f = this,\n          u = /^url\\((.*?)\\)$/,\n          g = u.test(b),\n          M = !g && (this.symbols[b] ? b : \"circle\"),\n          G = M && this.symbols[M];\n        let O, l, m, I;\n        if (G) \"number\" === typeof c && (l = G.call(this.symbols, Math.round(c || 0), Math.round(n || 0), a || 0, k || 0, N)), O = this.path(l), f.styledMode || O.attr(\"fill\", \"none\"), d(O, {\n          symbolName: M || void 0,\n          x: c,\n          y: n,\n          width: a,\n          height: k\n        }), N && d(O, N);else if (g) {\n          m = b.match(u)[1];\n          const d = O = this.image(m);\n          d.imgwidth = K(N && N.width, x[m] && x[m].width);\n          d.imgheight = K(N && N.height, x[m] && x[m].height);\n          I = b => b.attr({\n            width: b.width,\n            height: b.height\n          });\n          [\"width\", \"height\"].forEach(function (b) {\n            d[b + \"Setter\"] = function (b, c) {\n              this[c] = b;\n              const {\n                alignByTranslate: d,\n                element: n,\n                width: h,\n                height: a,\n                imgwidth: k,\n                imgheight: f\n              } = this;\n              b = this[\"img\" + c];\n              if (q(b)) {\n                let q = 1;\n                N && \"within\" === N.backgroundSize && h && a ? (q = Math.min(h / k, a / f), e(n, {\n                  width: Math.round(k * q),\n                  height: Math.round(f * q)\n                })) : n && n.setAttribute(c, b);\n                d || this.translate(((h || 0) - k * q) / 2, ((a || 0) - f * q) / 2);\n              }\n            };\n          });\n          q(c) && d.attr({\n            x: c,\n            y: n\n          });\n          d.isImg = !0;\n          q(d.imgwidth) && q(d.imgheight) ? I(d) : (d.attr({\n            width: 0,\n            height: 0\n          }), h(\"img\", {\n            onload: function () {\n              const b = r[f.chartIndex];\n              0 === this.width && (w(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), p.body.appendChild(this));\n              x[m] = {\n                width: this.width,\n                height: this.height\n              };\n              d.imgwidth = this.width;\n              d.imgheight = this.height;\n              d.element && I(d);\n              this.parentNode && this.parentNode.removeChild(this);\n              f.imgCount--;\n              if (!f.imgCount && b && !b.hasLoaded) b.onload();\n            },\n            src: m\n          }), this.imgCount++);\n        }\n        return O;\n      }\n      clipRect(b, c, d, n) {\n        const h = R() + \"-\",\n          e = this.createElement(\"clipPath\").attr({\n            id: h\n          }).add(this.defs);\n        b = this.rect(b, c, d, n, 0).add(e);\n        b.id = h;\n        b.clipPath = e;\n        b.count = 0;\n        return b;\n      }\n      text(b, c, d, n) {\n        const h = {};\n        if (n && (this.allowHTML || !this.forExport)) return this.html(b, c, d);\n        h.x = Math.round(c || 0);\n        d && (h.y = Math.round(d));\n        q(b) && (h.text = b);\n        b = this.createElement(\"text\").attr(h);\n        if (!n || this.forExport && !this.allowHTML) b.xSetter = function (b, c, d) {\n          const n = d.getElementsByTagName(\"tspan\"),\n            h = d.getAttribute(c);\n          for (let d = 0, e; d < n.length; d++) e = n[d], e.getAttribute(c) === h && e.setAttribute(c, b);\n          d.setAttribute(c, b);\n        };\n        return b;\n      }\n      fontMetrics(b) {\n        b = T(A.prototype.getStyle.call(b, \"font-size\") || 0);\n        const c = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: c,\n          b: Math.round(.8 * c),\n          f: b\n        };\n      }\n      rotCorr(b, c, d) {\n        let n = b;\n        c && d && (n = Math.max(n * Math.cos(c * g), 4));\n        return {\n          x: -b / 3 * Math.sin(c * g),\n          y: n\n        };\n      }\n      pathToSegments(b) {\n        const d = [],\n          n = [],\n          h = {\n            A: 8,\n            C: 7,\n            H: 2,\n            L: 3,\n            M: 3,\n            Q: 5,\n            S: 5,\n            T: 3,\n            V: 2\n          };\n        for (let e = 0; e < b.length; e++) G(n[0]) && c(b[e]) && n.length === h[n[0].toUpperCase()] && b.splice(e, 0, n[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[e] && (n.length && d.push(n.slice(0)), n.length = 0), n.push(b[e]);\n        d.push(n.slice(0));\n        return d;\n      }\n      label(b, c, d, n, h, e, q, a, N) {\n        return new D(this, b, c, d, n, h, e, q, a, N);\n      }\n      alignElements() {\n        this.alignedObjects.forEach(b => b.align());\n      }\n    }\n    d(N.prototype, {\n      Element: A,\n      SVG_NS: k,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: E,\n      draw: f\n    });\n    H.registerRendererType(\"svg\", N, !0);\n    \"\";\n    return N;\n  });\n  L(a, \"Core/Renderer/HTML/HTMLElement.js\", [a[\"Core/Globals.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        isFirefox: y,\n        isMS: A,\n        isWebKit: D,\n        win: E\n      } = a,\n      {\n        css: B,\n        defined: t,\n        extend: r,\n        pick: g,\n        pInt: p\n      } = F,\n      v = [];\n    class l extends z {\n      static compose(a) {\n        if (F.pushUnique(v, a)) {\n          const f = l.prototype,\n            k = a.prototype;\n          k.getSpanCorrection = f.getSpanCorrection;\n          k.htmlCss = f.htmlCss;\n          k.htmlGetBBox = f.htmlGetBBox;\n          k.htmlUpdateTransform = f.htmlUpdateTransform;\n          k.setSpanRotation = f.setSpanRotation;\n        }\n        return a;\n      }\n      getSpanCorrection(a, f, k) {\n        this.xCorr = -a * k;\n        this.yCorr = -f;\n      }\n      htmlCss(a) {\n        const f = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n          k = g(f && a.width, void 0);\n        let l;\n        f && (delete a.width, this.textWidth = k, l = !0);\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = r(this.styles, a);\n        B(this.element, a);\n        l && this.htmlUpdateTransform();\n        return this;\n      }\n      htmlGetBBox() {\n        const a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      }\n      htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n            f = this.element,\n            k = this.x || 0,\n            g = this.y || 0,\n            l = this.textAlign || \"left\",\n            v = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[l],\n            e = this.styles,\n            h = e && e.whiteSpace;\n          B(f, {\n            marginLeft: this.translateX || 0,\n            marginTop: this.translateY || 0\n          });\n          if (\"SPAN\" === f.tagName) {\n            e = this.rotation;\n            const q = this.textWidth && p(this.textWidth),\n              u = [e, l, f.innerHTML, this.textWidth, this.textAlign].join();\n            let d = !1;\n            if (q !== this.oldTextWidth) {\n              if (this.textPxLength) var w = this.textPxLength;else B(f, {\n                width: \"\",\n                whiteSpace: h || \"nowrap\"\n              }), w = f.offsetWidth;\n              (q > this.oldTextWidth || w > q) && (/[ \\-]/.test(f.textContent || f.innerText) || \"ellipsis\" === f.style.textOverflow) && (B(f, {\n                width: w > q || e ? q + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: h || \"normal\"\n              }), this.oldTextWidth = q, d = !0);\n            }\n            this.hasBoxWidthChanged = d;\n            u !== this.cTT && (a = a.fontMetrics(f).b, !t(e) || e === (this.oldRotation || 0) && l === this.oldAlign || this.setSpanRotation(e, v, a), this.getSpanCorrection(!t(e) && this.textPxLength || f.offsetWidth, a, v, e, l));\n            B(f, {\n              left: k + (this.xCorr || 0) + \"px\",\n              top: g + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = u;\n            this.oldRotation = e;\n            this.oldAlign = l;\n          }\n        } else this.alignOnAdd = !0;\n      }\n      setSpanRotation(a, f, k) {\n        const g = {},\n          l = A && !/Edge/.test(E.navigator.userAgent) ? \"-ms-transform\" : D ? \"-webkit-transform\" : y ? \"MozTransform\" : E.opera ? \"-o-transform\" : void 0;\n        l && (g[l] = g.transform = \"rotate(\" + a + \"deg)\", g[l + (y ? \"Origin\" : \"-origin\")] = g.transformOrigin = 100 * f + \"% \" + k + \"px\", B(this.element, g));\n      }\n    }\n    return l;\n  });\n  L(a, \"Core/Renderer/HTML/HTMLRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H) {\n    const {\n        attr: y,\n        createElement: D,\n        extend: E,\n        pick: B\n      } = H,\n      t = [];\n    class r extends F {\n      static compose(a) {\n        H.pushUnique(t, a) && (a.prototype.html = r.prototype.html);\n        return a;\n      }\n      html(g, p, v) {\n        const l = this.createElement(\"span\"),\n          m = l.element,\n          f = l.renderer,\n          k = function (a, k) {\n            [\"opacity\", \"visibility\"].forEach(function (f) {\n              a[f + \"Setter\"] = function (e, h, g) {\n                const q = a.div ? a.div.style : k;\n                z.prototype[f + \"Setter\"].call(this, e, h, g);\n                q && (q[h] = e);\n              };\n            });\n            a.addedSetters = !0;\n          };\n        l.textSetter = function (k) {\n          k !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, B(k, \"\")), this.textStr = k, l.doTransform = !0);\n        };\n        k(l, l.element.style);\n        l.xSetter = l.ySetter = l.alignSetter = l.rotationSetter = function (a, k) {\n          \"align\" === k ? l.alignValue = l.textAlign = a : l[k] = a;\n          l.doTransform = !0;\n        };\n        l.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n        l.attr({\n          text: g,\n          x: Math.round(p),\n          y: Math.round(v)\n        }).css({\n          position: \"absolute\"\n        });\n        f.styledMode || l.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        m.style.whiteSpace = \"nowrap\";\n        l.css = l.htmlCss;\n        l.add = function (a) {\n          const g = f.box.parentNode,\n            x = [];\n          let e;\n          if (this.parentGroup = a) {\n            if (e = a.div, !e) {\n              for (; a;) x.push(a), a = a.parentGroup;\n              x.reverse().forEach(function (h) {\n                function a(b, c) {\n                  h[c] = b;\n                  \"translateX\" === c ? d.left = b + \"px\" : d.top = b + \"px\";\n                  h.doTransform = !0;\n                }\n                const q = y(h.element, \"class\"),\n                  f = h.styles || {};\n                e = h.div = h.div || D(\"div\", q ? {\n                  className: q\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (h.translateX || 0) + \"px\",\n                  top: (h.translateY || 0) + \"px\",\n                  display: h.display,\n                  opacity: h.opacity,\n                  visibility: h.visibility\n                }, e || g);\n                const d = e.style;\n                E(h, {\n                  classSetter: function (b) {\n                    return function (c) {\n                      this.element.setAttribute(\"class\", c);\n                      b.className = c;\n                    };\n                  }(e),\n                  css: function (b) {\n                    l.css.call(h, b);\n                    [\"cursor\", \"pointerEvents\"].forEach(c => {\n                      b[c] && (d[c] = b[c]);\n                    });\n                    return h;\n                  },\n                  on: function () {\n                    x[0].div && l.on.apply({\n                      element: x[0].div,\n                      onEvents: h.onEvents\n                    }, arguments);\n                    return h;\n                  },\n                  translateXSetter: a,\n                  translateYSetter: a\n                });\n                h.addedSetters || k(h);\n                h.css(f);\n              });\n            }\n          } else e = g;\n          e.appendChild(m);\n          l.added = !0;\n          l.alignOnAdd && l.htmlUpdateTransform();\n          return l;\n        };\n        return l;\n      }\n    }\n    return r;\n  });\n  L(a, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var a = /*#__PURE__*/(() => {\n      a = a || {};\n      a.defaultXAxisOptions = {\n        alignTicks: !0,\n        allowDecimals: void 0,\n        panningEnabled: !0,\n        zIndex: 2,\n        zoomEnabled: !0,\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e %b\"\n          },\n          week: {\n            main: \"%e %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        gridLineDashStyle: \"Solid\",\n        gridZIndex: 1,\n        labels: {\n          autoRotation: void 0,\n          autoRotationLimit: 80,\n          distance: 15,\n          enabled: !0,\n          indentation: 10,\n          overflow: \"justify\",\n          padding: 5,\n          reserveSpace: void 0,\n          rotation: void 0,\n          staggerLines: 0,\n          step: 0,\n          useHTML: !1,\n          zIndex: 7,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          }\n        },\n        maxPadding: .01,\n        minorGridLineDashStyle: \"Solid\",\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minorTicksPerMajor: 5,\n        minPadding: .01,\n        offset: void 0,\n        opposite: !1,\n        reversed: void 0,\n        reversedStacks: !1,\n        showEmpty: !0,\n        showFirstLabel: !0,\n        showLastLabel: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          rotation: 0,\n          useHTML: !1,\n          x: 0,\n          y: 0,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          }\n        },\n        type: \"linear\",\n        uniqueNames: !0,\n        visible: !0,\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#333333\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        gridLineWidth: void 0,\n        tickColor: \"#333333\"\n      };\n      a.defaultYAxisOptions = {\n        reversedStacks: !0,\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: void 0\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          animation: {},\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function () {\n            const {\n              numberFormatter: a\n            } = this.axis.chart;\n            return a(this.total || 0, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      a.defaultLeftAxisOptions = {\n        title: {\n          rotation: 270\n        }\n      };\n      a.defaultRightAxisOptions = {\n        title: {\n          rotation: 90\n        }\n      };\n      a.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      a.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      return a;\n    })();\n    return a;\n  });\n  L(a, \"Core/Foundation.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: y,\n      isFunction: F,\n      objectEach: H,\n      removeEvent: A\n    } = a;\n    var D = /*#__PURE__*/(() => {\n      (function (a) {\n        a.registerEventOptions = function (a, t) {\n          a.eventOptions = a.eventOptions || {};\n          H(t.events, function (r, g) {\n            a.eventOptions[g] !== r && (a.eventOptions[g] && (A(a, g, a.eventOptions[g]), delete a.eventOptions[g]), F(r) && (a.eventOptions[g] = r, y(a, g, r, {\n              order: 0\n            })));\n          });\n        };\n      })(D || (D = {}));\n      return D;\n    })();\n    return D;\n  });\n  L(a, \"Core/Axis/Tick.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        deg2rad: y\n      } = z,\n      {\n        clamp: A,\n        correctFloat: D,\n        defined: E,\n        destroyObjectProperties: B,\n        extend: t,\n        fireEvent: r,\n        isNumber: g,\n        merge: p,\n        objectEach: v,\n        pick: l\n      } = F;\n    class m {\n      constructor(a, k, g, l, p) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = a;\n        this.pos = k;\n        this.type = g || \"\";\n        this.parameters = p || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        r(this, \"init\");\n        g || l || this.addLabel();\n      }\n      addLabel() {\n        const f = this,\n          k = f.axis;\n        var x = k.options;\n        const p = k.chart;\n        var m = k.categories;\n        const e = k.logarithmic,\n          h = k.names,\n          w = f.pos,\n          q = l(f.options && f.options.labels, x.labels);\n        var u = k.tickPositions;\n        const d = w === u[0],\n          b = w === u[u.length - 1],\n          c = (!q.step || 1 === q.step) && 1 === k.tickInterval;\n        u = u.info;\n        let n = f.label,\n          G,\n          I,\n          K;\n        m = this.parameters.category || (m ? l(m[w], h[w], w) : w);\n        e && g(m) && (m = D(e.lin2log(m)));\n        k.dateTime && (u ? (I = p.time.resolveDTLFormat(x.dateTimeLabelFormats[!x.grid && u.higherRanks[w] || u.unitName]), G = I.main) : g(m) && (G = k.dateTime.getXDateFormat(m, x.dateTimeLabelFormats || {})));\n        f.isFirst = d;\n        f.isLast = b;\n        const v = {\n          axis: k,\n          chart: p,\n          dateTimeLabelFormat: G,\n          isFirst: d,\n          isLast: b,\n          pos: w,\n          tick: f,\n          tickPositionInfo: u,\n          value: m\n        };\n        r(this, \"labelFormat\", v);\n        const R = b => q.formatter ? q.formatter.call(b, b) : q.format ? (b.text = k.defaultLabelFormatter.call(b, b), a.format(q.format, b, p)) : k.defaultLabelFormatter.call(b, b);\n        x = R.call(v, v);\n        const P = I && I.list;\n        f.shortenLabel = P ? function () {\n          for (K = 0; K < P.length; K++) if (t(v, {\n            dateTimeLabelFormat: P[K]\n          }), n.attr({\n            text: R.call(v, v)\n          }), n.getBBox().width < k.getSlotWidth(f) - 2 * q.padding) return;\n          n.attr({\n            text: \"\"\n          });\n        } : void 0;\n        c && k._addedPlotLB && f.moveLabel(x, q);\n        E(n) || f.movedLabel ? n && n.textStr !== x && !c && (!n.textWidth || q.style.width || n.styles.width || n.css({\n          width: null\n        }), n.attr({\n          text: x\n        }), n.textPxLength = n.getBBox().width) : (f.label = n = f.createLabel({\n          x: 0,\n          y: 0\n        }, x, q), f.rotation = 0);\n      }\n      createLabel(a, k, g) {\n        const f = this.axis,\n          l = f.chart;\n        if (a = E(k) && g.enabled ? l.renderer.text(k, a.x, a.y, g.useHTML).add(f.labelGroup) : null) l.styledMode || a.css(p(g.style)), a.textPxLength = a.getBBox().width;\n        return a;\n      }\n      destroy() {\n        B(this, this.axis);\n      }\n      getPosition(a, k, g, l) {\n        const f = this.axis,\n          e = f.chart,\n          h = l && e.oldChartHeight || e.chartHeight;\n        a = {\n          x: a ? D(f.translate(k + g, void 0, void 0, l) + f.transB) : f.left + f.offset + (f.opposite ? (l && e.oldChartWidth || e.chartWidth) - f.right - f.left : 0),\n          y: a ? h - f.bottom + f.offset - (f.opposite ? f.height : 0) : D(h - f.translate(k + g, void 0, void 0, l) - f.transB)\n        };\n        a.y = A(a.y, -1E5, 1E5);\n        r(this, \"afterGetPosition\", {\n          pos: a\n        });\n        return a;\n      }\n      getLabelPosition(a, k, g, m, p, e, h, w) {\n        const q = this.axis,\n          f = q.transA,\n          d = q.isLinked && q.linkedParent ? q.linkedParent.reversed : q.reversed,\n          b = q.staggerLines,\n          c = q.tickRotCorr || {\n            x: 0,\n            y: 0\n          },\n          n = m || q.reserveSpaceDefault ? 0 : -q.labelOffset * (\"center\" === q.labelAlign ? .5 : 1),\n          G = p.distance,\n          I = {};\n        g = 0 === q.side ? g.rotation ? -G : -g.getBBox().height : 2 === q.side ? c.y + G : Math.cos(g.rotation * y) * (c.y - g.getBBox(!1, 0).height / 2);\n        E(p.y) && (g = 0 === q.side && q.horiz ? p.y + g : p.y);\n        a = a + l(p.x, [0, 1, 0, -1][q.side] * G) + n + c.x - (e && m ? e * f * (d ? -1 : 1) : 0);\n        k = k + g - (e && !m ? e * f * (d ? 1 : -1) : 0);\n        b && (m = h / (w || 1) % b, q.opposite && (m = b - m - 1), k += q.labelOffset / b * m);\n        I.x = a;\n        I.y = Math.round(k);\n        r(this, \"afterGetLabelPosition\", {\n          pos: I,\n          tickmarkOffset: e,\n          index: h\n        });\n        return I;\n      }\n      getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      }\n      getMarkPath(a, k, g, l, m, e) {\n        return e.crispLine([[\"M\", a, k], [\"L\", a + (m ? 0 : -g), k + (m ? g : 0)]], l);\n      }\n      handleOverflow(a) {\n        const k = this.axis,\n          f = k.options.labels,\n          g = a.x;\n        var m = k.chart.chartWidth,\n          e = k.chart.spacing;\n        const h = l(k.labelLeft, Math.min(k.pos, e[3]));\n        e = l(k.labelRight, Math.max(k.isRadial ? 0 : k.pos + k.len, m - e[1]));\n        const w = this.label,\n          q = this.rotation,\n          u = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[k.labelAlign || w.attr(\"align\")],\n          d = w.getBBox().width,\n          b = k.getSlotWidth(this),\n          c = {};\n        let n = b,\n          G = 1,\n          I;\n        if (q || \"justify\" !== f.overflow) 0 > q && g - u * d < h ? I = Math.round(g / Math.cos(q * y) - h) : 0 < q && g + u * d > e && (I = Math.round((m - g) / Math.cos(q * y)));else if (m = g + (1 - u) * d, g - u * d < h ? n = a.x + n * (1 - u) - h : m > e && (n = e - a.x + n * u, G = -1), n = Math.min(b, n), n < b && \"center\" === k.labelAlign && (a.x += G * (b - n - u * (b - Math.min(d, n)))), d > n || k.autoRotation && (w.styles || {}).width) I = n;\n        I && (this.shortenLabel ? this.shortenLabel() : (c.width = Math.floor(I) + \"px\", (f.style || {}).textOverflow || (c.textOverflow = \"ellipsis\"), w.css(c)));\n      }\n      moveLabel(a, k) {\n        const f = this;\n        var g = f.label;\n        const l = f.axis;\n        let e = !1;\n        g && g.textStr === a ? (f.movedLabel = g, e = !0, delete f.label) : v(l.ticks, function (h) {\n          e || h.isNew || h === f || !h.label || h.label.textStr !== a || (f.movedLabel = h.label, e = !0, h.labelPos = f.movedLabel.xy, delete h.label);\n        });\n        e || !f.labelPos && !g || (g = f.labelPos || g.xy, f.movedLabel = f.createLabel(g, a, k), f.movedLabel && f.movedLabel.attr({\n          opacity: 0\n        }));\n      }\n      render(a, k, g) {\n        var f = this.axis,\n          m = f.horiz,\n          e = this.pos,\n          h = l(this.tickmarkOffset, f.tickmarkOffset);\n        e = this.getPosition(m, e, h, k);\n        h = e.x;\n        const w = e.y;\n        f = m && h === f.pos + f.len || !m && w === f.pos ? -1 : 1;\n        m = l(g, this.label && this.label.newOpacity, 1);\n        g = l(g, 1);\n        this.isActive = !0;\n        this.renderGridLine(k, g, f);\n        this.renderMark(e, g, f);\n        this.renderLabel(e, k, m, a);\n        this.isNew = !1;\n        r(this, \"afterRender\");\n      }\n      renderGridLine(a, k, g) {\n        const f = this.axis,\n          m = f.options,\n          e = {},\n          h = this.pos,\n          w = this.type,\n          q = l(this.tickmarkOffset, f.tickmarkOffset),\n          u = f.chart.renderer;\n        let d = this.gridLine,\n          b = m.gridLineWidth,\n          c = m.gridLineColor,\n          n = m.gridLineDashStyle;\n        \"minor\" === this.type && (b = m.minorGridLineWidth, c = m.minorGridLineColor, n = m.minorGridLineDashStyle);\n        d || (f.chart.styledMode || (e.stroke = c, e[\"stroke-width\"] = b || 0, e.dashstyle = n), w || (e.zIndex = 1), a && (k = 0), this.gridLine = d = u.path().attr(e).addClass(\"highcharts-\" + (w ? w + \"-\" : \"\") + \"grid-line\").add(f.gridGroup));\n        if (d && (g = f.getPlotLinePath({\n          value: h + q,\n          lineWidth: d.strokeWidth() * g,\n          force: \"pass\",\n          old: a,\n          acrossPanes: !1\n        }))) d[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: g,\n          opacity: k\n        });\n      }\n      renderMark(a, k, g) {\n        const f = this.axis;\n        var m = f.options;\n        const e = f.chart.renderer,\n          h = this.type,\n          w = f.tickSize(h ? h + \"Tick\" : \"tick\"),\n          q = a.x;\n        a = a.y;\n        const u = l(m[\"minor\" !== h ? \"tickWidth\" : \"minorTickWidth\"], !h && f.isXAxis ? 1 : 0);\n        m = m[\"minor\" !== h ? \"tickColor\" : \"minorTickColor\"];\n        let d = this.mark;\n        const b = !d;\n        w && (f.opposite && (w[0] = -w[0]), d || (this.mark = d = e.path().addClass(\"highcharts-\" + (h ? h + \"-\" : \"\") + \"tick\").add(f.axisGroup), f.chart.styledMode || d.attr({\n          stroke: m,\n          \"stroke-width\": u\n        })), d[b ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(q, a, w[0], d.strokeWidth() * g, f.horiz, e),\n          opacity: k\n        }));\n      }\n      renderLabel(a, k, m, p) {\n        var f = this.axis;\n        const e = f.horiz,\n          h = f.options,\n          w = this.label,\n          q = h.labels,\n          u = q.step;\n        f = l(this.tickmarkOffset, f.tickmarkOffset);\n        const d = a.x;\n        a = a.y;\n        let b = !0;\n        w && g(d) && (w.xy = a = this.getLabelPosition(d, a, w, e, q, f, p, u), this.isFirst && !this.isLast && !h.showFirstLabel || this.isLast && !this.isFirst && !h.showLastLabel ? b = !1 : !e || q.step || q.rotation || k || 0 === m || this.handleOverflow(a), u && p % u && (b = !1), b && g(a.y) ? (a.opacity = m, w[this.isNewLabel ? \"attr\" : \"animate\"](a).show(!0), this.isNewLabel = !1) : (w.hide(), this.isNewLabel = !0));\n      }\n      replaceMovedLabel() {\n        const a = this.label,\n          k = this.axis;\n        a && !this.isNew && (a.animate({\n          opacity: 0\n        }, void 0, a.destroy), delete this.label);\n        k.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      }\n    }\n    \"\";\n    return m;\n  });\n  L(a, \"Core/Axis/Axis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/AxisDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D, E, B) {\n    const {\n        animObject: t\n      } = a,\n      {\n        defaultOptions: r\n      } = H,\n      {\n        registerEventOptions: g\n      } = A,\n      {\n        deg2rad: p\n      } = D,\n      {\n        arrayMax: v,\n        arrayMin: l,\n        clamp: m,\n        correctFloat: f,\n        defined: k,\n        destroyObjectProperties: x,\n        erase: J,\n        error: C,\n        extend: e,\n        fireEvent: h,\n        isArray: w,\n        isNumber: q,\n        isString: u,\n        merge: d,\n        normalizeTickInterval: b,\n        objectEach: c,\n        pick: n,\n        relativeLength: G,\n        removeEvent: I,\n        splat: K,\n        syncTimeout: T\n      } = B,\n      R = (c, d) => b(d, void 0, void 0, n(c.options.allowDecimals, .5 > d || void 0 !== c.tickAmount), !!c.tickAmount);\n    class P {\n      constructor(b, c) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;\n        this.init(b, c);\n      }\n      init(b, c) {\n        const d = c.isX;\n        this.chart = b;\n        this.horiz = b.inverted && !this.isZAxis ? !d : d;\n        this.isXAxis = d;\n        this.coll = this.coll || (d ? \"xAxis\" : \"yAxis\");\n        h(this, \"init\", {\n          userOptions: c\n        });\n        this.opposite = n(c.opposite, this.opposite);\n        this.side = n(c.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n        this.setOptions(c);\n        const a = this.options,\n          e = a.labels,\n          f = a.type;\n        this.userOptions = c;\n        this.minPixelPadding = 0;\n        this.reversed = n(a.reversed, this.reversed);\n        this.visible = a.visible;\n        this.zoomEnabled = a.zoomEnabled;\n        this.hasNames = \"category\" === f || !0 === a.categories;\n        this.categories = a.categories || (this.hasNames ? [] : void 0);\n        this.names || (this.names = [], this.names.keys = {});\n        this.plotLinesAndBandsGroups = {};\n        this.positiveValuesOnly = !!this.logarithmic;\n        this.isLinked = k(a.linkedTo);\n        this.ticks = {};\n        this.labelEdge = [];\n        this.minorTicks = {};\n        this.plotLinesAndBands = [];\n        this.alternateBands = {};\n        this.len = 0;\n        this.minRange = this.userMinRange = a.minRange || a.maxZoom;\n        this.range = a.range;\n        this.offset = a.offset || 0;\n        this.min = this.max = null;\n        c = n(a.crosshair, K(b.options.tooltip.crosshairs)[d ? 0 : 1]);\n        this.crosshair = !0 === c ? {} : c;\n        -1 === b.axes.indexOf(this) && (d ? b.axes.splice(b.xAxis.length, 0, this) : b.axes.push(this), b[this.coll].push(this));\n        this.series = this.series || [];\n        b.inverted && !this.isZAxis && d && \"undefined\" === typeof this.reversed && (this.reversed = !0);\n        this.labelRotation = q(e.rotation) ? e.rotation : void 0;\n        g(this, a);\n        h(this, \"afterInit\");\n      }\n      setOptions(b) {\n        this.options = d(z.defaultXAxisOptions, \"yAxis\" === this.coll && z.defaultYAxisOptions, [z.defaultTopAxisOptions, z.defaultRightAxisOptions, z.defaultBottomAxisOptions, z.defaultLeftAxisOptions][this.side], d(r[this.coll], b));\n        h(this, \"afterSetOptions\", {\n          userOptions: b\n        });\n      }\n      defaultLabelFormatter(b) {\n        var c = this.axis;\n        ({\n          numberFormatter: b\n        } = this.chart);\n        const d = q(this.value) ? this.value : NaN,\n          n = c.chart.time,\n          h = this.dateTimeLabelFormat;\n        var a = r.lang;\n        const e = a.numericSymbols;\n        a = a.numericSymbolMagnitude || 1E3;\n        const k = c.logarithmic ? Math.abs(d) : c.tickInterval;\n        let f = e && e.length,\n          N;\n        if (c.categories) N = `${this.value}`;else if (h) N = n.dateFormat(h, d);else if (f && 1E3 <= k) for (; f-- && \"undefined\" === typeof N;) c = Math.pow(a, f + 1), k >= c && 0 === 10 * d % c && null !== e[f] && 0 !== d && (N = b(d / c, -1) + e[f]);\n        \"undefined\" === typeof N && (N = 1E4 <= Math.abs(d) ? b(d, -1) : b(d, -1, void 0, \"\"));\n        return N;\n      }\n      getSeriesExtremes() {\n        const b = this,\n          c = b.chart;\n        let d;\n        h(this, \"getSeriesExtremes\", null, function () {\n          b.hasVisibleSeries = !1;\n          b.dataMin = b.dataMax = b.threshold = null;\n          b.softThreshold = !b.isXAxis;\n          b.series.forEach(function (h) {\n            if (h.visible || !c.options.chart.ignoreHiddenSeries) {\n              var a = h.options;\n              let c = a.threshold,\n                e,\n                f;\n              b.hasVisibleSeries = !0;\n              b.positiveValuesOnly && 0 >= c && (c = null);\n              if (b.isXAxis) (a = h.xData) && a.length && (a = b.logarithmic ? a.filter(b => 0 < b) : a, d = h.getXExtremes(a), e = d.min, f = d.max, q(e) || e instanceof Date || (a = a.filter(q), d = h.getXExtremes(a), e = d.min, f = d.max), a.length && (b.dataMin = Math.min(n(b.dataMin, e), e), b.dataMax = Math.max(n(b.dataMax, f), f)));else if (h = h.applyExtremes(), q(h.dataMin) && (e = h.dataMin, b.dataMin = Math.min(n(b.dataMin, e), e)), q(h.dataMax) && (f = h.dataMax, b.dataMax = Math.max(n(b.dataMax, f), f)), k(c) && (b.threshold = c), !a.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;\n            }\n          });\n        });\n        h(this, \"afterGetSeriesExtremes\");\n      }\n      translate(b, c, d, n, h, a) {\n        const e = this.linkedParent || this,\n          k = n && e.old ? e.old.min : e.min;\n        if (!q(k)) return NaN;\n        const N = e.minPixelPadding;\n        h = (e.isOrdinal || e.brokenAxis && e.brokenAxis.hasBreaks || e.logarithmic && h) && e.lin2val;\n        let g = 1,\n          u = 0;\n        n = n && e.old ? e.old.transA : e.transA;\n        n || (n = e.transA);\n        d && (g *= -1, u = e.len);\n        e.reversed && (g *= -1, u -= g * (e.sector || e.len));\n        c ? (a = (b * g + u - N) / n + k, h && (a = e.lin2val(a))) : (h && (b = e.val2lin(b)), b = g * (b - k) * n, a = (e.isRadial ? b : f(b)) + u + g * N + (q(a) ? n * a : 0));\n        return a;\n      }\n      toPixels(b, c) {\n        return this.translate(b, !1, !this.horiz, void 0, !0) + (c ? 0 : this.pos);\n      }\n      toValue(b, c) {\n        return this.translate(b - (c ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      }\n      getPlotLinePath(b) {\n        function c(b, c, d) {\n          \"pass\" !== I && (b < c || b > d) && (I ? b = m(b, c, d) : P = !0);\n          return b;\n        }\n        const d = this,\n          a = d.chart,\n          e = d.left,\n          k = d.top,\n          f = b.old,\n          g = b.value,\n          N = b.lineWidth,\n          u = f && a.oldChartHeight || a.chartHeight,\n          G = f && a.oldChartWidth || a.chartWidth,\n          w = d.transB;\n        let l = b.translatedValue,\n          I = b.force,\n          p,\n          K,\n          v,\n          x,\n          P;\n        b = {\n          value: g,\n          lineWidth: N,\n          old: f,\n          force: I,\n          acrossPanes: b.acrossPanes,\n          translatedValue: l\n        };\n        h(this, \"getPlotLinePath\", b, function (b) {\n          l = n(l, d.translate(g, void 0, void 0, f));\n          l = m(l, -1E5, 1E5);\n          p = v = Math.round(l + w);\n          K = x = Math.round(u - l - w);\n          q(l) ? d.horiz ? (K = k, x = u - d.bottom, p = v = c(p, e, e + d.width)) : (p = e, v = G - d.right, K = x = c(K, k, k + d.height)) : (P = !0, I = !1);\n          b.path = P && !I ? null : a.renderer.crispLine([[\"M\", p, K], [\"L\", v, x]], N || 1);\n        });\n        return b.path;\n      }\n      getLinearTickPositions(b, c, d) {\n        const n = f(Math.floor(c / b) * b);\n        d = f(Math.ceil(d / b) * b);\n        const h = [];\n        let a, e;\n        f(n + b) === n && (e = 20);\n        if (this.single) return [c];\n        for (c = n; c <= d;) {\n          h.push(c);\n          c = f(c + b, e);\n          if (c === a) break;\n          a = c;\n        }\n        return h;\n      }\n      getMinorTickInterval() {\n        const b = this.options;\n        return !0 === b.minorTicks ? n(b.minorTickInterval, \"auto\") : !1 === b.minorTicks ? null : b.minorTickInterval;\n      }\n      getMinorTickPositions() {\n        var b = this.options;\n        const c = this.tickPositions,\n          d = this.minorTickInterval;\n        var n = this.pointRangePadding || 0;\n        const h = this.min - n;\n        n = this.max + n;\n        const a = n - h;\n        let e = [];\n        if (a && a / d < this.len / 3) {\n          const a = this.logarithmic;\n          if (a) this.paddedTicks.forEach(function (b, c, n) {\n            c && e.push.apply(e, a.getLogTickPositions(d, n[c - 1], n[c], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) e = e.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(d), h, n, b.startOfWeek));else for (b = h + (c[0] - h) % d; b <= n && b !== e[0]; b += d) e.push(b);\n        }\n        0 !== e.length && this.trimTicks(e);\n        return e;\n      }\n      adjustForMinRange() {\n        const b = this.options,\n          c = this.logarithmic;\n        let d = this.min;\n        var h = this.max;\n        let a,\n          e = 0,\n          q,\n          f,\n          g,\n          u,\n          G;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !c && (k(b.min) || k(b.max) || k(b.floor) || k(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {\n          g = b.xData;\n          u = b.xIncrement ? 1 : g.length - 1;\n          if (1 < g.length) for (q = u; 0 < q; q--) if (f = g[q] - g[q - 1], !e || f < e) e = f;\n        }), this.minRange = Math.min(5 * e, this.dataMax - this.dataMin)));\n        if (h - d < this.minRange) {\n          a = this.dataMax - this.dataMin >= this.minRange;\n          G = this.minRange;\n          var w = (G - h + d) / 2;\n          w = [d - w, n(b.min, d - w)];\n          a && (w[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          d = v(w);\n          h = [d + G, n(b.max, d + G)];\n          a && (h[2] = c ? c.log2lin(this.dataMax) : this.dataMax);\n          h = l(h);\n          h - d < G && (w[0] = h - G, w[1] = n(b.min, h - G), d = v(w));\n        }\n        this.min = d;\n        this.max = h;\n      }\n      getClosest() {\n        let b;\n        this.categories ? b = 1 : this.series.forEach(function (c) {\n          const d = c.closestPointRange,\n            n = c.visible || !c.chart.options.chart.ignoreHiddenSeries;\n          !c.noSharedTooltip && k(d) && n && (b = k(b) ? Math.min(b, d) : d);\n        });\n        return b;\n      }\n      nameToX(b) {\n        const c = w(this.options.categories),\n          d = c ? this.categories : this.names;\n        let h = b.options.x,\n          a;\n        b.series.requireSorting = !1;\n        k(h) || (h = this.options.uniqueNames && d ? c ? d.indexOf(b.name) : n(d.keys[b.name], -1) : b.series.autoIncrement());\n        -1 === h ? !c && d && (a = d.length) : a = h;\n        \"undefined\" !== typeof a ? (this.names[a] = b.name, this.names.keys[b.name] = a) : b.x && (a = b.x);\n        return a;\n      }\n      updateNames() {\n        const b = this,\n          c = this.names;\n        0 < c.length && (Object.keys(c.keys).forEach(function (b) {\n          delete c.keys[b];\n        }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (c) {\n          c.xIncrement = null;\n          if (!c.points || c.isDirtyData) b.max = Math.max(b.max, c.xData.length - 1), c.processData(), c.generatePoints();\n          c.data.forEach(function (d, n) {\n            let h;\n            d && d.options && \"undefined\" !== typeof d.name && (h = b.nameToX(d), \"undefined\" !== typeof h && h !== d.x && (d.x = h, c.xData[n] = h));\n          });\n        }));\n      }\n      setAxisTranslation() {\n        const b = this,\n          c = b.max - b.min;\n        var d = b.linkedParent;\n        const a = !!b.categories,\n          e = b.isXAxis;\n        let q = b.axisPointRange || 0,\n          f,\n          k = 0,\n          g = 0,\n          G = b.transA;\n        if (e || a || q) f = b.getClosest(), d ? (k = d.minPointOffset, g = d.pointRangePadding) : b.series.forEach(function (c) {\n          const d = a ? 1 : e ? n(c.options.pointRange, f, 0) : b.axisPointRange || 0,\n            h = c.options.pointPlacement;\n          q = Math.max(q, d);\n          if (!b.single || a) c = c.is(\"xrange\") ? !e : e, k = Math.max(k, c && u(h) ? 0 : d / 2), g = Math.max(g, c && \"on\" === h ? 0 : d);\n        }), d = b.ordinal && b.ordinal.slope && f ? b.ordinal.slope / f : 1, b.minPointOffset = k *= d, b.pointRangePadding = g *= d, b.pointRange = Math.min(q, b.single && a ? 1 : c), e && (b.closestPointRange = f);\n        b.translationSlope = b.transA = G = b.staticScale || b.len / (c + g || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = G * k;\n        h(this, \"afterSetAxisTranslation\");\n      }\n      minFromRange() {\n        return this.max - this.range;\n      }\n      setTickInterval(b) {\n        var c = this.chart;\n        const d = this.logarithmic,\n          a = this.options,\n          e = this.isXAxis,\n          g = this.isLinked,\n          u = a.tickPixelInterval,\n          G = this.categories,\n          N = this.softThreshold;\n        let w = a.maxPadding,\n          l = a.minPadding;\n        let m = q(a.tickInterval) && 0 <= a.tickInterval ? a.tickInterval : void 0,\n          I = q(this.threshold) ? this.threshold : null,\n          p,\n          K,\n          v;\n        this.dateTime || G || g || this.getTickAmount();\n        K = n(this.userMin, a.min);\n        v = n(this.userMax, a.max);\n        if (g) {\n          this.linkedParent = c[this.coll][a.linkedTo];\n          var x = this.linkedParent.getExtremes();\n          this.min = n(x.min, x.dataMin);\n          this.max = n(x.max, x.dataMax);\n          a.type !== this.linkedParent.options.type && C(11, 1, c);\n        } else N && k(I) && (this.dataMin >= I ? (x = I, l = 0) : this.dataMax <= I && (p = I, w = 0)), this.min = n(K, x, this.dataMin), this.max = n(v, p, this.dataMax);\n        d && (this.positiveValuesOnly && !b && 0 >= Math.min(this.min, n(this.dataMin, this.min)) && C(10, 1, c), this.min = f(d.log2lin(this.min), 16), this.max = f(d.log2lin(this.max), 16));\n        this.range && k(this.max) && (this.userMin = this.min = K = Math.max(this.dataMin, this.minFromRange()), this.userMax = v = this.max, this.range = null);\n        h(this, \"foundExtremes\");\n        this.beforePadding && this.beforePadding();\n        this.adjustForMinRange();\n        !(G || this.axisPointRange || this.stacking && this.stacking.usePercentage || g) && k(this.min) && k(this.max) && (c = this.max - this.min) && (!k(K) && l && (this.min -= c * l), !k(v) && w && (this.max += c * w));\n        q(this.userMin) || (q(a.softMin) && a.softMin < this.min && (this.min = K = a.softMin), q(a.floor) && (this.min = Math.max(this.min, a.floor)));\n        q(this.userMax) || (q(a.softMax) && a.softMax > this.max && (this.max = v = a.softMax), q(a.ceiling) && (this.max = Math.min(this.max, a.ceiling)));\n        N && k(this.dataMin) && (I = I || 0, !k(K) && this.min < I && this.dataMin >= I ? this.min = this.options.minRange ? Math.min(I, this.max - this.minRange) : I : !k(v) && this.max > I && this.dataMax <= I && (this.max = this.options.minRange ? Math.max(I, this.min + this.minRange) : I));\n        q(this.min) && q(this.max) && !this.chart.polar && this.min > this.max && (k(this.options.min) ? this.max = this.min : k(this.options.max) && (this.min = this.max));\n        this.tickInterval = this.min === this.max || \"undefined\" === typeof this.min || \"undefined\" === typeof this.max ? 1 : g && this.linkedParent && !m && u === this.linkedParent.options.tickPixelInterval ? m = this.linkedParent.tickInterval : n(m, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, G ? 1 : (this.max - this.min) * u / Math.max(this.len, u));\n        if (e && !b) {\n          const b = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n          this.series.forEach(function (c) {\n            c.forceCrop = c.forceCropping && c.forceCropping();\n            c.processData(b);\n          });\n          h(this, \"postProcessData\", {\n            hasExtremesChanged: b\n          });\n        }\n        this.setAxisTranslation();\n        h(this, \"initialAxisTranslation\");\n        this.pointRange && !m && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        b = n(a.minTickInterval, this.dateTime && !this.series.some(b => b.noSharedTooltip) ? this.closestPointRange : 0);\n        !m && this.tickInterval < b && (this.tickInterval = b);\n        this.dateTime || this.logarithmic || m || (this.tickInterval = R(this, this.tickInterval));\n        this.tickAmount || (this.tickInterval = this.unsquish());\n        this.setTickPositions();\n      }\n      setTickPositions() {\n        var b = this.options;\n        const c = b.tickPositions,\n          d = b.tickPositioner;\n        var n = this.getMinorTickInterval(),\n          a = this.hasVerticalPanning(),\n          e = \"colorAxis\" === this.coll;\n        const f = (e || !a) && b.startOnTick;\n        a = (e || !a) && b.endOnTick;\n        e = [];\n        let g;\n        this.tickmarkOffset = this.categories && \"between\" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === n && this.tickInterval ? this.tickInterval / b.minorTicksPerMajor : n;\n        this.single = this.min === this.max && k(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);\n        if (c) e = c.slice();else if (q(this.min) && q(this.max)) {\n          if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {\n            if (this.dateTime) e = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) e = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (n = b = this.tickInterval; n <= 2 * b;) if (e = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && e.length > this.tickAmount) this.tickInterval = R(this, n *= 1.1);else break;\n          } else e = [this.min, this.max], C(19, !1, this.chart);\n          e.length > this.len && (e = [e[0], e[e.length - 1]], e[0] === e[1] && (e.length = 1));\n          d && (this.tickPositions = e, (g = d.apply(this, [this.min, this.max])) && (e = g));\n        }\n        this.tickPositions = e;\n        this.paddedTicks = e.slice(0);\n        this.trimTicks(e, f, a);\n        !this.isLinked && q(this.min) && q(this.max) && (this.single && 2 > e.length && !this.categories && !this.series.some(b => b.is(\"heatmap\") && \"between\" === b.options.pointPlacement) && (this.min -= .5, this.max += .5), c || g || this.adjustTickAmount());\n        h(this, \"afterSetTickPositions\");\n      }\n      trimTicks(b, c, d) {\n        const n = b[0],\n          a = b[b.length - 1],\n          e = !this.isOrdinal && this.minPointOffset || 0;\n        h(this, \"trimTicks\");\n        if (!this.isLinked) {\n          if (c && -Infinity !== n) this.min = n;else for (; this.min - e > b[0];) b.shift();\n          if (d) this.max = a;else for (; this.max + e < b[b.length - 1];) b.pop();\n          0 === b.length && k(n) && !this.options.tickPositions && b.push((a + n) / 2);\n        }\n      }\n      alignToOthers() {\n        const b = this,\n          c = [this],\n          d = b.options,\n          n = \"yAxis\" === this.coll && this.chart.options.chart.alignThresholds,\n          h = [];\n        let a;\n        b.thresholdAlignment = void 0;\n        if ((!1 !== this.chart.options.chart.alignTicks && d.alignTicks || n) && !1 !== d.startOnTick && !1 !== d.endOnTick && !b.logarithmic) {\n          const d = b => {\n              const {\n                horiz: c,\n                options: d\n              } = b;\n              return [c ? d.left : d.top, d.width, d.height, d.pane].join();\n            },\n            n = d(this);\n          this.chart[this.coll].forEach(function (h) {\n            const {\n              series: e\n            } = h;\n            e.length && e.some(b => b.visible) && h !== b && d(h) === n && (a = !0, c.push(h));\n          });\n        }\n        if (a && n) {\n          c.forEach(c => {\n            c = c.getThresholdAlignment(b);\n            q(c) && h.push(c);\n          });\n          const d = 1 < h.length ? h.reduce((b, c) => b + c, 0) / h.length : void 0;\n          c.forEach(b => {\n            b.thresholdAlignment = d;\n          });\n        }\n        return a;\n      }\n      getThresholdAlignment(b) {\n        (!q(this.dataMin) || this !== b && this.series.some(b => b.isDirty || b.isDirtyData)) && this.getSeriesExtremes();\n        if (q(this.threshold)) return b = m((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (b = 1 - b), b;\n      }\n      getTickAmount() {\n        const b = this.options,\n          c = b.tickPixelInterval;\n        let d = b.tickAmount;\n        !k(b.tickInterval) && !d && this.len < c && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (d = 2);\n        !d && this.alignToOthers() && (d = Math.ceil(this.len / c) + 1);\n        4 > d && (this.finalTickAmt = d, d = 5);\n        this.tickAmount = d;\n      }\n      adjustTickAmount() {\n        const b = this,\n          {\n            finalTickAmt: c,\n            max: d,\n            min: h,\n            options: a,\n            tickPositions: e,\n            tickAmount: g,\n            thresholdAlignment: u\n          } = b,\n          G = e && e.length;\n        var w = n(b.threshold, b.softThreshold ? 0 : null);\n        var l = b.tickInterval;\n        let m;\n        q(u) && (m = .5 > u ? Math.ceil(u * (g - 1)) : Math.floor(u * (g - 1)), a.reversed && (m = g - 1 - m));\n        if (b.hasData() && q(h) && q(d)) {\n          const n = () => {\n            b.transA *= (G - 1) / (g - 1);\n            b.min = a.startOnTick ? e[0] : Math.min(h, e[0]);\n            b.max = a.endOnTick ? e[e.length - 1] : Math.max(d, e[e.length - 1]);\n          };\n          if (q(m) && q(b.threshold)) {\n            for (; e[m] !== w || e.length !== g || e[0] > h || e[e.length - 1] < d;) {\n              e.length = 0;\n              for (e.push(b.threshold); e.length < g;) void 0 === e[m] || e[m] > b.threshold ? e.unshift(f(e[0] - l)) : e.push(f(e[e.length - 1] + l));\n              if (l > 8 * b.tickInterval) break;\n              l *= 2;\n            }\n            n();\n          } else if (G < g) {\n            for (; e.length < g;) e.length % 2 || h === w ? e.push(f(e[e.length - 1] + l)) : e.unshift(f(e[0] - l));\n            n();\n          }\n          if (k(c)) {\n            for (l = w = e.length; l--;) (3 === c && 1 === l % 2 || 2 >= c && 0 < l && l < w - 1) && e.splice(l, 1);\n            b.finalTickAmt = void 0;\n          }\n        }\n      }\n      setScale() {\n        let b = !1,\n          c = !1;\n        this.series.forEach(function (d) {\n          b = b || d.isDirtyData || d.isDirty;\n          c = c || d.xAxis && d.xAxis.isDirty || !1;\n        });\n        this.setAxisSize();\n        const d = this.len !== (this.old && this.old.len);\n        d || b || c || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = d || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();\n        b && this.panningState && (this.panningState.isDirty = !0);\n        h(this, \"afterSetScale\");\n      }\n      setExtremes(b, c, d, a, q) {\n        const f = this,\n          k = f.chart;\n        d = n(d, !0);\n        f.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        q = e(q, {\n          min: b,\n          max: c\n        });\n        h(f, \"setExtremes\", q, function () {\n          f.userMin = b;\n          f.userMax = c;\n          f.eventArgs = q;\n          d && k.redraw(a);\n        });\n      }\n      zoom(b, c) {\n        const d = this,\n          e = this.dataMin,\n          a = this.dataMax,\n          q = this.options,\n          f = Math.min(e, n(q.min, e)),\n          g = Math.max(a, n(q.max, a));\n        b = {\n          newMin: b,\n          newMax: c\n        };\n        h(this, \"zoom\", b, function (b) {\n          let c = b.newMin,\n            n = b.newMax;\n          if (c !== d.min || n !== d.max) d.allowZoomOutside || (k(e) && (c < f && (c = f), c > g && (c = g)), k(a) && (n < f && (n = f), n > g && (n = g))), d.displayBtn = \"undefined\" !== typeof c || \"undefined\" !== typeof n, d.setExtremes(c, n, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return b.zoomed;\n      }\n      setAxisSize() {\n        const b = this.chart;\n        var c = this.options;\n        const d = c.offsets || [0, 0, 0, 0],\n          h = this.horiz,\n          e = this.width = Math.round(G(n(c.width, b.plotWidth - d[3] + d[1]), b.plotWidth)),\n          a = this.height = Math.round(G(n(c.height, b.plotHeight - d[0] + d[2]), b.plotHeight)),\n          q = this.top = Math.round(G(n(c.top, b.plotTop + d[0]), b.plotHeight, b.plotTop));\n        c = this.left = Math.round(G(n(c.left, b.plotLeft + d[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - a - q;\n        this.right = b.chartWidth - e - c;\n        this.len = Math.max(h ? e : a, 0);\n        this.pos = h ? c : q;\n      }\n      getExtremes() {\n        const b = this.logarithmic;\n        return {\n          min: b ? f(b.lin2log(this.min)) : this.min,\n          max: b ? f(b.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      }\n      getThreshold(b) {\n        var c = this.logarithmic;\n        const d = c ? c.lin2log(this.min) : this.min;\n        c = c ? c.lin2log(this.max) : this.max;\n        null === b || -Infinity === b ? b = d : Infinity === b ? b = c : d > b ? b = d : c < b && (b = c);\n        return this.translate(b, 0, 1, 0, 1);\n      }\n      autoLabelAlign(b) {\n        const c = (n(b, 0) - 90 * this.side + 720) % 360;\n        b = {\n          align: \"center\"\n        };\n        h(this, \"autoLabelAlign\", b, function (b) {\n          15 < c && 165 > c ? b.align = \"right\" : 195 < c && 345 > c && (b.align = \"left\");\n        });\n        return b.align;\n      }\n      tickSize(b) {\n        const c = this.options,\n          d = n(c[\"tick\" === b ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === b && this.isXAxis && !this.categories ? 1 : 0);\n        let e = c[\"tick\" === b ? \"tickLength\" : \"minorTickLength\"],\n          a;\n        d && e && (\"inside\" === c[b + \"Position\"] && (e = -e), a = [e, d]);\n        b = {\n          tickSize: a\n        };\n        h(this, \"afterTickSize\", b);\n        return b.tickSize;\n      }\n      labelMetrics() {\n        const b = this.chart.renderer;\n        var c = this.ticks;\n        c = c[Object.keys(c)[0]] || {};\n        return this.chart.renderer.fontMetrics(c.label || c.movedLabel || b.box);\n      }\n      unsquish() {\n        const b = this.options.labels;\n        var c = this.horiz;\n        const d = this.tickInterval,\n          h = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / d),\n          e = b.rotation,\n          a = .75 * this.labelMetrics().h,\n          k = Math.max(this.max - this.min, 0),\n          g = function (b) {\n            let c = b / (h || 1);\n            c = 1 < c ? Math.ceil(c) : 1;\n            c * d > k && Infinity !== b && Infinity !== h && k && (c = Math.ceil(k / d));\n            return f(c * d);\n          };\n        let u = d,\n          G,\n          w = Number.MAX_VALUE,\n          l;\n        if (c) {\n          if (b.staggerLines || (q(e) ? l = [e] : h < b.autoRotationLimit && (l = b.autoRotation)), l) {\n            let b;\n            for (const d of l) if (d === e || d && -90 <= d && 90 >= d) c = g(Math.abs(a / Math.sin(p * d))), b = c + Math.abs(d / 360), b < w && (w = b, G = d, u = c);\n          }\n        } else u = g(a);\n        this.autoRotation = l;\n        this.labelRotation = n(G, q(e) ? e : 0);\n        return b.step ? d : u;\n      }\n      getSlotWidth(b) {\n        const c = this.chart,\n          d = this.horiz,\n          n = this.options.labels,\n          h = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n          e = c.margin[3];\n        if (b && q(b.slotWidth)) return b.slotWidth;\n        if (d && 2 > n.step) return n.rotation ? 0 : (this.staggerLines || 1) * this.len / h;\n        if (!d) {\n          b = n.style.width;\n          if (void 0 !== b) return parseInt(String(b), 10);\n          if (e) return e - c.spacing[3];\n        }\n        return .33 * c.chartWidth;\n      }\n      renderUnsquish() {\n        const b = this.chart,\n          c = b.renderer,\n          d = this.tickPositions,\n          n = this.ticks,\n          h = this.options.labels,\n          e = h.style,\n          a = this.horiz,\n          q = this.getSlotWidth();\n        var f = Math.max(1, Math.round(q - 2 * h.padding));\n        const k = {},\n          g = this.labelMetrics(),\n          G = e.textOverflow;\n        let w,\n          l,\n          m = 0;\n        u(h.rotation) || (k.rotation = h.rotation || 0);\n        d.forEach(function (b) {\n          b = n[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > m && (m = b.label.textPxLength);\n        });\n        this.maxLabelLength = m;\n        if (this.autoRotation) m > f && m > g.h ? k.rotation = this.labelRotation : this.labelRotation = 0;else if (q && (w = f, !G)) for (l = \"clip\", f = d.length; !a && f--;) {\n          var I = d[f];\n          if (I = n[I].label) I.styles && \"ellipsis\" === I.styles.textOverflow ? I.css({\n            textOverflow: \"clip\"\n          }) : I.textPxLength > q && I.css({\n            width: q + \"px\"\n          }), I.getBBox().height > this.len / d.length - (g.h - g.f) && (I.specificTextOverflow = \"ellipsis\");\n        }\n        k.rotation && (w = m > .5 * b.chartHeight ? .33 * b.chartHeight : m, G || (l = \"ellipsis\"));\n        if (this.labelAlign = h.align || this.autoLabelAlign(this.labelRotation)) k.align = this.labelAlign;\n        d.forEach(function (b) {\n          const c = (b = n[b]) && b.label,\n            d = e.width,\n            h = {};\n          c && (c.attr(k), b.shortenLabel ? b.shortenLabel() : w && !d && \"nowrap\" !== e.whiteSpace && (w < c.textPxLength || \"SPAN\" === c.element.tagName) ? (h.width = w + \"px\", G || (h.textOverflow = c.specificTextOverflow || l), c.css(h)) : c.styles && c.styles.width && !h.width && !d && c.css({\n            width: null\n          }), delete c.specificTextOverflow, b.rotation = k.rotation);\n        }, this);\n        this.tickRotCorr = c.rotCorr(g.b, this.labelRotation || 0, 0 !== this.side);\n      }\n      hasData() {\n        return this.series.some(function (b) {\n          return b.hasData();\n        }) || this.options.showEmpty && k(this.min) && k(this.max);\n      }\n      addTitle(b) {\n        const c = this.chart.renderer,\n          n = this.horiz,\n          h = this.opposite,\n          e = this.options.title,\n          a = this.chart.styledMode;\n        let q;\n        this.axisTitle || ((q = e.textAlign) || (q = (n ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: h ? \"right\" : \"left\",\n          middle: \"center\",\n          high: h ? \"left\" : \"right\"\n        })[e.align]), this.axisTitle = c.text(e.text || \"\", 0, 0, e.useHTML).attr({\n          zIndex: 7,\n          rotation: e.rotation,\n          align: q\n        }).addClass(\"highcharts-axis-title\"), a || this.axisTitle.css(d(e.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        a || e.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[b ? \"show\" : \"hide\"](b);\n      }\n      generateTick(b) {\n        const c = this.ticks;\n        c[b] ? c[b].addLabel() : c[b] = new E(this, b);\n      }\n      getOffset() {\n        const b = this,\n          {\n            chart: d,\n            horiz: e,\n            options: a,\n            side: f,\n            ticks: g,\n            tickPositions: u,\n            coll: G,\n            axisParent: w\n          } = b,\n          l = d.renderer,\n          m = d.inverted && !b.isZAxis ? [1, 0, 3, 2][f] : f;\n        var I = b.hasData();\n        const p = a.title;\n        var K = a.labels;\n        const v = q(a.crossing);\n        var x = d.axisOffset;\n        const P = d.clipOffset,\n          r = [-1, 1, 1, -1][f],\n          T = a.className;\n        let J,\n          t = 0,\n          C;\n        var R = 0;\n        let y = 0;\n        b.showAxis = J = I || a.showEmpty;\n        b.staggerLines = b.horiz && K.staggerLines || void 0;\n        if (!b.axisGroup) {\n          const c = (b, c, d) => l.g(b).attr({\n            zIndex: d\n          }).addClass(`highcharts-${G.toLowerCase()}${c} ` + (this.isRadial ? `highcharts-radial-axis${c} ` : \"\") + (T || \"\")).add(w);\n          b.gridGroup = c(\"grid\", \"-grid\", a.gridZIndex);\n          b.axisGroup = c(\"axis\", \"\", a.zIndex);\n          b.labelGroup = c(\"axis-labels\", \"-labels\", K.zIndex);\n        }\n        I || b.isLinked ? (u.forEach(function (c) {\n          b.generateTick(c);\n        }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === f || 2 === f || {\n          1: \"left\",\n          3: \"right\"\n        }[f] === b.labelAlign, n(K.reserveSpace, v ? !1 : null, \"center\" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && u.forEach(function (b) {\n          y = Math.max(g[b].getLabelSize(), y);\n        }), b.staggerLines && (y *= b.staggerLines), b.labelOffset = y * (b.opposite ? -1 : 1)) : c(g, function (b, c) {\n          b.destroy();\n          delete g[c];\n        });\n        p && p.text && !1 !== p.enabled && (b.addTitle(J), J && !v && !1 !== p.reserveSpace && (b.titleOffset = t = b.axisTitle.getBBox()[e ? \"height\" : \"width\"], C = p.offset, R = k(C) ? 0 : n(p.margin, e ? 5 : 10)));\n        b.renderLine();\n        b.offset = r * n(a.offset, x[f] ? x[f] + (a.margin || 0) : 0);\n        b.tickRotCorr = b.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        I = 0 === f ? -b.labelMetrics().h : 2 === f ? b.tickRotCorr.y : 0;\n        R = Math.abs(y) + R;\n        y && (R = R - I + r * (e ? n(K.y, b.tickRotCorr.y + r * K.distance) : n(K.x, r * K.distance)));\n        b.axisTitleMargin = n(C, R);\n        b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(g, u));\n        \"colorAxis\" !== G && (K = this.tickSize(\"tick\"), x[f] = Math.max(x[f], (b.axisTitleMargin || 0) + t + r * b.offset, R, u && u.length && K ? K[0] + r * b.offset : 0), x = !b.axisLine || a.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2), P[m] = Math.max(P[m], x));\n        h(this, \"afterGetOffset\");\n      }\n      getLinePath(b) {\n        const c = this.chart,\n          d = this.opposite;\n        var n = this.offset;\n        const h = this.horiz,\n          e = this.left + (d ? this.width : 0) + n;\n        n = c.chartHeight - this.bottom - (d ? this.height : 0) + n;\n        d && (b *= -1);\n        return c.renderer.crispLine([[\"M\", h ? this.left : e, h ? n : this.top], [\"L\", h ? c.chartWidth - this.right : e, h ? n : c.chartHeight - this.bottom]], b);\n      }\n      renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      }\n      getTitlePosition(b) {\n        var c = this.horiz,\n          d = this.left;\n        const n = this.top;\n        var e = this.len;\n        const a = this.options.title,\n          q = c ? d : n,\n          f = this.opposite,\n          k = this.offset,\n          g = a.x,\n          u = a.y,\n          G = this.chart.renderer.fontMetrics(b);\n        b = b ? Math.max(b.getBBox(!1, 0).height - G.h - 1, 0) : 0;\n        e = {\n          low: q + (c ? 0 : e),\n          middle: q + e / 2,\n          high: q + (c ? e : 0)\n        }[a.align];\n        d = (c ? n + this.height : d) + (c ? 1 : -1) * (f ? -1 : 1) * (this.axisTitleMargin || 0) + [-b, b, G.f, -b][this.side];\n        c = {\n          x: c ? e + g : d + (f ? this.width : 0) + k + g,\n          y: c ? d + u - (f ? this.height : 0) + k : e + u\n        };\n        h(this, \"afterGetTitlePosition\", {\n          titlePosition: c\n        });\n        return c;\n      }\n      renderMinorTick(b, c) {\n        const d = this.minorTicks;\n        d[b] || (d[b] = new E(this, b, \"minor\"));\n        c && d[b].isNew && d[b].render(null, !0);\n        d[b].render(null, !1, 1);\n      }\n      renderTick(b, c, d) {\n        const n = this.ticks;\n        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) n[b] || (n[b] = new E(this, b)), d && n[b].isNew && n[b].render(c, !0, -1), n[b].render(c);\n      }\n      render() {\n        const b = this,\n          d = b.chart,\n          n = b.logarithmic,\n          e = b.options,\n          a = b.isLinked,\n          f = b.tickPositions,\n          k = b.axisTitle,\n          g = b.ticks,\n          u = b.minorTicks,\n          G = b.alternateBands,\n          w = e.stackLabels,\n          l = e.alternateGridColor,\n          m = e.crossing,\n          I = b.tickmarkOffset,\n          p = b.axisLine,\n          K = b.showAxis,\n          x = t(d.renderer.globalAnimation);\n        let v, P;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        [g, u, G].forEach(function (b) {\n          c(b, function (b) {\n            b.isActive = !1;\n          });\n        });\n        if (q(m)) {\n          const b = this.isXAxis ? d.yAxis[0] : d.xAxis[0],\n            c = [1, -1, -1, 1][this.side];\n          b && (this.offset = c * b.toPixels(m, !0));\n        }\n        if (b.hasData() || a) {\n          const c = b.chart.hasRendered && b.old && q(b.old.min);\n          b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (d) {\n            b.renderMinorTick(d, c);\n          });\n          f.length && (f.forEach(function (d, n) {\n            b.renderTick(d, n, c);\n          }), I && (0 === b.min || b.single) && (g[-1] || (g[-1] = new E(b, -1, null, !0)), g[-1].render(-1)));\n          l && f.forEach(function (c, e) {\n            P = \"undefined\" !== typeof f[e + 1] ? f[e + 1] + I : b.max - I;\n            0 === e % 2 && c < b.max && P <= b.max + (d.polar ? -I : I) && (G[c] || (G[c] = new D.PlotLineOrBand(b)), v = c + I, G[c].options = {\n              from: n ? n.lin2log(v) : v,\n              to: n ? n.lin2log(P) : P,\n              color: l,\n              className: \"highcharts-alternate-grid\"\n            }, G[c].render(), G[c].isActive = !0);\n          });\n          b._addedPlotLB || (b._addedPlotLB = !0, (e.plotLines || []).concat(e.plotBands || []).forEach(function (c) {\n            b.addPlotBandOrLine(c);\n          }));\n        }\n        [g, u, G].forEach(function (b) {\n          const n = [],\n            e = x.duration;\n          c(b, function (b, c) {\n            b.isActive || (b.render(c, !1, 0), b.isActive = !1, n.push(c));\n          });\n          T(function () {\n            let c = n.length;\n            for (; c--;) b[n[c]] && !b[n[c]].isActive && (b[n[c]].destroy(), delete b[n[c]]);\n          }, b !== G && d.hasRendered && e ? e : 0);\n        });\n        p && (p[p.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(p.strokeWidth())\n        }), p.isPlaced = !0, p[K ? \"show\" : \"hide\"](K));\n        k && K && (k[k.isNew ? \"attr\" : \"animate\"](b.getTitlePosition(k)), k.isNew = !1);\n        w && w.enabled && b.stacking && b.stacking.renderStackTotals();\n        b.old = {\n          len: b.len,\n          max: b.max,\n          min: b.min,\n          transA: b.transA,\n          userMax: b.userMax,\n          userMin: b.userMin\n        };\n        b.isDirty = !1;\n        h(this, \"afterRender\");\n      }\n      redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {\n          b.render();\n        }));\n        this.series.forEach(function (b) {\n          b.isDirty = !0;\n        });\n      }\n      getKeepProps() {\n        return this.keepProps || P.keepProps;\n      }\n      destroy(b) {\n        const d = this,\n          n = d.plotLinesAndBands,\n          e = this.eventOptions;\n        h(this, \"destroy\", {\n          keepEvents: b\n        });\n        b || I(d);\n        [d.ticks, d.minorTicks, d.alternateBands].forEach(function (b) {\n          x(b);\n        });\n        if (n) for (b = n.length; b--;) n[b].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (b) {\n          d[b] && (d[b] = d[b].destroy());\n        });\n        for (const b in d.plotLinesAndBandsGroups) d.plotLinesAndBandsGroups[b] = d.plotLinesAndBandsGroups[b].destroy();\n        c(d, function (b, c) {\n          -1 === d.getKeepProps().indexOf(c) && delete d[c];\n        });\n        this.eventOptions = e;\n      }\n      drawCrosshair(b, c) {\n        const d = this.crosshair;\n        var a = n(d && d.snap, !0);\n        const q = this.chart;\n        let f,\n          g = this.cross;\n        h(this, \"drawCrosshair\", {\n          e: b,\n          point: c\n        });\n        b || (b = this.cross && this.cross.e);\n        if (d && !1 !== (k(c) || !a)) {\n          a ? k(c) && (f = n(\"colorAxis\" !== this.coll ? c.crosshairPos : null, this.isXAxis ? c.plotX : this.len - c.plotY)) : f = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);\n          if (k(f)) {\n            var u = {\n              value: c && (this.isXAxis ? c.x : n(c.stackY, c.y)),\n              translatedValue: f\n            };\n            q.polar && e(u, {\n              isCrosshair: !0,\n              chartX: b && b.chartX,\n              chartY: b && b.chartY,\n              point: c\n            });\n            u = this.getPlotLinePath(u) || null;\n          }\n          if (!k(u)) {\n            this.hideCrosshair();\n            return;\n          }\n          a = this.categories && !this.isRadial;\n          g || (this.cross = g = q.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (a ? \"category \" : \"thin \") + (d.className || \"\")).attr({\n            zIndex: n(d.zIndex, 2)\n          }).add(), q.styledMode || (g.attr({\n            stroke: d.color || (a ? F.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": n(d.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), d.dashStyle && g.attr({\n            dashstyle: d.dashStyle\n          })));\n          g.show().attr({\n            d: u\n          });\n          a && !d.width && g.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = b;\n        } else this.hideCrosshair();\n        h(this, \"afterDrawCrosshair\", {\n          e: b,\n          point: c\n        });\n      }\n      hideCrosshair() {\n        this.cross && this.cross.hide();\n        h(this, \"afterHideCrosshair\");\n      }\n      hasVerticalPanning() {\n        const b = this.chart.options.chart.panning;\n        return !!(b && b.enabled && /y/.test(b.type));\n      }\n      update(b, c) {\n        const e = this.chart;\n        b = d(this.userOptions, b);\n        this.destroy(!0);\n        this.init(e, b);\n        e.isDirtyBox = !0;\n        n(c, !0) && e.redraw();\n      }\n      remove(b) {\n        const c = this.chart,\n          d = this.coll,\n          e = this.series;\n        let h = e.length;\n        for (; h--;) e[h] && e[h].remove(!1);\n        J(c.axes, this);\n        J(c[d], this);\n        c[d].forEach(function (b, c) {\n          b.options.index = b.userOptions.index = c;\n        });\n        this.destroy();\n        c.isDirtyBox = !0;\n        n(b, !0) && c.redraw();\n      }\n      setTitle(b, c) {\n        this.update({\n          title: b\n        }, c);\n      }\n      setCategories(b, c) {\n        this.update({\n          categories: b\n        }, c);\n      }\n    }\n    P.defaultOptions = z.defaultXAxisOptions;\n    P.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n    \"\";\n    return P;\n  });\n  L(a, \"Core/Axis/DateTimeAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: y,\n      getMagnitude: F,\n      normalizeTickInterval: H,\n      timeUnits: A\n    } = a;\n    var D;\n    (function (E) {\n      function B() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function t(a) {\n        \"datetime\" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new g(this));\n      }\n      const r = [];\n      E.compose = function (g) {\n        a.pushUnique(r, g) && (g.keepProps.push(\"dateTime\"), g.prototype.getTimeTicks = B, y(g, \"init\", t));\n        return g;\n      };\n      class g {\n        constructor(a) {\n          this.axis = a;\n        }\n        normalizeTimeTickInterval(a, g) {\n          const l = g || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n          g = l[l.length - 1];\n          let m = A[g[0]],\n            f = g[1],\n            k;\n          for (k = 0; k < l.length && !(g = l[k], m = A[g[0]], f = g[1], l[k + 1] && a <= (m * f[f.length - 1] + A[l[k + 1][0]]) / 2); k++);\n          m === A.year && a < 5 * m && (f = [1, 2, 5]);\n          a = H(a / m, f, \"year\" === g[0] ? Math.max(F(a / m), 1) : 1);\n          return {\n            unitRange: m,\n            count: a,\n            unitName: g[0]\n          };\n        }\n        getXDateFormat(a, g) {\n          const {\n              axis: l\n            } = this,\n            m = l.chart.time;\n          return l.closestPointRange ? m.getDateFormat(l.closestPointRange, a, l.options.startOfWeek, g) || m.resolveDTLFormat(g.year).main : m.resolveDTLFormat(g.day).main;\n        }\n      }\n      E.Additions = g;\n    })(D || (D = {}));\n    return D;\n  });\n  L(a, \"Core/Axis/LogarithmicAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: y,\n      normalizeTickInterval: F,\n      pick: H\n    } = a;\n    var A;\n    (function (z) {\n      function E(a) {\n        let g = this.logarithmic;\n        \"logarithmic\" !== a.userOptions.type ? this.logarithmic = void 0 : g || (this.logarithmic = new r(this));\n      }\n      function B() {\n        const a = this.logarithmic;\n        a && (this.lin2val = function (g) {\n          return a.lin2log(g);\n        }, this.val2lin = function (g) {\n          return a.log2lin(g);\n        });\n      }\n      const t = [];\n      z.compose = function (g) {\n        a.pushUnique(t, g) && (g.keepProps.push(\"logarithmic\"), y(g, \"init\", E), y(g, \"afterInit\", B));\n        return g;\n      };\n      class r {\n        constructor(a) {\n          this.axis = a;\n        }\n        getLogTickPositions(a, p, v, l) {\n          const g = this.axis;\n          var f = g.len,\n            k = g.options;\n          let x = [];\n          l || (this.minorAutoInterval = void 0);\n          if (.5 <= a) a = Math.round(a), x = g.getLinearTickPositions(a, p, v);else if (.08 <= a) {\n            k = Math.floor(p);\n            let g, m, e, h, w;\n            for (f = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; k < v + 1 && !w; k++) for (m = f.length, g = 0; g < m && !w; g++) e = this.log2lin(this.lin2log(k) * f[g]), e > p && (!l || h <= v) && \"undefined\" !== typeof h && x.push(h), h > v && (w = !0), h = e;\n          } else p = this.lin2log(p), v = this.lin2log(v), a = l ? g.getMinorTickInterval() : k.tickInterval, a = H(\"auto\" === a ? null : a, this.minorAutoInterval, k.tickPixelInterval / (l ? 5 : 1) * (v - p) / ((l ? f / g.tickPositions.length : f) || 1)), a = F(a), x = g.getLinearTickPositions(a, p, v).map(this.log2lin), l || (this.minorAutoInterval = a / 5);\n          l || (g.tickInterval = a);\n          return x;\n        }\n        lin2log(a) {\n          return Math.pow(10, a);\n        }\n        log2lin(a) {\n          return Math.log(a) / Math.LN10;\n        }\n      }\n      z.Additions = r;\n    })(A || (A = {}));\n    return A;\n  });\n  L(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      erase: y,\n      extend: F,\n      isNumber: H\n    } = a;\n    var A;\n    (function (z) {\n      function E(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      }\n      function B(a, k) {\n        const f = this.userOptions;\n        let g = new m(this, a);\n        this.visible && (g = g.render());\n        if (g) {\n          this._addedPlotLB || (this._addedPlotLB = !0, (f.plotLines || []).concat(f.plotBands || []).forEach(a => {\n            this.addPlotBandOrLine(a);\n          }));\n          if (k) {\n            const g = f[k] || [];\n            g.push(a);\n            f[k] = g;\n          }\n          this.plotLinesAndBands.push(g);\n        }\n        return g;\n      }\n      function t(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      }\n      function r(a, k, g = this.options) {\n        const f = this.getPlotLinePath({\n            value: k,\n            force: !0,\n            acrossPanes: g.acrossPanes\n          }),\n          l = [],\n          e = this.horiz;\n        k = !H(this.min) || !H(this.max) || a < this.min && k < this.min || a > this.max && k > this.max;\n        a = this.getPlotLinePath({\n          value: a,\n          force: !0,\n          acrossPanes: g.acrossPanes\n        });\n        g = 1;\n        let h;\n        if (a && f) for (k && (h = a.toString() === f.toString(), g = 0), k = 0; k < a.length; k += 2) {\n          const w = a[k],\n            q = a[k + 1],\n            u = f[k],\n            d = f[k + 1];\n          \"M\" !== w[0] && \"L\" !== w[0] || \"M\" !== q[0] && \"L\" !== q[0] || \"M\" !== u[0] && \"L\" !== u[0] || \"M\" !== d[0] && \"L\" !== d[0] || (e && u[1] === w[1] ? (u[1] += g, d[1] += g) : e || u[2] !== w[2] || (u[2] += g, d[2] += g), l.push([\"M\", w[1], w[2]], [\"L\", q[1], q[2]], [\"L\", d[1], d[2]], [\"L\", u[1], u[2]], [\"Z\"]));\n          l.isFlat = h;\n        }\n        return l;\n      }\n      function g(a) {\n        this.removePlotBandOrLine(a);\n      }\n      function p(a) {\n        const f = this.plotLinesAndBands,\n          g = this.options,\n          l = this.userOptions;\n        if (f) {\n          let k = f.length;\n          for (; k--;) f[k].id === a && f[k].destroy();\n          [g.plotLines || [], l.plotLines || [], g.plotBands || [], l.plotBands || []].forEach(function (e) {\n            for (k = e.length; k--;) (e[k] || {}).id === a && y(e, e[k]);\n          });\n        }\n      }\n      function v(a) {\n        this.removePlotBandOrLine(a);\n      }\n      const l = [];\n      let m;\n      z.compose = function (f, k) {\n        m || (m = f);\n        a.pushUnique(l, k) && F(k.prototype, {\n          addPlotBand: E,\n          addPlotLine: t,\n          addPlotBandOrLine: B,\n          getPlotBandPath: r,\n          removePlotBand: g,\n          removePlotLine: v,\n          removePlotBandOrLine: p\n        });\n        return k;\n      };\n    })(A || (A = {}));\n    return A;\n  });\n  L(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [a[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    const {\n      arrayMax: y,\n      arrayMin: H,\n      defined: A,\n      destroyObjectProperties: D,\n      erase: E,\n      fireEvent: B,\n      merge: t,\n      objectEach: r,\n      pick: g\n    } = z;\n    class p {\n      static compose(g) {\n        return a.compose(p, g);\n      }\n      constructor(a, g) {\n        this.axis = a;\n        g && (this.options = g, this.id = g.id);\n      }\n      render() {\n        B(this, \"render\");\n        const a = this,\n          l = a.axis,\n          m = l.horiz;\n        var f = l.logarithmic;\n        const k = a.options,\n          p = k.color,\n          J = g(k.zIndex, 0),\n          C = k.events,\n          e = {},\n          h = l.chart.renderer;\n        let w = k.label,\n          q = a.label,\n          u = k.to,\n          d = k.from,\n          b = k.value,\n          c = a.svgElem;\n        var n = [];\n        const G = A(d) && A(u);\n        n = A(b);\n        const I = !c,\n          K = {\n            \"class\": \"highcharts-plot-\" + (G ? \"band \" : \"line \") + (k.className || \"\")\n          };\n        let T = G ? \"bands\" : \"lines\";\n        f && (d = f.log2lin(d), u = f.log2lin(u), b = f.log2lin(b));\n        l.chart.styledMode || (n ? (K.stroke = p || \"#999999\", K[\"stroke-width\"] = g(k.width, 1), k.dashStyle && (K.dashstyle = k.dashStyle)) : G && (K.fill = p || \"#e6e9ff\", k.borderWidth && (K.stroke = k.borderColor, K[\"stroke-width\"] = k.borderWidth)));\n        e.zIndex = J;\n        T += \"-\" + J;\n        (f = l.plotLinesAndBandsGroups[T]) || (l.plotLinesAndBandsGroups[T] = f = h.g(\"plot-\" + T).attr(e).add());\n        I && (a.svgElem = c = h.path().attr(K).add(f));\n        if (n) n = l.getPlotLinePath({\n          value: b,\n          lineWidth: c.strokeWidth(),\n          acrossPanes: k.acrossPanes\n        });else if (G) n = l.getPlotBandPath(d, u, k);else return;\n        !a.eventsAdded && C && (r(C, function (b, d) {\n          c.on(d, function (b) {\n            C[d].apply(a, [b]);\n          });\n        }), a.eventsAdded = !0);\n        (I || !c.d) && n && n.length ? c.attr({\n          d: n\n        }) : c && (n ? (c.show(), c.animate({\n          d: n\n        })) : c.d && (c.hide(), q && (a.label = q = q.destroy())));\n        w && (A(w.text) || A(w.formatter)) && n && n.length && 0 < l.width && 0 < l.height && !n.isFlat ? (w = t({\n          align: m && G && \"center\",\n          x: m ? !G && 4 : 10,\n          verticalAlign: !m && G && \"middle\",\n          y: m ? G ? 16 : 10 : G ? 6 : -4,\n          rotation: m && !G && 90\n        }, w), this.renderLabel(w, n, G, J)) : q && q.hide();\n        return a;\n      }\n      renderLabel(a, g, m, f) {\n        const k = this.axis;\n        var l = k.chart.renderer;\n        let p = this.label;\n        p || (this.label = p = l.text(this.getLabelText(a), 0, 0, a.useHTML).attr({\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (m ? \"band\" : \"line\") + \"-label \" + (a.className || \"\"),\n          zIndex: f\n        }).add(), k.chart.styledMode || p.css(t({\n          fontSize: \"0.8em\",\n          textOverflow: \"ellipsis\"\n        }, a.style)));\n        f = g.xBounds || [g[0][1], g[1][1], m ? g[2][1] : g[0][1]];\n        g = g.yBounds || [g[0][2], g[1][2], m ? g[2][2] : g[0][2]];\n        m = H(f);\n        l = H(g);\n        p.align(a, !1, {\n          x: m,\n          y: l,\n          width: y(f) - m,\n          height: y(g) - l\n        });\n        p.alignValue && \"left\" !== p.alignValue || (a = a.clip ? k.width : k.chart.chartWidth, p.css({\n          width: (90 === p.rotation ? k.height - (p.alignAttr.y - k.top) : a - (p.alignAttr.x - k.left)) + \"px\"\n        }));\n        p.show(!0);\n      }\n      getLabelText(a) {\n        return A(a.formatter) ? a.formatter.call(this) : a.text;\n      }\n      destroy() {\n        E(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        D(this);\n      }\n    }\n    \"\";\n    \"\";\n    return p;\n  });\n  L(a, \"Core/Tooltip.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A) {\n    const {\n        format: y\n      } = a,\n      {\n        doc: E,\n        isSafari: B\n      } = z,\n      {\n        distribute: t\n      } = F,\n      {\n        addEvent: r,\n        clamp: g,\n        css: p,\n        discardElement: v,\n        extend: l,\n        fireEvent: m,\n        isArray: f,\n        isNumber: k,\n        isString: x,\n        merge: J,\n        pick: C,\n        splat: e,\n        syncTimeout: h\n      } = A;\n    class w {\n      constructor(a, e) {\n        this.allowShared = !0;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = a;\n        this.init(a, e);\n      }\n      bodyFormatter(a) {\n        return a.map(function (a) {\n          const d = a.series.tooltipOptions;\n          return (d[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, d[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      }\n      cleanSplit(a) {\n        this.chart.series.forEach(function (e) {\n          const d = e && e.tt;\n          d && (!d.isActive || a ? e.tt = d.destroy() : d.isActive = !1);\n        });\n      }\n      defaultFormatter(a) {\n        const h = this.points || e(this);\n        let d;\n        d = [a.tooltipFooterHeaderFormatter(h[0])];\n        d = d.concat(a.bodyFormatter(h));\n        d.push(a.tooltipFooterHeaderFormatter(h[0], !0));\n        return d;\n      }\n      destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy()));\n        this.renderer && (this.renderer = this.renderer.destroy(), v(this.container));\n        A.clearTimeout(this.hideTimer);\n        A.clearTimeout(this.tooltipTimeout);\n      }\n      getAnchor(a, h) {\n        var d = this.chart;\n        const b = d.pointer,\n          c = d.inverted,\n          n = d.plotTop;\n        d = d.plotLeft;\n        a = e(a);\n        a[0].series && a[0].series.yAxis && !a[0].series.yAxis.options.reversedStacks && (a = a.slice().reverse());\n        if (this.followPointer && h) \"undefined\" === typeof h.chartX && (h = b.normalize(h)), a = [h.chartX - d, h.chartY - n];else if (a[0].tooltipPos) a = a[0].tooltipPos;else {\n          let b = 0,\n            e = 0;\n          a.forEach(function (c) {\n            if (c = c.pos(!0)) b += c[0], e += c[1];\n          });\n          b /= a.length;\n          e /= a.length;\n          this.shared && 1 < a.length && h && (c ? b = h.chartX : e = h.chartY);\n          a = [b - d, e - n];\n        }\n        return a.map(Math.round);\n      }\n      getClassName(a, e, d) {\n        const b = a.series,\n          c = b.options;\n        return [this.options.className, \"highcharts-label\", d && \"highcharts-tooltip-header\", e ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !d && \"highcharts-color-\" + C(a.colorIndex, b.colorIndex), c && c.className].filter(x).join(\" \");\n      }\n      getLabel() {\n        const a = this,\n          e = this.chart.styledMode,\n          d = this.options,\n          b = this.split && this.allowShared,\n          c = d.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\");\n        let n,\n          h = this.chart.renderer;\n        if (this.label) {\n          var f = !this.label.hasClass(\"highcharts-label\");\n          (!b && f || b && !f) && this.destroy();\n        }\n        if (!this.label) {\n          if (this.outside) {\n            f = this.chart.options.chart.style;\n            const b = H.getRendererType();\n            this.container = n = z.doc.createElement(\"div\");\n            n.className = \"highcharts-tooltip-container\";\n            p(n, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: c,\n              zIndex: Math.max(this.options.style.zIndex || 0, (f && f.zIndex || 0) + 3)\n            });\n            z.doc.body.appendChild(n);\n            this.renderer = h = new b(n, 0, 0, f, void 0, void 0, h.styledMode);\n          }\n          b ? this.label = h.g(\"tooltip\") : (this.label = h.label(\"\", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, \"tooltip\").attr({\n            padding: d.padding,\n            r: d.borderRadius\n          }), e || this.label.attr({\n            fill: d.backgroundColor,\n            \"stroke-width\": d.borderWidth || 0\n          }).css(d.style).css({\n            pointerEvents: c\n          }));\n          if (a.outside) {\n            const b = this.label,\n              {\n                xSetter: c,\n                ySetter: d\n              } = b;\n            b.xSetter = function (d) {\n              c.call(b, a.distance);\n              n.style.left = d + \"px\";\n            };\n            b.ySetter = function (c) {\n              d.call(b, a.distance);\n              n.style.top = c + \"px\";\n            };\n          }\n          this.label.attr({\n            zIndex: 8\n          }).shadow(d.shadow).add();\n        }\n        return this.label;\n      }\n      getPlayingField() {\n        const {\n            body: a,\n            documentElement: e\n          } = E,\n          {\n            chart: d,\n            distance: b,\n            outside: c\n          } = this;\n        return {\n          width: c ? Math.max(a.scrollWidth, e.scrollWidth, a.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * b : d.chartWidth,\n          height: c ? Math.max(a.scrollHeight, e.scrollHeight, a.offsetHeight, e.offsetHeight, e.clientHeight) : d.chartHeight\n        };\n      }\n      getPosition(a, e, d) {\n        const b = this.chart,\n          c = this.distance,\n          n = {},\n          h = b.inverted && d.h || 0,\n          f = this.outside;\n        var q = this.getPlayingField();\n        const g = q.width,\n          k = q.height,\n          u = b.pointer.getChartPosition();\n        q = n => {\n          const h = \"x\" === n;\n          return [n, h ? g : k, h ? a : e].concat(f ? [h ? a * u.scaleX : e * u.scaleY, h ? u.left - c + (d.plotX + b.plotLeft) * u.scaleX : u.top - c + (d.plotY + b.plotTop) * u.scaleY, 0, h ? g : k] : [h ? a : e, h ? d.plotX + b.plotLeft : d.plotY + b.plotTop, h ? b.plotLeft : b.plotTop, h ? b.plotLeft + b.plotWidth : b.plotTop + b.plotHeight]);\n        };\n        let w = q(\"y\"),\n          l = q(\"x\"),\n          m;\n        q = !!d.negative;\n        !b.polar && b.hoverSeries && b.hoverSeries.yAxis && b.hoverSeries.yAxis.reversed && (q = !q);\n        const p = !this.followPointer && C(d.ttBelow, !b.inverted === q),\n          x = function (b, d, a, e, q, g, k) {\n            const G = f ? \"y\" === b ? c * u.scaleY : c * u.scaleX : c,\n              w = (a - e) / 2,\n              l = e < q - c,\n              m = q + c + e < d,\n              I = q - G - a + w;\n            q = q + G - w;\n            if (p && m) n[b] = q;else if (!p && l) n[b] = I;else if (l) n[b] = Math.min(k - e, 0 > I - h ? I : I - h);else if (m) n[b] = Math.max(g, q + h + a > d ? q : q + h);else return !1;\n          },\n          v = function (b, d, a, e, h) {\n            let q;\n            h < c || h > d - c ? q = !1 : n[b] = h < a / 2 ? 1 : h > d - e / 2 ? d - e - 2 : h - a / 2;\n            return q;\n          },\n          r = function (b) {\n            const c = w;\n            w = l;\n            l = c;\n            m = b;\n          },\n          Q = function () {\n            !1 !== x.apply(0, w) ? !1 !== v.apply(0, l) || m || (r(!0), Q()) : m ? n.x = n.y = 0 : (r(!0), Q());\n          };\n        (b.inverted || 1 < this.len) && r();\n        Q();\n        return n;\n      }\n      hide(a) {\n        const e = this;\n        A.clearTimeout(this.hideTimer);\n        a = C(a, this.options.hideDelay);\n        this.isHidden || (this.hideTimer = h(function () {\n          e.getLabel().fadeOut(a ? void 0 : a);\n          e.isHidden = !0;\n        }, a));\n      }\n      init(a, e) {\n        this.chart = a;\n        this.options = e;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = e.split && !a.inverted && !a.polar;\n        this.shared = e.shared || this.split;\n        this.outside = C(e.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n      }\n      shouldStickOnContact(a) {\n        return !(this.followPointer || !this.options.stickOnContact || a && !this.chart.pointer.inClass(a.target, \"highcharts-tooltip\"));\n      }\n      move(a, e, d, b) {\n        const c = this,\n          n = c.now,\n          h = !1 !== c.options.animation && !c.isHidden && (1 < Math.abs(a - n.x) || 1 < Math.abs(e - n.y)),\n          f = c.followPointer || 1 < c.len;\n        l(n, {\n          x: h ? (2 * n.x + a) / 3 : a,\n          y: h ? (n.y + e) / 2 : e,\n          anchorX: f ? void 0 : h ? (2 * n.anchorX + d) / 3 : d,\n          anchorY: f ? void 0 : h ? (n.anchorY + b) / 2 : b\n        });\n        c.getLabel().attr(n);\n        c.drawTracker();\n        h && (A.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          c && c.move(a, e, d, b);\n        }, 32));\n      }\n      refresh(a, h) {\n        const d = this.chart,\n          b = this.options,\n          c = d.pointer,\n          n = e(a),\n          g = n[0],\n          q = [];\n        var k = b.formatter || this.defaultFormatter,\n          u = this.shared;\n        const w = d.styledMode;\n        let l = {};\n        if (b.enabled && g.series) {\n          A.clearTimeout(this.hideTimer);\n          this.allowShared = !(!f(a) && a.series && a.series.noSharedTooltip);\n          this.followPointer = !this.split && g.series.tooltipOptions.followPointer;\n          a = this.getAnchor(a, h);\n          var p = a[0],\n            x = a[1];\n          u && this.allowShared ? (c.applyInactiveState(n), n.forEach(function (b) {\n            b.setState(\"hover\");\n            q.push(b.getLabelConfig());\n          }), l = {\n            x: g.category,\n            y: g.y\n          }, l.points = q) : l = g.getLabelConfig();\n          this.len = q.length;\n          k = k.call(l, this);\n          u = g.series;\n          this.distance = C(u.tooltipOptions.distance, 16);\n          if (!1 === k) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(k, n);else {\n              let e = p,\n                f = x;\n              h && c.isDirectTouch && (e = h.chartX - d.plotLeft, f = h.chartY - d.plotTop);\n              if (d.polar || !1 === u.options.clip || n.some(b => c.isDirectTouch || b.series.shouldShowTooltip(e, f))) h = this.getLabel(), b.style.width && !w || h.css({\n                width: (this.outside ? this.getPlayingField() : d.spacingBox).width + \"px\"\n              }), h.attr({\n                text: k && k.join ? k.join(\"\") : k\n              }), h.addClass(this.getClassName(g), !0), w || h.attr({\n                stroke: b.borderColor || g.color || u.color || \"#666666\"\n              }), this.updatePosition({\n                plotX: p,\n                plotY: x,\n                negative: g.negative,\n                ttBelow: g.ttBelow,\n                h: a[2] || 0\n              });else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show();\n            this.isHidden = !1;\n          }\n          m(this, \"refresh\");\n        }\n      }\n      renderSplit(a, e) {\n        function d(c, d, a, e, n = !0) {\n          a ? (d = z ? 0 : H, c = g(c - e / 2, Q.left, Q.right - e - (b.outside ? U : 0))) : (d -= D, c = n ? c - e - J : c + J, c = g(c, n ? c : Q.left, Q.right));\n          return {\n            x: c,\n            y: d\n          };\n        }\n        const b = this,\n          {\n            chart: c,\n            chart: {\n              chartWidth: n,\n              chartHeight: h,\n              plotHeight: f,\n              plotLeft: k,\n              plotTop: q,\n              pointer: u,\n              scrollablePixelsY: w = 0,\n              scrollablePixelsX: m,\n              scrollingContainer: {\n                scrollLeft: p,\n                scrollTop: v\n              } = {\n                scrollLeft: 0,\n                scrollTop: 0\n              },\n              styledMode: r\n            },\n            distance: J,\n            options: M,\n            options: {\n              positioner: Y\n            }\n          } = b,\n          Q = b.outside && \"number\" !== typeof m ? E.documentElement.getBoundingClientRect() : {\n            left: p,\n            right: p + n,\n            top: v,\n            bottom: v + h\n          },\n          y = b.getLabel(),\n          S = this.renderer || c.renderer,\n          z = !(!c.xAxis[0] || !c.xAxis[0].opposite),\n          {\n            left: U,\n            top: A\n          } = u.getChartPosition();\n        let D = q + v,\n          F = 0,\n          H = f - w;\n        x(a) && (a = [!1, a]);\n        a = a.slice(0, e.length + 1).reduce(function (c, a, n) {\n          if (!1 !== a && \"\" !== a) {\n            n = e[n - 1] || {\n              isHeader: !0,\n              plotX: e[0].plotX,\n              plotY: f,\n              series: {}\n            };\n            const m = n.isHeader;\n            var h = m ? b : n.series,\n              u;\n            {\n              var w = n;\n              a = a.toString();\n              var G = h.tt;\n              const {\n                isHeader: c,\n                series: d\n              } = w;\n              G || (G = {\n                padding: M.padding,\n                r: M.borderRadius\n              }, r || (G.fill = M.backgroundColor, G[\"stroke-width\"] = null !== (u = M.borderWidth) && void 0 !== u ? u : 1), G = S.label(\"\", 0, 0, M[c ? \"headerShape\" : \"shape\"], void 0, void 0, M.useHTML).addClass(b.getClassName(w, !0, c)).attr(G).add(y));\n              G.isActive = !0;\n              G.attr({\n                text: a\n              });\n              r || G.css(M.style).attr({\n                stroke: M.borderColor || w.color || d.color || \"#333333\"\n              });\n              u = G;\n            }\n            u = h.tt = u;\n            w = u.getBBox();\n            h = w.width + u.strokeWidth();\n            m && (F = w.height, H += F, z && (D -= F));\n            {\n              const {\n                isHeader: b,\n                plotX: c = 0,\n                plotY: d = 0,\n                series: e\n              } = n;\n              if (b) {\n                a = k + c;\n                var l = q + f / 2;\n              } else {\n                const {\n                  xAxis: b,\n                  yAxis: n\n                } = e;\n                a = b.pos + g(c, -J, b.len + J);\n                e.shouldShowTooltip(0, n.pos - q + d, {\n                  ignoreX: !0\n                }) && (l = n.pos + d);\n              }\n              a = g(a, Q.left - J, Q.right + J);\n              l = {\n                anchorX: a,\n                anchorY: l\n              };\n            }\n            const {\n              anchorX: I,\n              anchorY: p\n            } = l;\n            \"number\" === typeof p ? (l = w.height + 1, w = Y ? Y.call(b, h, l, n) : d(I, p, m, h), c.push({\n              align: Y ? 0 : void 0,\n              anchorX: I,\n              anchorY: p,\n              boxWidth: h,\n              point: n,\n              rank: C(w.rank, m ? 1 : 0),\n              size: l,\n              target: w.y,\n              tt: u,\n              x: w.x\n            })) : u.isActive = !1;\n          }\n          return c;\n        }, []);\n        !Y && a.some(c => {\n          var {\n            outside: d\n          } = b;\n          d = (d ? U : 0) + c.anchorX;\n          return d < Q.left && d + c.boxWidth < Q.right ? !0 : d < U - Q.left + c.boxWidth && Q.right - d > d;\n        }) && (a = a.map(b => {\n          const {\n            x: c,\n            y: a\n          } = d(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);\n          return l(b, {\n            target: a,\n            x: c\n          });\n        }));\n        b.cleanSplit();\n        t(a, H);\n        var V = U,\n          ha = U;\n        a.forEach(function (c) {\n          const {\n            x: d,\n            boxWidth: a,\n            isHeader: n\n          } = c;\n          n || (b.outside && U + d < V && (V = U + d), !n && b.outside && V + a > ha && (ha = U + d));\n        });\n        a.forEach(function (c) {\n          const {\n              x: d,\n              anchorX: a,\n              anchorY: n,\n              pos: e,\n              point: {\n                isHeader: h\n              }\n            } = c,\n            f = {\n              visibility: \"undefined\" === typeof e ? \"hidden\" : \"inherit\",\n              x: d,\n              y: (e || 0) + D,\n              anchorX: a,\n              anchorY: n\n            };\n          if (b.outside && d < a) {\n            const b = U - V;\n            0 < b && (h || (f.x = d + b, f.anchorX = a + b), h && (f.x = (ha - V) / 2, f.anchorX = a + b));\n          }\n          c.tt.attr(f);\n        });\n        const {\n          container: ia,\n          outside: ka,\n          renderer: ja\n        } = b;\n        if (ka && ia && ja) {\n          const {\n            width: b,\n            height: c,\n            x: d,\n            y: a\n          } = y.getBBox();\n          ja.setSize(b + d, c + a, !1);\n          ia.style.left = V + \"px\";\n          ia.style.top = A + \"px\";\n        }\n        B && y.attr({\n          opacity: 1 === y.opacity ? .999 : 1\n        });\n      }\n      drawTracker() {\n        if (this.shouldStickOnContact()) {\n          var a = this.chart,\n            e = this.label,\n            d = this.shared ? a.hoverPoints : a.hoverPoint;\n          if (e && d) {\n            var b = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            d = this.getAnchor(d);\n            var c = e.getBBox();\n            d[0] += a.plotLeft - e.translateX;\n            d[1] += a.plotTop - e.translateY;\n            b.x = Math.min(0, d[0]);\n            b.y = Math.min(0, d[1]);\n            b.width = 0 > d[0] ? Math.max(Math.abs(d[0]), c.width - d[0]) : Math.max(Math.abs(d[0]), c.width);\n            b.height = 0 > d[1] ? Math.max(Math.abs(d[1]), c.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), c.height);\n            this.tracker ? this.tracker.attr(b) : (this.tracker = e.renderer.rect(b).addClass(\"highcharts-tracker\").add(e), a.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        } else this.tracker && (this.tracker = this.tracker.destroy());\n      }\n      styledModeFormat(a) {\n        return a.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n      }\n      tooltipFooterHeaderFormatter(a, e) {\n        const d = a.series,\n          b = d.tooltipOptions;\n        var c = d.xAxis;\n        const n = c && c.dateTime;\n        c = {\n          isFooter: e,\n          labelConfig: a\n        };\n        let h = b.xDateFormat,\n          f = b[e ? \"footerFormat\" : \"headerFormat\"];\n        m(this, \"headerFormatter\", c, function (c) {\n          n && !h && k(a.key) && (h = n.getXDateFormat(a.key, b.dateTimeLabelFormats));\n          n && h && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (b) {\n            f = f.replace(\"{point.\" + b + \"}\", \"{point.\" + b + \":\" + h + \"}\");\n          });\n          d.chart.styledMode && (f = this.styledModeFormat(f));\n          c.text = y(f, {\n            point: a,\n            series: d\n          }, this.chart);\n        });\n        return c.text;\n      }\n      update(a) {\n        this.destroy();\n        J(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, J(!0, this.options, a));\n      }\n      updatePosition(a) {\n        const {\n          chart: e,\n          distance: d,\n          options: b\n        } = this;\n        var c = e.pointer;\n        const n = this.getLabel(),\n          {\n            left: h,\n            top: f,\n            scaleX: g,\n            scaleY: k\n          } = c.getChartPosition();\n        c = (b.positioner || this.getPosition).call(this, n.width, n.height, a);\n        let q = (a.plotX || 0) + e.plotLeft;\n        a = (a.plotY || 0) + e.plotTop;\n        let w;\n        if (this.outside) {\n          b.positioner && (c.x += h - d, c.y += f - d);\n          w = (b.borderWidth || 0) + 2 * d;\n          this.renderer.setSize(n.width + w, n.height + w, !1);\n          if (1 !== g || 1 !== k) p(this.container, {\n            transform: `scale(${g}, ${k})`\n          }), q *= g, a *= k;\n          q += h - c.x;\n          a += f - c.y;\n        }\n        this.move(Math.round(c.x), Math.round(c.y || 0), q, a);\n      }\n    }\n    (function (a) {\n      const e = [];\n      a.compose = function (d) {\n        A.pushUnique(e, d) && r(d, \"afterInit\", function () {\n          const b = this.chart;\n          b.options.tooltip && (b.tooltip = new a(b, b.options.tooltip));\n        });\n      };\n    })(w || (w = {}));\n    \"\";\n    return w;\n  });\n  L(a, \"Core/Series/Point.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A) {\n    const {\n        animObject: y\n      } = z,\n      {\n        defaultOptions: E\n      } = F,\n      {\n        format: B\n      } = H,\n      {\n        addEvent: t,\n        defined: r,\n        erase: g,\n        extend: p,\n        fireEvent: v,\n        getNestedProperty: l,\n        isArray: m,\n        isFunction: f,\n        isNumber: k,\n        isObject: x,\n        merge: J,\n        objectEach: C,\n        pick: e,\n        syncTimeout: h,\n        removeEvent: w,\n        uniqueKey: q\n      } = A;\n    class u {\n      constructor() {\n        this.category = void 0;\n        this.destroyed = !1;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.shapeArgs = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n      animateBeforeDestroy() {\n        const d = this,\n          b = {\n            x: d.startXPos,\n            opacity: 0\n          },\n          c = d.getGraphicalProps();\n        c.singular.forEach(function (c) {\n          d[c] = d[c].animate(\"dataLabel\" === c ? {\n            x: d[c].startXPos,\n            y: d[c].startYPos,\n            opacity: 0\n          } : b);\n        });\n        c.plural.forEach(function (b) {\n          d[b].forEach(function (b) {\n            b.element && b.animate(p({\n              x: d.startXPos\n            }, b.startYPos ? {\n              x: b.startXPos,\n              y: b.startYPos\n            } : {}));\n          });\n        });\n      }\n      applyOptions(d, b) {\n        const c = this.series,\n          a = c.options.pointValKey || c.pointValKey;\n        d = u.prototype.optionsToObject.call(this, d);\n        p(this, d);\n        this.options = this.options ? p(this.options, d) : d;\n        d.group && delete this.group;\n        d.dataLabels && delete this.dataLabels;\n        a && (this.y = u.prototype.getNestedProperty.call(this, a));\n        this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof b && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && c ? this.x = \"undefined\" === typeof b ? c.autoIncrement() : b : k(d.x) && c.options.relativeXValue && (this.x = c.autoIncrement(d.x));\n        return this;\n      }\n      destroy() {\n        if (!this.destroyed) {\n          const b = this;\n          var d = b.series;\n          const c = d.chart;\n          d = d.options.dataSorting;\n          const a = c.hoverPoints,\n            e = y(b.series.chart.renderer.globalAnimation),\n            f = () => {\n              if (b.graphic || b.graphics || b.dataLabel || b.dataLabels) w(b), b.destroyElements();\n              for (const c in b) delete b[c];\n            };\n          b.legendItem && c.legend.destroyItem(b);\n          a && (b.setState(), g(a, b), a.length || (c.hoverPoints = null));\n          if (b === c.hoverPoint) b.onMouseOut();\n          d && d.enabled ? (this.animateBeforeDestroy(), h(f, e.duration)) : f();\n          c.pointCount--;\n        }\n        this.destroyed = !0;\n      }\n      destroyElements(d) {\n        const b = this;\n        d = b.getGraphicalProps(d);\n        d.singular.forEach(function (c) {\n          b[c] = b[c].destroy();\n        });\n        d.plural.forEach(function (c) {\n          b[c].forEach(function (b) {\n            b && b.element && b.destroy();\n          });\n          delete b[c];\n        });\n      }\n      firePointEvent(d, b, c) {\n        const a = this,\n          e = this.series.options;\n        (e.point.events[d] || a.options && a.options.events && a.options.events[d]) && a.importEvents();\n        \"click\" === d && e.allowPointSelect && (c = function (b) {\n          a.select && a.select(null, b.ctrlKey || b.metaKey || b.shiftKey);\n        });\n        v(a, d, b, c);\n      }\n      getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      }\n      getGraphicalProps(d) {\n        const b = this,\n          c = [],\n          a = {\n            singular: [],\n            plural: []\n          };\n        let e, h;\n        d = d || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        d.graphic && c.push(\"graphic\");\n        d.dataLabel && c.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\", \"connector\");\n        for (h = c.length; h--;) e = c[h], b[e] && a.singular.push(e);\n        [\"graphic\", \"dataLabel\", \"connector\"].forEach(function (c) {\n          const e = c + \"s\";\n          d[c] && b[e] && a.plural.push(e);\n        });\n        return a;\n      }\n      getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      }\n      getNestedProperty(d) {\n        if (d) return 0 === d.indexOf(\"custom.\") ? l(d, this.options) : this[d];\n      }\n      getZone() {\n        var d = this.series;\n        const b = d.zones;\n        d = d.zoneAxis || \"y\";\n        let c,\n          a = 0;\n        for (c = b[a]; this[d] >= c.value;) c = b[++a];\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;\n        return c;\n      }\n      hasNewShapeType() {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      }\n      init(d, b, c) {\n        this.series = d;\n        this.applyOptions(b, c);\n        this.id = r(this.id) ? this.id : q();\n        this.resolveColor();\n        d.chart.pointCount++;\n        v(this, \"afterInit\");\n        return this;\n      }\n      isValid() {\n        return null !== this.x && k(this.y);\n      }\n      optionsToObject(d) {\n        var b = this.series;\n        const c = b.options.keys,\n          a = c || b.pointArrayMap || [\"y\"],\n          e = a.length;\n        let h = {},\n          f = 0,\n          g = 0;\n        if (k(d) || null === d) h[a[0]] = d;else if (m(d)) for (!c && d.length > e && (b = typeof d[0], \"string\" === b ? h.name = d[0] : \"number\" === b && (h.x = d[0]), f++); g < e;) c && \"undefined\" === typeof d[f] || (0 < a[g].indexOf(\".\") ? u.prototype.setNestedProperty(h, d[f], a[g]) : h[a[g]] = d[f]), f++, g++;else \"object\" === typeof d && (h = d, d.dataLabels && (b._hasPointLabels = !0), d.marker && (b._hasPointMarkers = !0));\n        return h;\n      }\n      pos(d, b = this.plotY) {\n        if (!this.destroyed) {\n          const {\n              plotX: c,\n              series: a\n            } = this,\n            {\n              chart: e,\n              xAxis: h,\n              yAxis: f\n            } = a;\n          let g = 0,\n            q = 0;\n          if (k(c) && k(b)) return d && (g = h ? h.pos : e.plotLeft, q = f ? f.pos : e.plotTop), e.inverted && h && f ? [f.len - b + q, h.len - c + g] : [c + g, b + q];\n        }\n      }\n      resolveColor() {\n        const d = this.series;\n        var b = d.chart.styledMode;\n        let c;\n        var a = d.chart.options.chart.colorCount;\n        delete this.nonZonedColor;\n        d.options.colorByPoint ? (b || (a = d.options.colors || d.chart.options.colors, c = a[d.colorCounter], a = a.length), b = d.colorCounter, d.colorCounter++, d.colorCounter === a && (d.colorCounter = 0)) : (b || (c = d.color), b = d.colorIndex);\n        this.colorIndex = e(this.options.colorIndex, b);\n        this.color = e(this.options.color, c);\n      }\n      setNestedProperty(d, b, c) {\n        c.split(\".\").reduce(function (c, d, a, e) {\n          c[d] = e.length - 1 === a ? b : x(c[d], !0) ? c[d] : {};\n          return c[d];\n        }, d);\n        return d;\n      }\n      shouldDraw() {\n        return !this.isNull;\n      }\n      tooltipFormatter(d) {\n        const b = this.series,\n          c = b.tooltipOptions,\n          a = e(c.valueDecimals, \"\"),\n          h = c.valuePrefix || \"\",\n          f = c.valueSuffix || \"\";\n        b.chart.styledMode && (d = b.chart.tooltip.styledModeFormat(d));\n        (b.pointArrayMap || [\"y\"]).forEach(function (b) {\n          b = \"{point.\" + b;\n          if (h || f) d = d.replace(RegExp(b + \"}\", \"g\"), h + b + \"}\" + f);\n          d = d.replace(RegExp(b + \"}\", \"g\"), b + \":,.\" + a + \"f}\");\n        });\n        return B(d, {\n          point: this,\n          series: this.series\n        }, b.chart);\n      }\n      update(d, b, c, a) {\n        function h() {\n          n.applyOptions(d);\n          var a = g && n.hasMockGraphic;\n          a = null === n.y ? !a : a;\n          g && a && (n.graphic = g.destroy(), delete n.hasMockGraphic);\n          x(d, !0) && (g && g.element && d && d.marker && \"undefined\" !== typeof d.marker.symbol && (n.graphic = g.destroy()), d && d.dataLabels && n.dataLabel && (n.dataLabel = n.dataLabel.destroy()), n.connector && (n.connector = n.connector.destroy()));\n          u = n.index;\n          f.updateParallelArrays(n, u);\n          q.data[u] = x(q.data[u], !0) || x(d, !0) ? n.options : e(d, q.data[u]);\n          f.isDirty = f.isDirtyData = !0;\n          !f.fixedBox && f.hasCartesianSeries && (k.isDirtyBox = !0);\n          \"point\" === q.legendType && (k.isDirtyLegend = !0);\n          b && k.redraw(c);\n        }\n        const n = this,\n          f = n.series,\n          g = n.graphic,\n          k = f.chart,\n          q = f.options;\n        let u;\n        b = e(b, !0);\n        !1 === a ? h() : n.firePointEvent(\"update\", {\n          options: d\n        }, h);\n      }\n      remove(d, b) {\n        this.series.removePoint(this.series.data.indexOf(this), d, b);\n      }\n      select(d, b) {\n        const c = this,\n          a = c.series,\n          h = a.chart;\n        this.selectedStaging = d = e(d, !c.selected);\n        c.firePointEvent(d ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          c.selected = c.options.selected = d;\n          a.options.data[a.data.indexOf(c)] = c.options;\n          c.setState(d && \"select\");\n          b || h.getSelectedPoints().forEach(function (b) {\n            const d = b.series;\n            b.selected && b !== c && (b.selected = b.options.selected = !1, d.options.data[d.data.indexOf(b)] = b.options, b.setState(h.hoverPoints && d.options.inactiveOtherPoints ? \"inactive\" : \"\"), b.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      }\n      onMouseOver(d) {\n        const b = this.series.chart,\n          c = b.pointer;\n        d = d ? c.normalize(d) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(d, this);\n      }\n      onMouseOut() {\n        const d = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (d.hoverPoints || []).forEach(function (b) {\n          b.setState();\n        });\n        d.hoverPoints = d.hoverPoint = null;\n      }\n      importEvents() {\n        if (!this.hasImportedEvents) {\n          const d = this,\n            b = J(d.series.options.point, d.options).events;\n          d.events = b;\n          C(b, function (b, a) {\n            f(b) && t(d, a, b);\n          });\n          this.hasImportedEvents = !0;\n        }\n      }\n      setState(d, b) {\n        const c = this.series;\n        var h = this.state,\n          f = c.options.states[d || \"normal\"] || {},\n          g = E.plotOptions[c.type].marker && c.options.marker;\n        const q = g && !1 === g.enabled,\n          u = g && g.states && g.states[d || \"normal\"] || {},\n          w = !1 === u.enabled,\n          l = this.marker || {},\n          m = c.chart,\n          x = g && c.markerAttribs;\n        let r = c.halo;\n        var t;\n        let J;\n        var M = c.stateMarkerGraphic;\n        d = d || \"\";\n        if (!(d === this.state && !b || this.selected && \"select\" !== d || !1 === f.enabled || d && (w || q && !1 === u.enabled) || d && l.states && l.states[d] && !1 === l.states[d].enabled)) {\n          this.state = d;\n          x && (t = c.markerAttribs(this, d));\n          if (this.graphic && !this.hasMockGraphic) {\n            h && this.graphic.removeClass(\"highcharts-point-\" + h);\n            d && this.graphic.addClass(\"highcharts-point-\" + d);\n            if (!m.styledMode) {\n              h = c.pointAttribs(this, d);\n              J = e(m.options.chart.animation, f.animation);\n              const b = h.opacity;\n              c.options.inactiveOtherPoints && k(b) && ((this.dataLabels || []).forEach(function (c) {\n                c && !c.hasClass(\"highcharts-data-label-hidden\") && c.animate({\n                  opacity: b\n                }, J);\n              }), this.connector && this.connector.animate({\n                opacity: b\n              }, J));\n              this.graphic.animate(h, J);\n            }\n            t && this.graphic.animate(t, e(m.options.chart.animation, u.animation, g.animation));\n            M && M.hide();\n          } else {\n            if (d && u) {\n              g = l.symbol || c.symbol;\n              M && M.currentSymbol !== g && (M = M.destroy());\n              if (t) if (M) M[b ? \"animate\" : \"attr\"]({\n                x: t.x,\n                y: t.y\n              });else g && (c.stateMarkerGraphic = M = m.renderer.symbol(g, t.x, t.y, t.width, t.height).add(c.markerGroup), M.currentSymbol = g);\n              !m.styledMode && M && \"inactive\" !== this.state && M.attr(c.pointAttribs(this, d));\n            }\n            M && (M[d && this.isInside ? \"show\" : \"hide\"](), M.element.point = this, M.addClass(this.getClassName(), !0));\n          }\n          f = f.halo;\n          t = (M = this.graphic || M) && M.visibility || \"inherit\";\n          f && f.size && M && \"hidden\" !== t && !this.isCluster ? (r || (c.halo = r = m.renderer.path().add(M.parentGroup)), r.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(f.size)\n          }), r.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + e(this.colorIndex, c.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: t,\n            zIndex: -1\n          }), r.point = this, m.styledMode || r.attr(p({\n            fill: this.color || c.color,\n            \"fill-opacity\": f.opacity\n          }, a.filterUserAttributes(f.attributes || {})))) : r && r.point && r.point.haloPath && r.animate({\n            d: r.point.haloPath(0)\n          }, null, r.hide);\n          v(this, \"afterSetState\", {\n            state: d\n          });\n        }\n      }\n      haloPath(d) {\n        const b = this.pos();\n        return b ? this.series.chart.renderer.symbols.circle(Math.floor(b[0]) - d, b[1] - d, 2 * d, 2 * d) : [];\n      }\n    }\n    \"\";\n    return u;\n  });\n  L(a, \"Core/Pointer.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        parse: y\n      } = a,\n      {\n        charts: A,\n        noop: D\n      } = z,\n      {\n        addEvent: E,\n        attr: B,\n        css: t,\n        defined: r,\n        extend: g,\n        find: p,\n        fireEvent: v,\n        isNumber: l,\n        isObject: m,\n        objectEach: f,\n        offset: k,\n        pick: x,\n        splat: J\n      } = F;\n    class C {\n      constructor(a, h) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.eventsToUnbind = [];\n        this.chart = a;\n        this.hasDragged = !1;\n        this.options = h;\n        this.init(a, h);\n      }\n      applyInactiveState(a) {\n        let e = [],\n          f;\n        (a || []).forEach(function (a) {\n          f = a.series;\n          e.push(f);\n          f.linkedParent && e.push(f.linkedParent);\n          f.linkedSeries && (e = e.concat(f.linkedSeries));\n          f.navigatorSeries && e.push(f.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === e.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      }\n      destroy() {\n        const a = this;\n        this.eventsToUnbind.forEach(a => a());\n        this.eventsToUnbind = [];\n        z.chartCount || (C.unbindDocumentMouseUp && (C.unbindDocumentMouseUp = C.unbindDocumentMouseUp()), C.unbindDocumentTouchEnd && (C.unbindDocumentTouchEnd = C.unbindDocumentTouchEnd()));\n        clearInterval(a.tooltipTimeout);\n        f(a, function (e, f) {\n          a[f] = void 0;\n        });\n      }\n      getSelectionMarkerAttrs(a, h) {\n        const e = {\n          args: {\n            chartX: a,\n            chartY: h\n          },\n          attrs: {},\n          shapeType: \"rect\"\n        };\n        v(this, \"getSelectionMarkerAttrs\", e, e => {\n          const {\n            chart: f,\n            mouseDownX: d = 0,\n            mouseDownY: b = 0,\n            zoomHor: c,\n            zoomVert: n\n          } = this;\n          e = e.attrs;\n          let g;\n          e.x = f.plotLeft;\n          e.y = f.plotTop;\n          e.width = c ? 1 : f.plotWidth;\n          e.height = n ? 1 : f.plotHeight;\n          c && (g = a - d, e.width = Math.abs(g), e.x = (0 < g ? 0 : g) + d);\n          n && (g = h - b, e.height = Math.abs(g), e.y = (0 < g ? 0 : g) + b);\n        });\n        return e;\n      }\n      drag(a) {\n        const e = this.chart,\n          f = e.options.chart;\n        var g = e.plotLeft;\n        const k = e.plotTop,\n          d = e.plotWidth,\n          b = e.plotHeight,\n          c = this.mouseDownX || 0,\n          n = this.mouseDownY || 0,\n          l = m(f.panning) ? f.panning && f.panning.enabled : f.panning,\n          p = f.panKey && a[f.panKey + \"Key\"];\n        let x = a.chartX,\n          v = a.chartY,\n          r = this.selectionMarker;\n        if (!r || !r.touch) if (x < g ? x = g : x > g + d && (x = g + d), v < k ? v = k : v > k + b && (v = k + b), this.hasDragged = Math.sqrt(Math.pow(c - x, 2) + Math.pow(n - v, 2)), 10 < this.hasDragged) {\n          g = e.isInsidePlot(c - g, n - k, {\n            visiblePlotOnly: !0\n          });\n          const {\n            shapeType: b,\n            attrs: d\n          } = this.getSelectionMarkerAttrs(x, v);\n          !e.hasCartesianSeries && !e.mapView || !this.zoomX && !this.zoomY || !g || p || r || (this.selectionMarker = r = e.renderer[b](), r.attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), e.styledMode || r.attr({\n            fill: f.selectionMarkerFill || y(\"#334eff\").setOpacity(.25).get()\n          }));\n          r && r.attr(d);\n          g && !r && l && e.pan(a, f.panning);\n        }\n      }\n      dragStart(a) {\n        const e = this.chart;\n        e.mouseIsDown = a.type;\n        e.cancelClick = !1;\n        e.mouseDownX = this.mouseDownX = a.chartX;\n        e.mouseDownY = this.mouseDownY = a.chartY;\n      }\n      getSelectionBox(a) {\n        const e = {\n          args: {\n            marker: a\n          },\n          result: {}\n        };\n        v(this, \"getSelectionBox\", e, e => {\n          e.result = {\n            x: a.attr ? +a.attr(\"x\") : a.x,\n            y: a.attr ? +a.attr(\"y\") : a.y,\n            width: a.attr ? a.attr(\"width\") : a.width,\n            height: a.attr ? a.attr(\"height\") : a.height\n          };\n        });\n        return e.result;\n      }\n      drop(a) {\n        const e = this,\n          f = this.chart,\n          k = this.hasPinched;\n        if (this.selectionMarker) {\n          const {\n              x: h,\n              y: d,\n              width: b,\n              height: c\n            } = this.getSelectionBox(this.selectionMarker),\n            n = {\n              originalEvent: a,\n              xAxis: [],\n              yAxis: [],\n              x: h,\n              y: d,\n              width: b,\n              height: c\n            };\n          let q = !!f.mapView;\n          if (this.hasDragged || k) f.axes.forEach(function (f) {\n            if (f.zoomEnabled && r(f.min) && (k || e[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[f.coll]]) && l(h) && l(d) && l(b) && l(c)) {\n              var g = f.horiz;\n              const e = \"touchend\" === a.type ? f.minPixelPadding : 0,\n                k = f.toValue((g ? h : d) + e);\n              g = f.toValue((g ? h + b : d + c) - e);\n              n[f.coll].push({\n                axis: f,\n                min: Math.min(k, g),\n                max: Math.max(k, g)\n              });\n              q = !0;\n            }\n          }), q && v(f, \"selection\", n, function (b) {\n            f.zoom(g(b, k ? {\n              animation: !1\n            } : null));\n          });\n          l(f.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          k && this.scaleGroups();\n        }\n        f && l(f.index) && (t(f.container, {\n          cursor: f._cursor\n        }), f.cancelClick = 10 < this.hasDragged, f.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      }\n      findNearestKDPoint(a, h, f) {\n        let e;\n        a.forEach(function (a) {\n          var d = !(a.noSharedTooltip && h) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(f, d);\n          if ((d = m(a, !0) && a.series) && !(d = !m(e, !0))) {\n            {\n              d = e.distX - a.distX;\n              const b = e.dist - a.dist,\n                c = (a.series.group && a.series.group.zIndex) - (e.series.group && e.series.group.zIndex);\n              d = 0 !== d && h ? d : 0 !== b ? b : 0 !== c ? c : e.series.index > a.series.index ? -1 : 1;\n            }\n            d = 0 < d;\n          }\n          d && (e = a);\n        });\n        return e;\n      }\n      getChartCoordinatesFromPoint(a, h) {\n        var e = a.series;\n        const f = e.xAxis;\n        e = e.yAxis;\n        const g = a.shapeArgs;\n        if (f && e) {\n          let d = x(a.clientX, a.plotX),\n            b = a.plotY || 0;\n          a.isNode && g && l(g.x) && l(g.y) && (d = g.x, b = g.y);\n          return h ? {\n            chartX: e.len + e.pos - b,\n            chartY: f.len + f.pos - d\n          } : {\n            chartX: d + f.pos,\n            chartY: b + e.pos\n          };\n        }\n        if (g && g.x && g.y) return {\n          chartX: g.x,\n          chartY: g.y\n        };\n      }\n      getChartPosition() {\n        if (this.chartPosition) return this.chartPosition;\n        var {\n          container: a\n        } = this.chart;\n        const h = k(a);\n        this.chartPosition = {\n          left: h.left,\n          top: h.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        const f = a.offsetWidth;\n        a = a.offsetHeight;\n        2 < f && 2 < a && (this.chartPosition.scaleX = h.width / f, this.chartPosition.scaleY = h.height / a);\n        return this.chartPosition;\n      }\n      getCoordinates(a) {\n        const e = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (h) {\n          e[h.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: h,\n            value: h.toValue(a[h.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return e;\n      }\n      getHoverData(a, h, f, g, k, d) {\n        const b = [];\n        g = !(!g || !a);\n        const c = function (b) {\n          return b.visible && !(!k && b.directTouch) && x(b.options.enableMouseTracking, !0);\n        };\n        let e,\n          q = {\n            chartX: d ? d.chartX : void 0,\n            chartY: d ? d.chartY : void 0,\n            shared: k\n          };\n        v(this, \"beforeGetHoverData\", q);\n        e = h && !h.stickyTracking ? [h] : f.filter(b => b.stickyTracking && (q.filter || c)(b));\n        const l = g || !d ? a : this.findNearestKDPoint(e, k, d);\n        h = l && l.series;\n        l && (k && !h.noSharedTooltip ? (e = f.filter(function (b) {\n          return q.filter ? q.filter(b) : c(b) && !b.noSharedTooltip;\n        }), e.forEach(function (c) {\n          let d = p(c.points, function (b) {\n            return b.x === l.x && !b.isNull;\n          });\n          m(d) && (c.boosted && c.boost && (d = c.boost.getPoint(d)), b.push(d));\n        })) : b.push(l));\n        q = {\n          hoverPoint: l\n        };\n        v(this, \"afterGetHoverData\", q);\n        return {\n          hoverPoint: q.hoverPoint,\n          hoverSeries: h,\n          hoverPoints: b\n        };\n      }\n      getPointFromEvent(a) {\n        a = a.target;\n        let e;\n        for (; a && !e;) e = a.point, a = a.parentNode;\n        return e;\n      }\n      onTrackerMouseOut(a) {\n        a = a.relatedTarget;\n        const e = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!e || !a || e.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + e.index) && this.inClass(a, \"highcharts-tracker\"))) e.onMouseOut();\n      }\n      inClass(a, h) {\n        let e;\n        for (; a;) {\n          if (e = B(a, \"class\")) {\n            if (-1 !== e.indexOf(h)) return !0;\n            if (-1 !== e.indexOf(\"highcharts-container\")) return !1;\n          }\n          a = a.parentElement;\n        }\n      }\n      init(a, h) {\n        this.options = h;\n        this.chart = a;\n        this.runChartClick = !(!h.chart.events || !h.chart.events.click);\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        this.setDOMEvents();\n        v(this, \"afterInit\");\n      }\n      normalize(a, h) {\n        var e = a.touches,\n          f = e ? e.length ? e.item(0) : x(e.changedTouches, a.changedTouches)[0] : a;\n        h || (h = this.getChartPosition());\n        e = f.pageX - h.left;\n        f = f.pageY - h.top;\n        e /= h.scaleX;\n        f /= h.scaleY;\n        return g(a, {\n          chartX: Math.round(e),\n          chartY: Math.round(f)\n        });\n      }\n      onContainerClick(a) {\n        const e = this.chart,\n          f = e.hoverPoint;\n        a = this.normalize(a);\n        const k = e.plotLeft,\n          l = e.plotTop;\n        e.cancelClick || (f && this.inClass(a.target, \"highcharts-tracker\") ? (v(f.series, \"click\", g(a, {\n          point: f\n        })), e.hoverPoint && f.firePointEvent(\"click\", a)) : (g(a, this.getCoordinates(a)), e.isInsidePlot(a.chartX - k, a.chartY - l, {\n          visiblePlotOnly: !0\n        }) && v(e, \"click\", a)));\n      }\n      onContainerMouseDown(a) {\n        const e = 1 === ((a.buttons || a.button) & 1);\n        a = this.normalize(a);\n        if (z.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);\n        if (\"undefined\" === typeof a.button || e) this.zoomOption(a), e && a.preventDefault && a.preventDefault(), this.dragStart(a);\n      }\n      onContainerMouseLeave(a) {\n        const e = A[x(C.hoverChartIndex, -1)];\n        a = this.normalize(a);\n        e && a.relatedTarget && !this.inClass(a.relatedTarget, \"highcharts-tooltip\") && (e.pointer.reset(), e.pointer.chartPosition = void 0);\n      }\n      onContainerMouseEnter(a) {\n        delete this.chartPosition;\n      }\n      onContainerMouseMove(a) {\n        const e = this.chart,\n          f = e.tooltip;\n        a = this.normalize(a);\n        this.setHoverChartIndex();\n        (\"mousedown\" === e.mouseIsDown || this.touchSelect(a)) && this.drag(a);\n        e.openMenu || !this.inClass(a.target, \"highcharts-tracker\") && !e.isInsidePlot(a.chartX - e.plotLeft, a.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        }) || f && f.shouldStickOnContact(a) || (this.inClass(a.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(a));\n      }\n      onDocumentTouchEnd(a) {\n        const e = A[x(C.hoverChartIndex, -1)];\n        e && e.pointer.drop(a);\n      }\n      onContainerTouchMove(a) {\n        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);\n      }\n      onContainerTouchStart(a) {\n        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);\n      }\n      onDocumentMouseMove(a) {\n        const e = this.chart,\n          f = e.tooltip,\n          g = this.chartPosition;\n        a = this.normalize(a, g);\n        !g || e.isInsidePlot(a.chartX - e.plotLeft, a.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        }) || f && f.shouldStickOnContact(a) || this.inClass(a.target, \"highcharts-tracker\") || this.reset();\n      }\n      onDocumentMouseUp(a) {\n        const e = A[x(C.hoverChartIndex, -1)];\n        e && e.pointer.drop(a);\n      }\n      pinch(a) {\n        const e = this,\n          f = e.chart,\n          k = e.pinchDown,\n          l = a.touches || [],\n          d = l.length,\n          b = e.lastValidTouch,\n          c = e.hasZoom,\n          n = {},\n          m = 1 === d && (e.inClass(a.target, \"highcharts-tracker\") && f.runTrackerClick || e.runChartClick),\n          p = {};\n        var K = e.chart.tooltip;\n        K = 1 === d && x(K && K.options.followTouchMove, !0);\n        let r = e.selectionMarker;\n        1 < d ? e.initiated = !0 : K && (e.initiated = !1);\n        c && e.initiated && !m && !1 !== a.cancelable && a.preventDefault();\n        [].map.call(l, function (b) {\n          return e.normalize(b);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(l, function (b, c) {\n          k[c] = {\n            chartX: b.chartX,\n            chartY: b.chartY\n          };\n        }), b.x = [k[0].chartX, k[1] && k[1].chartX], b.y = [k[0].chartY, k[1] && k[1].chartY], f.axes.forEach(function (b) {\n          if (b.zoomEnabled) {\n            const c = f.bounds[b.horiz ? \"h\" : \"v\"],\n              d = b.minPixelPadding,\n              a = b.toPixels(Math.min(x(b.options.min, b.dataMin), b.dataMin)),\n              e = b.toPixels(Math.max(x(b.options.max, b.dataMax), b.dataMax)),\n              n = Math.max(a, e);\n            c.min = Math.min(b.pos, Math.min(a, e) - d);\n            c.max = Math.max(b.pos + b.len, n + d);\n          }\n        }), e.res = !0) : K ? this.runPointActions(e.normalize(a)) : k.length && (v(f, \"touchpan\", {\n          originalEvent: a\n        }, () => {\n          r || (e.selectionMarker = r = g({\n            destroy: D,\n            touch: !0\n          }, f.plotBox));\n          e.pinchTranslate(k, l, n, r, p, b);\n          e.hasPinched = c;\n          e.scaleGroups(n, p);\n        }), e.res && (e.res = !1, this.reset(!1, 0)));\n      }\n      pinchTranslate(a, h, f, g, k, d) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, h, f, g, k, d);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, h, f, g, k, d);\n      }\n      pinchTranslateDirection(a, h, f, g, k, d, b, c) {\n        const e = this.chart,\n          q = a ? \"x\" : \"y\",\n          l = a ? \"X\" : \"Y\",\n          u = \"chart\" + l,\n          m = a ? \"width\" : \"height\",\n          w = e[\"plot\" + (a ? \"Left\" : \"Top\")],\n          p = e.inverted,\n          x = e.bounds[a ? \"h\" : \"v\"],\n          v = 1 === h.length,\n          r = h[0][u],\n          t = !v && h[1][u];\n        h = function () {\n          \"number\" === typeof y && 20 < Math.abs(r - t) && (C = c || Math.abs(Q - y) / Math.abs(r - t));\n          M = (w - Q) / C + r;\n          J = e[\"plot\" + (a ? \"Width\" : \"Height\")] / C;\n        };\n        let J,\n          M,\n          C = c || 1,\n          Q = f[0][u],\n          y = !v && f[1][u],\n          B;\n        h();\n        f = M;\n        f < x.min ? (f = x.min, B = !0) : f + J > x.max && (f = x.max - J, B = !0);\n        B ? (Q -= .8 * (Q - b[q][0]), \"number\" === typeof y && (y -= .8 * (y - b[q][1])), h()) : b[q] = [Q, y];\n        p || (d[q] = M - w, d[m] = J);\n        d = p ? 1 / C : C;\n        k[m] = J;\n        k[q] = f;\n        g[p ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + l] = C;\n        g[\"translate\" + l] = d * w + (Q - d * r);\n      }\n      reset(a, h) {\n        const e = this.chart,\n          f = e.hoverSeries,\n          g = e.hoverPoint,\n          d = e.hoverPoints,\n          b = e.tooltip,\n          c = b && b.shared ? d : g;\n        a && c && J(c).forEach(function (b) {\n          b.series.isCartesian && \"undefined\" === typeof b.plotX && (a = !1);\n        });\n        if (a) b && c && J(c).length && (b.refresh(c), b.shared && d ? d.forEach(function (b) {\n          b.setState(b.state, !0);\n          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));\n        }) : g && (g.setState(g.state, !0), e.axes.forEach(function (b) {\n          b.crosshair && g.series[b.coll] === b && b.drawCrosshair(null, g);\n        })));else {\n          if (g) g.onMouseOut();\n          d && d.forEach(function (b) {\n            b.setState();\n          });\n          if (f) f.onMouseOut();\n          b && b.hide(h);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          e.axes.forEach(function (b) {\n            b.hideCrosshair();\n          });\n          this.hoverX = e.hoverPoints = e.hoverPoint = null;\n        }\n      }\n      runPointActions(a, h, f) {\n        const e = this.chart,\n          g = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,\n          d = g ? g.shared : !1;\n        let b = h || e.hoverPoint,\n          c = b && b.series || e.hoverSeries;\n        h = this.getHoverData(b, c, e.series, (!a || \"touchmove\" !== a.type) && (!!h || c && c.directTouch && this.isDirectTouch), d, a);\n        b = h.hoverPoint;\n        c = h.hoverSeries;\n        const n = h.hoverPoints;\n        h = c && c.tooltipOptions.followPointer && !c.tooltipOptions.split;\n        const k = d && c && !c.noSharedTooltip;\n        if (b && (f || b !== e.hoverPoint || g && g.isHidden)) {\n          (e.hoverPoints || []).forEach(function (b) {\n            -1 === n.indexOf(b) && b.setState();\n          });\n          if (e.hoverSeries !== c) c.onMouseOver();\n          this.applyInactiveState(n);\n          (n || []).forEach(function (b) {\n            b.setState(\"hover\");\n          });\n          e.hoverPoint && e.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!b.series) return;\n          e.hoverPoints = n;\n          e.hoverPoint = b;\n          b.firePointEvent(\"mouseOver\", void 0, () => {\n            g && b && g.refresh(k ? n : b, a);\n          });\n        } else h && g && !g.isHidden && (f = g.getAnchor([{}], a), e.isInsidePlot(f[0], f[1], {\n          visiblePlotOnly: !0\n        }) && g.updatePosition({\n          plotX: f[0],\n          plotY: f[1]\n        }));\n        this.unDocMouseMove || (this.unDocMouseMove = E(e.container.ownerDocument, \"mousemove\", function (b) {\n          const c = A[C.hoverChartIndex];\n          if (c) c.pointer.onDocumentMouseMove(b);\n        }), this.eventsToUnbind.push(this.unDocMouseMove));\n        e.axes.forEach(function (b) {\n          const c = x((b.crosshair || {}).snap, !0);\n          let d;\n          c && ((d = e.hoverPoint) && d.series[b.coll] === b || (d = p(n, c => c.series && c.series[b.coll] === b)));\n          d || !c ? b.drawCrosshair(a, d) : b.hideCrosshair();\n        });\n      }\n      scaleGroups(a, h) {\n        const e = this.chart;\n        e.series.forEach(function (f) {\n          const g = a || f.getPlotBox();\n          f.group && (f.xAxis && f.xAxis.zoomEnabled || e.mapView) && (f.group.attr(g), f.markerGroup && (f.markerGroup.attr(g), f.markerGroup.clip(h ? e.clipRect : null)), f.dataLabelsGroup && f.dataLabelsGroup.attr(g));\n        });\n        e.clipRect.attr(h || e.clipBox);\n      }\n      setDOMEvents() {\n        const a = this.chart.container,\n          h = a.ownerDocument;\n        a.onmousedown = this.onContainerMouseDown.bind(this);\n        a.onmousemove = this.onContainerMouseMove.bind(this);\n        a.onclick = this.onContainerClick.bind(this);\n        this.eventsToUnbind.push(E(a, \"mouseenter\", this.onContainerMouseEnter.bind(this)));\n        this.eventsToUnbind.push(E(a, \"mouseleave\", this.onContainerMouseLeave.bind(this)));\n        C.unbindDocumentMouseUp || (C.unbindDocumentMouseUp = E(h, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n        let f = this.chart.renderTo.parentElement;\n        for (; f && \"BODY\" !== f.tagName;) this.eventsToUnbind.push(E(f, \"scroll\", () => {\n          delete this.chartPosition;\n        })), f = f.parentElement;\n        z.hasTouch && (this.eventsToUnbind.push(E(a, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(E(a, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), C.unbindDocumentTouchEnd || (C.unbindDocumentTouchEnd = E(h, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      }\n      setHoverChartIndex() {\n        const a = this.chart,\n          h = z.charts[x(C.hoverChartIndex, -1)];\n        if (h && h !== a) h.pointer.onContainerMouseLeave({\n          relatedTarget: a.container\n        });\n        h && h.mouseIsDown || (C.hoverChartIndex = a.index);\n      }\n      touch(a, h) {\n        const e = this.chart;\n        let f, g;\n        this.setHoverChartIndex();\n        1 === a.touches.length ? (a = this.normalize(a), (g = e.isInsidePlot(a.chartX - e.plotLeft, a.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        })) && !e.openMenu ? (h && this.runPointActions(a), \"touchmove\" === a.type && (h = this.pinchDown, f = h[0] ? 4 <= Math.sqrt(Math.pow(h[0].chartX - a.chartX, 2) + Math.pow(h[0].chartY - a.chartY, 2)) : !1), x(f, !0) && this.pinch(a)) : h && this.reset()) : 2 === a.touches.length && this.pinch(a);\n      }\n      touchSelect(a) {\n        return !(!this.chart.options.chart.zooming.singleTouch || !a.touches || 1 !== a.touches.length);\n      }\n      zoomOption(a) {\n        var e = this.chart,\n          f = e.options.chart;\n        e = e.inverted;\n        let g = f.zooming.type || \"\";\n        /touch/.test(a.type) && (g = x(f.zooming.pinchType, g));\n        this.zoomX = a = /x/.test(g);\n        this.zoomY = f = /y/.test(g);\n        this.zoomHor = a && !e || f && e;\n        this.zoomVert = f && !e || a && e;\n        this.hasZoom = a || f;\n      }\n    }\n    (function (a) {\n      const e = [],\n        f = [];\n      a.compose = function (e) {\n        F.pushUnique(f, e) && E(e, \"beforeRender\", function () {\n          this.pointer = new a(this, this.options);\n        });\n      };\n      a.dissolve = function () {\n        for (let a = 0, h = e.length; a < h; ++a) e[a]();\n        e.length = 0;\n      };\n    })(C || (C = {}));\n    \"\";\n    return C;\n  });\n  L(a, \"Core/Legend/Legend.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D) {\n    const {\n        animObject: y,\n        setAnimation: B\n      } = a,\n      {\n        format: t\n      } = z,\n      {\n        marginNames: r\n      } = F,\n      {\n        distribute: g\n      } = A,\n      {\n        addEvent: p,\n        createElement: v,\n        css: l,\n        defined: m,\n        discardElement: f,\n        find: k,\n        fireEvent: x,\n        isNumber: J,\n        merge: C,\n        pick: e,\n        relativeLength: h,\n        stableSort: w,\n        syncTimeout: q\n      } = D;\n    class u {\n      constructor(d, b) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = void 0;\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = d;\n        this.init(d, b);\n      }\n      init(d, b) {\n        this.chart = d;\n        this.setOptions(b);\n        b.enabled && (this.render(), p(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), p(this.chart, \"render\", () => {\n          this.proximate && (this.proximatePositions(), this.positionItems());\n        }));\n      }\n      setOptions(d) {\n        const b = e(d.padding, 8);\n        this.options = d;\n        this.chart.styledMode || (this.itemStyle = d.itemStyle, this.itemHiddenStyle = C(this.itemStyle, d.itemHiddenStyle));\n        this.itemMarginTop = d.itemMarginTop;\n        this.itemMarginBottom = d.itemMarginBottom;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = e(d.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === d.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      }\n      update(d, b) {\n        const c = this.chart;\n        this.setOptions(C(!0, this.options, d));\n        this.destroy();\n        c.isDirtyLegend = c.isDirtyBox = !0;\n        e(b, !0) && c.redraw();\n        x(this, \"afterUpdate\");\n      }\n      colorizeItem(d, b) {\n        const {\n          group: c,\n          label: a,\n          line: e,\n          symbol: h\n        } = d.legendItem || {};\n        if (c) c[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n        if (!this.chart.styledMode) {\n          var f = this.options;\n          const c = this.itemHiddenStyle.color;\n          f = b ? f.itemStyle.color : c;\n          const n = b ? d.color || c : c,\n            g = d.options && d.options.marker;\n          let k = {\n            fill: n\n          };\n          a && a.css({\n            fill: f\n          });\n          e && e.attr({\n            stroke: n\n          });\n          h && (g && h.isMarker && (k = d.pointAttribs(), b || (k.stroke = k.fill = c)), h.attr(k));\n        }\n        x(this, \"afterColorizeItem\", {\n          item: d,\n          visible: b\n        });\n      }\n      positionItems() {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      }\n      positionItem(d) {\n        const {\n          group: b,\n          x: c = 0,\n          y: a = 0\n        } = d.legendItem || {};\n        var e = this.options,\n          h = e.symbolPadding;\n        const f = !e.rtl;\n        e = d.checkbox;\n        b && b.element && (h = {\n          translateX: f ? c : this.legendWidth - c - 2 * h - 4,\n          translateY: a\n        }, b[m(b.translateY) ? \"animate\" : \"attr\"](h, void 0, () => {\n          x(this, \"afterPositionItem\", {\n            item: d\n          });\n        }));\n        e && (e.x = c, e.y = a);\n      }\n      destroyItem(a) {\n        const b = a.checkbox,\n          c = a.legendItem || {};\n        for (const b of [\"group\", \"label\", \"line\", \"symbol\"]) c[b] && (c[b] = c[b].destroy());\n        b && f(b);\n        a.legendItem = void 0;\n      }\n      destroy() {\n        for (const a of this.getAllItems()) this.destroyItem(a);\n        for (const a of \"clipRect up down pager nav box title group\".split(\" \")) this[a] && (this[a] = this[a].destroy());\n        this.display = null;\n      }\n      positionCheckboxes() {\n        const a = this.group && this.group.alignAttr,\n          b = this.clipHeight || this.legendHeight,\n          c = this.titleHeight;\n        let e;\n        a && (e = a.translateY, this.allItems.forEach(function (d) {\n          const h = d.checkbox;\n          let n;\n          h && (n = e + c + h.y + (this.scrollOffset || 0) + 3, l(h, {\n            left: a.translateX + d.checkboxOffset + h.x - 20 + \"px\",\n            top: n + \"px\",\n            display: this.proximate || n > e - 6 && n < e + b - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      }\n      renderTitle() {\n        var a = this.options;\n        const b = this.padding,\n          c = a.title;\n        let e = 0;\n        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, void 0, void 0, void 0, a.useHTML, void 0, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), e = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: e\n        }));\n        this.titleHeight = e;\n      }\n      setText(a) {\n        const b = this.options;\n        a.legendItem.label.attr({\n          text: b.labelFormat ? t(b.labelFormat, a, this.chart) : b.labelFormatter.call(a)\n        });\n      }\n      renderItem(a) {\n        const b = a.legendItem = a.legendItem || {};\n        var c = this.chart,\n          d = c.renderer;\n        const h = this.options,\n          f = this.symbolWidth,\n          g = h.symbolPadding || 0,\n          k = this.itemStyle,\n          q = this.itemHiddenStyle,\n          l = \"horizontal\" === h.layout ? e(h.itemDistance, 20) : 0,\n          m = !h.rtl,\n          u = !a.series,\n          p = !u && a.series.drawLegendSymbol ? a.series : a;\n        var w = p.options;\n        const x = this.createCheckboxForItem && w && w.showCheckbox,\n          v = h.useHTML,\n          r = a.options.className;\n        let Q = b.label;\n        w = f + g + l + (x ? 20 : 0);\n        Q || (b.group = d.g(\"legend-item\").addClass(\"highcharts-\" + p.type + \"-series highcharts-color-\" + a.colorIndex + (r ? \" \" + r : \"\") + (u ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), b.label = Q = d.text(\"\", m ? f + g : -g, this.baseline || 0, v), c.styledMode || Q.css(C(a.visible ? k : q)), Q.attr({\n          align: m ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(b.group), this.baseline || (this.fontMetrics = d.fontMetrics(Q), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, Q.attr(\"y\", this.baseline), this.symbolHeight = e(h.symbolHeight, this.fontMetrics.f), h.squareSymbol && (this.symbolWidth = e(h.symbolWidth, Math.max(this.symbolHeight, 16)), w = this.symbolWidth + g + l + (x ? 20 : 0), m && Q.attr(\"x\", this.symbolWidth + g))), p.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, Q, v));\n        x && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !c.styledMode && k.width || Q.css({\n          width: (h.itemWidth || this.widthOption || c.spacingBox.width) - w + \"px\"\n        });\n        this.setText(a);\n        c = Q.getBBox();\n        d = this.fontMetrics && this.fontMetrics.h || 0;\n        a.itemWidth = a.checkboxOffset = h.itemWidth || b.labelWidth || c.width + w;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(b.labelHeight || (c.height > 1.5 * d ? c.height : d));\n      }\n      layoutItem(a) {\n        var b = this.options;\n        const c = this.padding,\n          d = \"horizontal\" === b.layout,\n          h = a.itemHeight,\n          f = this.itemMarginBottom,\n          g = this.itemMarginTop,\n          k = d ? e(b.itemDistance, 20) : 0,\n          q = this.maxLegendWidth;\n        b = b.alignColumns && this.totalItemWidth > q ? this.maxItemWidth : a.itemWidth;\n        const l = a.legendItem || {};\n        d && this.itemX - c + b > q && (this.itemX = c, this.lastLineHeight && (this.itemY += g + this.lastLineHeight + f), this.lastLineHeight = 0);\n        this.lastItemY = g + this.itemY + f;\n        this.lastLineHeight = Math.max(h, this.lastLineHeight);\n        l.x = this.itemX;\n        l.y = this.itemY;\n        d ? this.itemX += b : (this.itemY += g + h + f, this.lastLineHeight = h);\n        this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - c - (a.checkbox ? 0 : k) : b) + c, this.offsetWidth);\n      }\n      getAllItems() {\n        let a = [];\n        this.chart.series.forEach(function (b) {\n          const c = b && b.options;\n          b && e(c.showInLegend, m(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat((b.legendItem || {}).labels || (\"point\" === c.legendType ? b.data : b)));\n        });\n        x(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      }\n      getAlignment() {\n        const a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      }\n      adjustMargins(a, b) {\n        const c = this.chart,\n          d = this.options,\n          h = this.getAlignment();\n        h && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (n, f) {\n          n.test(h) && !m(a[f]) && (c[r[f]] = Math.max(c[r[f]], c.legend[(f + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][f] * d[f % 2 ? \"x\" : \"y\"] + e(d.margin, 12) + b[f] + (c.titleOffset[f] || 0)));\n        });\n      }\n      proximatePositions() {\n        const a = this.chart,\n          b = [],\n          c = \"left\" === this.options.align;\n        this.allItems.forEach(function (d) {\n          var e;\n          var h = c;\n          let n;\n          d.yAxis && (d.xAxis.options.reversed && (h = !h), d.points && (e = k(h ? d.points : d.points.slice(0).reverse(), function (b) {\n            return J(b.plotY);\n          })), h = this.itemMarginTop + d.legendItem.label.getBBox().height + this.itemMarginBottom, n = d.yAxis.top - a.plotTop, d.visible ? (e = e ? e.plotY : d.yAxis.height, e += n - .3 * h) : e = n + d.yAxis.height, b.push({\n            target: e,\n            size: h,\n            item: d\n          }));\n        }, this);\n        let e;\n        for (const c of g(b, a.plotHeight)) e = c.item.legendItem || {}, J(c.pos) && (e.y = a.plotTop - a.spacing[0] + c.pos);\n      }\n      render() {\n        const a = this.chart,\n          b = a.renderer,\n          c = this.options,\n          e = this.padding;\n        var f = this.getAllItems();\n        let g,\n          k = this.group,\n          q = this.box;\n        this.itemX = e;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = h(c.width, a.spacingBox.width - e);\n        var l = a.spacingBox.width - 2 * e - c.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (l /= 2);\n        this.maxLegendWidth = this.widthOption || l;\n        k || (this.group = k = b.g(\"legend\").addClass(c.className || \"\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(k), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        w(f, (b, c) => (b.options && b.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0));\n        c.reversed && f.reverse();\n        this.allItems = f;\n        this.display = l = !!f.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        f.forEach(this.renderItem, this);\n        f.forEach(this.layoutItem, this);\n        f = (this.widthOption || this.offsetWidth) + e;\n        g = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        g = this.handleOverflow(g);\n        g += e;\n        q || (this.box = q = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: c.borderRadius\n        }).add(k));\n        a.styledMode || q.attr({\n          stroke: c.borderColor,\n          \"stroke-width\": c.borderWidth || 0,\n          fill: c.backgroundColor || \"none\"\n        }).shadow(c.shadow);\n        if (0 < f && 0 < g) q[q.placed ? \"animate\" : \"attr\"](q.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: f,\n          height: g\n        }, q.strokeWidth()));\n        k[l ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === k.getStyle(\"display\") && (f = g = 0);\n        this.legendWidth = f;\n        this.legendHeight = g;\n        l && this.align();\n        this.proximate || this.positionItems();\n        x(this, \"afterRender\");\n      }\n      align(a = this.chart.spacingBox) {\n        const b = this.chart,\n          c = this.options;\n        let d = a.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? d += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (d -= b.titleOffset[2]);\n        d !== a.y && (a = C(a, {\n          y: d\n        }));\n        b.hasRendered || (this.group.placed = !1);\n        this.group.align(C(c, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : c.verticalAlign\n        }), !0, a);\n      }\n      handleOverflow(a) {\n        const b = this,\n          c = this.chart,\n          d = c.renderer,\n          h = this.options;\n        var f = h.y;\n        const g = \"top\" === h.verticalAlign,\n          k = this.padding,\n          q = h.maxHeight,\n          l = h.navigation,\n          m = e(l.animation, !0),\n          u = l.arrowSize || 12,\n          p = this.pages,\n          w = this.allItems,\n          x = function (c) {\n            \"number\" === typeof c ? C.attr({\n              height: c\n            }) : C && (b.clipRect = C.destroy(), b.contentGroup.clip());\n            b.contentGroup.div && (b.contentGroup.div.style.clip = c ? \"rect(\" + k + \"px,9999px,\" + (k + c) + \"px,0)\" : \"auto\");\n          },\n          v = function (a) {\n            b[a] = d.circle(0, 0, 1.3 * u).translate(u / 2, u / 2).add(J);\n            c.styledMode || b[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n            return b[a];\n          };\n        let r, Q, t;\n        f = c.spacingBox.height + (g ? -f : f) - k;\n        let J = this.nav,\n          C = this.clipRect;\n        \"horizontal\" !== h.layout || \"middle\" === h.verticalAlign || h.floating || (f /= 2);\n        q && (f = Math.min(f, q));\n        p.length = 0;\n        a && 0 < f && a > f && !1 !== l.enabled ? (this.clipHeight = r = Math.max(f - 20 - this.titleHeight - k, 0), this.currentPage = e(this.currentPage, 1), this.fullHeight = a, w.forEach((b, c) => {\n          t = b.legendItem || {};\n          b = t.y || 0;\n          const a = Math.round(t.label.getBBox().height);\n          let d = p.length;\n          if (!d || b - p[d - 1] > r && (Q || b) !== p[d - 1]) p.push(Q || b), d++;\n          t.pageIx = d - 1;\n          Q && ((w[c - 1].legendItem || {}).pageIx = d - 1);\n          c === w.length - 1 && b + a - p[d - 1] > r && b > p[d - 1] && (p.push(b), t.pageIx = d);\n          b !== Q && (Q = b);\n        }), C || (C = b.clipRect = d.clipRect(0, k - 2, 9999, 0), b.contentGroup.clip(C)), x(r), J || (this.nav = J = d.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = d.symbol(\"triangle\", 0, 0, u, u).add(J), v(\"upTracker\").on(\"click\", function () {\n          b.scroll(-1, m);\n        }), this.pager = d.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !c.styledMode && l.style && this.pager.css(l.style), this.pager.add(J), this.down = d.symbol(\"triangle-down\", 0, 0, u, u).add(J), v(\"downTracker\").on(\"click\", function () {\n          b.scroll(1, m);\n        })), b.scroll(0), a = f) : J && (x(), this.nav = J.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      }\n      scroll(a, b) {\n        const c = this.chart,\n          d = this.pages,\n          h = d.length,\n          f = this.clipHeight,\n          g = this.options.navigation,\n          k = this.pager,\n          l = this.padding;\n        let m = this.currentPage + a;\n        m > h && (m = h);\n        0 < m && (\"undefined\" !== typeof b && B(b, c), this.nav.attr({\n          translateX: l,\n          translateY: f + this.padding + 7 + this.titleHeight,\n          visibility: \"inherit\"\n        }), [this.up, this.upTracker].forEach(function (b) {\n          b.attr({\n            \"class\": 1 === m ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), k.attr({\n          text: m + \"/\" + h\n        }), [this.down, this.downTracker].forEach(function (b) {\n          b.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": m === h ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), c.styledMode || (this.up.attr({\n          fill: 1 === m ? g.inactiveColor : g.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === m ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: m === h ? g.inactiveColor : g.activeColor\n        }), this.downTracker.css({\n          cursor: m === h ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -d[m - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = m, this.positionCheckboxes(), a = y(e(b, c.renderer.globalAnimation, !0)), q(() => {\n          x(this, \"afterScroll\", {\n            currentPage: m\n          });\n        }, a.duration));\n      }\n      setItemEvents(a, b, c) {\n        const d = this,\n          e = a.legendItem || {},\n          h = d.chart.renderer.boxWrapper,\n          f = a instanceof H,\n          g = \"highcharts-legend-\" + (f ? \"point\" : \"series\") + \"-active\",\n          k = d.chart.styledMode;\n        c = c ? [b, e.symbol] : [e.group];\n        const q = b => {\n          d.allItems.forEach(c => {\n            a !== c && [c].concat(c.linkedSeries || []).forEach(c => {\n              c.setState(b, !f);\n            });\n          });\n        };\n        for (const e of c) if (e) e.on(\"mouseover\", function () {\n          a.visible && q(\"inactive\");\n          a.setState(\"hover\");\n          a.visible && h.addClass(g);\n          k || b.css(d.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          d.chart.styledMode || b.css(C(a.visible ? d.itemStyle : d.itemHiddenStyle));\n          q(\"\");\n          h.removeClass(g);\n          a.setState();\n        }).on(\"click\", function (b) {\n          const c = function () {\n            a.setVisible && a.setVisible();\n            q(a.visible ? \"inactive\" : \"\");\n          };\n          h.removeClass(g);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : x(a, \"legendItemClick\", b, c);\n        });\n      }\n      createCheckboxForItem(a) {\n        a.checkbox = v(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        p(a.checkbox, \"click\", function (b) {\n          x(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    }\n    (function (a) {\n      const b = [];\n      a.compose = function (c) {\n        D.pushUnique(b, c) && p(c, \"beforeMargins\", function () {\n          this.legend = new a(this, this.options.legend);\n        });\n      };\n    })(u || (u = {}));\n    \"\";\n    return u;\n  });\n  L(a, \"Core/Series/SeriesRegistry.js\", [a[\"Core/Globals.js\"], a[\"Core/Defaults.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H) {\n    const {\n        defaultOptions: y\n      } = z,\n      {\n        extendClass: D,\n        merge: E\n      } = H;\n    var B;\n    (function (t) {\n      function r(a, p) {\n        const g = y.plotOptions || {},\n          l = p.defaultOptions,\n          m = p.prototype;\n        m.type = a;\n        m.pointClass || (m.pointClass = F);\n        l && (g[a] = l);\n        t.seriesTypes[a] = p;\n      }\n      t.seriesTypes = a.seriesTypes;\n      t.registerSeriesType = r;\n      t.seriesType = function (a, p, v, l, m) {\n        const f = y.plotOptions || {};\n        p = p || \"\";\n        f[a] = E(f[p], v);\n        r(a, D(t.seriesTypes[p] || function () {}, l));\n        t.seriesTypes[a].prototype.type = a;\n        m && (t.seriesTypes[a].prototype.pointClass = D(F, m));\n        return t.seriesTypes[a];\n      };\n    })(B || (B = {}));\n    return B;\n  });\n  L(a, \"Core/Chart/Chart.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"], a[\"Core/Renderer/HTML/AST.js\"]], function (a, z, F, H, A, D, E, B, t, r, g, p) {\n    const {\n        animate: v,\n        animObject: l,\n        setAnimation: m\n      } = a,\n      {\n        defaultOptions: f,\n        defaultTime: k\n      } = F,\n      {\n        numberFormat: x\n      } = H,\n      {\n        registerEventOptions: J\n      } = A,\n      {\n        charts: C,\n        doc: e,\n        marginNames: h,\n        svg: w,\n        win: q\n      } = D,\n      {\n        seriesTypes: u\n      } = B,\n      {\n        addEvent: d,\n        attr: b,\n        cleanRecursively: c,\n        createElement: n,\n        css: G,\n        defined: I,\n        discardElement: K,\n        erase: y,\n        error: R,\n        extend: P,\n        find: N,\n        fireEvent: O,\n        getStyle: ba,\n        isArray: da,\n        isNumber: X,\n        isObject: M,\n        isString: Y,\n        merge: Q,\n        objectEach: ca,\n        pick: S,\n        pInt: aa,\n        relativeLength: U,\n        removeEvent: Z,\n        splat: ea,\n        syncTimeout: fa,\n        uniqueKey: L\n      } = g;\n    class V {\n      static chart(b, c, a) {\n        return new V(b, c, a);\n      }\n      constructor(b, c, a) {\n        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.sharedClips = {};\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;\n        this.getArgs(b, c, a);\n      }\n      getArgs(b, c, a) {\n        Y(b) || b.nodeName ? (this.renderTo = b, this.init(c, a)) : this.init(b, c);\n      }\n      init(b, c) {\n        const a = b.plotOptions || {};\n        O(this, \"init\", {\n          args: arguments\n        }, function () {\n          const d = Q(f, b),\n            e = d.chart;\n          ca(d.plotOptions, function (b, c) {\n            M(b) && (b.tooltip = a[c] && Q(a[c].tooltip) || void 0);\n          });\n          d.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;\n          this.userOptions = b;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = c;\n          this.isResizing = 0;\n          const h = e.zooming = e.zooming || {};\n          b.chart && !b.chart.zooming && (h.resetButton = e.resetZoomButton);\n          h.key = S(h.key, e.zoomKey);\n          h.pinchType = S(h.pinchType, e.pinchType);\n          h.singleTouch = S(h.singleTouch, e.zoomBySingleTouch);\n          h.type = S(h.type, e.zoomType);\n          this.options = d;\n          this.axes = [];\n          this.series = [];\n          this.time = b.time && Object.keys(b.time).length ? new r(b.time) : D.time;\n          this.numberFormatter = e.numberFormatter || x;\n          this.styledMode = e.styledMode;\n          this.hasCartesianSeries = e.showAxes;\n          this.index = C.length;\n          C.push(this);\n          D.chartCount++;\n          J(this, e);\n          this.xAxis = [];\n          this.yAxis = [];\n          this.pointCount = this.colorCounter = this.symbolCounter = 0;\n          O(this, \"afterInit\");\n          this.firstRender();\n        });\n      }\n      initSeries(b) {\n        var c = this.options.chart;\n        c = b.type || c.type;\n        const a = u[c];\n        a || R(17, !0, this, {\n          missingModuleFor: c\n        });\n        c = new a();\n        \"function\" === typeof c.init && c.init(this, b);\n        return c;\n      }\n      setSeriesData() {\n        this.getSeriesOrderByLinks().forEach(function (b) {\n          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);\n        });\n      }\n      getSeriesOrderByLinks() {\n        return this.series.concat().sort(function (b, c) {\n          return b.linkedSeries.length || c.linkedSeries.length ? c.linkedSeries.length - b.linkedSeries.length : 0;\n        });\n      }\n      orderSeries(b) {\n        const c = this.series;\n        for (let a = b || 0, d = c.length; a < d; ++a) c[a] && (c[a].index = a, c[a].name = c[a].getName());\n      }\n      isInsidePlot(b, c, a = {}) {\n        const {\n          inverted: d,\n          plotBox: e,\n          plotLeft: h,\n          plotTop: f,\n          scrollablePlotBox: n\n        } = this;\n        var g = 0;\n        let k = 0;\n        a.visiblePlotOnly && this.scrollingContainer && ({\n          scrollLeft: g,\n          scrollTop: k\n        } = this.scrollingContainer);\n        const q = a.series,\n          l = a.visiblePlotOnly && n || e;\n        var m = a.inverted ? c : b;\n        c = a.inverted ? b : c;\n        b = {\n          x: m,\n          y: c,\n          isInsidePlot: !0,\n          options: a\n        };\n        if (!a.ignoreX) {\n          const c = q && (d && !this.polar ? q.yAxis : q.xAxis) || {\n            pos: h,\n            len: Infinity\n          };\n          m = a.paneCoordinates ? c.pos + m : h + m;\n          m >= Math.max(g + h, c.pos) && m <= Math.min(g + h + l.width, c.pos + c.len) || (b.isInsidePlot = !1);\n        }\n        !a.ignoreY && b.isInsidePlot && (g = !d && a.axis && !a.axis.isXAxis && a.axis || q && (d ? q.xAxis : q.yAxis) || {\n          pos: f,\n          len: Infinity\n        }, a = a.paneCoordinates ? g.pos + c : f + c, a >= Math.max(k + f, g.pos) && a <= Math.min(k + f + l.height, g.pos + g.len) || (b.isInsidePlot = !1));\n        O(this, \"afterIsInsidePlot\", b);\n        return b.isInsidePlot;\n      }\n      redraw(b) {\n        O(this, \"beforeRedraw\");\n        const c = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n          a = this.series,\n          d = this.pointer,\n          e = this.legend,\n          h = this.userOptions.legend,\n          f = this.renderer,\n          n = f.isHidden(),\n          g = [];\n        let k,\n          q,\n          l = this.isDirtyBox,\n          u = this.isDirtyLegend,\n          p;\n        f.rootFontSize = f.boxWrapper.getStyle(\"font-size\");\n        this.setResponsive && this.setResponsive(!1);\n        m(this.hasRendered ? b : !1, this);\n        n && this.temporaryDisplay();\n        this.layOutTitles();\n        for (b = a.length; b--;) if (p = a[b], p.options.stacking || p.options.centerInCategory) if (q = !0, p.isDirty) {\n          k = !0;\n          break;\n        }\n        if (k) for (b = a.length; b--;) p = a[b], p.options.stacking && (p.isDirty = !0);\n        a.forEach(function (b) {\n          b.isDirty && (\"point\" === b.options.legendType ? (\"function\" === typeof b.updateTotals && b.updateTotals(), u = !0) : h && (h.labelFormatter || h.labelFormat) && (u = !0));\n          b.isDirtyData && O(b, \"updatedData\");\n        });\n        u && e && e.options.enabled && (e.render(), this.isDirtyLegend = !1);\n        q && this.getStacks();\n        c.forEach(function (b) {\n          b.updateNames();\n          b.setScale();\n        });\n        this.getMargins();\n        c.forEach(function (b) {\n          b.isDirty && (l = !0);\n        });\n        c.forEach(function (b) {\n          const c = b.min + \",\" + b.max;\n          b.extKey !== c && (b.extKey = c, g.push(function () {\n            O(b, \"afterSetExtremes\", P(b.eventArgs, b.getExtremes()));\n            delete b.eventArgs;\n          }));\n          (l || q) && b.redraw();\n        });\n        l && this.drawChartBox();\n        O(this, \"predraw\");\n        a.forEach(function (b) {\n          (l || b.isDirty) && b.visible && b.redraw();\n          b.isDirtyData = !1;\n        });\n        d && d.reset(!0);\n        f.draw();\n        O(this, \"redraw\");\n        O(this, \"render\");\n        n && this.temporaryDisplay(!0);\n        g.forEach(function (b) {\n          b.call();\n        });\n      }\n      get(b) {\n        function c(c) {\n          return c.id === b || c.options && c.options.id === b;\n        }\n        const a = this.series;\n        let d = N(this.axes, c) || N(this.series, c);\n        for (let b = 0; !d && b < a.length; b++) d = N(a[b].points || [], c);\n        return d;\n      }\n      getAxes() {\n        const b = this;\n        var c = this.options;\n        const a = c.xAxis = ea(c.xAxis || {});\n        c = c.yAxis = ea(c.yAxis || {});\n        O(this, \"getAxes\");\n        a.forEach(function (b, c) {\n          b.index = c;\n          b.isX = !0;\n        });\n        c.forEach(function (b, c) {\n          b.index = c;\n        });\n        a.concat(c).forEach(function (c) {\n          new z(b, c);\n        });\n        O(this, \"afterGetAxes\");\n      }\n      getSelectedPoints() {\n        return this.series.reduce((b, c) => {\n          c.getPointsCollection().forEach(c => {\n            S(c.selectedStaging, c.selected) && b.push(c);\n          });\n          return b;\n        }, []);\n      }\n      getSelectedSeries() {\n        return this.series.filter(function (b) {\n          return b.selected;\n        });\n      }\n      setTitle(b, c, a) {\n        this.applyDescription(\"title\", b);\n        this.applyDescription(\"subtitle\", c);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(a);\n      }\n      applyDescription(b, c) {\n        const a = this;\n        var d = \"title\" === b ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"1em\" : \"1.2em\",\n          fontWeight: \"bold\"\n        } : {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        };\n        d = this.options[b] = Q(!this.styledMode && {\n          style: d\n        }, this.options[b], c);\n        let e = this[b];\n        e && c && (this[b] = e = e.destroy());\n        d && !e && (e = this.renderer.text(d.text, 0, 0, d.useHTML).attr({\n          align: d.align,\n          \"class\": \"highcharts-\" + b,\n          zIndex: d.zIndex || 4\n        }).add(), e.update = function (c) {\n          a[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[b]](c);\n        }, this.styledMode || e.css(d.style), this[b] = e);\n      }\n      layOutTitles(b) {\n        const c = [0, 0, 0],\n          a = this.renderer,\n          d = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (b) {\n          const e = this[b],\n            h = this.options[b],\n            f = h.verticalAlign || \"top\";\n          b = \"title\" === b ? \"top\" === f ? -3 : 0 : \"top\" === f ? c[0] + 2 : 0;\n          if (e) {\n            e.css({\n              width: (h.width || d.width + (h.widthAdjust || 0)) + \"px\"\n            });\n            const n = a.fontMetrics(e).b,\n              g = Math.round(e.getBBox(h.useHTML).height);\n            e.align(P({\n              y: \"bottom\" === f ? n : b + n,\n              height: g\n            }, h), !1, \"spacingBox\");\n            h.floating || (\"top\" === f ? c[0] = Math.ceil(c[0] + g) : \"bottom\" === f && (c[2] = Math.ceil(c[2] + g)));\n          }\n        }, this);\n        c[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (c[0] += this.options.title.margin);\n        c[2] && \"bottom\" === this.options.caption.verticalAlign && (c[2] += this.options.caption.margin);\n        const e = !this.titleOffset || this.titleOffset.join(\",\") !== c.join(\",\");\n        this.titleOffset = c;\n        O(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && e && (this.isDirtyBox = this.isDirtyLegend = e, this.hasRendered && S(b, !0) && this.isDirtyBox && this.redraw());\n      }\n      getContainerBox() {\n        return {\n          width: ba(this.renderTo, \"width\", !0) || 0,\n          height: ba(this.renderTo, \"height\", !0) || 0\n        };\n      }\n      getChartSize() {\n        var b = this.options.chart;\n        const c = b.width;\n        b = b.height;\n        const a = this.getContainerBox();\n        this.chartWidth = Math.max(0, c || a.width || 600);\n        this.chartHeight = Math.max(0, U(b, this.chartWidth) || (1 < a.height ? a.height : 400));\n        this.containerBox = a;\n      }\n      temporaryDisplay(b) {\n        let c = this.renderTo;\n        if (b) for (; c && c.style;) c.hcOrigStyle && (G(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (e.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;else for (; c && c.style;) {\n          e.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, e.body.appendChild(c));\n          if (\"none\" === ba(c, \"display\", !1) || c.hcOricDetached) c.hcOrigStyle = {\n            display: c.style.display,\n            height: c.style.height,\n            overflow: c.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, c !== this.renderTo && (b.height = 0), G(c, b), c.offsetWidth || c.style.setProperty(\"display\", \"block\", \"important\");\n          c = c.parentNode;\n          if (c === e.body) break;\n        }\n      }\n      setClassName(b) {\n        this.container.className = \"highcharts-container \" + (b || \"\");\n      }\n      getContainer() {\n        const c = this.options,\n          a = c.chart;\n        var d = L();\n        let h,\n          f = this.renderTo;\n        f || (this.renderTo = f = a.renderTo);\n        Y(f) && (this.renderTo = f = e.getElementById(f));\n        f || R(13, !0, this);\n        var g = aa(b(f, \"data-highcharts-chart\"));\n        X(g) && C[g] && C[g].hasRendered && C[g].destroy();\n        b(f, \"data-highcharts-chart\", this.index);\n        f.innerHTML = p.emptyHTML;\n        a.skipClone || f.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        g = this.chartWidth;\n        const k = this.chartHeight;\n        G(f, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (h = P({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: g + \"px\",\n          height: k + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\",\n          \"touch-action\": \"manipulation\",\n          outline: \"none\"\n        }, a.style || {}));\n        this.container = d = n(\"div\", {\n          id: d\n        }, h, f);\n        this._cursor = d.style.cursor;\n        this.renderer = new (a.renderer || !w ? E.getRendererType(a.renderer) : t)(d, g, k, void 0, a.forExport, c.exporting && c.exporting.allowHTML, this.styledMode);\n        this.containerBox = this.getContainerBox();\n        m(void 0, this);\n        this.setClassName(a.className);\n        if (this.styledMode) for (const b in c.defs) this.renderer.definition(c.defs[b]);else this.renderer.setStyle(a.style);\n        this.renderer.chartIndex = this.index;\n        O(this, \"afterGetContainer\");\n      }\n      getMargins(b) {\n        const {\n          spacing: c,\n          margin: a,\n          titleOffset: d\n        } = this;\n        this.resetMargins();\n        d[0] && !I(a[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + c[0]));\n        d[2] && !I(a[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + c[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(a, c);\n        O(this, \"getMargins\");\n        b || this.getAxisMargins();\n      }\n      getAxisMargins() {\n        const b = this,\n          c = b.axisOffset = [0, 0, 0, 0],\n          a = b.colorAxis,\n          d = b.margin,\n          e = function (b) {\n            b.forEach(function (b) {\n              b.visible && b.getOffset();\n            });\n          };\n        b.hasCartesianSeries ? e(b.axes) : a && a.length && e(a);\n        h.forEach(function (a, e) {\n          I(d[e]) || (b[a] += c[e]);\n        });\n        b.setChartSize();\n      }\n      reflow(b) {\n        const c = this;\n        var a = c.options.chart;\n        a = I(a.width) && I(a.height);\n        const d = c.containerBox,\n          e = c.getContainerBox();\n        delete c.pointer.chartPosition;\n        if (!a && !c.isPrinting && d && e.width) {\n          if (e.width !== d.width || e.height !== d.height) g.clearTimeout(c.reflowTimeout), c.reflowTimeout = fa(function () {\n            c.container && c.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          c.containerBox = e;\n        }\n      }\n      setReflow() {\n        const b = this;\n        var c = c => {\n          var a;\n          (null === (a = b.options) || void 0 === a ? 0 : a.chart.reflow) && b.hasLoaded && b.reflow(c);\n        };\n        \"function\" === typeof ResizeObserver ? new ResizeObserver(c).observe(b.renderTo) : (c = d(q, \"resize\", c), d(this, \"destroy\", c));\n      }\n      setSize(b, c, a) {\n        const d = this,\n          e = d.renderer;\n        d.isResizing += 1;\n        m(a, d);\n        a = e.globalAnimation;\n        d.oldChartHeight = d.chartHeight;\n        d.oldChartWidth = d.chartWidth;\n        \"undefined\" !== typeof b && (d.options.chart.width = b);\n        \"undefined\" !== typeof c && (d.options.chart.height = c);\n        d.getChartSize();\n        d.styledMode || (a ? v : G)(d.container, {\n          width: d.chartWidth + \"px\",\n          height: d.chartHeight + \"px\"\n        }, a);\n        d.setChartSize(!0);\n        e.setSize(d.chartWidth, d.chartHeight, a);\n        d.axes.forEach(function (b) {\n          b.isDirty = !0;\n          b.setScale();\n        });\n        d.isDirtyLegend = !0;\n        d.isDirtyBox = !0;\n        d.layOutTitles();\n        d.getMargins();\n        d.redraw(a);\n        d.oldChartHeight = null;\n        O(d, \"resize\");\n        fa(function () {\n          d && O(d, \"endResize\", null, function () {\n            --d.isResizing;\n          });\n        }, l(a).duration);\n      }\n      setChartSize(b) {\n        var c = this.inverted;\n        const a = this.renderer;\n        var d = this.chartWidth,\n          e = this.chartHeight;\n        const h = this.options.chart,\n          f = this.spacing,\n          n = this.clipOffset;\n        let g, k, q, l;\n        this.plotLeft = g = Math.round(this.plotLeft);\n        this.plotTop = k = Math.round(this.plotTop);\n        this.plotWidth = q = Math.max(0, Math.round(d - g - this.marginRight));\n        this.plotHeight = l = Math.max(0, Math.round(e - k - this.marginBottom));\n        this.plotSizeX = c ? l : q;\n        this.plotSizeY = c ? q : l;\n        this.plotBorderWidth = h.plotBorderWidth || 0;\n        this.spacingBox = a.spacingBox = {\n          x: f[3],\n          y: f[0],\n          width: d - f[3] - f[1],\n          height: e - f[0] - f[2]\n        };\n        this.plotBox = a.plotBox = {\n          x: g,\n          y: k,\n          width: q,\n          height: l\n        };\n        c = 2 * Math.floor(this.plotBorderWidth / 2);\n        d = Math.ceil(Math.max(c, n[3]) / 2);\n        e = Math.ceil(Math.max(c, n[0]) / 2);\n        this.clipBox = {\n          x: d,\n          y: e,\n          width: Math.floor(this.plotSizeX - Math.max(c, n[1]) / 2 - d),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(c, n[2]) / 2 - e))\n        };\n        b || (this.axes.forEach(function (b) {\n          b.setAxisSize();\n          b.setAxisTranslation();\n        }), a.alignElements());\n        O(this, \"afterSetChartSize\", {\n          skipAxes: b\n        });\n      }\n      resetMargins() {\n        O(this, \"resetMargins\");\n        const b = this,\n          c = b.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (a) {\n          const d = c[a],\n            e = M(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, h) {\n            b[a][h] = S(c[a + d], e[h]);\n          });\n        });\n        h.forEach(function (c, a) {\n          b[c] = S(b.margin[a], b.spacing[a]);\n        });\n        b.axisOffset = [0, 0, 0, 0];\n        b.clipOffset = [0, 0, 0, 0];\n      }\n      drawChartBox() {\n        const b = this.options.chart,\n          c = this.renderer,\n          a = this.chartWidth,\n          d = this.chartHeight,\n          e = this.styledMode,\n          h = this.plotBGImage;\n        var f = b.backgroundColor;\n        const n = b.plotBackgroundColor,\n          g = b.plotBackgroundImage,\n          k = this.plotLeft,\n          q = this.plotTop,\n          l = this.plotWidth,\n          m = this.plotHeight,\n          u = this.plotBox,\n          p = this.clipRect,\n          w = this.clipBox;\n        let x = this.chartBackground,\n          G = this.plotBackground,\n          v = this.plotBorder,\n          M,\n          r,\n          I = \"animate\";\n        x || (this.chartBackground = x = c.rect().addClass(\"highcharts-background\").add(), I = \"attr\");\n        if (e) M = r = x.strokeWidth();else {\n          M = b.borderWidth || 0;\n          r = M + (b.shadow ? 8 : 0);\n          f = {\n            fill: f || \"none\"\n          };\n          if (M || x[\"stroke-width\"]) f.stroke = b.borderColor, f[\"stroke-width\"] = M;\n          x.attr(f).shadow(b.shadow);\n        }\n        x[I]({\n          x: r / 2,\n          y: r / 2,\n          width: a - r - M % 2,\n          height: d - r - M % 2,\n          r: b.borderRadius\n        });\n        I = \"animate\";\n        G || (I = \"attr\", this.plotBackground = G = c.rect().addClass(\"highcharts-plot-background\").add());\n        G[I](u);\n        e || (G.attr({\n          fill: n || \"none\"\n        }).shadow(b.plotShadow), g && (h ? (g !== h.attr(\"href\") && h.attr(\"href\", g), h.animate(u)) : this.plotBGImage = c.image(g, k, q, l, m).add()));\n        p ? p.animate({\n          width: w.width,\n          height: w.height\n        }) : this.clipRect = c.clipRect(w);\n        I = \"animate\";\n        v || (I = \"attr\", this.plotBorder = v = c.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        e || v.attr({\n          stroke: b.plotBorderColor,\n          \"stroke-width\": b.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        v[I](v.crisp({\n          x: k,\n          y: q,\n          width: l,\n          height: m\n        }, -v.strokeWidth()));\n        this.isDirtyBox = !1;\n        O(this, \"afterDrawChartBox\");\n      }\n      propFromSeries() {\n        const b = this,\n          c = b.options.chart,\n          a = b.options.series;\n        let d, e, h;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (f) {\n          e = u[c.type];\n          h = c[f] || e && e.prototype[f];\n          for (d = a && a.length; !h && d--;) (e = u[a[d].type]) && e.prototype[f] && (h = !0);\n          b[f] = h;\n        });\n      }\n      linkSeries(b) {\n        const c = this,\n          a = c.series;\n        a.forEach(function (b) {\n          b.linkedSeries.length = 0;\n        });\n        a.forEach(function (b) {\n          let a = b.options.linkedTo;\n          Y(a) && (a = \":previous\" === a ? c.series[b.index - 1] : c.get(a)) && a.linkedParent !== b && (a.linkedSeries.push(b), b.linkedParent = a, a.enabledDataSorting && b.setDataSortingOptions(), b.visible = S(b.options.visible, a.options.visible, b.visible));\n        });\n        O(this, \"afterLinkSeries\", {\n          isUpdating: b\n        });\n      }\n      renderSeries() {\n        this.series.forEach(function (b) {\n          b.translate();\n          b.render();\n        });\n      }\n      render() {\n        const b = this.axes,\n          c = this.colorAxis,\n          a = this.renderer,\n          d = function (b) {\n            b.forEach(function (b) {\n              b.visible && b.render();\n            });\n          };\n        let e = 0;\n        this.setTitle();\n        O(this, \"beforeMargins\");\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        const h = this.plotWidth;\n        b.some(function (b) {\n          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return e = 21, !0;\n        });\n        const f = this.plotHeight = Math.max(this.plotHeight - e, 0);\n        b.forEach(function (b) {\n          b.setScale();\n        });\n        this.getAxisMargins();\n        const n = 1.1 < h / this.plotWidth,\n          g = 1.05 < f / this.plotHeight;\n        if (n || g) b.forEach(function (b) {\n          (b.horiz && n || !b.horiz && g) && b.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? d(b) : c && c.length && d(c);\n        this.seriesGroup || (this.seriesGroup = a.g(\"series-group\").attr({\n          zIndex: 3\n        }).shadow(this.options.chart.seriesGroupShadow).add());\n        this.renderSeries();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      }\n      addCredits(b) {\n        const c = this,\n          a = Q(!0, this.options.credits, b);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (q.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }), c.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (b) {\n          c.credits = c.credits.destroy();\n          c.addCredits(b);\n        });\n      }\n      destroy() {\n        const b = this,\n          c = b.axes,\n          a = b.series,\n          d = b.container,\n          e = d && d.parentNode;\n        let h;\n        O(b, \"destroy\");\n        b.renderer.forExport ? y(C, b) : C[b.index] = void 0;\n        D.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        Z(b);\n        for (h = c.length; h--;) c[h] = c[h].destroy();\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n        for (h = a.length; h--;) a[h] = a[h].destroy();\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (c) {\n          const a = b[c];\n          a && a.destroy && (b[c] = a.destroy());\n        });\n        d && (d.innerHTML = p.emptyHTML, Z(d), e && K(d));\n        ca(b, function (c, a) {\n          delete b[a];\n        });\n      }\n      firstRender() {\n        const b = this,\n          c = b.options;\n        b.getContainer();\n        b.resetMargins();\n        b.setChartSize();\n        b.propFromSeries();\n        b.getAxes();\n        (da(c.series) ? c.series : []).forEach(function (c) {\n          b.initSeries(c);\n        });\n        b.linkSeries();\n        b.setSeriesData();\n        O(b, \"beforeRender\");\n        b.render();\n        b.pointer.getChartPosition();\n        if (!b.renderer.imgCount && !b.hasLoaded) b.onload();\n        b.temporaryDisplay(!0);\n      }\n      onload() {\n        this.callbacks.concat([this.callback]).forEach(function (b) {\n          b && \"undefined\" !== typeof this.index && b.apply(this, [this]);\n        }, this);\n        O(this, \"load\");\n        O(this, \"render\");\n        I(this.index) && this.setReflow();\n        this.warnIfA11yModuleNotLoaded();\n        this.hasLoaded = !0;\n      }\n      warnIfA11yModuleNotLoaded() {\n        const {\n          options: b,\n          title: c\n        } = this;\n        b && !this.accessibility && (this.renderer.boxWrapper.attr({\n          role: \"img\",\n          \"aria-label\": (c && c.element.textContent || \"\").replace(/</g, \"&lt;\")\n        }), b.accessibility && !1 === b.accessibility.enabled || R('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n      }\n      addSeries(b, c, a) {\n        const d = this;\n        let e;\n        b && (c = S(c, !0), O(d, \"addSeries\", {\n          options: b\n        }, function () {\n          e = d.initSeries(b);\n          d.isDirtyLegend = !0;\n          d.linkSeries();\n          e.enabledDataSorting && e.setData(b.data, !1);\n          O(d, \"afterAddSeries\", {\n            series: e\n          });\n          c && d.redraw(a);\n        }));\n        return e;\n      }\n      addAxis(b, c, a, d) {\n        return this.createAxis(c ? \"xAxis\" : \"yAxis\", {\n          axis: b,\n          redraw: a,\n          animation: d\n        });\n      }\n      addColorAxis(b, c, a) {\n        return this.createAxis(\"colorAxis\", {\n          axis: b,\n          redraw: c,\n          animation: a\n        });\n      }\n      createAxis(b, c) {\n        b = new z(this, Q(c.axis, {\n          index: this[b].length,\n          isX: \"xAxis\" === b\n        }));\n        S(c.redraw, !0) && this.redraw(c.animation);\n        return b;\n      }\n      showLoading(b) {\n        const c = this,\n          a = c.options,\n          e = a.loading,\n          h = function () {\n            f && G(f, {\n              left: c.plotLeft + \"px\",\n              top: c.plotTop + \"px\",\n              width: c.plotWidth + \"px\",\n              height: c.plotHeight + \"px\"\n            });\n          };\n        let f = c.loadingDiv,\n          g = c.loadingSpan;\n        f || (c.loadingDiv = f = n(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, c.container));\n        g || (c.loadingSpan = g = n(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, f), d(c, \"redraw\", h));\n        f.className = \"highcharts-loading\";\n        p.setElementHTML(g, S(b, a.lang.loading, \"\"));\n        c.styledMode || (G(f, P(e.style, {\n          zIndex: 10\n        })), G(g, e.labelStyle), c.loadingShown || (G(f, {\n          opacity: 0,\n          display: \"\"\n        }), v(f, {\n          opacity: e.style.opacity || .5\n        }, {\n          duration: e.showDuration || 0\n        })));\n        c.loadingShown = !0;\n        h();\n      }\n      hideLoading() {\n        const b = this.options,\n          c = this.loadingDiv;\n        c && (c.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || v(c, {\n          opacity: 0\n        }, {\n          duration: b.loading.hideDuration || 100,\n          complete: function () {\n            G(c, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      }\n      update(b, a, d, e) {\n        const h = this,\n          f = {\n            credits: \"addCredits\",\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          },\n          n = b.isResponsiveOptions,\n          g = [];\n        let q, l;\n        O(h, \"update\", {\n          options: b\n        });\n        n || h.setResponsive(!1, !0);\n        b = c(b, h.options);\n        h.userOptions = Q(h.userOptions, b);\n        var m = b.chart;\n        if (m) {\n          Q(!0, h.options.chart, m);\n          \"className\" in m && h.setClassName(m.className);\n          if (\"inverted\" in m || \"polar\" in m || \"type\" in m) {\n            h.propFromSeries();\n            var u = !0;\n          }\n          \"alignTicks\" in m && (u = !0);\n          \"events\" in m && J(this, m);\n          ca(m, function (b, c) {\n            -1 !== h.propsRequireUpdateSeries.indexOf(\"chart.\" + c) && (q = !0);\n            -1 !== h.propsRequireDirtyBox.indexOf(c) && (h.isDirtyBox = !0);\n            -1 !== h.propsRequireReflow.indexOf(c) && (n ? h.isDirtyBox = !0 : l = !0);\n          });\n          !h.styledMode && m.style && h.renderer.setStyle(h.options.chart.style || {});\n        }\n        !h.styledMode && b.colors && (this.options.colors = b.colors);\n        b.time && (this.time === k && (this.time = new r(b.time)), Q(!0, h.options.time, b.time));\n        ca(b, function (c, a) {\n          if (h[a] && \"function\" === typeof h[a].update) h[a].update(c, !1);else if (\"function\" === typeof h[f[a]]) h[f[a]](c);else \"colors\" !== a && -1 === h.collectionsWithUpdate.indexOf(a) && Q(!0, h.options[a], b[a]);\n          \"chart\" !== a && -1 !== h.propsRequireUpdateSeries.indexOf(a) && (q = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (c) {\n          let a;\n          b[c] && (a = [], h[c].forEach(function (b, c) {\n            b.options.isInternal || a.push(S(b.options.index, c));\n          }), ea(b[c]).forEach(function (b, e) {\n            const f = I(b.id);\n            let n;\n            f && (n = h.get(b.id));\n            !n && h[c] && (n = h[c][a ? a[e] : e]) && f && I(n.options.id) && (n = void 0);\n            n && n.coll === c && (n.update(b, !1), d && (n.touched = !0));\n            !n && d && h.collectionsWithInit[c] && (h.collectionsWithInit[c][0].apply(h, [b].concat(h.collectionsWithInit[c][1] || []).concat([!1])).touched = !0);\n          }), d && h[c].forEach(function (b) {\n            b.touched || b.options.isInternal ? delete b.touched : g.push(b);\n          }));\n        });\n        g.forEach(function (b) {\n          b.chart && b.remove && b.remove(!1);\n        });\n        u && h.axes.forEach(function (b) {\n          b.update({}, !1);\n        });\n        q && h.getSeriesOrderByLinks().forEach(function (b) {\n          b.chart && b.update({}, !1);\n        }, this);\n        u = m && m.width;\n        m = m && (Y(m.height) ? U(m.height, u || h.chartWidth) : m.height);\n        l || X(u) && u !== h.chartWidth || X(m) && m !== h.chartHeight ? h.setSize(u, m, e) : S(a, !0) && h.redraw(e);\n        O(h, \"afterUpdate\", {\n          options: b,\n          redraw: a,\n          animation: e\n        });\n      }\n      setSubtitle(b, c) {\n        this.applyDescription(\"subtitle\", b);\n        this.layOutTitles(c);\n      }\n      setCaption(b, c) {\n        this.applyDescription(\"caption\", b);\n        this.layOutTitles(c);\n      }\n      showResetZoom() {\n        function b() {\n          c.zoomOut();\n        }\n        const c = this,\n          a = f.lang,\n          d = c.options.chart.zooming.resetButton,\n          e = d.theme,\n          h = \"chart\" === d.relativeTo || \"spacingBox\" === d.relativeTo ? null : \"scrollablePlotBox\";\n        O(this, \"beforeShowResetZoom\", null, function () {\n          c.resetZoomButton = c.renderer.button(a.resetZoom, null, null, b, e).attr({\n            align: d.position.align,\n            title: a.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, h);\n        });\n        O(this, \"afterShowResetZoom\");\n      }\n      zoomOut() {\n        O(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      }\n      zoom(b) {\n        const c = this,\n          a = c.pointer;\n        let d = !1,\n          e;\n        !b || b.resetSelection ? (c.axes.forEach(function (b) {\n          e = b.zoom();\n        }), a.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {\n          const h = b.axis;\n          if (a[h.isXAxis ? \"zoomX\" : \"zoomY\"] && I(a.mouseDownX) && I(a.mouseDownY) && c.isInsidePlot(a.mouseDownX - c.plotLeft, a.mouseDownY - c.plotTop, {\n            axis: h\n          }) || !I(c.inverted ? a.mouseDownX : a.mouseDownY)) e = h.zoom(b.min, b.max), h.displayBtn && (d = !0);\n        });\n        const h = c.resetZoomButton;\n        d && !h ? c.showResetZoom() : !d && M(h) && (c.resetZoomButton = h.destroy());\n        e && c.redraw(S(c.options.chart.animation, b && b.animation, 100 > c.pointCount));\n      }\n      pan(b, c) {\n        const a = this,\n          d = a.hoverPoints;\n        c = \"object\" === typeof c ? c : {\n          enabled: c,\n          type: \"x\"\n        };\n        const e = a.options.chart;\n        e && e.panning && (e.panning = c);\n        const h = c.type;\n        let f;\n        O(this, \"pan\", {\n          originalEvent: b\n        }, function () {\n          d && d.forEach(function (b) {\n            b.setState();\n          });\n          let c = a.xAxis;\n          \"xy\" === h ? c = c.concat(a.yAxis) : \"y\" === h && (c = a.yAxis);\n          const e = {};\n          c.forEach(function (c) {\n            if (c.options.panningEnabled && !c.options.isInternal) {\n              var d = c.horiz,\n                n = b[d ? \"chartX\" : \"chartY\"];\n              d = d ? \"mouseDownX\" : \"mouseDownY\";\n              var g = a[d],\n                k = c.minPointOffset || 0,\n                q = c.reversed && !a.inverted || !c.reversed && a.inverted ? -1 : 1,\n                l = c.getExtremes(),\n                m = c.toValue(g - n, !0) + k * q,\n                u = c.toValue(g + c.len - n, !0) - (k * q || c.isXAxis && c.pointRangePadding || 0),\n                p = u < m;\n              q = c.hasVerticalPanning();\n              g = p ? u : m;\n              m = p ? m : u;\n              var w = c.panningState;\n              !q || c.isXAxis || w && !w.isDirty || c.series.forEach(function (b) {\n                var c = b.getProcessedData(!0);\n                c = b.getExtremes(c.yData, !0);\n                w || (w = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                X(c.dataMin) && X(c.dataMax) && (w.startMin = Math.min(S(b.options.threshold, Infinity), c.dataMin, w.startMin), w.startMax = Math.max(S(b.options.threshold, -Infinity), c.dataMax, w.startMax));\n              });\n              q = Math.min(S(w && w.startMin, l.dataMin), k ? l.min : c.toValue(c.toPixels(l.min) - c.minPixelPadding));\n              u = Math.max(S(w && w.startMax, l.dataMax), k ? l.max : c.toValue(c.toPixels(l.max) + c.minPixelPadding));\n              c.panningState = w;\n              c.isOrdinal || (k = q - g, 0 < k && (m += k, g = q), k = m - u, 0 < k && (m = u, g -= k), c.series.length && g !== l.min && m !== l.max && g >= q && m <= u && (c.setExtremes(g, m, !1, !1, {\n                trigger: \"pan\"\n              }), !a.resetZoomButton && g !== q && m !== u && h.match(\"y\") && (a.showResetZoom(), c.displayBtn = !1), f = !0), e[d] = n);\n            }\n          });\n          ca(e, (b, c) => {\n            a[c] = b;\n          });\n          f && a.redraw(!1);\n          G(a.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    }\n    P(V.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [V.prototype.addAxis, [!0]],\n        yAxis: [V.prototype.addAxis, [!1]],\n        series: [V.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n    \"\";\n    return V;\n  });\n  L(a, \"Core/Legend/LegendSymbol.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      extend: y,\n      merge: F,\n      pick: H\n    } = a;\n    var A = /*#__PURE__*/(() => {\n      (function (a) {\n        a.lineMarker = function (a, B) {\n          B = this.legendItem = this.legendItem || {};\n          var t = this.options;\n          const r = a.symbolWidth,\n            g = a.symbolHeight,\n            p = g / 2,\n            v = this.chart.renderer,\n            l = B.group;\n          a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n          let m = {},\n            f = t.marker,\n            k = 0;\n          this.chart.styledMode || (m = {\n            \"stroke-width\": Math.min(t.lineWidth || 0, 24)\n          }, t.dashStyle ? m.dashstyle = t.dashStyle : \"square\" !== t.linecap && (m[\"stroke-linecap\"] = \"round\"));\n          B.line = v.path().addClass(\"highcharts-graph\").attr(m).add(l);\n          m[\"stroke-linecap\"] && (k = Math.min(B.line.strokeWidth(), r) / 2);\n          r && B.line.attr({\n            d: [[\"M\", k, a], [\"L\", r - k, a]]\n          });\n          f && !1 !== f.enabled && r && (t = Math.min(H(f.radius, p), p), 0 === this.symbol.indexOf(\"url\") && (f = F(f, {\n            width: g,\n            height: g\n          }), t = 0), B.symbol = B = v.symbol(this.symbol, r / 2 - t, a - t, 2 * t, 2 * t, y({\n            context: \"legend\"\n          }, f)).addClass(\"highcharts-point\").add(l), B.isMarker = !0);\n        };\n        a.rectangle = function (a, y) {\n          y = y.legendItem || {};\n          const t = a.symbolHeight,\n            r = a.options.squareSymbol;\n          y.symbol = this.chart.renderer.rect(r ? (a.symbolWidth - t) / 2 : 0, a.baseline - t + 1, r ? t : a.symbolWidth, t, H(a.options.symbolRadius, t / 2)).addClass(\"highcharts-point\").attr({\n            zIndex: 3\n          }).add(y.group);\n        };\n      })(A || (A = {}));\n      return A;\n    })();\n    return A;\n  });\n  L(a, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 1,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function () {\n          const {\n            numberFormatter: a\n          } = this.series.chart;\n          return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    };\n  });\n  L(a, \"Core/Series/Series.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Legend/LegendSymbol.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/SeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D, E, B, t, r) {\n    const {\n        animObject: g,\n        setAnimation: p\n      } = a,\n      {\n        defaultOptions: v\n      } = z,\n      {\n        registerEventOptions: l\n      } = F,\n      {\n        hasTouch: m,\n        svg: f,\n        win: k\n      } = H,\n      {\n        seriesTypes: x\n      } = B,\n      {\n        arrayMax: J,\n        arrayMin: C,\n        clamp: e,\n        cleanRecursively: h,\n        correctFloat: w,\n        defined: q,\n        erase: u,\n        error: d,\n        extend: b,\n        find: c,\n        fireEvent: n,\n        getNestedProperty: G,\n        isArray: I,\n        isNumber: K,\n        isString: y,\n        merge: R,\n        objectEach: P,\n        pick: N,\n        removeEvent: O,\n        splat: ba,\n        syncTimeout: da\n      } = r;\n    class X {\n      constructor() {\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n      init(c, a) {\n        n(this, \"init\", {\n          options: a\n        });\n        const d = this,\n          e = c.series;\n        this.eventsToUnbind = [];\n        d.chart = c;\n        d.options = d.setOptions(a);\n        a = d.options;\n        d.linkedSeries = [];\n        d.bindAxes();\n        b(d, {\n          name: a.name,\n          state: \"\",\n          visible: !1 !== a.visible,\n          selected: !0 === a.selected\n        });\n        l(this, a);\n        const h = a.events;\n        if (h && h.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) c.runTrackerClick = !0;\n        d.getColor();\n        d.getSymbol();\n        d.parallelArrays.forEach(function (b) {\n          d[b + \"Data\"] || (d[b + \"Data\"] = []);\n        });\n        d.isCartesian && (c.hasCartesianSeries = !0);\n        let f;\n        e.length && (f = e[e.length - 1]);\n        d._i = N(f && f._i, -1) + 1;\n        d.opacity = d.options.opacity;\n        c.orderSeries(this.insert(e));\n        a.dataSorting && a.dataSorting.enabled ? d.setDataSortingOptions() : d.points || d.data || d.setData(a.data, !1);\n        n(this, \"afterInit\");\n      }\n      is(b) {\n        return x[b] && this instanceof x[b];\n      }\n      insert(b) {\n        const c = this.options.index;\n        let a;\n        if (K(c)) {\n          for (a = b.length; a--;) if (c >= N(b[a].options.index, b[a]._i)) {\n            b.splice(a + 1, 0, this);\n            break;\n          }\n          -1 === a && b.unshift(this);\n          a += 1;\n        } else b.push(this);\n        return N(a, b.length - 1);\n      }\n      bindAxes() {\n        const b = this,\n          c = b.options,\n          a = b.chart;\n        let e;\n        n(this, \"bindAxes\", null, function () {\n          (b.axisTypes || []).forEach(function (h) {\n            let f = 0;\n            a[h].forEach(function (a) {\n              e = a.options;\n              if (c[h] === f && !e.isInternal || \"undefined\" !== typeof c[h] && c[h] === e.id || \"undefined\" === typeof c[h] && 0 === e.index) b.insert(a.series), b[h] = a, a.isDirty = !0;\n              e.isInternal || f++;\n            });\n            b[h] || b.optionalAxis === h || d(18, !0, a);\n          });\n        });\n        n(this, \"afterBindAxes\");\n      }\n      updateParallelArrays(b, c, a) {\n        const d = b.series,\n          e = K(c) ? function (a) {\n            const e = \"y\" === a && d.toYData ? d.toYData(b) : b[a];\n            d[a + \"Data\"][c] = e;\n          } : function (b) {\n            Array.prototype[c].apply(d[b + \"Data\"], a);\n          };\n        d.parallelArrays.forEach(e);\n      }\n      hasData() {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      }\n      autoIncrement(b) {\n        var c = this.options;\n        const a = c.pointIntervalUnit,\n          d = c.relativeXValue,\n          e = this.chart.time;\n        let h = this.xIncrement,\n          f;\n        h = N(h, c.pointStart, 0);\n        this.pointInterval = f = N(this.pointInterval, c.pointInterval, 1);\n        d && K(b) && (f *= b);\n        a && (c = new e.Date(h), \"day\" === a ? e.set(\"Date\", c, e.get(\"Date\", c) + f) : \"month\" === a ? e.set(\"Month\", c, e.get(\"Month\", c) + f) : \"year\" === a && e.set(\"FullYear\", c, e.get(\"FullYear\", c) + f), f = c.getTime() - h);\n        if (d && K(b)) return h + f;\n        this.xIncrement = h + f;\n        return h;\n      }\n      setDataSortingOptions() {\n        const c = this.options;\n        b(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        q(c.pointRange) || (c.pointRange = 1);\n      }\n      setOptions(b) {\n        var c = this.chart,\n          a = c.options,\n          d = a.plotOptions,\n          e = c.userOptions || {};\n        b = R(b);\n        c = c.styledMode;\n        const h = {\n          plotOptions: d,\n          userOptions: b\n        };\n        n(this, \"setOptions\", h);\n        const f = h.plotOptions[this.type],\n          g = e.plotOptions || {};\n        this.userOptions = h.userOptions;\n        e = R(f, d.series, e.plotOptions && e.plotOptions[this.type], b);\n        this.tooltipOptions = R(v.tooltip, v.plotOptions.series && v.plotOptions.series.tooltip, v.plotOptions[this.type].tooltip, a.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, b.tooltip);\n        this.stickyTracking = N(b.stickyTracking, g[this.type] && g[this.type].stickyTracking, g.series && g.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);\n        null === f.marker && delete e.marker;\n        this.zoneAxis = e.zoneAxis;\n        d = this.zones = (e.zones || []).slice();\n        !e.negativeColor && !e.negativeFillColor || e.zones || (a = {\n          value: e[this.zoneAxis + \"Threshold\"] || e.threshold || 0,\n          className: \"highcharts-negative\"\n        }, c || (a.color = e.negativeColor, a.fillColor = e.negativeFillColor), d.push(a));\n        d.length && q(d[d.length - 1].value) && d.push(c ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        n(this, \"afterSetOptions\", {\n          options: e\n        });\n        return e;\n      }\n      getName() {\n        return N(this.options.name, \"Series \" + (this.index + 1));\n      }\n      getCyclic(b, c, a) {\n        const d = this.chart,\n          e = this.userOptions,\n          h = b + \"Index\",\n          f = b + \"Counter\",\n          n = a ? a.length : N(d.options.chart[b + \"Count\"], d[b + \"Count\"]);\n        if (!c) {\n          var g = N(e[h], e[\"_\" + h]);\n          q(g) || (d.series.length || (d[f] = 0), e[\"_\" + h] = g = d[f] % n, d[f] += 1);\n          a && (c = a[g]);\n        }\n        \"undefined\" !== typeof g && (this[h] = g);\n        this[b] = c;\n      }\n      getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || v.plotOptions[this.type].color, this.chart.options.colors);\n      }\n      getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      }\n      getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      }\n      findPointIndex(b, a) {\n        const d = b.id,\n          e = b.x,\n          h = this.points;\n        var f = this.options.dataSorting,\n          n;\n        let g, k;\n        if (d) f = this.chart.get(d), f instanceof D && (n = f);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (n = c => !c.touched && c.index === b.index, f && f.matchByName ? n = c => !c.touched && c.name === b.name : this.options.relativeXValue && (n = c => !c.touched && c.options.x === b.x), n = c(h, n), !n) return;\n        n && (k = n && n.index, \"undefined\" !== typeof k && (g = !0));\n        \"undefined\" === typeof k && K(e) && (k = this.xData.indexOf(e, a));\n        -1 !== k && \"undefined\" !== typeof k && this.cropped && (k = k >= this.cropStart ? k - this.cropStart : k);\n        !g && K(k) && h[k] && h[k].touched && (k = void 0);\n        return k;\n      }\n      updateData(b, c) {\n        const a = this.options,\n          d = a.dataSorting,\n          e = this.points,\n          h = [],\n          f = this.requireSorting,\n          n = b.length === e.length;\n        let g,\n          k,\n          l,\n          m = !0;\n        this.xIncrement = null;\n        b.forEach(function (b, c) {\n          var k = q(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b) || {};\n          const m = k.x;\n          if (k.id || K(m)) {\n            if (k = this.findPointIndex(k, l), -1 === k || \"undefined\" === typeof k ? h.push(b) : e[k] && b !== a.data[k] ? (e[k].update(b, !1, null, !1), e[k].touched = !0, f && (l = k + 1)) : e[k] && (e[k].touched = !0), !n || c !== k || d && d.enabled || this.hasDerivedData) g = !0;\n          } else h.push(b);\n        }, this);\n        if (g) for (b = e.length; b--;) (k = e[b]) && !k.touched && k.remove && k.remove(!1, c);else !n || d && d.enabled ? m = !1 : (b.forEach(function (b, c) {\n          b === e[c].y || e[c].destroyed || e[c].update(b, !1, null, !1);\n        }), h.length = 0);\n        e.forEach(function (b) {\n          b && (b.touched = !1);\n        });\n        if (!m) return !1;\n        h.forEach(function (b) {\n          this.addPoint(b, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = J(this.xData), this.autoIncrement());\n        return !0;\n      }\n      setData(b, c = !0, a, e) {\n        var h;\n        const f = this,\n          n = f.points,\n          g = n && n.length || 0,\n          k = f.options,\n          q = f.chart,\n          l = k.dataSorting,\n          m = f.xAxis,\n          u = k.turboThreshold,\n          p = this.xData,\n          w = this.yData;\n        var x = f.pointArrayMap;\n        x = x && x.length;\n        const G = k.keys;\n        let v,\n          r = 0,\n          M = 1,\n          t = null;\n        if (!q.options.chart.allowMutatingData) {\n          k.data && delete f.options.data;\n          f.userOptions.data && delete f.userOptions.data;\n          var P = R(!0, b);\n        }\n        b = P || b || [];\n        P = b.length;\n        l && l.enabled && (b = this.sortData(b));\n        q.options.chart.allowMutatingData && !1 !== e && P && g && !f.cropped && !f.hasGroupedData && f.visible && !f.boosted && (v = this.updateData(b, a));\n        if (!v) {\n          f.xIncrement = null;\n          f.colorCounter = 0;\n          this.parallelArrays.forEach(function (b) {\n            f[b + \"Data\"].length = 0;\n          });\n          if (u && P > u) {\n            if (t = f.getFirstValidPoint(b), K(t)) for (a = 0; a < P; a++) p[a] = this.autoIncrement(), w[a] = b[a];else if (I(t)) {\n              if (x) {\n                if (t.length === x) for (a = 0; a < P; a++) p[a] = this.autoIncrement(), w[a] = b[a];else for (a = 0; a < P; a++) e = b[a], p[a] = e[0], w[a] = e.slice(1, x + 1);\n              } else if (G && (r = G.indexOf(\"x\"), M = G.indexOf(\"y\"), r = 0 <= r ? r : 0, M = 0 <= M ? M : 1), 1 === t.length && (M = 0), r === M) for (a = 0; a < P; a++) p[a] = this.autoIncrement(), w[a] = b[a][M];else for (a = 0; a < P; a++) e = b[a], p[a] = e[r], w[a] = e[M];\n            } else d(12, !1, q);\n          } else for (a = 0; a < P; a++) e = {\n            series: f\n          }, f.pointClass.prototype.applyOptions.apply(e, [b[a]]), f.updateParallelArrays(e, a);\n          w && y(w[0]) && d(14, !0, q);\n          f.data = [];\n          f.options.data = f.userOptions.data = b;\n          for (a = g; a--;) null === (h = n[a]) || void 0 === h ? void 0 : h.destroy();\n          m && (m.minRange = m.userMinRange);\n          f.isDirty = q.isDirtyBox = !0;\n          f.isDirtyData = !!n;\n          a = !1;\n        }\n        \"point\" === k.legendType && (this.processData(), this.generatePoints());\n        c && q.redraw(a);\n      }\n      sortData(b) {\n        const c = this,\n          a = c.options.dataSorting.sortKey || \"y\",\n          d = function (b, c) {\n            return q(c) && b.pointClass.prototype.optionsToObject.call({\n              series: b\n            }, c) || {};\n          };\n        b.forEach(function (a, e) {\n          b[e] = d(c, a);\n          b[e].index = e;\n        }, this);\n        b.concat().sort((b, c) => {\n          b = G(a, b);\n          c = G(a, c);\n          return c < b ? -1 : c > b ? 1 : 0;\n        }).forEach(function (b, c) {\n          b.x = c;\n        }, this);\n        c.linkedSeries && c.linkedSeries.forEach(function (c) {\n          const a = c.options,\n            e = a.data;\n          a.dataSorting && a.dataSorting.enabled || !e || (e.forEach(function (a, h) {\n            e[h] = d(c, a);\n            b[h] && (e[h].x = b[h].x, e[h].index = h);\n          }), c.setData(e, !1));\n        });\n        return b;\n      }\n      getProcessedData(b) {\n        var c = this.xAxis,\n          a = this.options,\n          e = a.cropThreshold;\n        const h = b || this.getExtremesFromAll || a.getExtremesFromAll,\n          f = this.isCartesian;\n        b = c && c.val2lin;\n        a = !(!c || !c.logarithmic);\n        let n = 0,\n          g;\n        let k,\n          q,\n          l = this.xData,\n          m = this.yData,\n          u = this.requireSorting;\n        var p = !1;\n        const w = l.length;\n        c && (p = c.getExtremes(), k = p.min, q = p.max, p = !(!c.categories || c.names.length));\n        if (f && this.sorted && !h && (!e || w > e || this.forceCrop)) if (l[w - 1] < k || l[0] > q) l = [], m = [];else if (this.yData && (l[0] < k || l[w - 1] > q)) {\n          var x = this.cropData(this.xData, this.yData, k, q);\n          l = x.xData;\n          m = x.yData;\n          n = x.start;\n          x = !0;\n        }\n        for (e = l.length || 1; --e;) c = a ? b(l[e]) - b(l[e - 1]) : l[e] - l[e - 1], 0 < c && (\"undefined\" === typeof g || c < g) ? g = c : 0 > c && u && !p && (d(15, !1, this.chart), u = !1);\n        return {\n          xData: l,\n          yData: m,\n          cropped: x,\n          cropStart: n,\n          closestPointRange: g\n        };\n      }\n      processData(b) {\n        const c = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !c.isDirty && !this.yAxis.isDirty && !b) return !1;\n        b = this.getProcessedData();\n        this.cropped = b.cropped;\n        this.cropStart = b.cropStart;\n        this.processedXData = b.xData;\n        this.processedYData = b.yData;\n        this.closestPointRange = this.basePointRange = b.closestPointRange;\n        n(this, \"afterProcessData\");\n      }\n      cropData(b, c, a, d, e) {\n        const h = b.length;\n        let f,\n          n = 0,\n          g = h;\n        e = N(e, this.cropShoulder);\n        for (f = 0; f < h; f++) if (b[f] >= a) {\n          n = Math.max(0, f - e);\n          break;\n        }\n        for (a = f; a < h; a++) if (b[a] > d) {\n          g = a + e;\n          break;\n        }\n        return {\n          xData: b.slice(n, g),\n          yData: c.slice(n, g),\n          start: n,\n          end: g\n        };\n      }\n      generatePoints() {\n        var c = this.options;\n        const a = this.processedData || c.data,\n          d = this.processedXData,\n          e = this.processedYData,\n          h = this.pointClass,\n          f = d.length,\n          g = this.cropStart || 0,\n          k = this.hasGroupedData,\n          q = c.keys,\n          l = [];\n        c = c.dataGrouping && c.dataGrouping.groupAll ? g : 0;\n        let m;\n        let u,\n          p,\n          w = this.data;\n        if (!w && !k) {\n          var x = [];\n          x.length = a.length;\n          w = this.data = x;\n        }\n        q && k && (this.options.keys = !1);\n        for (p = 0; p < f; p++) x = g + p, k ? (u = new h().init(this, [d[p]].concat(ba(e[p]))), u.dataGroup = this.groupMap[c + p], u.dataGroup.options && (u.options = u.dataGroup.options, b(u, u.dataGroup.options), delete u.dataLabels)) : (u = w[x]) || \"undefined\" === typeof a[x] || (w[x] = u = new h().init(this, a[x], d[p])), u && (u.index = k ? c + p : x, l[p] = u);\n        this.options.keys = q;\n        if (w && (f !== (m = w.length) || k)) for (p = 0; p < m; p++) p !== g || k || (p += f), w[p] && (w[p].destroyElements(), w[p].plotX = void 0);\n        this.data = w;\n        this.points = l;\n        n(this, \"afterGeneratePoints\");\n      }\n      getXExtremes(b) {\n        return {\n          min: C(b),\n          max: J(b)\n        };\n      }\n      getExtremes(b, c) {\n        const a = this.xAxis;\n        var d = this.yAxis;\n        const e = this.processedXData || this.xData,\n          h = [],\n          f = this.requireSorting ? this.cropShoulder : 0;\n        d = d ? d.positiveValuesOnly : !1;\n        let g,\n          k = 0,\n          q = 0,\n          l = 0;\n        b = b || this.stackedYData || this.processedYData || [];\n        const m = b.length;\n        if (a) {\n          var u = a.getExtremes();\n          k = u.min;\n          q = u.max;\n        }\n        for (g = 0; g < m; g++) {\n          var p = e[g];\n          u = b[g];\n          var w = (K(u) || I(u)) && (u.length || 0 < u || !d);\n          p = c || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !a || (e[g + f] || p) >= k && (e[g - f] || p) <= q;\n          if (w && p) if (w = u.length) for (; w--;) K(u[w]) && (h[l++] = u[w]);else h[l++] = u;\n        }\n        b = {\n          activeYData: h,\n          dataMin: C(h),\n          dataMax: J(h)\n        };\n        n(this, \"afterGetExtremes\", {\n          dataExtremes: b\n        });\n        return b;\n      }\n      applyExtremes() {\n        const b = this.getExtremes();\n        this.dataMin = b.dataMin;\n        this.dataMax = b.dataMax;\n        return b;\n      }\n      getFirstValidPoint(b) {\n        const c = b.length;\n        let a = 0,\n          d = null;\n        for (; null === d && a < c;) d = b[a], a++;\n        return d;\n      }\n      translate() {\n        var b;\n        this.processedXData || this.processData();\n        this.generatePoints();\n        const c = this.options,\n          a = c.stacking,\n          d = this.xAxis,\n          h = d.categories,\n          f = this.enabledDataSorting,\n          g = this.yAxis,\n          k = this.points,\n          l = k.length,\n          m = this.pointPlacementToXValue(),\n          u = !!m,\n          p = c.threshold,\n          x = c.startFromThreshold ? p : 0,\n          G = this.zoneAxis || \"y\";\n        let v,\n          r,\n          P,\n          t,\n          J = Number.MAX_VALUE;\n        for (v = 0; v < l; v++) {\n          const n = k[v],\n            l = n.x;\n          let M,\n            O,\n            C = n.y,\n            y = n.low;\n          const Q = a && (null === (b = g.stacking) || void 0 === b ? void 0 : b.stacks[(this.negStacks && C < (x ? 0 : p) ? \"-\" : \"\") + this.stackKey]);\n          r = d.translate(l, !1, !1, !1, !0, m);\n          n.plotX = K(r) ? w(e(r, -1E5, 1E5)) : void 0;\n          a && this.visible && Q && Q[l] && (t = this.getStackIndicator(t, l, this.index), !n.isNull && t.key && (M = Q[l], O = M.points[t.key]), M && I(O) && (y = O[0], C = O[1], y === x && t.key === Q[l].base && (y = N(K(p) ? p : g.min)), g.positiveValuesOnly && q(y) && 0 >= y && (y = void 0), n.total = n.stackTotal = N(M.total), n.percentage = q(n.y) && M.total ? n.y / M.total * 100 : void 0, n.stackY = C, this.irregularWidths || M.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));\n          n.yBottom = q(y) ? e(g.translate(y, !1, !0, !1, !0), -1E5, 1E5) : void 0;\n          this.dataModify && (C = this.dataModify.modifyValue(C, v));\n          let T;\n          K(C) && void 0 !== n.plotX && (T = g.translate(C, !1, !0, !1, !0), T = K(T) ? e(T, -1E5, 1E5) : void 0);\n          n.plotY = T;\n          n.isInside = this.isPointInside(n);\n          n.clientX = u ? w(d.translate(l, !1, !1, !1, !0, m)) : r;\n          n.negative = n[G] < (c[G + \"Threshold\"] || p || 0);\n          n.category = N(h && h[n.x], n.x);\n          n.isNull || !1 === n.visible || (\"undefined\" !== typeof P && (J = Math.min(J, Math.abs(r - P))), P = r);\n          n.zone = this.zones.length ? n.getZone() : void 0;\n          !n.graphic && this.group && f && (n.isNew = !0);\n        }\n        this.closestPointRangePx = J;\n        n(this, \"afterTranslate\");\n      }\n      getValidPoints(b, c, a) {\n        const d = this.chart;\n        return (b || this.points || []).filter(function (b) {\n          const {\n            plotX: e,\n            plotY: h\n          } = b;\n          return !a && (b.isNull || !K(h)) || c && !d.isInsidePlot(e, h, {\n            inverted: d.inverted\n          }) ? !1 : !1 !== b.visible;\n        });\n      }\n      getClipBox() {\n        const {\n            chart: b,\n            xAxis: c,\n            yAxis: a\n          } = this,\n          d = R(b.clipBox);\n        c && c.len !== b.plotSizeX && (d.width = c.len);\n        a && a.len !== b.plotSizeY && (d.height = a.len);\n        return d;\n      }\n      getSharedClipKey() {\n        return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0);\n      }\n      setClip() {\n        const {\n            chart: b,\n            group: c,\n            markerGroup: a\n          } = this,\n          d = b.sharedClips,\n          e = b.renderer,\n          h = this.getClipBox(),\n          f = this.getSharedClipKey();\n        let n = d[f];\n        n ? n.animate(h) : d[f] = n = e.clipRect(h);\n        c && c.clip(!1 === this.options.clip ? void 0 : n);\n        a && a.clip();\n      }\n      animate(b) {\n        const {\n            chart: c,\n            group: a,\n            markerGroup: d\n          } = this,\n          e = c.inverted;\n        var h = g(this.options.animation),\n          f = [this.getSharedClipKey(), h.duration, h.easing, h.defer].join();\n        let n = c.sharedClips[f],\n          k = c.sharedClips[f + \"m\"];\n        if (b && a) h = this.getClipBox(), n ? n.attr(\"height\", h.height) : (h.width = 0, e && (h.x = c.plotHeight), n = c.renderer.clipRect(h), c.sharedClips[f] = n, k = c.renderer.clipRect({\n          x: -99,\n          y: -99,\n          width: e ? c.plotWidth + 199 : 99,\n          height: e ? 99 : c.plotHeight + 199\n        }), c.sharedClips[f + \"m\"] = k), a.clip(n), d && d.clip(k);else if (n && !n.hasClass(\"highcharts-animating\")) {\n          f = this.getClipBox();\n          const b = h.step;\n          d && d.element.childNodes.length && (h.step = function (c, a) {\n            b && b.apply(a, arguments);\n            \"width\" === a.prop && k && k.element && k.attr(e ? \"height\" : \"width\", c + 99);\n          });\n          n.addClass(\"highcharts-animating\").animate(f, h);\n        }\n      }\n      afterAnimate() {\n        this.setClip();\n        P(this.chart.sharedClips, (b, c, a) => {\n          b && !this.chart.container.querySelector(`[clip-path=\"url(#${b.id})\"]`) && (b.destroy(), delete a[c]);\n        });\n        this.finishedAnimating = !0;\n        n(this, \"afterAnimate\");\n      }\n      drawPoints(b = this.points) {\n        const c = this.chart,\n          a = c.styledMode,\n          {\n            colorAxis: d,\n            options: e\n          } = this,\n          h = e.marker,\n          f = this[this.specialGroup || \"markerGroup\"],\n          n = this.xAxis,\n          g = N(h.enabled, !n || n.isRadial ? !0 : null, this.closestPointRangePx >= h.enabledThreshold * h.radius);\n        let k, q, l, m;\n        let u, p;\n        if (!1 !== h.enabled || this._hasPointMarkers) for (k = 0; k < b.length; k++) {\n          q = b[k];\n          m = (l = q.graphic) ? \"animate\" : \"attr\";\n          var w = q.marker || {};\n          u = !!q.marker;\n          if ((g && \"undefined\" === typeof w.enabled || w.enabled) && !q.isNull && !1 !== q.visible) {\n            const b = N(w.symbol, this.symbol, \"rect\");\n            p = this.markerAttribs(q, q.selected && \"select\");\n            this.enabledDataSorting && (q.startXPos = n.reversed ? -(p.width || 0) : n.width);\n            const e = !1 !== q.isInside;\n            !l && e && (0 < (p.width || 0) || q.hasImage) && (q.graphic = l = c.renderer.symbol(b, p.x, p.y, p.width, p.height, u ? w : h).add(f), this.enabledDataSorting && c.hasRendered && (l.attr({\n              x: q.startXPos\n            }), m = \"animate\"));\n            l && \"animate\" === m && l[e ? \"show\" : \"hide\"](e).animate(p);\n            if (l) if (w = this.pointAttribs(q, a || !q.selected ? void 0 : \"select\"), a) d && l.css({\n              fill: w.fill\n            });else l[m](w);\n            l && l.addClass(q.getClassName(), !0);\n          } else l && (q.graphic = l.destroy());\n        }\n      }\n      markerAttribs(b, c) {\n        const a = this.options;\n        var d = a.marker;\n        const e = b.marker || {},\n          h = e.symbol || d.symbol,\n          f = {};\n        let n = N(e.radius, d && d.radius);\n        c && (d = d.states[c], c = e.states && e.states[c], n = N(c && c.radius, d && d.radius, n && n + (d && d.radiusPlus || 0)));\n        b.hasImage = h && 0 === h.indexOf(\"url\");\n        b.hasImage && (n = 0);\n        b = b.pos();\n        K(n) && b && (f.x = b[0] - n, f.y = b[1] - n, a.crisp && (f.x = Math.floor(f.x)));\n        n && (f.width = f.height = 2 * n);\n        return f;\n      }\n      pointAttribs(b, c) {\n        var a = this.options.marker,\n          d = b && b.options;\n        const e = d && d.marker || {};\n        var h = d && d.color,\n          f = b && b.color;\n        const n = b && b.zone && b.zone.color;\n        let g = this.color;\n        b = N(e.lineWidth, a.lineWidth);\n        d = 1;\n        g = h || n || f || g;\n        h = e.fillColor || a.fillColor || g;\n        f = e.lineColor || a.lineColor || g;\n        c = c || \"normal\";\n        a = a.states[c] || {};\n        c = e.states && e.states[c] || {};\n        b = N(c.lineWidth, a.lineWidth, b + N(c.lineWidthPlus, a.lineWidthPlus, 0));\n        h = c.fillColor || a.fillColor || h;\n        f = c.lineColor || a.lineColor || f;\n        d = N(c.opacity, a.opacity, d);\n        return {\n          stroke: f,\n          \"stroke-width\": b,\n          fill: h,\n          opacity: d\n        };\n      }\n      destroy(b) {\n        const c = this,\n          a = c.chart,\n          d = /AppleWebKit\\/533/.test(k.navigator.userAgent),\n          e = c.data || [];\n        let h, f, g, q;\n        n(c, \"destroy\", {\n          keepEventsForUpdate: b\n        });\n        this.removeEvents(b);\n        (c.axisTypes || []).forEach(function (b) {\n          (q = c[b]) && q.series && (u(q.series, c), q.isDirty = q.forceRedraw = !0);\n        });\n        c.legendItem && c.chart.legend.destroyItem(c);\n        for (f = e.length; f--;) (g = e[f]) && g.destroy && g.destroy();\n        c.clips && c.clips.forEach(b => b.destroy());\n        r.clearTimeout(c.animationTimeout);\n        P(c, function (b, c) {\n          b instanceof t && !b.survive && (h = d && \"group\" === c ? \"hide\" : \"destroy\", b[h]());\n        });\n        a.hoverSeries === c && (a.hoverSeries = void 0);\n        u(a.series, c);\n        a.orderSeries();\n        P(c, function (a, d) {\n          b && \"hcEvents\" === d || delete c[d];\n        });\n      }\n      applyZones() {\n        const b = this,\n          c = this.chart,\n          a = c.renderer,\n          d = this.zones,\n          h = this.clips || [],\n          f = this.graph,\n          n = this.area,\n          g = Math.max(c.plotWidth, c.plotHeight),\n          k = this[(this.zoneAxis || \"y\") + \"Axis\"],\n          q = c.inverted;\n        let l,\n          m,\n          u,\n          p,\n          w,\n          x,\n          G,\n          v,\n          r,\n          I,\n          K,\n          P = !1;\n        d.length && (f || n) && k && \"undefined\" !== typeof k.min ? (w = k.reversed, x = k.horiz, f && !this.showLine && f.hide(), n && n.hide(), p = k.getExtremes(), d.forEach(function (d, t) {\n          l = w ? x ? c.plotWidth : 0 : x ? 0 : k.toPixels(p.min) || 0;\n          l = e(N(m, l), 0, g);\n          m = e(Math.round(k.toPixels(N(d.value, p.max), !0) || 0), 0, g);\n          P && (l = m = k.toPixels(p.max));\n          G = Math.abs(l - m);\n          v = Math.min(l, m);\n          r = Math.max(l, m);\n          k.isXAxis ? (u = {\n            x: q ? r : v,\n            y: 0,\n            width: G,\n            height: g\n          }, x || (u.x = c.plotHeight - u.x)) : (u = {\n            x: 0,\n            y: q ? r : v,\n            width: g,\n            height: G\n          }, x && (u.y = c.plotWidth - u.y));\n          h[t] ? h[t].animate(u) : h[t] = a.clipRect(u);\n          I = b[\"zone-area-\" + t];\n          K = b[\"zone-graph-\" + t];\n          f && K && K.clip(h[t]);\n          n && I && I.clip(h[t]);\n          P = d.value > p.max;\n          b.resetZones && 0 === m && (m = void 0);\n        }), this.clips = h) : b.visible && (f && f.show(), n && n.show());\n      }\n      plotGroup(b, c, a, d, e) {\n        let h = this[b];\n        const f = !h;\n        a = {\n          visibility: a,\n          zIndex: d || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (a.opacity = this.opacity);\n        f && (this[b] = h = this.chart.renderer.g().add(e));\n        h.addClass(\"highcharts-\" + c + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (q(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (h.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        h.attr(a)[f ? \"attr\" : \"animate\"](this.getPlotBox(c));\n        return h;\n      }\n      getPlotBox(b) {\n        let c = this.xAxis,\n          a = this.yAxis;\n        const d = this.chart;\n        b = d.inverted && !d.polar && c && !1 !== this.invertible && \"series\" === b;\n        d.inverted && (c = a, a = this.xAxis);\n        return {\n          translateX: c ? c.left : d.plotLeft,\n          translateY: a ? a.top : d.plotTop,\n          rotation: b ? 90 : 0,\n          rotationOriginX: b ? (c.len - a.len) / 2 : 0,\n          rotationOriginY: b ? (c.len + a.len) / 2 : 0,\n          scaleX: b ? -1 : 1,\n          scaleY: 1\n        };\n      }\n      removeEvents(b) {\n        b || O(this);\n        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {\n          b();\n        }), this.eventsToUnbind.length = 0);\n      }\n      render() {\n        const b = this;\n        var c = b.chart;\n        const a = b.options,\n          d = g(a.animation),\n          e = b.visible ? \"inherit\" : \"hidden\",\n          h = a.zIndex,\n          f = b.hasRendered;\n        c = c.seriesGroup;\n        let k = b.finishedAnimating ? 0 : d.duration;\n        n(this, \"render\");\n        b.plotGroup(\"group\", \"series\", e, h, c);\n        b.markerGroup = b.plotGroup(\"markerGroup\", \"markers\", e, h, c);\n        !1 !== a.clip && b.setClip();\n        b.animate && k && b.animate(!0);\n        b.drawGraph && (b.drawGraph(), b.applyZones());\n        b.visible && b.drawPoints();\n        b.drawDataLabels && b.drawDataLabels();\n        b.redrawPoints && b.redrawPoints();\n        b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();\n        b.animate && k && b.animate();\n        f || (k && d.defer && (k += d.defer), b.animationTimeout = da(function () {\n          b.afterAnimate();\n        }, k || 0));\n        b.isDirty = !1;\n        b.hasRendered = !0;\n        n(b, \"afterRender\");\n      }\n      redraw() {\n        const b = this.isDirty || this.isDirtyData;\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      }\n      searchPoint(b, c) {\n        const a = this.xAxis,\n          d = this.yAxis,\n          e = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: e ? a.len - b.chartY + a.pos : b.chartX - a.pos,\n          plotY: e ? d.len - b.chartX + d.pos : b.chartY - d.pos\n        }, c, b);\n      }\n      buildKDTree(b) {\n        function c(b, d, e) {\n          var h = b && b.length;\n          let f;\n          if (h) return f = a.kdAxisArray[d % e], b.sort(function (b, c) {\n            return b[f] - c[f];\n          }), h = Math.floor(h / 2), {\n            point: b[h],\n            left: c(b.slice(0, h), d + 1, e),\n            right: c(b.slice(h + 1), d + 1, e)\n          };\n        }\n        this.buildingKdTree = !0;\n        const a = this,\n          d = -1 < a.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete a.kdTree;\n        da(function () {\n          a.kdTree = c(a.getValidPoints(null, !a.directTouch), d, d);\n          a.buildingKdTree = !1;\n        }, a.options.kdNow || b && \"touchstart\" === b.type ? 0 : 1);\n      }\n      searchKDTree(b, c, a) {\n        function d(b, c, a, g) {\n          const k = c.point;\n          var l = e.kdAxisArray[a % g];\n          let m = k;\n          var u = q(b[h]) && q(k[h]) ? Math.pow(b[h] - k[h], 2) : null;\n          var p = q(b[f]) && q(k[f]) ? Math.pow(b[f] - k[f], 2) : null;\n          p = (u || 0) + (p || 0);\n          k.dist = q(p) ? Math.sqrt(p) : Number.MAX_VALUE;\n          k.distX = q(u) ? Math.sqrt(u) : Number.MAX_VALUE;\n          l = b[l] - k[l];\n          p = 0 > l ? \"left\" : \"right\";\n          u = 0 > l ? \"right\" : \"left\";\n          c[p] && (p = d(b, c[p], a + 1, g), m = p[n] < m[n] ? p : k);\n          c[u] && Math.sqrt(l * l) < m[n] && (b = d(b, c[u], a + 1, g), m = b[n] < m[n] ? b : m);\n          return m;\n        }\n        const e = this,\n          h = this.kdAxisArray[0],\n          f = this.kdAxisArray[1],\n          n = c ? \"distX\" : \"dist\";\n        c = -1 < e.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(a);\n        if (this.kdTree) return d(b, this.kdTree, c, c);\n      }\n      pointPlacementToXValue() {\n        const {\n          options: {\n            pointPlacement: b,\n            pointRange: c\n          },\n          xAxis: a\n        } = this;\n        let d = b;\n        \"between\" === d && (d = a.reversed ? -.5 : .5);\n        return K(d) ? d * (c || a.pointRange) : 0;\n      }\n      isPointInside(b) {\n        const {\n          chart: c,\n          xAxis: a,\n          yAxis: d\n        } = this;\n        return \"undefined\" !== typeof b.plotY && \"undefined\" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (d ? d.len : c.plotHeight) && 0 <= b.plotX && b.plotX <= (a ? a.len : c.plotWidth);\n      }\n      drawTracker() {\n        const b = this,\n          c = b.options,\n          a = c.trackByArea,\n          d = [].concat(a ? b.areaPath : b.graphPath),\n          e = b.chart,\n          h = e.pointer,\n          g = e.renderer,\n          k = e.options.tooltip.snap,\n          q = b.tracker,\n          l = function (c) {\n            if (e.hoverSeries !== b) b.onMouseOver();\n          },\n          u = \"rgba(192,192,192,\" + (f ? .0001 : .002) + \")\";\n        q ? q.attr({\n          d\n        }) : b.graph && (b.tracker = g.path(d).attr({\n          visibility: b.visible ? \"inherit\" : \"hidden\",\n          zIndex: 2\n        }).addClass(a ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(b.group), e.styledMode || b.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: u,\n          fill: a ? u : \"none\",\n          \"stroke-width\": b.graph.strokeWidth() + (a ? 0 : 2 * k)\n        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {\n          if (b && (b.addClass(\"highcharts-tracker\").on(\"mouseover\", l).on(\"mouseout\", function (b) {\n            h.onTrackerMouseOut(b);\n          }), c.cursor && !e.styledMode && b.css({\n            cursor: c.cursor\n          }), m)) b.on(\"touchstart\", l);\n        }));\n        n(this, \"afterDrawTracker\");\n      }\n      addPoint(b, c, a, d, e) {\n        const h = this.options,\n          f = this.data,\n          g = this.chart;\n        var k = this.xAxis;\n        k = k && k.hasNames && k.names;\n        const q = h.data,\n          l = this.xData;\n        let m, u;\n        c = N(c, !0);\n        const p = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(p, [b]);\n        const w = p.x;\n        u = l.length;\n        if (this.requireSorting && w < l[u - 1]) for (m = !0; u && l[u - 1] > w;) u--;\n        this.updateParallelArrays(p, \"splice\", [u, 0, 0]);\n        this.updateParallelArrays(p, u);\n        k && p.name && (k[w] = p.name);\n        q.splice(u, 0, b);\n        if (m || this.processedData) this.data.splice(u, 0, null), this.processData();\n        \"point\" === h.legendType && this.generatePoints();\n        a && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(p, \"shift\"), q.shift()));\n        !1 !== e && n(this, \"addPoint\", {\n          point: p\n        });\n        this.isDirtyData = this.isDirty = !0;\n        c && g.redraw(d);\n      }\n      removePoint(b, c, a) {\n        const d = this,\n          e = d.data,\n          h = e[b],\n          f = d.points,\n          n = d.chart,\n          g = function () {\n            f && f.length === e.length && f.splice(b, 1);\n            e.splice(b, 1);\n            d.options.data.splice(b, 1);\n            d.updateParallelArrays(h || {\n              series: d\n            }, \"splice\", [b, 1]);\n            h && h.destroy();\n            d.isDirty = !0;\n            d.isDirtyData = !0;\n            c && n.redraw();\n          };\n        p(a, n);\n        c = N(c, !0);\n        h ? h.firePointEvent(\"remove\", null, g) : g();\n      }\n      remove(b, c, a, d) {\n        function e() {\n          h.destroy(d);\n          f.isDirtyLegend = f.isDirtyBox = !0;\n          f.linkSeries(d);\n          N(b, !0) && f.redraw(c);\n        }\n        const h = this,\n          f = h.chart;\n        !1 !== a ? n(h, \"remove\", null, e) : e();\n      }\n      update(c, a) {\n        c = h(c, this.userOptions);\n        n(this, \"update\", {\n          options: c\n        });\n        const e = this,\n          f = e.chart;\n        var g = e.userOptions;\n        const k = e.initialType || e.type;\n        var q = f.options.plotOptions;\n        const l = x[k].prototype;\n        var m = e.finishedAnimating && {\n          animation: !1\n        };\n        const u = {};\n        let p,\n          w = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n          G = c.type || g.type || f.options.chart.type;\n        const v = !(this.hasDerivedData || G && G !== this.type || \"undefined\" !== typeof c.pointStart || \"undefined\" !== typeof c.pointInterval || \"undefined\" !== typeof c.relativeXValue || c.joinBy || c.mapData || e.hasOptionChanged(\"dataGrouping\") || e.hasOptionChanged(\"pointStart\") || e.hasOptionChanged(\"pointInterval\") || e.hasOptionChanged(\"pointIntervalUnit\") || e.hasOptionChanged(\"keys\"));\n        G = G || k;\n        v && (w.push(\"data\", \"isDirtyData\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"clips\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== c.visible && w.push(\"area\", \"graph\"), e.parallelArrays.forEach(function (b) {\n          w.push(b + \"Data\");\n        }), c.data && (c.dataSorting && b(e.options.dataSorting, c.dataSorting), this.setData(c.data, !1)));\n        c = R(g, m, {\n          index: \"undefined\" === typeof g.index ? e.index : g.index,\n          pointStart: N(q && q.series && q.series.pointStart, g.pointStart, e.xData[0])\n        }, !v && {\n          data: e.options.data\n        }, c);\n        v && c.data && (c.data = e.options.data);\n        w = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(w);\n        w.forEach(function (b) {\n          w[b] = e[b];\n          delete e[b];\n        });\n        q = !1;\n        if (x[G]) {\n          if (q = G !== e.type, e.remove(!1, !1, !1, !0), q) if (Object.setPrototypeOf) Object.setPrototypeOf(e, x[G].prototype);else {\n            m = Object.hasOwnProperty.call(e, \"hcEvents\") && e.hcEvents;\n            for (p in l) e[p] = void 0;\n            b(e, x[G].prototype);\n            m ? e.hcEvents = m : delete e.hcEvents;\n          }\n        } else d(17, !0, f, {\n          missingModuleFor: G\n        });\n        w.forEach(function (b) {\n          e[b] = w[b];\n        });\n        e.init(f, c);\n        if (v && this.points) {\n          c = e.options;\n          if (!1 === c.visible) u.graphic = 1, u.dataLabel = 1;else if (!e._hasPointLabels) {\n            const {\n              marker: b,\n              dataLabels: a\n            } = c;\n            g = g.marker || {};\n            !b || !1 !== b.enabled && g.symbol === b.symbol && g.height === b.height && g.width === b.width || (u.graphic = 1);\n            a && !1 === a.enabled && (u.dataLabel = 1);\n          }\n          for (const b of this.points) b && b.series && (b.resolveColor(), Object.keys(u).length && b.destroyElements(u), !1 === c.showInLegend && b.legendItem && f.legend.destroyItem(b));\n        }\n        e.initialType = k;\n        f.linkSeries();\n        q && e.linkedSeries.length && (e.isDirtyData = !0);\n        n(this, \"afterUpdate\");\n        N(a, !0) && f.redraw(v ? void 0 : !1);\n      }\n      setName(b) {\n        this.name = this.options.name = this.userOptions.name = b;\n        this.chart.isDirtyLegend = !0;\n      }\n      hasOptionChanged(b) {\n        const c = this.options[b],\n          a = this.chart.options.plotOptions,\n          d = this.userOptions[b];\n        return d ? c !== d : c !== N(a && a[this.type] && a[this.type][b], a && a.series && a.series[b], c);\n      }\n      onMouseOver() {\n        const b = this.chart,\n          c = b.hoverSeries;\n        b.pointer.setHoverChartIndex();\n        if (c && c !== this) c.onMouseOut();\n        this.options.events.mouseOver && n(this, \"mouseOver\");\n        this.setState(\"hover\");\n        b.hoverSeries = this;\n      }\n      onMouseOut() {\n        const b = this.options,\n          c = this.chart,\n          a = c.tooltip,\n          d = c.hoverPoint;\n        c.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && b.events.mouseOut && n(this, \"mouseOut\");\n        !a || this.stickyTracking || a.shared && !this.noSharedTooltip || a.hide();\n        c.series.forEach(function (b) {\n          b.setState(\"\", !0);\n        });\n      }\n      setState(b, c) {\n        const a = this;\n        var d = a.options;\n        const e = a.graph,\n          h = d.inactiveOtherPoints,\n          f = d.states,\n          n = N(f[b || \"normal\"] && f[b || \"normal\"].animation, a.chart.options.chart.animation);\n        let g = d.lineWidth,\n          k = 0,\n          q = d.opacity;\n        b = b || \"\";\n        if (a.state !== b && ([a.group, a.markerGroup, a.dataLabelsGroup].forEach(function (c) {\n          c && (a.state && c.removeClass(\"highcharts-series-\" + a.state), b && c.addClass(\"highcharts-series-\" + b));\n        }), a.state = b, !a.chart.styledMode)) {\n          if (f[b] && !1 === f[b].enabled) return;\n          b && (g = f[b].lineWidth || g + (f[b].lineWidthPlus || 0), q = N(f[b].opacity, q));\n          if (e && !e.dashstyle && K(g)) for (d = {\n            \"stroke-width\": g\n          }, e.animate(d, n); a[\"zone-graph-\" + k];) a[\"zone-graph-\" + k].animate(d, n), k += 1;\n          h || [a.group, a.markerGroup, a.dataLabelsGroup, a.labelBySeries].forEach(function (b) {\n            b && b.animate({\n              opacity: q\n            }, n);\n          });\n        }\n        c && h && a.points && a.setAllPointsToState(b || void 0);\n      }\n      setAllPointsToState(b) {\n        this.points.forEach(function (c) {\n          c.setState && c.setState(b);\n        });\n      }\n      setVisible(b, c) {\n        const a = this,\n          d = a.chart,\n          e = d.options.chart.ignoreHiddenSeries,\n          h = a.visible,\n          f = (a.visible = b = a.options.visible = a.userOptions.visible = \"undefined\" === typeof b ? !h : b) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (b) {\n          if (a[b]) a[b][f]();\n        });\n        if (d.hoverSeries === a || (d.hoverPoint && d.hoverPoint.series) === a) a.onMouseOut();\n        a.legendItem && d.legend.colorizeItem(a, b);\n        a.isDirty = !0;\n        a.options.stacking && d.series.forEach(function (b) {\n          b.options.stacking && b.visible && (b.isDirty = !0);\n        });\n        a.linkedSeries.forEach(function (c) {\n          c.setVisible(b, !1);\n        });\n        e && (d.isDirtyBox = !0);\n        n(a, f);\n        !1 !== c && d.redraw();\n      }\n      show() {\n        this.setVisible(!0);\n      }\n      hide() {\n        this.setVisible(!1);\n      }\n      select(b) {\n        this.selected = b = this.options.selected = \"undefined\" === typeof b ? !this.selected : b;\n        this.checkbox && (this.checkbox.checked = b);\n        n(this, b ? \"select\" : \"unselect\");\n      }\n      shouldShowTooltip(b, c, a = {}) {\n        a.series = this;\n        a.visiblePlotOnly = !0;\n        return this.chart.isInsidePlot(b, c, a);\n      }\n      drawLegendSymbol(b, c) {\n        var a;\n        null === (a = A[this.options.legendSymbol || \"rectangle\"]) || void 0 === a ? void 0 : a.call(this, b, c);\n      }\n    }\n    X.defaultOptions = E;\n    X.types = B.seriesTypes;\n    X.registerType = B.registerSeriesType;\n    b(X.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: D,\n      requireSorting: !0,\n      sorted: !0\n    });\n    B.series = X;\n    \"\";\n    \"\";\n    return X;\n  });\n  L(a, \"Extensions/ScrollablePlotArea.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D) {\n    const {\n        stop: y\n      } = a,\n      {\n        addEvent: B,\n        createElement: t,\n        defined: r,\n        merge: g,\n        pick: p\n      } = D;\n    B(F, \"afterSetChartSize\", function (a) {\n      var l = this.options.chart.scrollablePlotArea,\n        m = l && l.minWidth;\n      l = l && l.minHeight;\n      let f;\n      if (!this.renderer.forExport) {\n        if (m) {\n          if (this.scrollablePixelsX = m = Math.max(0, m - this.chartWidth)) this.scrollablePlotBox = this.renderer.scrollablePlotBox = g(this.plotBox), this.plotBox.width = this.plotWidth += m, this.inverted ? this.clipBox.height += m : this.clipBox.width += m, f = {\n            1: {\n              name: \"right\",\n              value: m\n            }\n          };\n        } else l && (this.scrollablePixelsY = m = Math.max(0, l - this.chartHeight), r(m) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = g(this.plotBox), this.plotBox.height = this.plotHeight += m, this.inverted ? this.clipBox.width += m : this.clipBox.height += m, f = {\n          2: {\n            name: \"bottom\",\n            value: m\n          }\n        }));\n        f && !a.skipAxes && this.axes.forEach(function (a) {\n          f[a.side] ? a.getPlotLinePath = function () {\n            let g = f[a.side].name,\n              k = this[g],\n              l;\n            this[g] = k - f[a.side].value;\n            l = z.prototype.getPlotLinePath.apply(this, arguments);\n            this[g] = k;\n            return l;\n          } : (a.setAxisSize(), a.setAxisTranslation());\n        });\n      }\n    });\n    B(F, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n    F.prototype.setUpScrolling = function () {\n      const a = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (a.overflowX = \"auto\");\n      this.scrollablePixelsY && (a.overflowY = \"auto\");\n      this.scrollingParent = t(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = t(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, a, this.scrollingParent);\n      let g;\n      B(this.scrollingContainer, \"scroll\", () => {\n        this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (g = this.hoverPoint), this.pointer.runPointActions(void 0, g, !0));\n      });\n      this.innerContainer = t(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n    F.prototype.moveFixedElements = function () {\n      let a = this.container,\n        g = this.fixedRenderer,\n        m = \".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n        f;\n      this.scrollablePixelsX && !this.inverted ? f = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? f = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? f = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (f = \".highcharts-yaxis\");\n      f && m.push(`${f}:not(.highcharts-radial-axis)`, `${f}-labels:not(.highcharts-radial-axis-labels)`);\n      m.forEach(function (f) {\n        [].forEach.call(a.querySelectorAll(f), function (a) {\n          (a.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n    F.prototype.applyFixed = function () {\n      var a = !this.fixedDiv,\n        g = this.options.chart,\n        m = g.scrollablePlotArea,\n        f = A.getRendererType();\n      a ? (this.fixedDiv = t(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (g.style && g.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = g = new f(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = g.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": p(m.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), B(this, \"afterShowResetZoom\", this.moveFixedElements), B(this, \"afterApplyDrilldown\", this.moveFixedElements), B(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();\n      g = this.chartWidth + (this.scrollablePixelsX || 0);\n      f = this.chartHeight + (this.scrollablePixelsY || 0);\n      y(this.container);\n      this.container.style.width = g + \"px\";\n      this.container.style.height = f + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: g,\n        height: f,\n        viewBox: [0, 0, g, f].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: g,\n        height: f\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      a && (m.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * m.scrollPositionX), m.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * m.scrollPositionY));\n      f = this.axisOffset;\n      a = this.plotTop - f[0] - 1;\n      m = this.plotLeft - f[3] - 1;\n      g = this.plotTop + this.plotHeight + f[2] + 1;\n      f = this.plotLeft + this.plotWidth + f[1] + 1;\n      let k = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n        x = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      a = this.scrollablePixelsX ? [[\"M\", 0, a], [\"L\", this.plotLeft - 1, a], [\"L\", this.plotLeft - 1, g], [\"L\", 0, g], [\"Z\"], [\"M\", k, a], [\"L\", this.chartWidth, a], [\"L\", this.chartWidth, g], [\"L\", k, g], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", m, 0], [\"L\", m, this.plotTop - 1], [\"L\", f, this.plotTop - 1], [\"L\", f, 0], [\"Z\"], [\"M\", m, x], [\"L\", m, this.chartHeight], [\"L\", f, this.chartHeight], [\"L\", f, x], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: a\n      });\n    };\n    B(z, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    B(H, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    \"\";\n  });\n  L(a, \"Core/Axis/Stacking/StackItem.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        format: y\n      } = a,\n      {\n        series: A\n      } = z,\n      {\n        destroyObjectProperties: D,\n        fireEvent: E,\n        isNumber: B,\n        pick: t\n      } = F;\n    class r {\n      constructor(a, p, v, l, m) {\n        const f = a.chart.inverted,\n          g = a.reversed;\n        this.axis = a;\n        a = this.isNegative = !!v !== !!g;\n        this.options = p = p || {};\n        this.x = l;\n        this.cumulative = this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = m;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: p.align || (f ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: p.verticalAlign || (f ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: p.y,\n          x: p.x\n        };\n        this.textAlign = p.textAlign || (f ? a ? \"right\" : \"left\" : \"center\");\n      }\n      destroy() {\n        D(this, this.axis);\n      }\n      render(a) {\n        const g = this.axis.chart,\n          v = this.options;\n        var l = v.format;\n        l = l ? y(l, this, g) : v.formatter.call(this);\n        this.label ? this.label.attr({\n          text: l,\n          visibility: \"hidden\"\n        }) : (this.label = g.renderer.label(l, null, void 0, v.shape, void 0, void 0, v.useHTML, !1, \"stack-labels\"), l = {\n          r: v.borderRadius || 0,\n          text: l,\n          padding: t(v.padding, 5),\n          visibility: \"hidden\"\n        }, g.styledMode || (l.fill = v.backgroundColor, l.stroke = v.borderColor, l[\"stroke-width\"] = v.borderWidth, this.label.css(v.style || {})), this.label.attr(l), this.label.added || this.label.add(a));\n        this.label.labelrank = g.plotSizeY;\n        E(this, \"afterRender\");\n      }\n      setOffset(a, p, v, l, m, f) {\n        const {\n            alignOptions: g,\n            axis: x,\n            label: r,\n            options: C,\n            textAlign: e\n          } = this,\n          h = x.chart;\n        v = this.getStackBox({\n          xOffset: a,\n          width: p,\n          boxBottom: v,\n          boxTop: l,\n          defaultX: m,\n          xAxis: f\n        });\n        var {\n          verticalAlign: w\n        } = g;\n        if (r && v) {\n          l = r.getBBox();\n          m = r.padding;\n          f = \"justify\" === t(C.overflow, \"justify\");\n          g.x = C.x || 0;\n          g.y = C.y || 0;\n          const {\n            x: a,\n            y: k\n          } = this.adjustStackPosition({\n            labelBox: l,\n            verticalAlign: w,\n            textAlign: e\n          });\n          v.x -= a;\n          v.y -= k;\n          r.align(g, !1, v);\n          (w = h.isInsidePlot(r.alignAttr.x + g.x + a, r.alignAttr.y + g.y + k)) || (f = !1);\n          f && A.prototype.justifyDataLabel.call(x, r, g, r.alignAttr, l, v);\n          r.attr({\n            x: r.alignAttr.x,\n            y: r.alignAttr.y,\n            rotation: C.rotation,\n            rotationOriginX: l.width / 2,\n            rotationOriginY: l.height / 2\n          });\n          t(!f && C.crop, !0) && (w = B(r.x) && B(r.y) && h.isInsidePlot(r.x - m + r.width, r.y) && h.isInsidePlot(r.x + m, r.y));\n          r[w ? \"show\" : \"hide\"]();\n        }\n        E(this, \"afterSetOffset\", {\n          xOffset: a,\n          width: p\n        });\n      }\n      adjustStackPosition({\n        labelBox: a,\n        verticalAlign: p,\n        textAlign: v\n      }) {\n        const g = {\n          bottom: 0,\n          middle: 1,\n          top: 2,\n          right: 1,\n          center: 0,\n          left: -1\n        };\n        return {\n          x: a.width / 2 + a.width / 2 * g[v],\n          y: a.height / 2 * g[p]\n        };\n      }\n      getStackBox(a) {\n        var g = this.axis;\n        const v = g.chart,\n          {\n            boxTop: l,\n            defaultX: m,\n            xOffset: f,\n            width: k,\n            boxBottom: x\n          } = a;\n        var r = g.stacking.usePercentage ? 100 : t(l, this.total, 0);\n        r = g.toPixels(r);\n        a = a.xAxis || v.xAxis[0];\n        const C = t(m, a.translate(this.x)) + f;\n        g = g.toPixels(x || B(g.min) && g.logarithmic && g.logarithmic.lin2log(g.min) || 0);\n        g = Math.abs(r - g);\n        const e = this.isNegative;\n        return v.inverted ? {\n          x: (e ? r : r - g) - v.plotLeft,\n          y: a.height - C - k,\n          width: g,\n          height: k\n        } : {\n          x: C + a.transB - v.plotLeft,\n          y: (e ? r - g : r) - v.plotTop,\n          width: k,\n          height: g\n        };\n      }\n    }\n    \"\";\n    return r;\n  });\n  L(a, \"Core/Axis/Stacking/StackingAxis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A) {\n    function y() {\n      const b = this,\n        c = b.inverted;\n      b.yAxis.forEach(b => {\n        b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);\n      });\n      b.series.forEach(a => {\n        const d = a.xAxis && a.xAxis.options || {};\n        !a.options.stacking || !0 !== a.visible && !1 !== b.options.chart.ignoreHiddenSeries || (a.stackKey = [a.type, q(a.options.stack, \"\"), c ? d.top : d.left, c ? d.height : d.width].join());\n      });\n    }\n    function E() {\n      const b = this.stacking;\n      if (b) {\n        var c = b.stacks;\n        w(c, function (b, a) {\n          J(b);\n          c[a] = null;\n        });\n        b && b.stackTotalGroup && b.stackTotalGroup.destroy();\n      }\n    }\n    function B() {\n      \"yAxis\" !== this.coll || this.stacking || (this.stacking = new u(this));\n    }\n    function t(b, c, a, d) {\n      !x(b) || b.x !== c || d && b.stackKey !== d ? b = {\n        x: c,\n        index: 0,\n        key: d,\n        stackKey: d\n      } : b.index++;\n      b.key = [a, c, b.index].join();\n      return b;\n    }\n    function r() {\n      const b = this,\n        c = b.stackKey,\n        a = b.yAxis.stacking.stacks,\n        d = b.processedXData,\n        e = b[b.options.stacking + \"Stacker\"];\n      let h;\n      e && [c, \"-\" + c].forEach(c => {\n        let f = d.length;\n        let n;\n        for (; f--;) {\n          var g = d[f];\n          h = b.getStackIndicator(h, g, b.index, c);\n          (n = (g = a[c] && a[c][g]) && g.points[h.key]) && e.call(b, n, g, f);\n        }\n      });\n    }\n    function g(b, c, a) {\n      c = c.total ? 100 / c.total : 0;\n      b[0] = k(b[0] * c);\n      b[1] = k(b[1] * c);\n      this.stackedYData[a] = b[1];\n    }\n    function p() {\n      const b = this.yAxis.stacking;\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length ? m.setStackedPoints.call(this, \"group\") : b && w(b.stacks, (c, a) => {\n        \"group\" === a.slice(-5) && (w(c, b => b.destroy()), delete b.stacks[a]);\n      });\n    }\n    function v(b) {\n      var c = this.chart;\n      const a = b || this.options.stacking;\n      if (a && (!0 === this.visible || !1 === c.options.chart.ignoreHiddenSeries)) {\n        var d = this.processedXData,\n          h = this.processedYData,\n          f = [],\n          g = h.length,\n          l = this.options,\n          m = l.threshold,\n          u = q(l.startFromThreshold && m, 0);\n        l = l.stack;\n        b = b ? `${this.type},${a}` : this.stackKey;\n        var p = \"-\" + b,\n          w = this.negStacks;\n        c = \"group\" === a ? c.yAxis[0] : this.yAxis;\n        var v = c.stacking.stacks,\n          r = c.stacking.oldStacks,\n          t,\n          C;\n        c.stacking.stacksTouched += 1;\n        for (C = 0; C < g; C++) {\n          var J = d[C];\n          var y = h[C];\n          var B = this.getStackIndicator(B, J, this.index);\n          var E = B.key;\n          var z = (t = w && y < (u ? 0 : m)) ? p : b;\n          v[z] || (v[z] = {});\n          v[z][J] || (r[z] && r[z][J] ? (v[z][J] = r[z][J], v[z][J].total = null) : v[z][J] = new H(c, c.options.stackLabels, !!t, J, l));\n          z = v[z][J];\n          null !== y ? (z.points[E] = z.points[this.index] = [q(z.cumulative, u)], x(z.cumulative) || (z.base = E), z.touched = c.stacking.stacksTouched, 0 < B.index && !1 === this.singleStacks && (z.points[E][0] = z.points[this.index + \",\" + J + \",0\"][0])) : z.points[E] = z.points[this.index] = null;\n          \"percent\" === a ? (t = t ? b : p, w && v[t] && v[t][J] ? (t = v[t][J], z.total = t.total = Math.max(t.total, z.total) + Math.abs(y) || 0) : z.total = k(z.total + (Math.abs(y) || 0))) : \"group\" === a ? (e(y) && (y = y[0]), null !== y && (z.total = (z.total || 0) + 1)) : z.total = k(z.total + (y || 0));\n          z.cumulative = \"group\" === a ? (z.total || 1) - 1 : k(q(z.cumulative, u) + (y || 0));\n          null !== y && (z.points[E].push(z.cumulative), f[C] = z.cumulative, z.hasValidPoints = !0);\n        }\n        \"percent\" === a && (c.stacking.usePercentage = !0);\n        \"group\" !== a && (this.stackedYData = f);\n        c.stacking.oldStacks = {};\n      }\n    }\n    const {\n        getDeferredAnimation: l\n      } = a,\n      {\n        series: {\n          prototype: m\n        }\n      } = F,\n      {\n        addEvent: f,\n        correctFloat: k,\n        defined: x,\n        destroyObjectProperties: J,\n        fireEvent: C,\n        isArray: e,\n        isNumber: h,\n        objectEach: w,\n        pick: q\n      } = A;\n    class u {\n      constructor(b) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = b;\n      }\n      buildStacks() {\n        const b = this.axis,\n          c = b.series,\n          a = b.options.reversedStacks,\n          d = c.length;\n        let e, h;\n        this.usePercentage = !1;\n        for (h = d; h--;) e = c[a ? h : d - h - 1], e.setStackedPoints(), e.setGroupedPoints();\n        for (h = 0; h < d; h++) c[h].modifyStacks();\n        C(b, \"afterBuildStacks\");\n      }\n      cleanStacks() {\n        let b;\n        this.oldStacks && (b = this.stacks = this.oldStacks);\n        w(b, function (b) {\n          w(b, function (b) {\n            b.cumulative = b.total;\n          });\n        });\n      }\n      resetStacks() {\n        w(this.stacks, b => {\n          w(b, (c, a) => {\n            h(c.touched) && c.touched < this.stacksTouched ? (c.destroy(), delete b[a]) : (c.total = null, c.cumulative = null);\n          });\n        });\n      }\n      renderStackTotals() {\n        var b = this.axis;\n        const c = b.chart,\n          a = c.renderer,\n          d = this.stacks;\n        b = l(c, b.options.stackLabels && b.options.stackLabels.animation || !1);\n        const e = this.stackTotalGroup = this.stackTotalGroup || a.g(\"stack-labels\").attr({\n          zIndex: 6,\n          opacity: 0\n        }).add();\n        e.translate(c.plotLeft, c.plotTop);\n        w(d, function (b) {\n          w(b, function (b) {\n            b.render(e);\n          });\n        });\n        e.animate({\n          opacity: 1\n        }, b);\n      }\n    }\n    var d;\n    (function (b) {\n      const c = [];\n      b.compose = function (b, a, d) {\n        A.pushUnique(c, b) && (f(b, \"init\", B), f(b, \"destroy\", E));\n        A.pushUnique(c, a) && (a.prototype.getStacks = y);\n        A.pushUnique(c, d) && (b = d.prototype, b.getStackIndicator = t, b.modifyStacks = r, b.percentStacker = g, b.setGroupedPoints = p, b.setStackedPoints = v);\n      };\n    })(d || (d = {}));\n    return d;\n  });\n  L(a, \"Series/Line/LineSeries.js\", [a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n      defined: y,\n      merge: A\n    } = F;\n    class D extends a {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawGraph() {\n        const a = this,\n          y = this.options,\n          t = (this.gappedPath || this.getGraphPath).call(this),\n          r = this.chart.styledMode;\n        let g = [[\"graph\", \"highcharts-graph\"]];\n        r || g[0].push(y.lineColor || this.color || \"#cccccc\", y.dashStyle);\n        g = a.getZonesGraphs(g);\n        g.forEach(function (g, v) {\n          var l = g[0];\n          let m = a[l];\n          const f = m ? \"animate\" : \"attr\";\n          m ? (m.endX = a.preventGraphAnimation ? null : t.xMap, m.animate({\n            d: t\n          })) : t.length && (a[l] = m = a.chart.renderer.path(t).addClass(g[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          m && !r && (l = {\n            stroke: g[2],\n            \"stroke-width\": y.lineWidth || 0,\n            fill: a.fillGraph && a.color || \"none\"\n          }, g[3] ? l.dashstyle = g[3] : \"square\" !== y.linecap && (l[\"stroke-linecap\"] = l[\"stroke-linejoin\"] = \"round\"), m[f](l).shadow(2 > v && y.shadow));\n          m && (m.startX = t.xMap, m.isArea = t.isArea);\n        });\n      }\n      getGraphPath(a, B, t) {\n        const r = this,\n          g = r.options,\n          p = [],\n          v = [];\n        let l,\n          m = g.step;\n        a = a || r.points;\n        const f = a.reversed;\n        f && a.reverse();\n        (m = {\n          right: 1,\n          center: 2\n        }[m] || m && 3) && f && (m = 4 - m);\n        a = this.getValidPoints(a, !1, !(g.connectNulls && !B && !t));\n        a.forEach(function (f, x) {\n          const k = f.plotX,\n            C = f.plotY,\n            e = a[x - 1],\n            h = f.isNull || \"number\" !== typeof C;\n          (f.leftCliff || e && e.rightCliff) && !t && (l = !0);\n          h && !y(B) && 0 < x ? l = !g.connectNulls : h && !B ? l = !0 : (0 === x || l ? x = [[\"M\", f.plotX, f.plotY]] : r.getPointSpline ? x = [r.getPointSpline(a, f, x)] : m ? (x = 1 === m ? [[\"L\", e.plotX, C]] : 2 === m ? [[\"L\", (e.plotX + k) / 2, e.plotY], [\"L\", (e.plotX + k) / 2, C]] : [[\"L\", k, e.plotY]], x.push([\"L\", k, C])) : x = [[\"L\", k, C]], v.push(f.x), m && (v.push(f.x), 2 === m && v.push(f.x)), p.push.apply(p, x), l = !1);\n        });\n        p.xMap = v;\n        return r.graphPath = p;\n      }\n      getZonesGraphs(a) {\n        this.zones.forEach(function (y, t) {\n          t = [\"zone-graph-\" + t, \"highcharts-graph highcharts-zone-graph-\" + t + \" \" + (y.className || \"\")];\n          this.chart.styledMode || t.push(y.color || this.color, y.dashStyle || this.options.dashStyle);\n          a.push(t);\n        }, this);\n        return a;\n      }\n    }\n    D.defaultOptions = A(a.defaultOptions, {\n      legendSymbol: \"lineMarker\"\n    });\n    z.registerSeriesType(\"line\", D);\n    \"\";\n    return D;\n  });\n  L(a, \"Series/Area/AreaSeries.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        parse: y\n      } = a,\n      {\n        seriesTypes: {\n          line: A\n        }\n      } = z,\n      {\n        extend: D,\n        merge: E,\n        objectEach: B,\n        pick: t\n      } = F;\n    class r extends A {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawGraph() {\n        this.areaPath = [];\n        super.drawGraph.apply(this);\n        const a = this,\n          p = this.areaPath,\n          v = this.options,\n          l = [[\"area\", \"highcharts-area\", this.color, v.fillColor]];\n        this.zones.forEach(function (g, f) {\n          l.push([\"zone-area-\" + f, \"highcharts-area highcharts-zone-area-\" + f + \" \" + g.className, g.color || a.color, g.fillColor || v.fillColor]);\n        });\n        l.forEach(function (g) {\n          const f = g[0],\n            k = {};\n          let l = a[f];\n          const m = l ? \"animate\" : \"attr\";\n          l ? (l.endX = a.preventGraphAnimation ? null : p.xMap, l.animate({\n            d: p\n          })) : (k.zIndex = 0, l = a[f] = a.chart.renderer.path(p).addClass(g[1]).add(a.group), l.isArea = !0);\n          a.chart.styledMode || (k.fill = t(g[3], y(g[2]).setOpacity(t(v.fillOpacity, .75)).get()));\n          l[m](k);\n          l.startX = p.xMap;\n          l.shiftUnit = v.step ? 2 : 1;\n        });\n      }\n      getGraphPath(a) {\n        var g = A.prototype.getGraphPath,\n          v = this.options;\n        const l = v.stacking,\n          m = this.yAxis,\n          f = [],\n          k = [],\n          x = this.index,\n          r = m.stacking.stacks[this.stackKey],\n          C = v.threshold,\n          e = Math.round(m.getThreshold(v.threshold));\n        v = t(v.connectNulls, \"percent\" === l);\n        var h = function (d, b, c) {\n          var h = a[d];\n          d = l && r[h.x].points[x];\n          const g = h[c + \"Null\"] || 0;\n          c = h[c + \"Cliff\"] || 0;\n          let q, u;\n          h = !0;\n          c || g ? (q = (g ? d[0] : d[1]) + c, u = d[0] + c, h = !!g) : !l && a[b] && a[b].isNull && (q = u = C);\n          \"undefined\" !== typeof q && (k.push({\n            plotX: w,\n            plotY: null === q ? e : m.getThreshold(q),\n            isNull: h,\n            isCliff: !0\n          }), f.push({\n            plotX: w,\n            plotY: null === u ? e : m.getThreshold(u),\n            doCurve: !1\n          }));\n        };\n        let w;\n        a = a || this.points;\n        l && (a = this.getStackPoints(a));\n        for (let d = 0, b = a.length; d < b; ++d) {\n          l || (a[d].leftCliff = a[d].rightCliff = a[d].leftNull = a[d].rightNull = void 0);\n          var q = a[d].isNull;\n          w = t(a[d].rectPlotX, a[d].plotX);\n          var u = l ? t(a[d].yBottom, e) : e;\n          if (!q || v) v || h(d, d - 1, \"left\"), q && !l && v || (k.push(a[d]), f.push({\n            x: d,\n            plotX: w,\n            plotY: u\n          })), v || h(d, d + 1, \"right\");\n        }\n        h = g.call(this, k, !0, !0);\n        f.reversed = !0;\n        q = g.call(this, f, !0, !0);\n        (u = q[0]) && \"M\" === u[0] && (q[0] = [\"L\", u[1], u[2]]);\n        q = h.concat(q);\n        q.length && q.push([\"Z\"]);\n        g = g.call(this, k, !1, v);\n        q.xMap = h.xMap;\n        this.areaPath = q;\n        return g;\n      }\n      getStackPoints(a) {\n        const g = this,\n          v = [],\n          l = [],\n          m = this.xAxis,\n          f = this.yAxis,\n          k = f.stacking.stacks[this.stackKey],\n          x = {},\n          r = f.series,\n          C = r.length,\n          e = f.options.reversedStacks ? 1 : -1,\n          h = r.indexOf(g);\n        a = a || this.points;\n        if (this.options.stacking) {\n          for (let e = 0; e < a.length; e++) a[e].leftNull = a[e].rightNull = void 0, x[a[e].x] = a[e];\n          B(k, function (a, e) {\n            null !== a.total && l.push(e);\n          });\n          l.sort(function (a, e) {\n            return a - e;\n          });\n          const p = r.map(a => a.visible);\n          l.forEach(function (a, u) {\n            let d = 0,\n              b,\n              c;\n            if (x[a] && !x[a].isNull) v.push(x[a]), [-1, 1].forEach(function (d) {\n              const f = 1 === d ? \"rightNull\" : \"leftNull\",\n                n = k[l[u + d]];\n              let q = 0;\n              if (n) {\n                let d = h;\n                for (; 0 <= d && d < C;) {\n                  const h = r[d].index;\n                  b = n.points[h];\n                  b || (h === g.index ? x[a][f] = !0 : p[d] && (c = k[a].points[h]) && (q -= c[1] - c[0]));\n                  d += e;\n                }\n              }\n              x[a][1 === d ? \"rightCliff\" : \"leftCliff\"] = q;\n            });else {\n              let c = h;\n              for (; 0 <= c && c < C;) {\n                if (b = k[a].points[r[c].index]) {\n                  d = b[1];\n                  break;\n                }\n                c += e;\n              }\n              d = t(d, 0);\n              d = f.translate(d, 0, 1, 0, 1);\n              v.push({\n                isNull: !0,\n                plotX: m.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: d,\n                yBottom: d\n              });\n            }\n          });\n        }\n        return v;\n      }\n    }\n    r.defaultOptions = E(A.defaultOptions, {\n      threshold: 0,\n      legendSymbol: \"rectangle\"\n    });\n    D(r.prototype, {\n      singleStacks: !1\n    });\n    z.registerSeriesType(\"area\", r);\n    \"\";\n    return r;\n  });\n  L(a, \"Series/Spline/SplineSeries.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    const {\n        line: y\n      } = a.seriesTypes,\n      {\n        merge: H,\n        pick: A\n      } = z;\n    class D extends y {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      getPointSpline(a, y, t) {\n        const r = y.plotX || 0,\n          g = y.plotY || 0,\n          p = a[t - 1];\n        t = a[t + 1];\n        let v, l;\n        let m;\n        if (p && !p.isNull && !1 !== p.doCurve && !y.isCliff && t && !t.isNull && !1 !== t.doCurve && !y.isCliff) {\n          a = p.plotY || 0;\n          var f = t.plotX || 0;\n          t = t.plotY || 0;\n          let k = 0;\n          v = (1.5 * r + (p.plotX || 0)) / 2.5;\n          l = (1.5 * g + a) / 2.5;\n          f = (1.5 * r + f) / 2.5;\n          m = (1.5 * g + t) / 2.5;\n          f !== v && (k = (m - l) * (f - r) / (f - v) + g - m);\n          l += k;\n          m += k;\n          l > a && l > g ? (l = Math.max(a, g), m = 2 * g - l) : l < a && l < g && (l = Math.min(a, g), m = 2 * g - l);\n          m > t && m > g ? (m = Math.max(t, g), l = 2 * g - m) : m < t && m < g && (m = Math.min(t, g), l = 2 * g - m);\n          y.rightContX = f;\n          y.rightContY = m;\n        }\n        y = [\"C\", A(p.rightContX, p.plotX, 0), A(p.rightContY, p.plotY, 0), A(v, r, 0), A(l, g, 0), r, g];\n        p.rightContX = p.rightContY = void 0;\n        return y;\n      }\n    }\n    D.defaultOptions = H(y.defaultOptions);\n    a.registerSeriesType(\"spline\", D);\n    \"\";\n    return D;\n  });\n  L(a, \"Series/AreaSpline/AreaSplineSeries.js\", [a[\"Series/Spline/SplineSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        area: y,\n        area: {\n          prototype: A\n        }\n      } = z.seriesTypes,\n      {\n        extend: D,\n        merge: E\n      } = F;\n    class B extends a {\n      constructor() {\n        super(...arguments);\n        this.options = this.points = this.data = void 0;\n      }\n    }\n    B.defaultOptions = E(a.defaultOptions, y.defaultOptions);\n    D(B.prototype, {\n      getGraphPath: A.getGraphPath,\n      getStackPoints: A.getStackPoints,\n      drawGraph: A.drawGraph\n    });\n    z.registerSeriesType(\"areaspline\", B);\n    \"\";\n    return B;\n  });\n  L(a, \"Series/Column/ColumnSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    };\n  });\n  L(a, \"Series/Column/ColumnSeries.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Series/Column/ColumnSeriesDefaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D, E) {\n    const {\n        animObject: y\n      } = a,\n      {\n        parse: t\n      } = z,\n      {\n        hasTouch: r,\n        noop: g\n      } = H,\n      {\n        clamp: p,\n        defined: v,\n        extend: l,\n        fireEvent: m,\n        isArray: f,\n        isNumber: k,\n        merge: x,\n        pick: J,\n        objectEach: C\n      } = E;\n    class e extends A {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.group = this.data = this.borderWidth = void 0;\n      }\n      animate(a) {\n        const e = this,\n          h = this.yAxis,\n          f = h.pos,\n          d = e.options,\n          b = this.chart.inverted,\n          c = {},\n          g = b ? \"translateX\" : \"translateY\";\n        let k;\n        a ? (c.scaleY = .001, a = p(h.toPixels(d.threshold), f, f + h.len), b ? c.translateX = a - h.len : c.translateY = a, e.clipBox && e.setClip(), e.group.attr(c)) : (k = Number(e.group.attr(g)), e.group.animate({\n          scaleY: 1\n        }, l(y(e.options.animation), {\n          step: function (b, a) {\n            e.group && (c[g] = k + a.pos * (f - k), e.group.attr(c));\n          }\n        })));\n      }\n      init(a, e) {\n        super.init.apply(this, arguments);\n        const h = this;\n        a = h.chart;\n        a.hasRendered && a.series.forEach(function (a) {\n          a.type === h.type && (a.isDirty = !0);\n        });\n      }\n      getColumnMetrics() {\n        const a = this;\n        var e = a.options;\n        const f = a.xAxis,\n          g = a.yAxis;\n        var d = f.options.reversedStacks;\n        d = f.reversed && !d || !f.reversed && d;\n        const b = {};\n        let c,\n          n = 0;\n        !1 === e.grouping ? n = 1 : a.chart.series.forEach(function (d) {\n          const e = d.yAxis,\n            h = d.options;\n          let f;\n          d.type !== a.type || !d.visible && a.chart.options.chart.ignoreHiddenSeries || g.len !== e.len || g.pos !== e.pos || (h.stacking && \"group\" !== h.stacking ? (c = d.stackKey, \"undefined\" === typeof b[c] && (b[c] = n++), f = b[c]) : !1 !== h.grouping && (f = n++), d.columnIndex = f);\n        });\n        const k = Math.min(Math.abs(f.transA) * (f.ordinal && f.ordinal.slope || e.pointRange || f.closestPointRange || f.tickInterval || 1), f.len),\n          l = k * e.groupPadding,\n          m = (k - 2 * l) / (n || 1);\n        e = Math.min(e.maxPointWidth || f.len, J(e.pointWidth, m * (1 - 2 * e.pointPadding)));\n        a.columnMetrics = {\n          width: e,\n          offset: (m - e) / 2 + (l + ((a.columnIndex || 0) + (d ? 1 : 0)) * m - k / 2) * (d ? -1 : 1),\n          paddedWidth: m,\n          columnCount: n\n        };\n        return a.columnMetrics;\n      }\n      crispCol(a, e, f, g) {\n        var d = this.borderWidth,\n          b = -(d % 2 ? .5 : 0);\n        d = d % 2 ? .5 : 1;\n        this.options.crisp && (f = Math.round(a + f) + b, a = Math.round(a) + b, f -= a);\n        g = Math.round(e + g) + d;\n        b = .5 >= Math.abs(e) && .5 < g;\n        e = Math.round(e) + d;\n        g -= e;\n        b && g && (--e, g += 1);\n        return {\n          x: a,\n          y: e,\n          width: f,\n          height: g\n        };\n      }\n      adjustForMissingColumns(a, e, g, k) {\n        const d = this.options.stacking;\n        if (!g.isNull && 1 < k.columnCount) {\n          const b = this.yAxis.options.reversedStacks;\n          let c = 0,\n            h = b ? 0 : -k.columnCount;\n          C(this.yAxis.stacking && this.yAxis.stacking.stacks, a => {\n            if (\"number\" === typeof g.x) {\n              const e = a[g.x.toString()];\n              e && (a = e.points[this.index], d ? (a && (c = h), e.hasValidPoints && (b ? h++ : h--)) : f(a) && (a = Object.keys(e.points).filter(b => !b.match(\",\") && e.points[b] && 1 < e.points[b].length).map(parseFloat).sort((b, a) => a - b), c = a.indexOf(this.index), h = a.length));\n            }\n          });\n          a = (g.plotX || 0) + ((h - 1) * k.paddedWidth + e) / 2 - e - c * k.paddedWidth;\n        }\n        return a;\n      }\n      translate() {\n        const a = this,\n          e = a.chart,\n          f = a.options;\n        var g = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        g = a.borderWidth = J(f.borderWidth, g ? 0 : 1);\n        const d = a.xAxis,\n          b = a.yAxis,\n          c = f.threshold,\n          n = J(f.minPointLength, 5),\n          l = a.getColumnMetrics(),\n          x = l.width,\n          r = a.pointXOffset = l.offset,\n          t = a.dataMin,\n          y = a.dataMax;\n        let P = a.barW = Math.max(x, 1 + 2 * g),\n          C = a.translatedThreshold = b.getThreshold(c);\n        e.inverted && (C -= .5);\n        f.pointPadding && (P = Math.ceil(P));\n        A.prototype.translate.apply(a);\n        a.points.forEach(function (h) {\n          const g = J(h.yBottom, C);\n          var q = 999 + Math.abs(g),\n            m = h.plotX || 0;\n          q = p(h.plotY, -q, b.len + q);\n          let u = Math.min(q, g),\n            w = Math.max(q, g) - u,\n            G = x,\n            I = m + r,\n            K = P;\n          n && Math.abs(w) < n && (w = n, m = !b.reversed && !h.negative || b.reversed && h.negative, k(c) && k(y) && h.y === c && y <= c && (b.min || 0) < c && (t !== y || (b.max || 0) <= c) && (m = !m), u = Math.abs(u - C) > n ? g - n : C - (m ? n : 0));\n          v(h.options.pointWidth) && (G = K = Math.ceil(h.options.pointWidth), I -= Math.round((G - x) / 2));\n          f.centerInCategory && (I = a.adjustForMissingColumns(I, G, h, l));\n          h.barX = I;\n          h.pointWidth = G;\n          h.tooltipPos = e.inverted ? [p(b.len + b.pos - e.plotLeft - q, b.pos - e.plotLeft, b.len + b.pos - e.plotLeft), d.len + d.pos - e.plotTop - I - K / 2, w] : [d.left - e.plotLeft + I + K / 2, p(q + b.pos - e.plotTop, b.pos - e.plotTop, b.len + b.pos - e.plotTop), w];\n          h.shapeType = a.pointClass.prototype.shapeType || \"roundedRect\";\n          h.shapeArgs = a.crispCol(I, h.isNull ? C : u, K, h.isNull ? 0 : w);\n        });\n        m(this, \"afterColumnTranslate\");\n      }\n      drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      }\n      pointAttribs(a, e) {\n        const h = this.options;\n        var f = this.pointAttrToOptions || {},\n          d = f.stroke || \"borderColor\";\n        const b = f[\"stroke-width\"] || \"borderWidth\";\n        let c,\n          g = a && a.color || this.color,\n          k = a && a[d] || h[d] || g;\n        f = a && a.options.dashStyle || h.dashStyle;\n        let l = a && a[b] || h[b] || this[b] || 0,\n          m = J(a && a.opacity, h.opacity, 1);\n        a && this.zones.length && (c = a.getZone(), g = a.options.color || c && (c.color || a.nonZonedColor) || this.color, c && (k = c.borderColor || k, f = c.dashStyle || f, l = c.borderWidth || l));\n        e && a && (a = x(h.states[e], a.options.states && a.options.states[e] || {}), e = a.brightness, g = a.color || \"undefined\" !== typeof e && t(g).brighten(a.brightness).get() || g, k = a[d] || k, l = a[b] || l, f = a.dashStyle || f, m = J(a.opacity, m));\n        d = {\n          fill: g,\n          stroke: k,\n          \"stroke-width\": l,\n          opacity: m\n        };\n        f && (d.dashstyle = f);\n        return d;\n      }\n      drawPoints(a = this.points) {\n        const e = this,\n          h = this.chart,\n          f = e.options,\n          d = h.renderer,\n          b = f.animationLimit || 250;\n        let c;\n        a.forEach(function (a) {\n          let g = a.graphic,\n            n = !!g,\n            l = g && h.pointCount < b ? \"animate\" : \"attr\";\n          if (k(a.plotY) && null !== a.y) {\n            c = a.shapeArgs;\n            g && a.hasNewShapeType() && (g = g.destroy());\n            e.enabledDataSorting && (a.startXPos = e.xAxis.reversed ? -(c ? c.width || 0 : 0) : e.xAxis.width);\n            g || (a.graphic = g = d[a.shapeType](c).add(a.group || e.group)) && e.enabledDataSorting && h.hasRendered && h.pointCount < b && (g.attr({\n              x: a.startXPos\n            }), n = !0, l = \"animate\");\n            if (g && n) g[l](x(c));\n            h.styledMode || g[l](e.pointAttribs(a, a.selected && \"select\")).shadow(!1 !== a.allowShadow && f.shadow);\n            g && (g.addClass(a.getClassName(), !0), g.attr({\n              visibility: a.visible ? \"inherit\" : \"hidden\"\n            }));\n          } else g && (a.graphic = g.destroy());\n        });\n      }\n      drawTracker(a = this.points) {\n        const e = this,\n          h = e.chart,\n          g = h.pointer,\n          d = function (b) {\n            const a = g.getPointFromEvent(b);\n            \"undefined\" !== typeof a && (g.isDirectTouch = !0, a.onMouseOver(b));\n          };\n        let b;\n        a.forEach(function (a) {\n          b = f(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          b.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        e._hasTracking || (e.trackerGroups.forEach(function (b) {\n          if (e[b]) {\n            e[b].addClass(\"highcharts-tracker\").on(\"mouseover\", d).on(\"mouseout\", function (b) {\n              g.onTrackerMouseOut(b);\n            });\n            if (r) e[b].on(\"touchstart\", d);\n            !h.styledMode && e.options.cursor && e[b].css({\n              cursor: e.options.cursor\n            });\n          }\n        }), e._hasTracking = !0);\n        m(this, \"afterDrawTracker\");\n      }\n      remove() {\n        const a = this,\n          e = a.chart;\n        e.hasRendered && e.series.forEach(function (e) {\n          e.type === a.type && (e.isDirty = !0);\n        });\n        A.prototype.remove.apply(a, arguments);\n      }\n    }\n    e.defaultOptions = x(A.defaultOptions, F);\n    l(e.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      getSymbol: g,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    D.registerSeriesType(\"column\", e);\n    \"\";\n    return e;\n  });\n  L(a, \"Core/Series/DataLabel.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        getDeferredAnimation: y\n      } = a,\n      {\n        format: A\n      } = z,\n      {\n        defined: D,\n        extend: E,\n        fireEvent: B,\n        isArray: t,\n        isString: r,\n        merge: g,\n        objectEach: p,\n        pick: v,\n        splat: l\n      } = F;\n    var m;\n    (function (a) {\n      function f(a, b, c, e, h) {\n        const d = this.chart;\n        var f = this.isCartesian && d.inverted;\n        const g = this.enabledDataSorting;\n        var n = a.plotX,\n          k = a.plotY;\n        const l = c.rotation;\n        var q = c.align;\n        k = D(n) && D(k) && d.isInsidePlot(n, Math.round(k), {\n          inverted: f,\n          paneCoordinates: !0,\n          series: this\n        });\n        let m = \"justify\" === v(c.overflow, g ? \"none\" : \"justify\");\n        f = this.visible && !1 !== a.visible && D(n) && (a.series.forceDL || g && !m || k || v(c.inside, !!this.options.stacking) && e && d.isInsidePlot(n, f ? e.x + 1 : e.y + e.height - 1, {\n          inverted: f,\n          paneCoordinates: !0,\n          series: this\n        }));\n        n = a.pos();\n        if (f && n) {\n          l && b.attr({\n            align: q\n          });\n          q = b.getBBox(!0);\n          var u = [0, 0];\n          var p = d.renderer.fontMetrics(b).b;\n          e = E({\n            x: n[0],\n            y: Math.round(n[1]),\n            width: 0,\n            height: 0\n          }, e);\n          E(c, {\n            width: q.width,\n            height: q.height\n          });\n          l ? (m = !1, u = d.renderer.rotCorr(p, l), p = {\n            x: e.x + (c.x || 0) + e.width / 2 + u.x,\n            y: e.y + (c.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[c.verticalAlign] * e.height\n          }, u = [q.x - Number(b.attr(\"x\")), q.y - Number(b.attr(\"y\"))], g && this.xAxis && !m && this.setDataLabelStartPos(a, b, h, k, p), b[h ? \"attr\" : \"animate\"](p)) : (g && this.xAxis && !m && this.setDataLabelStartPos(a, b, h, k, e), b.align(c, void 0, e), p = b.alignAttr);\n          if (m && 0 <= e.height) this.justifyDataLabel(b, c, p, q, e, h);else if (v(c.crop, !0)) {\n            let {\n              x: b,\n              y: a\n            } = p;\n            b += u[0];\n            a += u[1];\n            f = d.isInsidePlot(b, a, {\n              paneCoordinates: !0,\n              series: this\n            }) && d.isInsidePlot(b + q.width, a + q.height, {\n              paneCoordinates: !0,\n              series: this\n            });\n          }\n          if (c.shape && !l) b[h ? \"attr\" : \"animate\"]({\n            anchorX: n[0],\n            anchorY: n[1]\n          });\n        }\n        h && g && (b.placed = !1);\n        f || g && !m ? b.show() : (b.hide(), b.placed = !1);\n      }\n      function m(a, b) {\n        var c = b.filter;\n        return c ? (b = c.operator, a = a[c.property], c = c.value, \">\" === b && a > c || \"<\" === b && a < c || \">=\" === b && a >= c || \"<=\" === b && a <= c || \"==\" === b && a == c || \"===\" === b && a === c ? !0 : !1) : !0;\n      }\n      function J() {\n        return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n      }\n      function C(a) {\n        const b = this.hasRendered || 0,\n          c = this.initDataLabelsGroup().attr({\n            opacity: +b\n          });\n        !b && c && (this.visible && c.show(), this.options.animation ? c.animate({\n          opacity: 1\n        }, a) : c.attr({\n          opacity: 1\n        }));\n        return c;\n      }\n      function e(a = this.points) {\n        const b = this,\n          c = b.chart,\n          d = b.options,\n          e = c.renderer,\n          {\n            backgroundColor: h,\n            plotBackgroundColor: f\n          } = c.options.chart,\n          g = e.getContrast(r(f) && f || r(h) && h || \"#000000\");\n        let k = d.dataLabels,\n          q,\n          u;\n        var x = l(k)[0];\n        const C = x.animation;\n        x = x.defer ? y(c, C, b) : {\n          defer: 0,\n          duration: 0\n        };\n        k = w(w(c.options.plotOptions && c.options.plotOptions.series && c.options.plotOptions.series.dataLabels, c.options.plotOptions && c.options.plotOptions[b.type] && c.options.plotOptions[b.type].dataLabels), k);\n        B(this, \"drawDataLabels\");\n        if (t(k) || k.enabled || b._hasPointLabels) u = this.initDataLabels(x), a.forEach(a => {\n          q = l(w(k, a.dlOptions || a.options && a.options.dataLabels));\n          q.forEach((h, f) => {\n            const n = h.enabled && (!a.isNull || a.dataLabelOnNull) && m(a, h),\n              k = a.connectors ? a.connectors[f] : a.connector;\n            let l,\n              q,\n              w = a.dataLabels ? a.dataLabels[f] : a.dataLabel,\n              x = !w;\n            const r = v(h.distance, a.labelDistance);\n            if (n) {\n              var G = a.getLabelConfig();\n              var t = v(h[a.formatPrefix + \"Format\"], h.format);\n              G = D(t) ? A(t, G, c) : (h[a.formatPrefix + \"Formatter\"] || h.formatter).call(G, h);\n              t = h.style;\n              l = h.rotation;\n              c.styledMode || (t.color = v(h.color, t.color, b.color, \"#000000\"), \"contrast\" === t.color ? (a.contrastColor = e.getContrast(a.color || b.color), t.color = !D(r) && h.inside || 0 > r || d.stacking ? a.contrastColor : g) : delete a.contrastColor, d.cursor && (t.cursor = d.cursor));\n              q = {\n                r: h.borderRadius || 0,\n                rotation: l,\n                padding: h.padding,\n                zIndex: 1\n              };\n              if (!c.styledMode) {\n                const {\n                  backgroundColor: b,\n                  borderColor: c\n                } = h;\n                q.fill = \"auto\" === b ? a.color : b;\n                q.stroke = \"auto\" === c ? a.color : c;\n                q[\"stroke-width\"] = h.borderWidth;\n              }\n              p(q, function (b, a) {\n                \"undefined\" === typeof b && delete q[a];\n              });\n            }\n            !w || n && D(G) && !!w.div === !!h.useHTML && (w.rotation && h.rotation || w.rotation === h.rotation) || (x = !0, a.dataLabel = w = a.dataLabel && a.dataLabel.destroy(), a.dataLabels && (1 === a.dataLabels.length ? delete a.dataLabels : delete a.dataLabels[f]), f || delete a.dataLabel, k && (a.connector = a.connector.destroy(), a.connectors && (1 === a.connectors.length ? delete a.connectors : delete a.connectors[f])));\n            n && D(G) ? (w ? q.text = G : (a.dataLabels = a.dataLabels || [], w = a.dataLabels[f] = l ? e.text(G, 0, 0, h.useHTML).addClass(\"highcharts-data-label\") : e.label(G, 0, 0, h.shape, null, null, h.useHTML, null, \"data-label\"), f || (a.dataLabel = w), w.addClass(\" highcharts-data-label-color-\" + a.colorIndex + \" \" + (h.className || \"\") + (h.useHTML ? \" highcharts-tracker\" : \"\"))), w.options = h, w.attr(q), c.styledMode || w.css(t).shadow(h.shadow), (f = h[a.formatPrefix + \"TextPath\"] || h.textPath) && !h.useHTML && (w.setTextPath(a.getDataLabelPath && a.getDataLabelPath(w) || a.graphic, f), a.dataLabelPath && !f.enabled && (a.dataLabelPath = a.dataLabelPath.destroy())), w.added || w.add(u), b.alignDataLabel(a, w, h, null, x)) : w && w.hide();\n          });\n        });\n        B(this, \"afterDrawDataLabels\");\n      }\n      function h(a, b, c, e, h, f) {\n        const d = this.chart,\n          g = b.align,\n          n = b.verticalAlign,\n          k = a.box ? 0 : a.padding || 0;\n        let {\n            x: l = 0,\n            y: q = 0\n          } = b,\n          m,\n          u;\n        m = (c.x || 0) + k;\n        0 > m && (\"right\" === g && 0 <= l ? (b.align = \"left\", b.inside = !0) : l -= m, u = !0);\n        m = (c.x || 0) + e.width - k;\n        m > d.plotWidth && (\"left\" === g && 0 >= l ? (b.align = \"right\", b.inside = !0) : l += d.plotWidth - m, u = !0);\n        m = c.y + k;\n        0 > m && (\"bottom\" === n && 0 <= q ? (b.verticalAlign = \"top\", b.inside = !0) : q -= m, u = !0);\n        m = (c.y || 0) + e.height - k;\n        m > d.plotHeight && (\"top\" === n && 0 >= q ? (b.verticalAlign = \"bottom\", b.inside = !0) : q += d.plotHeight - m, u = !0);\n        u && (b.x = l, b.y = q, a.placed = !f, a.align(b, void 0, h));\n        return u;\n      }\n      function w(a, b) {\n        let c = [],\n          d;\n        if (t(a) && !t(b)) c = a.map(function (a) {\n          return g(a, b);\n        });else if (t(b) && !t(a)) c = b.map(function (b) {\n          return g(a, b);\n        });else if (t(a) || t(b)) for (d = Math.max(a.length, b.length); d--;) c[d] = g(a[d], b[d]);else c = g(a, b);\n        return c;\n      }\n      function q(a, b, c, e, h) {\n        const d = this.chart,\n          f = d.inverted,\n          g = this.xAxis,\n          n = g.reversed,\n          k = f ? b.height / 2 : b.width / 2;\n        a = (a = a.pointWidth) ? a / 2 : 0;\n        b.startXPos = f ? h.x : n ? -k - a : g.width - k + a;\n        b.startYPos = f ? n ? this.yAxis.height - k + a : -k - a : h.y;\n        e ? \"hidden\" === b.visibility && (b.show(), b.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : b.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, b.hide);\n        d.hasRendered && (c && b.attr({\n          x: b.startXPos,\n          y: b.startYPos\n        }), b.placed = !0);\n      }\n      const u = [];\n      a.compose = function (a) {\n        F.pushUnique(u, a) && (a = a.prototype, a.initDataLabelsGroup = J, a.initDataLabels = C, a.alignDataLabel = f, a.drawDataLabels = e, a.justifyDataLabel = h, a.setDataLabelStartPos = q);\n      };\n    })(m || (m = {}));\n    \"\";\n    return m;\n  });\n  L(a, \"Series/Column/ColumnDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        series: y\n      } = z,\n      {\n        merge: A,\n        pick: D\n      } = F;\n    var E;\n    (function (B) {\n      function t(a, p, v, l, m) {\n        let f = this.chart.inverted;\n        var g = a.series;\n        let x = (g.xAxis ? g.xAxis.len : this.chart.plotSizeX) || 0;\n        g = (g.yAxis ? g.yAxis.len : this.chart.plotSizeY) || 0;\n        var r = a.dlBox || a.shapeArgs;\n        let t = D(a.below, a.plotY > D(this.translatedThreshold, g)),\n          e = D(v.inside, !!this.options.stacking);\n        r && (l = A(r), 0 > l.y && (l.height += l.y, l.y = 0), r = l.y + l.height - g, 0 < r && r < l.height && (l.height -= r), f && (l = {\n          x: g - l.y - l.height,\n          y: x - l.x - l.width,\n          width: l.height,\n          height: l.width\n        }), e || (f ? (l.x += t ? 0 : l.width, l.width = 0) : (l.y += t ? l.height : 0, l.height = 0)));\n        v.align = D(v.align, !f || e ? \"center\" : t ? \"right\" : \"left\");\n        v.verticalAlign = D(v.verticalAlign, f || e ? \"middle\" : t ? \"top\" : \"bottom\");\n        y.prototype.alignDataLabel.call(this, a, p, v, l, m);\n        v.inside && a.contrastColor && p.css({\n          color: a.contrastColor\n        });\n      }\n      const r = [];\n      B.compose = function (g) {\n        a.compose(y);\n        F.pushUnique(r, g) && (g.prototype.alignDataLabel = t);\n      };\n    })(E || (E = {}));\n    return E;\n  });\n  L(a, \"Series/Bar/BarSeries.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n      extend: y,\n      merge: A\n    } = F;\n    class D extends a {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n    }\n    D.defaultOptions = A(a.defaultOptions, {});\n    y(D.prototype, {\n      inverted: !0\n    });\n    z.registerSeriesType(\"bar\", D);\n    \"\";\n    return D;\n  });\n  L(a, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    };\n  });\n  L(a, \"Series/Scatter/ScatterSeries.js\", [a[\"Series/Scatter/ScatterSeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        column: y,\n        line: A\n      } = z.seriesTypes,\n      {\n        addEvent: D,\n        extend: E,\n        merge: B\n      } = F;\n    class t extends A {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      applyJitter() {\n        const a = this,\n          g = this.options.jitter,\n          p = this.points.length;\n        g && this.points.forEach(function (r, l) {\n          [\"x\", \"y\"].forEach(function (m, f) {\n            let k = \"plot\" + m.toUpperCase(),\n              x,\n              v;\n            if (g[m] && !r.isNull) {\n              var t = a[m + \"Axis\"];\n              v = g[m] * t.transA;\n              t && !t.isLog && (x = Math.max(0, r[k] - v), t = Math.min(t.len, r[k] + v), f = 1E4 * Math.sin(l + f * p), f -= Math.floor(f), r[k] = x + (t - x) * f, \"x\" === m && (r.clientX = r.plotX));\n            }\n          });\n        });\n      }\n      drawGraph() {\n        this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());\n      }\n    }\n    t.defaultOptions = B(A.defaultOptions, a);\n    E(t.prototype, {\n      drawTracker: y.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    D(t, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    z.registerSeriesType(\"scatter\", t);\n    return t;\n  });\n  L(a, \"Series/CenteredUtilities.js\", [a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        deg2rad: y\n      } = a,\n      {\n        fireEvent: A,\n        isNumber: D,\n        pick: E,\n        relativeLength: B\n      } = F;\n    var t = /*#__PURE__*/(() => {\n      (function (a) {\n        a.getCenter = function () {\n          var a = this.options,\n            p = this.chart;\n          const r = 2 * (a.slicedOffset || 0),\n            l = p.plotWidth - 2 * r,\n            m = p.plotHeight - 2 * r;\n          var f = a.center;\n          const k = Math.min(l, m),\n            x = a.thickness;\n          var t = a.size;\n          let y = a.innerSize || 0;\n          \"string\" === typeof t && (t = parseFloat(t));\n          \"string\" === typeof y && (y = parseFloat(y));\n          a = [E(f[0], \"50%\"), E(f[1], \"50%\"), E(t && 0 > t ? void 0 : a.size, \"100%\"), E(y && 0 > y ? void 0 : a.innerSize || 0, \"0%\")];\n          !p.angular || this instanceof z || (a[3] = 0);\n          for (f = 0; 4 > f; ++f) t = a[f], p = 2 > f || 2 === f && /%$/.test(t), a[f] = B(t, [l, m, k, a[2]][f]) + (p ? r : 0);\n          a[3] > a[2] && (a[3] = a[2]);\n          D(x) && 2 * x < a[2] && 0 < x && (a[3] = a[2] - 2 * x);\n          A(this, \"afterGetCenter\", {\n            positions: a\n          });\n          return a;\n        };\n        a.getStartAndEndRadians = function (a, p) {\n          a = D(a) ? a : 0;\n          p = D(p) && p > a && 360 > p - a ? p : a + 360;\n          return {\n            start: y * (a + -90),\n            end: y * (p + -90)\n          };\n        };\n      })(t || (t = {}));\n      return t;\n    })();\n    \"\";\n    return t;\n  });\n  L(a, \"Series/Pie/PiePoint.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        setAnimation: y\n      } = a,\n      {\n        addEvent: A,\n        defined: D,\n        extend: E,\n        isNumber: B,\n        pick: t,\n        relativeLength: r\n      } = F;\n    class g extends z {\n      constructor() {\n        super(...arguments);\n        this.series = this.options = this.labelDistance = void 0;\n      }\n      getConnectorPath() {\n        const a = this.labelPosition,\n          g = this.series.options.dataLabels,\n          l = this.connectorShapes;\n        let m = g.connectorShape;\n        l[m] && (m = l[m]);\n        return m.call(this, {\n          x: a.computed.x,\n          y: a.computed.y,\n          alignment: a.alignment\n        }, a.connectorPosition, g);\n      }\n      getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      }\n      haloPath(a) {\n        const g = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(g.x, g.y, g.r + a, g.r + a, {\n          innerR: g.r - 1,\n          start: g.start,\n          end: g.end,\n          borderRadius: g.borderRadius\n        });\n      }\n      init() {\n        super.init.apply(this, arguments);\n        this.name = t(this.name, \"Slice\");\n        const a = a => {\n          this.slice(\"select\" === a.type);\n        };\n        A(this, \"select\", a);\n        A(this, \"unselect\", a);\n        return this;\n      }\n      isValid() {\n        return B(this.y) && 0 <= this.y;\n      }\n      setVisible(a, g) {\n        const l = this.series,\n          m = l.chart,\n          f = l.options.ignoreHiddenPoint;\n        g = t(g, f);\n        a !== this.visible && (this.visible = this.options.visible = a = \"undefined\" === typeof a ? !this.visible : a, l.options.data[l.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\"].forEach(f => {\n          if (this[f]) this[f][a ? \"show\" : \"hide\"](a);\n        }), this.legendItem && m.legend.colorizeItem(this, a), a || \"hover\" !== this.state || this.setState(\"\"), f && (l.isDirty = !0), g && m.redraw());\n      }\n      slice(a, g, l) {\n        const m = this.series;\n        y(l, m.chart);\n        t(g, !0);\n        this.sliced = this.options.sliced = D(a) ? a : !this.sliced;\n        m.options.data[m.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n      }\n    }\n    E(g.prototype, {\n      connectorShapes: {\n        fixedOffset: function (a, g, l) {\n          const m = g.breakAt;\n          g = g.touchingSliceAt;\n          return [[\"M\", a.x, a.y], l.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * m.x - g.x, 2 * m.y - g.y, m.x, m.y] : [\"L\", m.x, m.y], [\"L\", g.x, g.y]];\n        },\n        straight: function (a, g) {\n          g = g.touchingSliceAt;\n          return [[\"M\", a.x, a.y], [\"L\", g.x, g.y]];\n        },\n        crookedLine: function (a, g, l) {\n          const {\n            breakAt: m,\n            touchingSliceAt: f\n          } = g;\n          ({\n            series: g\n          } = this);\n          const [k, p, v] = g.center,\n            t = v / 2,\n            e = g.chart.plotWidth,\n            h = g.chart.plotLeft;\n          g = \"left\" === a.alignment;\n          const {\n            x: w,\n            y: q\n          } = a;\n          l.crookDistance ? (a = r(l.crookDistance, 1), a = g ? k + t + (e + h - k - t) * (1 - a) : h + (k - t) * a) : a = k + (p - q) * Math.tan((this.angle || 0) - Math.PI / 2);\n          l = [[\"M\", w, q]];\n          (g ? a <= w && a >= m.x : a >= w && a <= m.x) && l.push([\"L\", a, q]);\n          l.push([\"L\", m.x, m.y], [\"L\", f.x, f.y]);\n          return l;\n        }\n      }\n    });\n    return g;\n  });\n  L(a, \"Series/Pie/PieSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"crookedLine\",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  });\n  L(a, \"Series/Pie/PieSeries.js\", [a[\"Series/CenteredUtilities.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Globals.js\"], a[\"Series/Pie/PiePoint.js\"], a[\"Series/Pie/PieSeriesDefaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D, E, B, t) {\n    const {\n      getStartAndEndRadians: r\n    } = a;\n    ({\n      noop: F\n    } = F);\n    const {\n      clamp: g,\n      extend: p,\n      fireEvent: v,\n      merge: l,\n      pick: m,\n      relativeLength: f\n    } = t;\n    class k extends D {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.maxLabelDistance = this.data = this.center = void 0;\n      }\n      animate(a) {\n        const f = this,\n          g = f.points,\n          e = f.startAngleRad;\n        a || g.forEach(function (a) {\n          const h = a.graphic,\n            g = a.shapeArgs;\n          h && g && (h.attr({\n            r: m(a.startR, f.center && f.center[3] / 2),\n            start: e,\n            end: e\n          }), h.animate({\n            r: g.r,\n            start: g.start,\n            end: g.end\n          }, f.options.animation));\n        });\n      }\n      drawEmpty() {\n        const a = this.startAngleRad,\n          f = this.endAngleRad,\n          g = this.options;\n        let e, h;\n        0 === this.total && this.center ? (e = this.center[0], h = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(e, h, this.center[1] / 2, 0, a, f).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n          d: B.arc(e, h, this.center[2] / 2, 0, {\n            start: a,\n            end: f,\n            innerR: this.center[3] / 2\n          })\n        }), this.chart.styledMode || this.graph.attr({\n          \"stroke-width\": g.borderWidth,\n          fill: g.fillColor || \"none\",\n          stroke: g.color || \"#cccccc\"\n        })) : this.graph && (this.graph = this.graph.destroy());\n      }\n      drawPoints() {\n        const a = this.chart.renderer;\n        this.points.forEach(function (f) {\n          f.graphic && f.hasNewShapeType() && (f.graphic = f.graphic.destroy());\n          f.graphic || (f.graphic = a[f.shapeType](f.shapeArgs).add(f.series.group), f.delayedRendering = !0);\n        });\n      }\n      generatePoints() {\n        super.generatePoints();\n        this.updateTotals();\n      }\n      getX(a, f, k) {\n        const e = this.center,\n          h = this.radii ? this.radii[k.index] || 0 : e[2] / 2;\n        a = Math.asin(g((a - e[1]) / (h + k.labelDistance), -1, 1));\n        return e[0] + (f ? -1 : 1) * Math.cos(a) * (h + k.labelDistance) + (0 < k.labelDistance ? (f ? -1 : 1) * this.options.dataLabels.padding : 0);\n      }\n      hasData() {\n        return !!this.processedXData.length;\n      }\n      redrawPoints() {\n        const a = this,\n          f = a.chart;\n        let g, e, h, k;\n        this.drawEmpty();\n        a.group && !f.styledMode && a.group.shadow(a.options.shadow);\n        a.points.forEach(function (q) {\n          const m = {};\n          e = q.graphic;\n          !q.isNull && e ? (k = q.shapeArgs, g = q.getTranslate(), f.styledMode || (h = a.pointAttribs(q, q.selected && \"select\")), q.delayedRendering ? (e.setRadialReference(a.center).attr(k).attr(g), f.styledMode || e.attr(h).attr({\n            \"stroke-linejoin\": \"round\"\n          }), q.delayedRendering = !1) : (e.setRadialReference(a.center), f.styledMode || l(!0, m, h), l(!0, m, k, g), e.animate(m)), e.attr({\n            visibility: q.visible ? \"inherit\" : \"hidden\"\n          }), e.addClass(q.getClassName(), !0)) : e && (q.graphic = e.destroy());\n        });\n      }\n      sortByAngle(a, f) {\n        a.sort(function (a, e) {\n          return \"undefined\" !== typeof a.angle && (e.angle - a.angle) * f;\n        });\n      }\n      translate(a) {\n        v(this, \"translate\");\n        this.generatePoints();\n        var g = this.options;\n        const k = g.slicedOffset,\n          e = k + (g.borderWidth || 0);\n        var h = r(g.startAngle, g.endAngle);\n        const l = this.startAngleRad = h.start;\n        h = (this.endAngleRad = h.end) - l;\n        const q = this.points,\n          u = g.dataLabels.distance;\n        g = g.ignoreHiddenPoint;\n        const d = q.length;\n        let b,\n          c,\n          n,\n          p = 0;\n        a || (this.center = a = this.getCenter());\n        for (c = 0; c < d; c++) {\n          n = q[c];\n          var x = l + p * h;\n          !n.isValid() || g && !n.visible || (p += n.percentage / 100);\n          var t = l + p * h;\n          var y = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * x) / 1E3,\n            end: Math.round(1E3 * t) / 1E3\n          };\n          n.shapeType = \"arc\";\n          n.shapeArgs = y;\n          n.labelDistance = m(n.options.dataLabels && n.options.dataLabels.distance, u);\n          n.labelDistance = f(n.labelDistance, y.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, n.labelDistance);\n          t = (t + x) / 2;\n          t > 1.5 * Math.PI ? t -= 2 * Math.PI : t < -Math.PI / 2 && (t += 2 * Math.PI);\n          n.slicedTranslation = {\n            translateX: Math.round(Math.cos(t) * k),\n            translateY: Math.round(Math.sin(t) * k)\n          };\n          y = Math.cos(t) * a[2] / 2;\n          b = Math.sin(t) * a[2] / 2;\n          n.tooltipPos = [a[0] + .7 * y, a[1] + .7 * b];\n          n.half = t < -Math.PI / 2 || t > Math.PI / 2 ? 1 : 0;\n          n.angle = t;\n          x = Math.min(e, n.labelDistance / 5);\n          n.labelPosition = {\n            natural: {\n              x: a[0] + y + Math.cos(t) * n.labelDistance,\n              y: a[1] + b + Math.sin(t) * n.labelDistance\n            },\n            computed: {},\n            alignment: 0 > n.labelDistance ? \"center\" : n.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + y + Math.cos(t) * x,\n                y: a[1] + b + Math.sin(t) * x\n              },\n              touchingSliceAt: {\n                x: a[0] + y,\n                y: a[1] + b\n              }\n            }\n          };\n        }\n        v(this, \"afterTranslate\");\n      }\n      updateTotals() {\n        const a = this.points,\n          f = a.length,\n          g = this.options.ignoreHiddenPoint;\n        let e,\n          h,\n          k = 0;\n        for (e = 0; e < f; e++) h = a[e], !h.isValid() || g && !h.visible || (k += h.y);\n        this.total = k;\n        for (e = 0; e < f; e++) h = a[e], h.percentage = 0 < k && (h.visible || !g) ? h.y / k * 100 : 0, h.total = k;\n      }\n    }\n    k.defaultOptions = l(D.defaultOptions, A);\n    p(k.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: z.prototype.drawTracker,\n      getCenter: a.getCenter,\n      getSymbol: F,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: z.prototype.pointAttribs,\n      pointClass: H,\n      requireSorting: !1,\n      searchPoint: F,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    E.registerSeriesType(\"pie\", k);\n    return k;\n  });\n  L(a, \"Series/Pie/PieDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A) {\n    const {\n        noop: y\n      } = z,\n      {\n        distribute: E\n      } = F,\n      {\n        series: B\n      } = H,\n      {\n        arrayMax: t,\n        clamp: r,\n        defined: g,\n        merge: p,\n        pick: v,\n        relativeLength: l\n      } = A;\n    var m;\n    (function (f) {\n      function k() {\n        const a = this,\n          e = a.data,\n          f = a.chart,\n          k = a.options.dataLabels || {},\n          d = k.connectorPadding,\n          b = f.plotWidth,\n          c = f.plotHeight,\n          n = f.plotLeft,\n          l = Math.round(f.chartWidth / 3),\n          m = a.center,\n          r = m[2] / 2,\n          x = m[1],\n          y = [[], []],\n          P = [0, 0, 0, 0],\n          C = a.dataLabelPositioners;\n        let O, J, z, A, D, F, H, L, S, aa, U, Z;\n        a.visible && (k.enabled || a._hasPointLabels) && (e.forEach(function (b) {\n          b.dataLabel && b.visible && b.dataLabel.shortened && (b.dataLabel.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), b.dataLabel.shortened = !1);\n        }), B.prototype.drawDataLabels.apply(a), e.forEach(function (b) {\n          b.dataLabel && (b.visible ? (y[b.half].push(b), b.dataLabel._pos = null, !g(k.style.width) && !g(b.options.dataLabels && b.options.dataLabels.style && b.options.dataLabels.style.width) && b.dataLabel.getBBox().width > l && (b.dataLabel.css({\n            width: Math.round(.7 * l) + \"px\"\n          }), b.dataLabel.shortened = !0)) : (b.dataLabel = b.dataLabel.destroy(), b.dataLabels && 1 === b.dataLabels.length && delete b.dataLabels));\n        }), y.forEach((e, h) => {\n          const l = e.length,\n            q = [];\n          let u,\n            p = 0;\n          if (l) {\n            a.sortByAngle(e, h - .5);\n            if (0 < a.maxLabelDistance) {\n              var w = Math.max(0, x - r - a.maxLabelDistance);\n              u = Math.min(x + r + a.maxLabelDistance, f.plotHeight);\n              e.forEach(function (b) {\n                0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, x - r - b.labelDistance), b.bottom = Math.min(x + r + b.labelDistance, f.plotHeight), p = b.dataLabel.getBBox().height || 21, b.distributeBox = {\n                  target: b.labelPosition.natural.y - b.top + p / 2,\n                  size: p,\n                  rank: b.y\n                }, q.push(b.distributeBox));\n              });\n              w = u + p - w;\n              E(q, w, w / 5);\n            }\n            for (U = 0; U < l; U++) {\n              O = e[U];\n              F = O.labelPosition;\n              A = O.dataLabel;\n              aa = !1 === O.visible ? \"hidden\" : \"inherit\";\n              S = w = F.natural.y;\n              q && g(O.distributeBox) && (\"undefined\" === typeof O.distributeBox.pos ? aa = \"hidden\" : (H = O.distributeBox.size, S = C.radialDistributionY(O)));\n              delete O.positionIndex;\n              if (k.justify) L = C.justify(O, r, m);else switch (k.alignTo) {\n                case \"connectors\":\n                  L = C.alignToConnectors(e, h, b, n);\n                  break;\n                case \"plotEdges\":\n                  L = C.alignToPlotEdges(A, h, b, n);\n                  break;\n                default:\n                  L = C.radialDistributionX(a, O, S, w);\n              }\n              A._attr = {\n                visibility: aa,\n                align: F.alignment\n              };\n              Z = O.options.dataLabels || {};\n              A._pos = {\n                x: L + v(Z.x, k.x) + ({\n                  left: d,\n                  right: -d\n                }[F.alignment] || 0),\n                y: S + v(Z.y, k.y) - A.getBBox().height / 2\n              };\n              F && (F.computed.x = L, F.computed.y = S);\n              v(k.crop, !0) && (D = A.getBBox().width, w = null, L - D < d && 1 === h ? (w = Math.round(D - L + d), P[3] = Math.max(w, P[3])) : L + D > b - d && 0 === h && (w = Math.round(L + D - b + d), P[1] = Math.max(w, P[1])), 0 > S - H / 2 ? P[0] = Math.max(Math.round(-S + H / 2), P[0]) : S + H / 2 > c && (P[2] = Math.max(Math.round(S + H / 2 - c), P[2])), A.sideOverflow = w);\n            }\n          }\n        }), 0 === t(P) || this.verifyDataLabelOverflow(P)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n          Z = p(k, b.options.dataLabels);\n          if (J = v(Z.connectorWidth, 1)) {\n            let c;\n            z = b.connector;\n            if ((A = b.dataLabel) && A._pos && b.visible && 0 < b.labelDistance) {\n              aa = A._attr.visibility;\n              if (c = !z) b.connector = z = f.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(a.dataLabelsGroup), f.styledMode || z.attr({\n                \"stroke-width\": J,\n                stroke: Z.connectorColor || b.color || \"#666666\"\n              });\n              z[c ? \"attr\" : \"animate\"]({\n                d: b.getConnectorPath()\n              });\n              z.attr(\"visibility\", aa);\n            } else z && (b.connector = z.destroy());\n          }\n        }));\n      }\n      function m() {\n        this.points.forEach(function (a) {\n          let e = a.dataLabel,\n            h;\n          e && a.visible && ((h = e._pos) ? (e.sideOverflow && (e._attr.width = Math.max(e.getBBox().width - e.sideOverflow, 0), e.css({\n            width: e._attr.width + \"px\",\n            textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n          }), e.shortened = !0), e.attr(e._attr), e[e.moved ? \"animate\" : \"attr\"](h), e.moved = !0) : e && e.attr({\n            y: -9999\n          }));\n          delete a.distributeBox;\n        }, this);\n      }\n      function J(a) {\n        let e = this.center,\n          h = this.options,\n          f = h.center,\n          d = h.minSize || 80,\n          b,\n          c = null !== h.size;\n        c || (null !== f[0] ? b = Math.max(e[2] - Math.max(a[1], a[3]), d) : (b = Math.max(e[2] - a[1] - a[3], d), e[0] += (a[3] - a[1]) / 2), null !== f[1] ? b = r(b, d, e[2] - Math.max(a[0], a[2])) : (b = r(b, d, e[2] - a[0] - a[2]), e[1] += (a[0] - a[2]) / 2), b < e[2] ? (e[2] = b, e[3] = Math.min(h.thickness ? Math.max(0, b - 2 * h.thickness) : Math.max(0, l(h.innerSize || 0, b)), b), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : c = !0);\n        return c;\n      }\n      const C = [],\n        e = {\n          radialDistributionY: function (a) {\n            return a.top + a.distributeBox.pos;\n          },\n          radialDistributionX: function (a, e, f, g) {\n            return a.getX(f < e.top + 2 || f > e.bottom - 2 ? g : f, e.half, e);\n          },\n          justify: function (a, e, f) {\n            return f[0] + (a.half ? -1 : 1) * (e + a.labelDistance);\n          },\n          alignToPlotEdges: function (a, e, f, g) {\n            a = a.getBBox().width;\n            return e ? a + g : f - a - g;\n          },\n          alignToConnectors: function (a, e, f, g) {\n            let d = 0,\n              b;\n            a.forEach(function (a) {\n              b = a.dataLabel.getBBox().width;\n              b > d && (d = b);\n            });\n            return e ? d + g : f - d - g;\n          }\n        };\n      f.compose = function (f) {\n        a.compose(B);\n        A.pushUnique(C, f) && (f = f.prototype, f.dataLabelPositioners = e, f.alignDataLabel = y, f.drawDataLabels = k, f.placeDataLabels = m, f.verifyDataLabelOverflow = J);\n      };\n    })(m || (m = {}));\n    return m;\n  });\n  L(a, \"Extensions/OverlappingDataLabels.js\", [a[\"Core/Chart/Chart.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    function y(a, g) {\n      let p,\n        r = !1;\n      a && (p = a.newOpacity, a.oldOpacity !== p && (a.alignAttr && a.placed ? (a[p ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), r = !0, a.alignAttr.opacity = p, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, function () {\n        g.styledMode || a.css({\n          pointerEvents: p ? \"auto\" : \"none\"\n        });\n      }), A(g, \"afterHideOverlappingLabel\")) : a.attr({\n        opacity: p\n      })), a.isOld = !0);\n      return r;\n    }\n    const {\n      addEvent: H,\n      fireEvent: A,\n      isArray: D,\n      isNumber: E,\n      objectEach: B,\n      pick: t\n    } = z;\n    H(a, \"render\", function () {\n      let a = this,\n        g = [];\n      (this.labelCollectors || []).forEach(function (a) {\n        g = g.concat(a());\n      });\n      (this.yAxis || []).forEach(function (a) {\n        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && B(a.stacking.stacks, function (a) {\n          B(a, function (a) {\n            a.label && g.push(a.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (p) {\n        var r = p.options.dataLabels;\n        p.visible && (!1 !== r.enabled || p._hasPointLabels) && (r = l => l.forEach(l => {\n          l.visible && (D(l.dataLabels) ? l.dataLabels : l.dataLabel ? [l.dataLabel] : []).forEach(function (f) {\n            const k = f.options;\n            f.labelrank = t(k.labelrank, l.labelrank, l.shapeArgs && l.shapeArgs.height);\n            k.allowOverlap ? (f.oldOpacity = f.opacity, f.newOpacity = 1, y(f, a)) : g.push(f);\n          });\n        }), r(p.nodes || []), r(p.points));\n      });\n      this.hideOverlappingLabels(g);\n    });\n    a.prototype.hideOverlappingLabels = function (a) {\n      let g = this,\n        p = a.length,\n        r = g.renderer;\n      var l;\n      let m;\n      let f,\n        k,\n        x,\n        t = !1;\n      var C = function (a) {\n        let e, f;\n        var g;\n        let k = a.box ? 0 : a.padding || 0,\n          d = g = 0,\n          b,\n          c;\n        if (a && (!a.alignAttr || a.placed)) return e = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, f = a.parentGroup, a.width || (g = a.getBBox(), a.width = g.width, a.height = g.height, g = r.fontMetrics(a.element).h), b = a.width - 2 * k, (c = {\n          left: \"0\",\n          center: \"0.5\",\n          right: \"1\"\n        }[a.alignValue]) ? d = +c * b : E(a.x) && Math.round(a.x) !== a.translateX && (d = a.x - a.translateX), {\n          x: e.x + (f.translateX || 0) + k - (d || 0),\n          y: e.y + (f.translateY || 0) + k - g,\n          width: a.width - 2 * k,\n          height: a.height - 2 * k\n        };\n      };\n      for (m = 0; m < p; m++) if (l = a[m]) l.oldOpacity = l.opacity, l.newOpacity = 1, l.absoluteBox = C(l);\n      a.sort(function (a, f) {\n        return (f.labelrank || 0) - (a.labelrank || 0);\n      });\n      for (m = 0; m < p; m++) for (k = (C = a[m]) && C.absoluteBox, l = m + 1; l < p; ++l) x = (f = a[l]) && f.absoluteBox, !k || !x || C === f || 0 === C.newOpacity || 0 === f.newOpacity || \"hidden\" === C.visibility || \"hidden\" === f.visibility || x.x >= k.x + k.width || x.x + x.width <= k.x || x.y >= k.y + k.height || x.y + x.height <= k.y || ((C.labelrank < f.labelrank ? C : f).newOpacity = 0);\n      a.forEach(function (a) {\n        y(a, g) && (t = !0);\n      });\n      t && A(g, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  L(a, \"Extensions/BorderRadius.js\", [a[\"Core/Defaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D) {\n    const {\n      defaultOptions: y\n    } = a;\n    ({\n      seriesTypes: a\n    } = F);\n    const {\n        addEvent: B,\n        extend: t,\n        isObject: r,\n        merge: g,\n        relativeLength: p\n      } = D,\n      v = {\n        radius: 0,\n        scope: \"stack\",\n        where: void 0\n      },\n      l = (a, f) => {\n        r(a) || (a = {\n          radius: a || 0\n        });\n        return g(v, f, a);\n      };\n    if (-1 === H.symbolCustomAttribs.indexOf(\"borderRadius\")) {\n      H.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\");\n      const g = A.prototype.symbols.arc;\n      A.prototype.symbols.arc = function (a, f, l, m, e = {}) {\n        a = g(a, f, l, m, e);\n        const {\n          innerR: h = 0,\n          r: k = l,\n          start: q = 0,\n          end: u = 0\n        } = e;\n        if (e.open || !e.borderRadius) return a;\n        l = u - q;\n        f = Math.sin(l / 2);\n        e = Math.max(Math.min(p(e.borderRadius || 0, k - h), (k - h) / 2, k * f / (1 + f)), 0);\n        l = Math.min(e, l / Math.PI * 2 * h);\n        for (f = a.length - 1; f--;) {\n          {\n            let h = void 0,\n              g = void 0,\n              k = void 0;\n            m = a;\n            var d = f,\n              b = 1 < f ? l : e,\n              c = m[d],\n              n = m[d + 1];\n            \"Z\" === n[0] && (n = m[0]);\n            \"M\" !== c[0] && \"L\" !== c[0] || \"A\" !== n[0] ? \"A\" !== c[0] || \"M\" !== n[0] && \"L\" !== n[0] || (k = n, g = c) : (k = c, g = n, h = !0);\n            if (k && g && g.params) {\n              c = g[1];\n              var r = g[5];\n              n = g.params;\n              const {\n                start: a,\n                end: e,\n                cx: f,\n                cy: l\n              } = n;\n              var x = r ? c - b : c + b;\n              const q = x ? Math.asin(b / x) : 0;\n              r = r ? q : -q;\n              x *= Math.cos(q);\n              h ? (n.start = a + r, k[1] = f + x * Math.cos(a), k[2] = l + x * Math.sin(a), m.splice(d + 1, 0, [\"A\", b, b, 0, 0, 1, f + c * Math.cos(n.start), l + c * Math.sin(n.start)])) : (n.end = e - r, g[6] = f + c * Math.cos(n.end), g[7] = l + c * Math.sin(n.end), m.splice(d + 1, 0, [\"A\", b, b, 0, 0, 1, f + x * Math.cos(e), l + x * Math.sin(e)]));\n              g[4] = Math.abs(n.end - n.start) < Math.PI ? 0 : 1;\n            }\n          }\n        }\n        return a;\n      };\n      const f = A.prototype.symbols.roundedRect;\n      A.prototype.symbols.roundedRect = function (a, g, l, m, e = {}) {\n        const h = f(a, g, l, m, e),\n          {\n            r: k = 0,\n            brBoxHeight: q = m,\n            brBoxY: u = g\n          } = e;\n        var d = g - u,\n          b = u + q - (g + m);\n        e = -.1 < d - k ? 0 : k;\n        const c = -.1 < b - k ? 0 : k;\n        var n = Math.max(e && d, 0);\n        const p = Math.max(c && b, 0);\n        b = [a + e, g];\n        d = [a + l - e, g];\n        const r = [a + l, g + e],\n          x = [a + l, g + m - c],\n          v = [a + l - c, g + m],\n          t = [a + c, g + m],\n          P = [a, g + m - c],\n          y = [a, g + e];\n        if (n) {\n          const a = Math.sqrt(Math.pow(e, 2) - Math.pow(e - n, 2));\n          b[0] -= a;\n          d[0] += a;\n          r[1] = y[1] = g + e - n;\n        }\n        m < e - n && (n = Math.sqrt(Math.pow(e, 2) - Math.pow(e - n - m, 2)), r[0] = x[0] = a + l - e + n, v[0] = Math.min(r[0], v[0]), t[0] = Math.max(x[0], t[0]), P[0] = y[0] = a + e - n, r[1] = y[1] = g + m);\n        p && (n = Math.sqrt(Math.pow(c, 2) - Math.pow(c - p, 2)), v[0] += n, t[0] -= n, x[1] = P[1] = g + m - c + p);\n        m < c - p && (m = Math.sqrt(Math.pow(c, 2) - Math.pow(c - p - m, 2)), r[0] = x[0] = a + l - c + m, d[0] = Math.min(r[0], d[0]), b[0] = Math.max(x[0], b[0]), P[0] = y[0] = a + c - m, x[1] = P[1] = g);\n        h.length = 0;\n        h.push([\"M\", ...b], [\"L\", ...d], [\"A\", e, e, 0, 0, 1, ...r], [\"L\", ...x], [\"A\", c, c, 0, 0, 1, ...v], [\"L\", ...t], [\"A\", c, c, 0, 0, 1, ...P], [\"L\", ...y], [\"A\", e, e, 0, 0, 1, ...b], [\"Z\"]);\n        return h;\n      };\n      B(a.pie, \"afterTranslate\", function () {\n        const a = l(this.options.borderRadius);\n        for (const f of this.points) {\n          const g = f.shapeArgs;\n          g && (g.borderRadius = p(a.radius, (g.r || 0) - (g.innerR || 0)));\n        }\n      });\n      B(z, \"afterColumnTranslate\", function () {\n        var a, f;\n        if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {\n          const {\n              options: h,\n              yAxis: k\n            } = this,\n            q = \"percent\" === h.stacking;\n          var g = null === (f = null === (a = y.plotOptions) || void 0 === a ? void 0 : a[this.type]) || void 0 === f ? void 0 : f.borderRadius;\n          a = l(h.borderRadius, r(g) ? g : {});\n          f = k.options.reversed;\n          for (const l of this.points) if (({\n            shapeArgs: g\n          } = l), \"roundedRect\" === l.shapeType && g) {\n            const {\n              width: d = 0,\n              height: b = 0,\n              y: c = 0\n            } = g;\n            var m = c,\n              e = b;\n            \"stack\" === a.scope && l.stackTotal && (m = k.translate(q ? 100 : l.stackTotal, !1, !0, !1, !0), e = k.translate(h.threshold || 0, !1, !0, !1, !0), e = this.crispCol(0, Math.min(m, e), 0, Math.abs(m - e)), m = e.y, e = e.height);\n            const n = -1 === (l.negative ? -1 : 1) * (f ? -1 : 1);\n            let u = a.where;\n            !u && this.is(\"waterfall\") && Math.abs((l.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (u = \"all\");\n            u || (u = \"end\");\n            const r = Math.min(p(a.radius, d), d / 2, \"all\" === u ? b / 2 : Infinity) || 0;\n            \"end\" === u && (n && (m -= r), e += r);\n            t(g, {\n              brBoxHeight: e,\n              brBoxY: m,\n              r\n            });\n          }\n        }\n      }, {\n        order: 9\n      });\n    }\n    z = {\n      optionsToObject: l\n    };\n    \"\";\n    return z;\n  });\n  L(a, \"Core/Responsive.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      extend: y,\n      find: F,\n      isArray: H,\n      isObject: A,\n      merge: D,\n      objectEach: E,\n      pick: B,\n      splat: t,\n      uniqueKey: r\n    } = a;\n    var g;\n    (function (g) {\n      function p(a) {\n        function f(a, h, k, l) {\n          let e;\n          E(a, function (a, b) {\n            if (!l && -1 < g.collectionsWithUpdate.indexOf(b) && h[b]) for (a = t(a), k[b] = [], e = 0; e < Math.max(a.length, h[b].length); e++) h[b][e] && (void 0 === a[e] ? k[b][e] = h[b][e] : (k[b][e] = {}, f(a[e], h[b][e], k[b][e], l + 1)));else A(a) ? (k[b] = H(a) ? [] : {}, f(a, h[b] || {}, k[b], l + 1)) : k[b] = \"undefined\" === typeof h[b] ? null : h[b];\n          });\n        }\n        const g = this,\n          k = {};\n        f(a, this.options, k, 0);\n        return k;\n      }\n      function l(a, f) {\n        const g = a.condition;\n        (g.callback || function () {\n          return this.chartWidth <= B(g.maxWidth, Number.MAX_VALUE) && this.chartHeight <= B(g.maxHeight, Number.MAX_VALUE) && this.chartWidth >= B(g.minWidth, 0) && this.chartHeight >= B(g.minHeight, 0);\n        }).call(this) && f.push(a._id);\n      }\n      function m(a, f) {\n        const g = this.options.responsive;\n        var k = this.currentResponsive;\n        let e = [];\n        !f && g && g.rules && g.rules.forEach(a => {\n          \"undefined\" === typeof a._id && (a._id = r());\n          this.matchResponsiveRule(a, e);\n        }, this);\n        f = D(...e.map(a => F((g || {}).rules || [], e => e._id === a)).map(a => a && a.chartOptions));\n        f.isResponsiveOptions = !0;\n        e = e.toString() || void 0;\n        e !== (k && k.ruleIds) && (k && this.update(k.undoOptions, a, !0), e ? (k = this.currentOptions(f), k.isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: e,\n          mergedOptions: f,\n          undoOptions: k\n        }, this.update(f, a, !0)) : this.currentResponsive = void 0);\n      }\n      const f = [];\n      g.compose = function (g) {\n        a.pushUnique(f, g) && y(g.prototype, {\n          currentOptions: p,\n          matchResponsiveRule: l,\n          setResponsive: m\n        });\n        return g;\n      };\n    })(g || (g = {}));\n    \"\";\n    \"\";\n    return g;\n  });\n  L(a, \"masters/highcharts.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Animation/Fx.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Renderer/HTML/HTMLElement.js\"], a[\"Core/Renderer/HTML/HTMLRenderer.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Axis/DateTimeAxis.js\"], a[\"Core/Axis/LogarithmicAxis.js\"], a[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Tooltip.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Pointer.js\"], a[\"Core/Legend/Legend.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Axis/Stacking/StackingAxis.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Series/Column/ColumnDataLabel.js\"], a[\"Series/Pie/PieSeries.js\"], a[\"Series/Pie/PieDataLabel.js\"], a[\"Core/Series/DataLabel.js\"], a[\"Core/Responsive.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Time.js\"]], function (a, z, F, H, A, D, E, B, t, r, g, p, v, l, m, f, k, x, J, C, e, h, w, q, u, d, b, c, n, G, I, K, T, R) {\n    a.animate = A.animate;\n    a.animObject = A.animObject;\n    a.getDeferredAnimation = A.getDeferredAnimation;\n    a.setAnimation = A.setAnimation;\n    a.stop = A.stop;\n    a.timers = H.timers;\n    a.AST = D;\n    a.Axis = v;\n    a.Chart = h;\n    a.chart = h.chart;\n    a.Fx = H;\n    a.Legend = e;\n    a.PlotLineOrBand = f;\n    a.Point = J;\n    a.Pointer = C;\n    a.Series = u;\n    a.StackItem = q;\n    a.SVGElement = t;\n    a.SVGRenderer = r;\n    a.Tick = k;\n    a.Time = R;\n    a.Tooltip = x;\n    a.Color = T;\n    a.color = T.parse;\n    p.compose(r);\n    g.compose(t);\n    C.compose(h);\n    e.compose(h);\n    a.defaultOptions = F.defaultOptions;\n    a.getOptions = F.getOptions;\n    a.time = F.defaultTime;\n    a.setOptions = F.setOptions;\n    a.dateFormat = E.dateFormat;\n    a.format = E.format;\n    a.numberFormat = E.numberFormat;\n    a.addEvent = z.addEvent;\n    a.arrayMax = z.arrayMax;\n    a.arrayMin = z.arrayMin;\n    a.attr = z.attr;\n    a.clearTimeout = z.clearTimeout;\n    a.correctFloat = z.correctFloat;\n    a.createElement = z.createElement;\n    a.css = z.css;\n    a.defined = z.defined;\n    a.destroyObjectProperties = z.destroyObjectProperties;\n    a.discardElement = z.discardElement;\n    a.distribute = B.distribute;\n    a.erase = z.erase;\n    a.error = z.error;\n    a.extend = z.extend;\n    a.extendClass = z.extendClass;\n    a.find = z.find;\n    a.fireEvent = z.fireEvent;\n    a.getMagnitude = z.getMagnitude;\n    a.getStyle = z.getStyle;\n    a.inArray = z.inArray;\n    a.isArray = z.isArray;\n    a.isClass = z.isClass;\n    a.isDOMElement = z.isDOMElement;\n    a.isFunction = z.isFunction;\n    a.isNumber = z.isNumber;\n    a.isObject = z.isObject;\n    a.isString = z.isString;\n    a.keys = z.keys;\n    a.merge = z.merge;\n    a.normalizeTickInterval = z.normalizeTickInterval;\n    a.objectEach = z.objectEach;\n    a.offset = z.offset;\n    a.pad = z.pad;\n    a.pick = z.pick;\n    a.pInt = z.pInt;\n    a.relativeLength = z.relativeLength;\n    a.removeEvent = z.removeEvent;\n    a.seriesType = d.seriesType;\n    a.splat = z.splat;\n    a.stableSort = z.stableSort;\n    a.syncTimeout = z.syncTimeout;\n    a.timeUnits = z.timeUnits;\n    a.uniqueKey = z.uniqueKey;\n    a.useSerialIds = z.useSerialIds;\n    a.wrap = z.wrap;\n    c.compose(b);\n    I.compose(u);\n    l.compose(v);\n    m.compose(v);\n    G.compose(n);\n    f.compose(v);\n    K.compose(h);\n    w.compose(v, h, u);\n    x.compose(C);\n    return a;\n  });\n  L(a, \"Core/Axis/NavigatorAxisComposition.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    function y() {\n      this.navigatorAxis || (this.navigatorAxis = new p(this));\n    }\n    function H(a) {\n      var g = this.chart.options,\n        m = g.navigator;\n      const f = this.navigatorAxis,\n        k = g.chart.zooming.pinchType,\n        p = g.rangeSelector;\n      g = g.chart.zooming.type;\n      this.isXAxis && (m && m.enabled || p && p.enabled) && (\"y\" === g ? a.zoomed = !1 : (!A && \"xy\" === g || A && \"xy\" === k) && this.options.range && (m = f.previousZoom, B(a.newMin) ? f.previousZoom = [this.min, this.max] : m && (a.newMin = m[0], a.newMax = m[1], f.previousZoom = void 0)));\n      \"undefined\" !== typeof a.zoomed && a.preventDefault();\n    }\n    const {\n        isTouchDevice: A\n      } = a,\n      {\n        addEvent: D,\n        correctFloat: E,\n        defined: B,\n        isNumber: t,\n        pick: r\n      } = z,\n      g = [];\n    class p {\n      static compose(a) {\n        z.pushUnique(g, a) && (a.keepProps.push(\"navigatorAxis\"), D(a, \"init\", y), D(a, \"zoom\", H));\n      }\n      constructor(a) {\n        this.axis = a;\n      }\n      destroy() {\n        this.axis = void 0;\n      }\n      toFixedRange(a, g, m, f) {\n        var k = this.axis,\n          l = k.chart;\n        a = r(m, k.translate(a, !0, !k.horiz));\n        g = r(f, k.translate(g, !0, !k.horiz));\n        l = l && l.fixedRange;\n        k = (k.pointRange || 0) / 2;\n        const p = l && (g - a) / l;\n        B(m) || (a = E(a + k));\n        B(f) || (g = E(g - k));\n        .7 < p && 1.3 > p && (f ? a = g - l : g = a + l);\n        t(a) && t(g) || (a = g = void 0);\n        return {\n          min: a,\n          max: g\n        };\n      }\n    }\n    return p;\n  });\n  L(a, \"Stock/Navigator/NavigatorDefaults.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"]], function (a, z) {\n    ({\n      parse: a\n    } = a);\n    ({\n      seriesTypes: z\n    } = z);\n    z = {\n      height: 40,\n      margin: 25,\n      maskInside: !0,\n      handles: {\n        width: 7,\n        height: 15,\n        symbols: [\"navigator-handle\", \"navigator-handle\"],\n        enabled: !0,\n        lineWidth: 1,\n        backgroundColor: \"#f2f2f2\",\n        borderColor: \"#999999\"\n      },\n      maskFill: a(\"#667aff\").setOpacity(.3).get(),\n      outlineColor: \"#999999\",\n      outlineWidth: 1,\n      series: {\n        type: \"undefined\" === typeof z.areaspline ? \"line\" : \"areaspline\",\n        fillOpacity: .05,\n        lineWidth: 1,\n        compare: null,\n        sonification: {\n          enabled: !1\n        },\n        dataGrouping: {\n          approximation: \"average\",\n          enabled: !0,\n          groupPixelWidth: 2,\n          firstAnchor: \"firstPoint\",\n          anchor: \"middle\",\n          lastAnchor: \"lastPoint\",\n          units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n        },\n        dataLabels: {\n          enabled: !1,\n          zIndex: 2\n        },\n        id: \"highcharts-navigator-series\",\n        className: \"highcharts-navigator-series\",\n        lineColor: null,\n        marker: {\n          enabled: !1\n        },\n        threshold: null\n      },\n      xAxis: {\n        overscroll: 0,\n        className: \"highcharts-navigator-xaxis\",\n        tickLength: 0,\n        lineWidth: 0,\n        gridLineColor: \"#e6e6e6\",\n        gridLineWidth: 1,\n        tickPixelInterval: 200,\n        labels: {\n          align: \"left\",\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            opacity: .6,\n            textOutline: \"2px contrast\"\n          },\n          x: 3,\n          y: -4\n        },\n        crosshair: !1\n      },\n      yAxis: {\n        className: \"highcharts-navigator-yaxis\",\n        gridLineWidth: 0,\n        startOnTick: !1,\n        endOnTick: !1,\n        minPadding: .1,\n        maxPadding: .1,\n        labels: {\n          enabled: !1\n        },\n        crosshair: !1,\n        title: {\n          text: null\n        },\n        tickLength: 0,\n        tickWidth: 0\n      }\n    };\n    \"\";\n    return z;\n  });\n  L(a, \"Stock/Navigator/NavigatorSymbols.js\", [], function () {\n    return {\n      \"navigator-handle\": function (a, z, F, H, A = {}) {\n        a = A.width ? A.width / 2 : F;\n        z = Math.round(a / 3) + .5;\n        H = A.height || H;\n        return [[\"M\", -a - 1, .5], [\"L\", a, .5], [\"L\", a, H + .5], [\"L\", -a - 1, H + .5], [\"L\", -a - 1, .5], [\"M\", -z, 4], [\"L\", -z, H - 3], [\"M\", z - 1, 4], [\"L\", z - 1, H - 3]];\n      }\n    };\n  });\n  L(a, \"Stock/Navigator/NavigatorComposition.js\", [a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/NavigatorAxisComposition.js\"], a[\"Stock/Navigator/NavigatorDefaults.js\"], a[\"Stock/Navigator/NavigatorSymbols.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D, E) {\n    function y() {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }\n    function t() {\n      var a;\n      const b = this.legend,\n        c = this.navigator;\n      let e, f, h;\n      if (c) {\n        e = b && b.options;\n        f = c.xAxis;\n        h = c.yAxis;\n        const {\n          scrollbarHeight: d,\n          scrollButtonSize: g\n        } = c;\n        this.inverted ? (c.left = c.opposite ? this.chartWidth - d - c.height : this.spacing[3] + d, c.top = this.plotTop + g) : (c.left = w(f.left, this.plotLeft + g), c.top = c.navigatorOptions.top || this.chartHeight - c.height - d - ((null === (a = this.scrollbar) || void 0 === a ? void 0 : a.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (e && \"bottom\" === e.verticalAlign && \"proximate\" !== e.layout && e.enabled && !e.floating ? b.legendHeight + w(e.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        f && h && (this.inverted ? f.options.left = h.options.left = c.left : f.options.top = h.options.top = c.top, f.setAxisSize(), h.setAxisSize());\n      }\n    }\n    function r(a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new u(this), w(a.redraw, !0) && this.redraw(a.animation));\n    }\n    function g() {\n      const a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new u(this);\n    }\n    function p() {\n      const a = this.options,\n        b = a.navigator,\n        c = a.rangeSelector;\n      if ((b && b.enabled || c && c.enabled) && (!x && \"x\" === a.chart.zooming.type || x && \"x\" === a.chart.zooming.pinchType)) return !1;\n    }\n    function v(a) {\n      const b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    }\n    function l(a) {\n      const b = a.options.navigator || {},\n        c = a.options.scrollbar || {};\n      this.navigator || this.scroller || !b.enabled && !c.enabled || (h(!0, this.options.navigator, b), h(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);\n    }\n    function m() {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }\n    const {\n        defaultOptions: f,\n        setOptions: k\n      } = a,\n      {\n        isTouchDevice: x\n      } = z,\n      {\n        getRendererType: J\n      } = D,\n      {\n        addEvent: C,\n        extend: e,\n        merge: h,\n        pick: w\n      } = E,\n      q = [];\n    let u;\n    return {\n      compose: function (a, b, c, h) {\n        F.compose(a);\n        u = c;\n        E.pushUnique(q, b) && (b.prototype.callbacks.push(v), C(b, \"afterAddSeries\", y), C(b, \"afterSetChartSize\", t), C(b, \"afterUpdate\", r), C(b, \"beforeRender\", g), C(b, \"beforeShowResetZoom\", p), C(b, \"update\", l));\n        E.pushUnique(q, h) && C(h, \"afterUpdate\", m);\n        E.pushUnique(q, J) && e(J().prototype.symbols, A);\n        E.pushUnique(q, k) && e(f, {\n          navigator: H\n        });\n      }\n    };\n  });\n  L(a, \"Core/Axis/ScrollbarAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n        addEvent: y,\n        defined: F,\n        pick: H\n      } = a,\n      A = [];\n    class D {\n      static compose(z, B) {\n        if (!a.pushUnique(A, z)) return z;\n        const t = a => {\n          const g = H(a.options && a.options.min, a.min),\n            p = H(a.options && a.options.max, a.max);\n          return {\n            axisMin: g,\n            axisMax: p,\n            scrollMin: F(a.dataMin) ? Math.min(g, a.min, a.dataMin, H(a.threshold, Infinity)) : g,\n            scrollMax: F(a.dataMax) ? Math.max(p, a.max, a.dataMax, H(a.threshold, -Infinity)) : p\n          };\n        };\n        y(z, \"afterInit\", function () {\n          const a = this;\n          a.options && a.options.scrollbar && a.options.scrollbar.enabled && (a.options.scrollbar.vertical = !a.horiz, a.options.startOnTick = a.options.endOnTick = !1, a.scrollbar = new B(a.chart.renderer, a.options.scrollbar, a.chart), y(a.scrollbar, \"changed\", function (g) {\n            let {\n              axisMin: p,\n              axisMax: r,\n              scrollMin: l,\n              scrollMax: m\n            } = t(a);\n            var f = m - l;\n            let k;\n            F(p) && F(r) && (a.horiz && !a.reversed || !a.horiz && a.reversed ? (k = l + f * this.to, f = l + f * this.from) : (k = l + f * (1 - this.from), f = l + f * (1 - this.to)), this.shouldUpdateExtremes(g.DOMType) ? a.setExtremes(f, k, !0, \"mousemove\" === g.DOMType || \"touchmove\" === g.DOMType ? !1 : void 0, g) : this.setRange(this.from, this.to));\n          }));\n        });\n        y(z, \"afterRender\", function () {\n          let {\n              scrollMin: a,\n              scrollMax: g\n            } = t(this),\n            p = this.scrollbar;\n          var v = this.axisTitleMargin + (this.titleOffset || 0),\n            l = this.chart.scrollbarsOffsets;\n          let m = this.options.margin || 0;\n          p && (this.horiz ? (this.opposite || (l[1] += v), p.position(this.left, this.top + this.height + 2 + l[1] - (this.opposite ? m : 0), this.width, this.height), this.opposite || (l[1] += m), v = 1) : (this.opposite && (l[0] += v), p.position(p.options.opposite ? this.left + this.width + 2 + l[0] - (this.opposite ? 0 : m) : this.opposite ? 0 : m, this.top, this.width, this.height), this.opposite && (l[0] += m), v = 0), l[v] += p.size + (p.options.margin || 0), isNaN(a) || isNaN(g) || !F(this.min) || !F(this.max) || this.min === this.max ? p.setRange(0, 1) : (l = (this.min - a) / (g - a), v = (this.max - a) / (g - a), this.horiz && !this.reversed || !this.horiz && this.reversed ? p.setRange(l, v) : p.setRange(1 - v, 1 - l)));\n        });\n        y(z, \"afterGetOffset\", function () {\n          const a = this.scrollbar;\n          var g = a && !a.options.opposite;\n          g = this.horiz ? 2 : g ? 3 : 1;\n          a && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[g] += a.size + (a.options.margin || 0));\n        });\n        return z;\n      }\n    }\n    return D;\n  });\n  L(a, \"Stock/Scrollbar/ScrollbarDefaults.js\", [a[\"Core/Globals.js\"]], function (a) {\n    return {\n      height: 10,\n      barBorderRadius: 5,\n      buttonBorderRadius: 0,\n      buttonsEnabled: !1,\n      liveRedraw: void 0,\n      margin: void 0,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 0,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"none\",\n      trackBackgroundColor: \"rgba(255, 255, 255, 0.001)\",\n      trackBorderColor: \"#cccccc\",\n      trackBorderRadius: 5,\n      trackBorderWidth: 1\n    };\n  });\n  L(a, \"Stock/Scrollbar/Scrollbar.js\", [a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/ScrollbarAxis.js\"], a[\"Stock/Scrollbar/ScrollbarDefaults.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A) {\n    const {\n        defaultOptions: y\n      } = a,\n      {\n        addEvent: E,\n        correctFloat: B,\n        defined: t,\n        destroyObjectProperties: r,\n        fireEvent: g,\n        merge: p,\n        pick: v,\n        removeEvent: l\n      } = A;\n    let m = /*#__PURE__*/(() => {\n      class m {\n        static compose(a) {\n          F.compose(a, m);\n        }\n        static swapXY(a, g) {\n          g && a.forEach(a => {\n            const f = a.length;\n            let g;\n            for (let e = 0; e < f; e += 2) g = a[e + 1], \"number\" === typeof g && (a[e + 1] = a[e + 2], a[e + 2] = g);\n          });\n          return a;\n        }\n        constructor(a, g, l) {\n          this._events = [];\n          this.chart = void 0;\n          this.from = this.chartY = this.chartX = 0;\n          this.scrollbar = this.renderer = this.options = this.group = void 0;\n          this.scrollbarButtons = [];\n          this.scrollbarGroup = void 0;\n          this.scrollbarLeft = 0;\n          this.scrollbarRifles = void 0;\n          this.scrollbarStrokeWidth = 1;\n          this.to = this.size = this.scrollbarTop = 0;\n          this.track = void 0;\n          this.trackBorderWidth = 1;\n          this.userOptions = void 0;\n          this.y = this.x = 0;\n          this.init(a, g, l);\n        }\n        addEvents() {\n          var a = this.options.inverted ? [1, 0] : [0, 1];\n          const g = this.scrollbarButtons,\n            l = this.scrollbarGroup.element,\n            m = this.track.element,\n            p = this.mouseDownHandler.bind(this),\n            e = this.mouseMoveHandler.bind(this),\n            h = this.mouseUpHandler.bind(this);\n          a = [[g[a[0]].element, \"click\", this.buttonToMinClick.bind(this)], [g[a[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [m, \"click\", this.trackClick.bind(this)], [l, \"mousedown\", p], [l.ownerDocument, \"mousemove\", e], [l.ownerDocument, \"mouseup\", h]];\n          z.hasTouch && a.push([l, \"touchstart\", p], [l.ownerDocument, \"touchmove\", e], [l.ownerDocument, \"touchend\", h]);\n          a.forEach(function (a) {\n            E.apply(null, a);\n          });\n          this._events = a;\n        }\n        buttonToMaxClick(a) {\n          const f = (this.to - this.from) * v(this.options.step, .2);\n          this.updatePosition(this.from + f, this.to + f);\n          g(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: a\n          });\n        }\n        buttonToMinClick(a) {\n          const f = B(this.to - this.from) * v(this.options.step, .2);\n          this.updatePosition(B(this.from - f), B(this.to - f));\n          g(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: a\n          });\n        }\n        cursorToScrollbarPosition(a) {\n          var f = this.options;\n          f = f.minWidth > this.calculatedWidth ? f.minWidth : 0;\n          return {\n            chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - f),\n            chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - f)\n          };\n        }\n        destroy() {\n          const a = this,\n            g = a.chart.scroller;\n          a.removeEvents();\n          [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (f) {\n            a[f] && a[f].destroy && (a[f] = a[f].destroy());\n          });\n          g && a === g.scrollbar && (g.scrollbar = null, r(g.scrollbarButtons));\n        }\n        drawScrollbarButton(a) {\n          const f = this.renderer,\n            g = this.scrollbarButtons,\n            l = this.options,\n            p = this.size;\n          var e = f.g().add(this.group);\n          g.push(e);\n          l.buttonsEnabled && (e = f.rect().addClass(\"highcharts-scrollbar-button\").add(e), this.chart.styledMode || e.attr({\n            stroke: l.buttonBorderColor,\n            \"stroke-width\": l.buttonBorderWidth,\n            fill: l.buttonBackgroundColor\n          }), e.attr(e.crisp({\n            x: -.5,\n            y: -.5,\n            width: p + 1,\n            height: p + 1,\n            r: l.buttonBorderRadius\n          }, e.strokeWidth())), a = f.path(m.swapXY([[\"M\", p / 2 + (a ? -1 : 1), p / 2 - 3], [\"L\", p / 2 + (a ? -1 : 1), p / 2 + 3], [\"L\", p / 2 + (a ? 2 : -2), p / 2]], l.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(g[a]), this.chart.styledMode || a.attr({\n            fill: l.buttonArrowColor\n          }));\n        }\n        init(a, g, l) {\n          this.scrollbarButtons = [];\n          this.renderer = a;\n          this.userOptions = g;\n          this.options = p(H, y.scrollbar, g);\n          this.options.margin = v(this.options.margin, 10);\n          this.chart = l;\n          this.size = v(this.options.size, this.options.height);\n          g.enabled && (this.render(), this.addEvents());\n        }\n        mouseDownHandler(a) {\n          a = this.chart.pointer.normalize(a);\n          a = this.cursorToScrollbarPosition(a);\n          this.chartX = a.chartX;\n          this.chartY = a.chartY;\n          this.initPositions = [this.from, this.to];\n          this.grabbedCenter = !0;\n        }\n        mouseMoveHandler(a) {\n          var f = this.chart.pointer.normalize(a),\n            l = this.options.vertical ? \"chartY\" : \"chartX\";\n          const m = this.initPositions || [];\n          !this.grabbedCenter || a.touches && 0 === a.touches[0][l] || (f = this.cursorToScrollbarPosition(f)[l], l = this[l], l = f - l, this.hasDragged = !0, this.updatePosition(m[0] + l, m[1] + l), this.hasDragged && g(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMType: a.type,\n            DOMEvent: a\n          }));\n        }\n        mouseUpHandler(a) {\n          this.hasDragged && g(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMType: a.type,\n            DOMEvent: a\n          });\n          this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n        }\n        position(a, g, l, m) {\n          const {\n              buttonsEnabled: f,\n              margin: e = 0,\n              vertical: h\n            } = this.options,\n            k = this.rendered ? \"animate\" : \"attr\";\n          let q = m,\n            u = 0;\n          this.group.show();\n          this.x = a;\n          this.y = g + this.trackBorderWidth;\n          this.width = l;\n          this.height = m;\n          this.xOffset = q;\n          this.yOffset = u;\n          h ? (this.width = this.yOffset = l = this.size, this.xOffset = q = 0, this.yOffset = u = f ? this.size : 0, this.barWidth = m - (f ? 2 * l : 0), this.x = a += e) : (this.height = m = this.size, this.xOffset = q = f ? this.size : 0, this.barWidth = l - (f ? 2 * m : 0), this.y += e);\n          this.group[k]({\n            translateX: a,\n            translateY: this.y\n          });\n          this.track[k]({\n            width: l,\n            height: m\n          });\n          this.scrollbarButtons[1][k]({\n            translateX: h ? 0 : l - q,\n            translateY: h ? m - u : 0\n          });\n        }\n        removeEvents() {\n          this._events.forEach(function (a) {\n            l.apply(null, a);\n          });\n          this._events.length = 0;\n        }\n        render() {\n          const a = this.renderer,\n            g = this.options,\n            l = this.size,\n            p = this.chart.styledMode,\n            r = a.g(\"scrollbar\").attr({\n              zIndex: g.zIndex\n            }).hide().add();\n          this.group = r;\n          this.track = a.rect().addClass(\"highcharts-scrollbar-track\").attr({\n            r: g.trackBorderRadius || 0,\n            height: l,\n            width: l\n          }).add(r);\n          p || this.track.attr({\n            fill: g.trackBackgroundColor,\n            stroke: g.trackBorderColor,\n            \"stroke-width\": g.trackBorderWidth\n          });\n          const e = this.trackBorderWidth = this.track.strokeWidth();\n          this.track.attr({\n            x: -e % 2 / 2,\n            y: -e % 2 / 2\n          });\n          this.scrollbarGroup = a.g().add(r);\n          this.scrollbar = a.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n            height: l - e,\n            width: l - e,\n            r: g.barBorderRadius || 0\n          }).add(this.scrollbarGroup);\n          this.scrollbarRifles = a.path(m.swapXY([[\"M\", -3, l / 4], [\"L\", -3, 2 * l / 3], [\"M\", 0, l / 4], [\"L\", 0, 2 * l / 3], [\"M\", 3, l / 4], [\"L\", 3, 2 * l / 3]], g.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n          p || (this.scrollbar.attr({\n            fill: g.barBackgroundColor,\n            stroke: g.barBorderColor,\n            \"stroke-width\": g.barBorderWidth\n          }), this.scrollbarRifles.attr({\n            stroke: g.rifleColor,\n            \"stroke-width\": 1\n          }));\n          this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n          this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n          this.drawScrollbarButton(0);\n          this.drawScrollbarButton(1);\n        }\n        setRange(a, g) {\n          const f = this.options,\n            k = f.vertical;\n          var l = f.minWidth,\n            e = this.barWidth;\n          const h = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n          if (t(e)) {\n            var m = e * Math.min(g, 1);\n            a = Math.max(a, 0);\n            var q = Math.ceil(e * a);\n            this.calculatedWidth = m = B(m - q);\n            m < l && (q = (e - l + m) * a, m = l);\n            l = Math.floor(q + this.xOffset + this.yOffset);\n            e = m / 2 - .5;\n            this.from = a;\n            this.to = g;\n            k ? (this.scrollbarGroup[h]({\n              translateY: l\n            }), this.scrollbar[h]({\n              height: m\n            }), this.scrollbarRifles[h]({\n              translateY: e\n            }), this.scrollbarTop = l, this.scrollbarLeft = 0) : (this.scrollbarGroup[h]({\n              translateX: l\n            }), this.scrollbar[h]({\n              width: m\n            }), this.scrollbarRifles[h]({\n              translateX: e\n            }), this.scrollbarLeft = l, this.scrollbarTop = 0);\n            12 >= m ? this.scrollbarRifles.hide() : this.scrollbarRifles.show();\n            !1 === f.showFull && (0 >= a && 1 <= g ? this.group.hide() : this.group.show());\n            this.rendered = !0;\n          }\n        }\n        shouldUpdateExtremes(a) {\n          return v(this.options.liveRedraw, z.svg && !z.isTouchDevice && !this.chart.boosted) || \"mouseup\" === a || \"touchend\" === a || !t(a);\n        }\n        trackClick(a) {\n          const f = this.chart.pointer.normalize(a),\n            l = this.to - this.from,\n            m = this.y + this.scrollbarTop,\n            p = this.x + this.scrollbarLeft;\n          this.options.vertical && f.chartY > m || !this.options.vertical && f.chartX > p ? this.updatePosition(this.from + l, this.to + l) : this.updatePosition(this.from - l, this.to - l);\n          g(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: a\n          });\n        }\n        update(a) {\n          this.destroy();\n          this.init(this.chart.renderer, p(!0, this.options, a), this.chart);\n        }\n        updatePosition(a, g) {\n          1 < g && (a = B(1 - B(g - a)), g = 1);\n          0 > a && (g = B(g - a), a = 0);\n          this.from = a;\n          this.to = g;\n        }\n      }\n      m.defaultOptions = H;\n      return m;\n    })();\n    y.scrollbar = p(!0, m.defaultOptions, y.scrollbar);\n    return m;\n  });\n  L(a, \"Stock/Navigator/Navigator.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/NavigatorAxisComposition.js\"], a[\"Stock/Navigator/NavigatorComposition.js\"], a[\"Stock/Scrollbar/Scrollbar.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D, E) {\n    function y(a, ...c) {\n      c = [].filter.call(c, e);\n      if (c.length) return Math[a].apply(0, c);\n    }\n    const {\n        defaultOptions: t\n      } = z,\n      {\n        hasTouch: r,\n        isTouchDevice: g\n      } = F,\n      {\n        addEvent: p,\n        clamp: v,\n        correctFloat: l,\n        defined: m,\n        destroyObjectProperties: f,\n        erase: k,\n        extend: x,\n        find: J,\n        isArray: C,\n        isNumber: e,\n        merge: h,\n        pick: w,\n        removeEvent: q,\n        splat: u\n      } = E;\n    class d {\n      static compose(a, c, e) {\n        A.compose(a, c, d, e);\n      }\n      constructor(a) {\n        this.rendered = this.range = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;\n        this.scrollbarHeight = 0;\n        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.scrollButtonSize = void 0;\n        this.init(a);\n      }\n      drawHandle(a, c, d, e) {\n        const b = this.navigatorOptions.handles.height;\n        this.handles[c][e](d ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - b)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - b / 2 - 1)\n        });\n      }\n      drawOutline(a, c, d, e) {\n        const b = this.navigatorOptions.maskInside;\n        var f = this.outline.strokeWidth();\n        const h = f / 2;\n        var g = f % 2 / 2;\n        const n = this.scrollButtonSize,\n          k = this.size,\n          l = this.top;\n        f = this.height;\n        const m = l - h,\n          q = l + f;\n        let u = this.left;\n        d ? (d = l + c + g, c = l + a + g, g = [[\"M\", u + f, l - n - g], [\"L\", u + f, d], [\"L\", u, d], [\"M\", u, c], [\"L\", u + f, c], [\"L\", u + f, l + k + n]], b && g.push([\"M\", u + f, d - h], [\"L\", u + f, c + h])) : (u -= n, a += u + n - g, c += u + n - g, g = [[\"M\", u, m], [\"L\", a, m], [\"L\", a, q], [\"M\", c, q], [\"L\", c, m], [\"L\", u + k + 2 * n, l + h]], b && g.push([\"M\", a - h, m], [\"L\", c + h, m]));\n        this.outline[e]({\n          d: g\n        });\n      }\n      drawMasks(a, c, d, e) {\n        const b = this.left,\n          f = this.top,\n          h = this.height;\n        let g, n, k, l;\n        d ? (k = [b, b, b], l = [f, f + a, f + c], n = [h, h, h], g = [a, c - a, this.size - c]) : (k = [b, b + a, b + c], l = [f, f, f], n = [a, c - a, this.size - c], g = [h, h, h]);\n        this.shades.forEach((a, b) => {\n          a[e]({\n            x: k[b],\n            y: l[b],\n            width: n[b],\n            height: g[b]\n          });\n        });\n      }\n      renderElements() {\n        const a = this,\n          c = a.navigatorOptions,\n          d = c.maskInside,\n          e = a.chart,\n          f = e.renderer,\n          h = {\n            cursor: e.inverted ? \"ns-resize\" : \"ew-resize\"\n          },\n          g = a.navigatorGroup = f.g(\"navigator\").attr({\n            zIndex: 8,\n            visibility: \"hidden\"\n          }).add();\n        [!d, d, !d].forEach((b, d) => {\n          const n = f.rect().addClass(\"highcharts-navigator-mask\" + (1 === d ? \"-inside\" : \"-outside\")).add(g);\n          e.styledMode || (n.attr({\n            fill: b ? c.maskFill : \"rgba(0,0,0,0)\"\n          }), 1 === d && n.css(h));\n          a.shades[d] = n;\n        });\n        a.outline = f.path().addClass(\"highcharts-navigator-outline\").add(g);\n        e.styledMode || a.outline.attr({\n          \"stroke-width\": c.outlineWidth,\n          stroke: c.outlineColor\n        });\n        if (c.handles && c.handles.enabled) {\n          const b = c.handles,\n            {\n              height: d,\n              width: n\n            } = b;\n          [0, 1].forEach(c => {\n            a.handles[c] = f.symbol(b.symbols[c], -n / 2 - 1, 0, n, d, b);\n            e.inverted && a.handles[c].attr({\n              rotation: 90,\n              rotationOriginX: Math.floor(-n / 2),\n              rotationOriginY: (d + n) / 2\n            });\n            a.handles[c].attr({\n              zIndex: 7 - c\n            }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(g);\n            e.styledMode || a.handles[c].attr({\n              fill: b.backgroundColor,\n              stroke: b.borderColor,\n              \"stroke-width\": b.lineWidth\n            }).css(h);\n          });\n        }\n      }\n      update(a) {\n        (this.series || []).forEach(a => {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        h(!0, this.chart.options.navigator, a);\n        this.init(this.chart);\n      }\n      render(a, c, d, f) {\n        var b = this.chart;\n        const h = this.xAxis,\n          g = h.pointRange || 0;\n        var n = h.navigatorAxis.fake ? b.xAxis[0] : h;\n        const k = this.navigatorEnabled;\n        var q = this.rendered,\n          u = b.inverted;\n        const p = b.xAxis[0].minRange,\n          r = b.xAxis[0].options.maxRange,\n          t = this.scrollButtonSize;\n        let x = this.scrollbarHeight,\n          G;\n        if (!this.hasDragged || m(d)) {\n          a = l(a - g / 2);\n          c = l(c + g / 2);\n          if (!e(a) || !e(c)) if (q) d = 0, f = w(h.width, n.width);else return;\n          this.left = w(h.left, b.plotLeft + t + (u ? b.plotWidth : 0));\n          var y = this.size = G = w(h.len, (u ? b.plotHeight : b.plotWidth) - 2 * t);\n          b = u ? x : G + 2 * t;\n          d = w(d, h.toPixels(a, !0));\n          f = w(f, h.toPixels(c, !0));\n          e(d) && Infinity !== Math.abs(d) || (d = 0, f = b);\n          a = h.toValue(d, !0);\n          c = h.toValue(f, !0);\n          var z = Math.abs(l(c - a));\n          z < p ? this.grabbedLeft ? d = h.toPixels(c - p - g, !0) : this.grabbedRight && (f = h.toPixels(a + p + g, !0)) : m(r) && l(z - g) > r && (this.grabbedLeft ? d = h.toPixels(c - r - g, !0) : this.grabbedRight && (f = h.toPixels(a + r + g, !0)));\n          this.zoomedMax = v(Math.max(d, f), 0, y);\n          this.zoomedMin = v(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(d, f), 0, y);\n          this.range = this.zoomedMax - this.zoomedMin;\n          y = Math.round(this.zoomedMax);\n          d = Math.round(this.zoomedMin);\n          k && (this.navigatorGroup.attr({\n            visibility: \"inherit\"\n          }), q = q && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(d, y, u, q), this.drawOutline(d, y, u, q), this.navigatorOptions.handles.enabled && (this.drawHandle(d, 0, u, q), this.drawHandle(y, 1, u, q)));\n          this.scrollbar && (u ? (u = this.top - t, n = this.left - x + (k || !n.opposite ? 0 : (n.titleOffset || 0) + n.axisTitleMargin), x = G + 2 * t) : (u = this.top + (k ? this.height : -x), n = this.left - t), this.scrollbar.position(n, u, b, x), this.scrollbar.setRange(this.zoomedMin / (G || 1), this.zoomedMax / (G || 1)));\n          this.rendered = !0;\n        }\n      }\n      addMouseEvents() {\n        const a = this,\n          c = a.chart,\n          d = c.container;\n        let e = [],\n          f,\n          h;\n        a.mouseMoveHandler = f = function (b) {\n          a.onMouseMove(b);\n        };\n        a.mouseUpHandler = h = function (b) {\n          a.onMouseUp(b);\n        };\n        e = a.getPartsEvents(\"mousedown\");\n        e.push(p(c.renderTo, \"mousemove\", f), p(d.ownerDocument, \"mouseup\", h));\n        r && (e.push(p(c.renderTo, \"touchmove\", f), p(d.ownerDocument, \"touchend\", h)), e.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = e;\n        a.series && a.series[0] && e.push(p(a.series[0].xAxis, \"foundExtremes\", function () {\n          c.navigator.modifyNavigatorAxisExtremes();\n        }));\n      }\n      getPartsEvents(a) {\n        const b = this,\n          d = [];\n        [\"shades\", \"handles\"].forEach(function (c) {\n          b[c].forEach(function (e, f) {\n            d.push(p(e.element, a, function (a) {\n              b[c + \"Mousedown\"](a, f);\n            }));\n          });\n        });\n        return d;\n      }\n      shadesMousedown(a, c) {\n        a = this.chart.pointer.normalize(a);\n        const b = this.chart,\n          d = this.xAxis,\n          e = this.zoomedMin,\n          f = this.size,\n          h = this.range;\n        let g = this.left,\n          k = a.chartX,\n          l,\n          q;\n        b.inverted && (k = a.chartY, g = this.top);\n        1 === c ? (this.grabbedCenter = k, this.fixedWidth = h, this.dragOffset = k - e) : (a = k - g - h / 2, 0 === c ? a = Math.max(0, a) : 2 === c && a + h >= f && (a = f - h, this.reversedExtremes ? (a -= h, q = this.getUnionExtremes().dataMin) : l = this.getUnionExtremes().dataMax), a !== e && (this.fixedWidth = h, c = d.navigatorAxis.toFixedRange(a, a + h, q, l), m(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, null, {\n          trigger: \"navigator\"\n        })));\n      }\n      handlesMousedown(a, c) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        const b = a.xAxis[0],\n          d = this.reversedExtremes;\n        0 === c ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? b.min : b.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? b.max : b.min);\n        a.fixedRange = null;\n      }\n      onMouseMove(a) {\n        const b = this;\n        var d = b.chart;\n        const e = b.navigatorSize,\n          f = b.range,\n          h = b.dragOffset,\n          k = d.inverted;\n        let l = b.left;\n        a.touches && 0 === a.touches[0].pageX || (a = d.pointer.normalize(a), d = a.chartX, k && (l = b.top, d = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, d - l, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, d - l)) : b.grabbedCenter && (b.hasDragged = !0, d < h ? d = h : d > e + h - f && (d = e + h - f), b.render(0, 0, d - h, d - h + f)), b.hasDragged && b.scrollbar && w(b.scrollbar.options.liveRedraw, !g && !this.chart.boosted) && (a.DOMType = a.type, setTimeout(function () {\n          b.onMouseUp(a);\n        }, 0)));\n      }\n      onMouseUp(a) {\n        var b = this.chart,\n          d = this.xAxis,\n          f = this.scrollbar;\n        const h = a.DOMEvent || a,\n          g = b.inverted,\n          k = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n        let l, q;\n        (!this.hasDragged || f && f.hasDragged) && \"scrollbar\" !== a.trigger || (f = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? l = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (q = this.fixedExtreme), this.zoomedMax === this.size && (q = this.reversedExtremes ? f.dataMin : f.dataMax), 0 === this.zoomedMin && (l = this.reversedExtremes ? f.dataMax : f.dataMin), d = d.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, l, q), m(d.min) && b.xAxis[0].setExtremes(Math.min(d.min, d.max), Math.max(d.min, d.max), !0, this.hasDragged ? !1 : null, {\n          trigger: \"navigator\",\n          triggerOp: \"navigator-drag\",\n          DOMEvent: h\n        }));\n        \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n        this.navigatorEnabled && e(this.zoomedMin) && e(this.zoomedMax) && (b = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a, g, k), this.outline && this.drawOutline(b, a, g, k), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, g, k), this.drawHandle(a, 1, g, k)));\n      }\n      removeEvents() {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      }\n      removeBaseSeriesEvents() {\n        const a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          q(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && q(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      }\n      init(b) {\n        var c = b.options,\n          d = c.navigator || {},\n          f = d.enabled,\n          g = c.scrollbar || {},\n          k = g.enabled;\n        c = f && d.height || 0;\n        var l = k && g.height || 0;\n        const m = g.buttonsEnabled && l || 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = b;\n        this.setBaseSeries();\n        this.height = c;\n        this.scrollbarHeight = l;\n        this.scrollButtonSize = m;\n        this.scrollbarEnabled = k;\n        this.navigatorEnabled = f;\n        this.navigatorOptions = d;\n        this.scrollbarOptions = g;\n        this.opposite = w(d.opposite, !(f || !b.inverted));\n        const q = this;\n        f = q.baseSeries;\n        g = b.xAxis.length;\n        k = b.yAxis.length;\n        l = f && f[0] && f[0].xAxis || b.xAxis[0] || {\n          options: {}\n        };\n        b.isDirtyBox = !0;\n        q.navigatorEnabled ? (q.xAxis = new a(b, h({\n          breaks: l.options.breaks,\n          ordinal: l.options.ordinal\n        }, d.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: g,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, b.inverted ? {\n          offsets: [m, 0, -m, 0],\n          width: c\n        } : {\n          offsets: [0, -m, 0, m],\n          height: c\n        })), q.yAxis = new a(b, h(d.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: k,\n          isInternal: !0,\n          reversed: w(d.yAxis && d.yAxis.reversed, b.yAxis[0] && b.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, b.inverted ? {\n          width: c\n        } : {\n          height: c\n        })), f || d.series.data ? q.updateNavigatorSeries(!1) : 0 === b.series.length && (q.unbindRedraw = p(b, \"beforeRedraw\", function () {\n          0 < b.series.length && !q.series && (q.setBaseSeries(), q.unbindRedraw());\n        })), q.reversedExtremes = b.inverted && !q.xAxis.reversed || !b.inverted && q.xAxis.reversed, q.renderElements(), q.addMouseEvents()) : (q.xAxis = {\n          chart: b,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function (a, c) {\n            var d = b.xAxis[0];\n            const e = d.getExtremes(),\n              f = d.len - 2 * m,\n              h = y(\"min\", d.options.min, e.dataMin);\n            d = y(\"max\", d.options.max, e.dataMax) - h;\n            return c ? a * d / f + h : f * (a - h) / d;\n          },\n          toPixels: function (a) {\n            return this.translate(a);\n          },\n          toValue: function (a) {\n            return this.translate(a, !0);\n          }\n        }, q.xAxis.navigatorAxis.axis = q.xAxis, q.xAxis.navigatorAxis.toFixedRange = H.prototype.toFixedRange.bind(q.xAxis.navigatorAxis));\n        b.options.scrollbar.enabled && (d = h(b.options.scrollbar, {\n          vertical: b.inverted\n        }), !e(d.margin) && q.navigatorEnabled && (d.margin = b.inverted ? -3 : 3), b.scrollbar = q.scrollbar = new D(b.renderer, d, b), p(q.scrollbar, \"changed\", function (a) {\n          var b = q.size;\n          const c = b * this.to;\n          b *= this.from;\n          q.hasDragged = q.scrollbar.hasDragged;\n          q.render(0, 0, b, c);\n          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {\n            q.onMouseUp(a);\n          });\n        }));\n        q.addBaseSeriesEvents();\n        q.addChartEvents();\n      }\n      getUnionExtremes(a) {\n        const b = this.chart.xAxis[0],\n          d = this.xAxis,\n          e = d.options,\n          f = b.options;\n        let h;\n        a && null === b.dataMin || (h = {\n          dataMin: w(e && e.min, y(\"min\", f.min, b.dataMin, d.dataMin, d.min)),\n          dataMax: w(e && e.max, y(\"max\", f.max, b.dataMax, d.dataMax, d.max))\n        });\n        return h;\n      }\n      setBaseSeries(a, c) {\n        const b = this.chart,\n          d = this.baseSeries = [];\n        a = a || b.options && b.options.navigator.baseSeries || (b.series.length ? J(b.series, a => !a.options.isInternal).index : 0);\n        (b.series || []).forEach((b, c) => {\n          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);\n        });\n        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, c);\n      }\n      updateNavigatorSeries(a, c) {\n        const b = this,\n          d = b.chart,\n          e = b.baseSeries,\n          f = {\n            enableMouseTracking: !1,\n            index: null,\n            linkedTo: null,\n            group: \"nav\",\n            padXAxis: !1,\n            xAxis: \"navigator-x-axis\",\n            yAxis: \"navigator-y-axis\",\n            showInLegend: !1,\n            stacking: void 0,\n            isInternal: !0,\n            states: {\n              inactive: {\n                opacity: 1\n              }\n            }\n          },\n          g = b.series = (b.series || []).filter(a => {\n            const c = a.baseSeries;\n            return 0 > e.indexOf(c) ? (c && (q(c, \"updatedData\", b.updatedDataHandler), delete c.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n          });\n        let k,\n          l,\n          m = b.navigatorOptions.series,\n          p;\n        e && e.length && e.forEach(a => {\n          const n = a.navigatorSeries;\n          var q = x({\n            color: a.color,\n            visible: a.visible\n          }, C(m) ? t.navigator.series : m);\n          n && !1 === b.navigatorOptions.adaptToUpdatedData || (f.name = \"Navigator \" + e.length, k = a.options || {}, p = k.navigatorOptions || {}, q.dataLabels = u(q.dataLabels), l = h(k, f, q, p), l.pointRange = w(q.pointRange, p.pointRange, t.plotOptions[l.type || \"line\"].pointRange), q = p.data || q.data, b.hasNavigatorData = b.hasNavigatorData || !!q, l.data = q || k.data && k.data.slice(0), n && n.options ? n.update(l, c) : (a.navigatorSeries = d.initSeries(l), a.navigatorSeries.baseSeries = a, g.push(a.navigatorSeries)));\n        });\n        if (m.data && (!e || !e.length) || C(m)) b.hasNavigatorData = !1, m = u(m), m.forEach((a, c) => {\n          f.name = \"Navigator \" + (g.length + 1);\n          l = h(t.navigator.series, {\n            color: d.series[c] && !d.series[c].options.isInternal && d.series[c].color || d.options.colors[c] || d.options.colors[0]\n          }, f, a);\n          l.data = a.data;\n          l.data && (b.hasNavigatorData = !0, g.push(d.initSeries(l)));\n        });\n        a && this.addBaseSeriesEvents();\n      }\n      addBaseSeriesEvents() {\n        const a = this,\n          c = a.baseSeries || [];\n        c[0] && c[0].xAxis && c[0].eventsToUnbind.push(p(c[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n        c.forEach(b => {\n          b.eventsToUnbind.push(p(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          }));\n          b.eventsToUnbind.push(p(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          }));\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(p(b, \"updatedData\", this.updatedDataHandler));\n          b.eventsToUnbind.push(p(b, \"remove\", function () {\n            this.navigatorSeries && (k(a.series, this.navigatorSeries), m(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          }));\n        });\n      }\n      getBaseSeriesMin(a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData && b.xData.length ? b.xData[0] : a);\n        }, a);\n      }\n      modifyNavigatorAxisExtremes() {\n        const a = this.xAxis;\n        if (\"undefined\" !== typeof a.getExtremes) {\n          const b = this.getUnionExtremes(!0);\n          !b || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax);\n        }\n      }\n      modifyBaseAxisExtremes() {\n        const a = this.chart.navigator;\n        var c = this.getExtremes();\n        const d = c.dataMin,\n          f = c.dataMax;\n        c = c.max - c.min;\n        const h = a.stickToMin,\n          g = a.stickToMax,\n          k = w(this.options.overscroll, 0),\n          l = a.series && a.series[0],\n          m = !!this.setExtremes;\n        let q, u;\n        this.eventArgs && \"rangeSelectorButton\" === this.eventArgs.trigger || (h && (u = d, q = u + c), g && (q = f + k, h || (u = Math.max(d, q - c, a.getBaseSeriesMin(l && l.xData ? l.xData[0] : -Number.MAX_VALUE)))), m && (h || g) && e(u) && (this.min = this.userMin = u, this.max = this.userMax = q));\n        a.stickToMin = a.stickToMax = null;\n      }\n      updatedDataHandler() {\n        const a = this.chart.navigator,\n          c = this.navigatorSeries;\n        a.stickToMax = w(this.chart.options.navigator && this.chart.options.navigator.stickToMax, a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size));\n        a.stickToMin = a.shouldStickToMin(this, a);\n        c && !a.hasNavigatorData && (c.options.pointStart = this.xData[0], c.setData(this.options.data, !1, null, !1));\n      }\n      shouldStickToMin(a, c) {\n        c = c.getBaseSeriesMin(a.xData[0]);\n        var b = a.xAxis;\n        a = b.max;\n        const d = b.min;\n        b = b.options.range;\n        return e(a) && e(d) ? b && 0 < a - c ? a - c < b : d <= c : !1;\n      }\n      addChartEvents() {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(p(this.chart, \"redraw\", function () {\n          const a = this.navigator,\n            c = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);\n          c && a.render(c.min, c.max);\n        }), p(this.chart, \"getMargins\", function () {\n          let a = this.navigator,\n            c = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (c = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[c] = (this[c] || 0) + (a.navigatorEnabled || !this.inverted ? a.height + a.scrollbarHeight : 0) + a.navigatorOptions.margin;\n        }));\n      }\n      destroy() {\n        this.removeEvents();\n        this.xAxis && (k(this.chart.xAxis, this.xAxis), k(this.chart.axes, this.xAxis));\n        this.yAxis && (k(this.chart.yAxis, this.yAxis), k(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(a => {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(a => {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        });\n        [this.handles].forEach(a => {\n          f(a);\n        });\n      }\n    }\n    return d;\n  });\n  L(a, \"Stock/RangeSelector/RangeSelectorDefaults.js\", [], function () {\n    return {\n      lang: {\n        rangeSelectorZoom: \"Zoom\",\n        rangeSelectorFrom: \"\",\n        rangeSelectorTo: \"\\u2192\"\n      },\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%e %b %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#334eff\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\"\n        },\n        labelStyle: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        }\n      }\n    };\n  });\n  L(a, \"Stock/RangeSelector/RangeSelectorComposition.js\", [a[\"Core/Defaults.js\"], a[\"Stock/RangeSelector/RangeSelectorDefaults.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    function y() {\n      const a = this.range,\n        e = a.type,\n        d = this.max,\n        b = this.chart.time,\n        c = function (a, c) {\n          const d = \"year\" === e ? \"FullYear\" : \"Month\",\n            f = new b.Date(a),\n            h = b.get(d, f);\n          b.set(d, f, h + c);\n          h === b.get(d, f) && b.set(\"Date\", f, 0);\n          return f.getTime() - a;\n        };\n      let f, h;\n      x(a) ? (f = d - a, h = a) : a && (f = d + c(d, -(a.count || 1)), this.chart && (this.chart.fixedRange = d - f));\n      const g = C(this.dataMin, Number.MIN_VALUE);\n      x(f) || (f = g);\n      f <= g && (f = g, \"undefined\" === typeof h && (h = c(f, a.count)), this.newMax = Math.min(f + h, C(this.dataMax, Number.MAX_VALUE)));\n      x(d) ? !x(a) && a && a._offsetMin && (f += a._offsetMin) : f = void 0;\n      return f;\n    }\n    function A() {\n      this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new w(this));\n    }\n    function D() {\n      var a = this.axes;\n      const e = this.rangeSelector;\n      e && (x(e.deferredYTDClick) && (e.clickButton(e.deferredYTDClick), delete e.deferredYTDClick), a.forEach(a => {\n        a.updateNames();\n        a.setScale();\n      }), this.getAxisMargins(), e.render(), a = e.options.verticalAlign, e.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n    }\n    function E(a) {\n      let f, d, b, c;\n      const h = a.rangeSelector,\n        g = () => {\n          h && (f = a.xAxis[0].getExtremes(), d = a.legend, c = h && h.options.verticalAlign, x(f.min) && h.render(f.min, f.max), d.display && \"top\" === c && c === d.options.verticalAlign && (b = J(a.spacingBox), b.y = \"vertical\" === d.options.layout ? a.plotTop : b.y + h.getHeight(), d.group.placed = !1, d.align(b)));\n        };\n      h && (k(e, b => b[0] === a) || e.push([a, [l(a.xAxis[0], \"afterSetExtremes\", function (a) {\n        h && h.render(a.min, a.max);\n      }), l(a, \"redraw\", g)]]), g());\n    }\n    function B() {\n      for (let a = 0, f = e.length; a < f; ++a) {\n        const d = e[a];\n        if (d[0] === this) {\n          d[1].forEach(a => a());\n          e.splice(a, 1);\n          break;\n        }\n      }\n    }\n    function t() {\n      var a = this.rangeSelector;\n      a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n    }\n    function r() {\n      var a = this.rangeSelector;\n      a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n    }\n    function g(a) {\n      var e = a.options.rangeSelector;\n      a = this.extraBottomMargin;\n      const d = this.extraTopMargin;\n      let b = this.rangeSelector;\n      e && e.enabled && !m(b) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = b = new w(this));\n      this.extraTopMargin = this.extraBottomMargin = !1;\n      b && (E(this), e = e && e.verticalAlign || b.options && b.options.verticalAlign, b.options.floating || (\"bottom\" === e ? this.extraBottomMargin = !0 : \"middle\" !== e && (this.extraTopMargin = !0)), this.extraBottomMargin !== a || this.extraTopMargin !== d) && (this.isDirtyBox = !0);\n    }\n    const {\n        defaultOptions: p,\n        setOptions: v\n      } = a,\n      {\n        addEvent: l,\n        defined: m,\n        extend: f,\n        find: k,\n        isNumber: x,\n        merge: J,\n        pick: C\n      } = F,\n      e = [],\n      h = [];\n    let w;\n    return {\n      compose: function (a, e, d) {\n        w = d;\n        F.pushUnique(h, a) && (a.prototype.minFromRange = y);\n        F.pushUnique(h, e) && (l(e, \"afterGetContainer\", A), l(e, \"beforeRender\", D), l(e, \"destroy\", B), l(e, \"getMargins\", t), l(e, \"render\", r), l(e, \"update\", g), e.prototype.callbacks.push(E));\n        F.pushUnique(h, v) && (f(p, {\n          rangeSelector: z.rangeSelector\n        }), f(p.lang, z.lang));\n      }\n    };\n  });\n  L(a, \"Stock/RangeSelector/RangeSelector.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Stock/RangeSelector/RangeSelectorComposition.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D) {\n    function y(a) {\n      if (-1 !== a.indexOf(\"%L\")) return \"text\";\n      const d = \"aAdewbBmoyY\".split(\"\").some(b => -1 !== a.indexOf(\"%\" + b)),\n        b = \"HkIlMS\".split(\"\").some(b => -1 !== a.indexOf(\"%\" + b));\n      return d && b ? \"datetime-local\" : d ? \"date\" : b ? \"time\" : \"text\";\n    }\n    const {\n        defaultOptions: B\n      } = z,\n      {\n        addEvent: t,\n        createElement: r,\n        css: g,\n        defined: p,\n        destroyObjectProperties: v,\n        discardElement: l,\n        extend: m,\n        fireEvent: f,\n        isNumber: k,\n        merge: x,\n        objectEach: J,\n        pad: C,\n        pick: e,\n        pInt: h,\n        splat: w\n      } = D;\n    class q {\n      static compose(a, d) {\n        H.compose(a, d, q);\n      }\n      constructor(a) {\n        this.buttons = void 0;\n        this.buttonOptions = q.prototype.defaultButtons;\n        this.initialButtonGroupWidth = 0;\n        this.options = void 0;\n        this.chart = a;\n        this.init(a);\n      }\n      clickButton(h, d) {\n        const b = this.chart,\n          c = this.buttonOptions[h],\n          g = b.xAxis[0];\n        var l = b.scroller && b.scroller.getUnionExtremes() || g || {},\n          m = c.type;\n        const q = c.dataGrouping;\n        let u = l.dataMin,\n          r = l.dataMax,\n          v,\n          x = g && Math.round(Math.min(g.max, e(r, g.max))),\n          y;\n        l = c._range;\n        let z,\n          B,\n          C,\n          A = !0;\n        if (null !== u && null !== r) {\n          b.fixedRange = l;\n          this.setSelected(h);\n          q && (this.forcedDataGrouping = !0, a.prototype.setDataGrouping.call(g || {\n            chart: this.chart\n          }, q, !1), this.frozenStates = c.preserveDataGrouping);\n          if (\"month\" === m || \"year\" === m) g ? (m = {\n            range: c,\n            max: x,\n            chart: b,\n            dataMin: u,\n            dataMax: r\n          }, v = g.minFromRange.call(m), k(m.newMax) && (x = m.newMax), A = !1) : l = c;else if (l) v = Math.max(x - l, u), x = Math.min(v + l, r), A = !1;else if (\"ytd\" === m) {\n            if (g) {\n              if (\"undefined\" === typeof r || \"undefined\" === typeof u) u = Number.MAX_VALUE, r = Number.MIN_VALUE, b.series.forEach(a => {\n                if (a = a.xData) u = Math.min(a[0], u), r = Math.max(a[a.length - 1], r);\n              }), d = !1;\n              m = this.getYTDExtremes(r, u, b.time.useUTC);\n              v = z = m.min;\n              x = m.max;\n            } else {\n              this.deferredYTDClick = h;\n              return;\n            }\n          } else \"all\" === m && g && (b.navigator && b.navigator.baseSeries[0] && (b.navigator.baseSeries[0].xAxis.options.range = void 0), v = u, x = r);\n          A && c._offsetMin && p(v) && (v += c._offsetMin);\n          c._offsetMax && p(x) && (x += c._offsetMax);\n          this.dropdown && (this.dropdown.selectedIndex = h + 1);\n          g ? g.setExtremes(v, x, e(d, !0), void 0, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: c\n          }) : (y = w(b.options.xAxis)[0], C = y.range, y.range = l, B = y.min, y.min = z, t(b, \"load\", function () {\n            y.range = C;\n            y.min = B;\n          }));\n          f(this, \"afterBtnClick\");\n        }\n      }\n      setSelected(a) {\n        this.selected = this.options.selected = a;\n      }\n      init(a) {\n        const d = this,\n          b = a.options.rangeSelector,\n          c = b.buttons || d.defaultButtons.slice(),\n          e = b.selected,\n          h = function () {\n            const a = d.minInput,\n              b = d.maxInput;\n            a && a.blur && f(a, \"blur\");\n            b && b.blur && f(b, \"blur\");\n          };\n        d.chart = a;\n        d.options = b;\n        d.buttons = [];\n        d.buttonOptions = c;\n        this.eventsToUnbind = [];\n        this.eventsToUnbind.push(t(a.container, \"mousedown\", h));\n        this.eventsToUnbind.push(t(a, \"resize\", h));\n        c.forEach(d.computeButtonRange);\n        \"undefined\" !== typeof e && c[e] && this.clickButton(e, !1);\n        this.eventsToUnbind.push(t(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && t(a.xAxis[0], \"setExtremes\", function (b) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== b.trigger && \"updatedData\" !== b.trigger && d.forcedDataGrouping && !d.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      }\n      updateButtonStates() {\n        const a = this;\n        var d = this.chart;\n        const b = this.dropdown,\n          c = d.xAxis[0],\n          e = Math.round(c.max - c.min),\n          f = !c.hasVisibleSeries,\n          h = d.scroller && d.scroller.getUnionExtremes() || c,\n          g = h.dataMin,\n          l = h.dataMax;\n        d = a.getYTDExtremes(l, g, d.time.useUTC);\n        const m = d.min,\n          q = d.max,\n          p = a.selected,\n          r = a.options.allButtonsEnabled,\n          w = a.buttons;\n        let t = k(p);\n        a.buttonOptions.forEach((d, h) => {\n          var k = d._range,\n            n = d.type,\n            u = d.count || 1;\n          const v = w[h],\n            x = d._offsetMax - d._offsetMin,\n            G = h === p,\n            y = k > l - g,\n            P = k < c.minRange;\n          d = 0;\n          let z = !1,\n            I = !1;\n          k = k === e;\n          (\"month\" === n || \"year\" === n) && e + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[n] * u - x && e - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[n] * u + x ? k = !0 : \"ytd\" === n ? (k = q - m + x === e, z = !G) : \"all\" === n && (k = c.max - c.min >= l - g, I = !G && t && k);\n          n = !r && (y || P || I || f);\n          u = G && k || k && !t && !z || G && a.frozenStates;\n          n ? d = 3 : u && (t = !0, d = 2);\n          v.state !== d && (v.setState(d), b && (b.options[h + 1].disabled = n, 2 === d && (b.selectedIndex = h + 1)), 0 === d && p === h && a.setSelected());\n        });\n      }\n      computeButtonRange(a) {\n        const d = a.type,\n          b = a.count || 1,\n          c = {\n            millisecond: 1,\n            second: 1E3,\n            minute: 6E4,\n            hour: 36E5,\n            day: 864E5,\n            week: 6048E5\n          };\n        if (c[d]) a._range = c[d] * b;else if (\"month\" === d || \"year\" === d) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[d] * b;\n        a._offsetMin = e(a.offsetMin, 0);\n        a._offsetMax = e(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      }\n      getInputValue(a) {\n        a = \"min\" === a ? this.minInput : this.maxInput;\n        const d = this.chart.options.rangeSelector,\n          b = this.chart.time;\n        return a ? (\"text\" === a.type && d.inputDateParser || this.defaultInputDateParser)(a.value, b.useUTC, b) : 0;\n      }\n      setInputValue(a, d) {\n        const b = this.options,\n          c = this.chart.time,\n          e = \"min\" === a ? this.minInput : this.maxInput;\n        a = \"min\" === a ? this.minDateBox : this.maxDateBox;\n        if (e) {\n          var f = e.getAttribute(\"data-hc-time\");\n          f = p(f) ? Number(f) : void 0;\n          p(d) && (p(f) && e.setAttribute(\"data-hc-time-previous\", f), e.setAttribute(\"data-hc-time\", d), f = d);\n          e.value = c.dateFormat(this.inputTypeFormats[e.type] || b.inputEditDateFormat, f);\n          a && a.attr({\n            text: c.dateFormat(b.inputDateFormat, f)\n          });\n        }\n      }\n      setInputExtremes(a, d, b) {\n        if (a = \"min\" === a ? this.minInput : this.maxInput) {\n          const c = this.inputTypeFormats[a.type],\n            e = this.chart.time;\n          c && (d = e.dateFormat(c, d), a.min !== d && (a.min = d), b = e.dateFormat(c, b), a.max !== b && (a.max = b));\n        }\n      }\n      showInput(a) {\n        const d = \"min\" === a ? this.minDateBox : this.maxDateBox;\n        if ((a = \"min\" === a ? this.minInput : this.maxInput) && d && this.inputGroup) {\n          const b = \"text\" === a.type,\n            {\n              translateX: c,\n              translateY: e\n            } = this.inputGroup,\n            {\n              inputBoxWidth: f\n            } = this.options;\n          g(a, {\n            width: b ? d.width + (f ? -2 : 20) + \"px\" : \"auto\",\n            height: d.height - 2 + \"px\",\n            border: \"2px solid silver\"\n          });\n          b && f ? g(a, {\n            left: c + d.x + \"px\",\n            top: e + \"px\"\n          }) : g(a, {\n            left: Math.min(Math.round(d.x + c - (a.offsetWidth - d.width) / 2), this.chart.chartWidth - a.offsetWidth) + \"px\",\n            top: e - (a.offsetHeight - d.height) / 2 + \"px\"\n          });\n        }\n      }\n      hideInput(a) {\n        (a = \"min\" === a ? this.minInput : this.maxInput) && g(a, {\n          top: \"-9999em\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n      }\n      defaultInputDateParser(a, d, b) {\n        var c = a.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n        -1 === c.indexOf(\"T\") && (c += \"T00:00\");\n        if (d) c += \"Z\";else {\n          var e;\n          if (e = F.isSafari) e = c, e = !(6 < e.length && (e.lastIndexOf(\"-\") === e.length - 6 || e.lastIndexOf(\"+\") === e.length - 6));\n          e && (e = new Date(c).getTimezoneOffset() / 60, c += 0 >= e ? `+${C(-e)}:00` : `-${C(e)}:00`);\n        }\n        c = Date.parse(c);\n        k(c) || (a = a.split(\"-\"), c = Date.UTC(h(a[0]), h(a[1]) - 1, h(a[2])));\n        b && d && k(c) && (c += b.getTimezoneOffset(c));\n        return c;\n      }\n      drawInput(a) {\n        function d() {\n          const {\n              maxInput: c,\n              minInput: d\n            } = f,\n            e = b.xAxis[0];\n          var h = b.scroller && b.scroller.xAxis ? b.scroller.xAxis : e;\n          const g = h.dataMin;\n          h = h.dataMax;\n          let l = f.getInputValue(a);\n          l !== Number(w.getAttribute(\"data-hc-time-previous\")) && k(l) && (w.setAttribute(\"data-hc-time-previous\", l), p && c && k(g) ? l > Number(c.getAttribute(\"data-hc-time\")) ? l = void 0 : l < g && (l = g) : d && k(h) && (l < Number(d.getAttribute(\"data-hc-time\")) ? l = void 0 : l > h && (l = h)), \"undefined\" !== typeof l && e.setExtremes(p ? l : e.min, p ? e.max : l, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          }));\n        }\n        const {\n            chart: b,\n            div: c,\n            inputGroup: e\n          } = this,\n          f = this,\n          h = b.renderer.style || {};\n        var l = b.renderer;\n        const q = b.options.rangeSelector,\n          p = \"min\" === a;\n        var u = B.lang[p ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\";\n        u = l.label(u, 0).addClass(\"highcharts-range-label\").attr({\n          padding: u ? 2 : 0,\n          height: u ? q.inputBoxHeight : 0\n        }).add(e);\n        l = l.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: q.inputBoxWidth,\n          height: q.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          f.showInput(a);\n          f[a + \"Input\"].focus();\n        });\n        b.styledMode || l.attr({\n          stroke: q.inputBoxBorderColor,\n          \"stroke-width\": 1\n        });\n        l.add(e);\n        const w = r(\"input\", {\n          name: a,\n          className: \"highcharts-range-selector\"\n        }, void 0, c);\n        w.setAttribute(\"type\", y(q.inputDateFormat || \"%e %b %Y\"));\n        b.styledMode || (u.css(x(h, q.labelStyle)), l.css(x({\n          color: \"#333333\"\n        }, h, q.inputStyle)), g(w, m({\n          position: \"absolute\",\n          border: 0,\n          boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: h.fontSize,\n          fontFamily: h.fontFamily,\n          top: \"-9999em\"\n        }, q.inputStyle)));\n        w.onfocus = () => {\n          f.showInput(a);\n        };\n        w.onblur = () => {\n          w === F.doc.activeElement && d();\n          f.hideInput(a);\n          f.setInputValue(a);\n          w.blur();\n        };\n        let t = !1;\n        w.onchange = () => {\n          t || (d(), f.hideInput(a), w.blur());\n        };\n        w.onkeypress = a => {\n          13 === a.keyCode && d();\n        };\n        w.onkeydown = a => {\n          t = !0;\n          38 !== a.keyCode && 40 !== a.keyCode || d();\n        };\n        w.onkeyup = () => {\n          t = !1;\n        };\n        return {\n          dateBox: l,\n          input: w,\n          label: u\n        };\n      }\n      getPosition() {\n        var a = this.chart;\n        const d = a.options.rangeSelector;\n        a = \"top\" === d.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + d.buttonPosition.y,\n          inputTop: a + d.inputPosition.y - 10\n        };\n      }\n      getYTDExtremes(a, d, b) {\n        const c = this.chart.time;\n        var e = new c.Date(a);\n        const f = c.get(\"FullYear\", e);\n        b = b ? c.Date.UTC(f, 0, 1) : +new c.Date(f, 0, 1);\n        d = Math.max(d, b);\n        e = e.getTime();\n        return {\n          max: Math.min(a || e, e),\n          min: d\n        };\n      }\n      render(a, d) {\n        var b = this.chart,\n          c = b.renderer;\n        const f = b.container;\n        var h = b.options;\n        const g = h.rangeSelector,\n          k = e(h.chart.style && h.chart.style.zIndex, 0) + 1;\n        h = g.inputEnabled;\n        if (!1 !== g.enabled) {\n          this.rendered || (this.group = c.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = r(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: k\n          }), this.buttonOptions.length && this.renderButtons(), f.parentNode && f.parentNode.insertBefore(this.div, f), h && (this.inputGroup = c.g(\"input-group\").add(this.group), c = this.drawInput(\"min\"), this.minDateBox = c.dateBox, this.minLabel = c.label, this.minInput = c.input, c = this.drawInput(\"max\"), this.maxDateBox = c.dateBox, this.maxLabel = c.label, this.maxInput = c.input));\n          if (h && (this.setInputValue(\"min\", a), this.setInputValue(\"max\", d), a = b.scroller && b.scroller.getUnionExtremes() || b.xAxis[0] || {}, p(a.dataMin) && p(a.dataMax) && (b = b.xAxis[0].minRange || 0, this.setInputExtremes(\"min\", a.dataMin, Math.min(a.dataMax, this.getInputValue(\"max\")) - b), this.setInputExtremes(\"max\", Math.max(a.dataMin, this.getInputValue(\"min\")) + b, a.dataMax)), this.inputGroup)) {\n            let a = 0;\n            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(b => {\n              if (b) {\n                const {\n                  width: c\n                } = b.getBBox();\n                c && (b.attr({\n                  x: a\n                }), a += c + g.inputSpacing);\n              }\n            });\n          }\n          this.alignElements();\n          this.rendered = !0;\n        }\n      }\n      renderButtons() {\n        const {\n            buttons: a,\n            chart: d,\n            options: b\n          } = this,\n          c = B.lang,\n          h = d.renderer,\n          g = x(b.buttonTheme),\n          k = g && g.states,\n          l = g.width || 28;\n        delete g.width;\n        delete g.states;\n        this.buttonGroup = h.g(\"range-selector-buttons\").add(this.group);\n        const m = this.dropdown = r(\"select\", void 0, {\n          position: \"absolute\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          border: 0,\n          top: \"-9999em\",\n          cursor: \"pointer\",\n          opacity: .0001\n        }, this.div);\n        t(m, \"touchstart\", () => {\n          m.style.fontSize = \"16px\";\n        });\n        [[F.isMS ? \"mouseover\" : \"mouseenter\"], [F.isMS ? \"mouseout\" : \"mouseleave\"], [\"change\", \"click\"]].forEach(([b, c]) => {\n          t(m, b, () => {\n            const d = a[this.currentButtonIndex()];\n            d && f(d.element, c || b);\n          });\n        });\n        this.zoomText = h.label(c && c.rangeSelectorZoom || \"\", 0).attr({\n          padding: b.buttonTheme.padding,\n          height: b.buttonTheme.height,\n          paddingLeft: 0,\n          paddingRight: 0\n        }).add(this.buttonGroup);\n        this.chart.styledMode || (this.zoomText.css(b.labelStyle), g[\"stroke-width\"] = e(g[\"stroke-width\"], 0));\n        r(\"option\", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, m);\n        this.buttonOptions.forEach((b, c) => {\n          r(\"option\", {\n            textContent: b.title || b.text\n          }, void 0, m);\n          a[c] = h.button(b.text, 0, 0, a => {\n            const d = b.events && b.events.click;\n            let e;\n            d && (e = d.call(b, a));\n            !1 !== e && this.clickButton(c);\n            this.isActive = !0;\n          }, g, k && k.hover, k && k.select, k && k.disabled).attr({\n            \"text-align\": \"center\",\n            width: l\n          }).add(this.buttonGroup);\n          b.title && a[c].attr(\"title\", b.title);\n        });\n      }\n      alignElements() {\n        const {\n          buttonGroup: a,\n          buttons: d,\n          chart: b,\n          group: c,\n          inputGroup: f,\n          options: h,\n          zoomText: g\n        } = this;\n        var k = b.options;\n        const l = k.exporting && !1 !== k.exporting.enabled && k.navigation && k.navigation.buttonOptions,\n          {\n            buttonPosition: m,\n            inputPosition: q,\n            verticalAlign: p\n          } = h;\n        k = (a, c) => l && this.titleCollision(b) && \"top\" === p && \"right\" === c.align && c.y - a.getBBox().height - 12 < (l.y || 0) + (l.height || 0) + b.spacing[0] ? -40 : 0;\n        var r = b.plotLeft;\n        if (c && m && q) {\n          var w = m.x - b.spacing[3];\n          if (a) {\n            this.positionButtons();\n            if (!this.initialButtonGroupWidth) {\n              let a = 0;\n              g && (a += g.getBBox().width + 5);\n              d.forEach((b, c) => {\n                a += b.width;\n                c !== d.length - 1 && (a += h.buttonSpacing);\n              });\n              this.initialButtonGroupWidth = a;\n            }\n            r -= b.spacing[3];\n            this.updateButtonStates();\n            var t = k(a, m);\n            this.alignButtonGroup(t);\n            c.placed = a.placed = b.hasLoaded;\n          }\n          t = 0;\n          f && (t = k(f, q), \"left\" === q.align ? w = r : \"right\" === q.align && (w = -Math.max(b.axisOffset[1], -t)), f.align({\n            y: q.y,\n            width: f.getBBox().width,\n            align: q.align,\n            x: q.x + w - 2\n          }, !0, b.spacingBox), f.placed = b.hasLoaded);\n          this.handleCollision(t);\n          c.align({\n            verticalAlign: p\n          }, !0, b.spacingBox);\n          k = c.alignAttr.translateY;\n          r = c.getBBox().height + 20;\n          w = 0;\n          \"bottom\" === p && (w = (w = b.legend && b.legend.options) && \"bottom\" === w.verticalAlign && w.enabled && !w.floating ? b.legend.legendHeight + e(w.margin, 10) : 0, r = r + w - 20, w = k - r - (h.floating ? 0 : h.y) - (b.titleOffset ? b.titleOffset[2] : 0) - 10);\n          if (\"top\" === p) h.floating && (w = 0), b.titleOffset && b.titleOffset[0] && (w = b.titleOffset[0]), w += b.margin[0] - b.spacing[0] || 0;else if (\"middle\" === p) if (q.y === m.y) w = k;else if (q.y || m.y) w = 0 > q.y || 0 > m.y ? w - Math.min(q.y, m.y) : k - r;\n          c.translate(h.x, h.y + Math.floor(w));\n          const {\n            minInput: l,\n            maxInput: n,\n            dropdown: u\n          } = this;\n          h.inputEnabled && l && n && (l.style.marginTop = c.translateY + \"px\", n.style.marginTop = c.translateY + \"px\");\n          u && (u.style.marginTop = c.translateY + \"px\");\n        }\n      }\n      alignButtonGroup(a, d) {\n        const {\n            chart: b,\n            options: c,\n            buttonGroup: f\n          } = this,\n          {\n            buttonPosition: h\n          } = c,\n          g = b.plotLeft - b.spacing[3];\n        let k = h.x - b.spacing[3];\n        \"right\" === h.align ? k += a - g : \"center\" === h.align && (k -= g / 2);\n        f && f.align({\n          y: h.y,\n          width: e(d, this.initialButtonGroupWidth),\n          align: h.align,\n          x: k\n        }, !0, b.spacingBox);\n      }\n      positionButtons() {\n        const {\n            buttons: a,\n            chart: d,\n            options: b,\n            zoomText: c\n          } = this,\n          f = d.hasLoaded ? \"animate\" : \"attr\",\n          {\n            buttonPosition: h\n          } = b,\n          g = d.plotLeft;\n        let k = g;\n        c && \"hidden\" !== c.visibility && (c[f]({\n          x: e(g + h.x, g)\n        }), k += h.x + c.getBBox().width + 5);\n        for (let c = 0, d = this.buttonOptions.length; c < d; ++c) if (\"hidden\" !== a[c].visibility) a[c][f]({\n          x: k\n        }), k += a[c].width + b.buttonSpacing;else a[c][f]({\n          x: g\n        });\n      }\n      handleCollision(a) {\n        const {\n            chart: d,\n            buttonGroup: b,\n            inputGroup: c\n          } = this,\n          {\n            buttonPosition: e,\n            dropdown: f,\n            inputPosition: h\n          } = this.options,\n          g = () => {\n            let a = 0;\n            this.buttons.forEach(b => {\n              b = b.getBBox();\n              b.width > a && (a = b.width);\n            });\n            return a;\n          },\n          k = d => {\n            if (c && b) {\n              const f = c.alignAttr.translateX + c.alignOptions.x - a + c.getBBox().x + 2,\n                g = c.alignOptions.width,\n                k = b.alignAttr.translateX + b.getBBox().x;\n              return k + d > f && f + g > k && e.y < h.y + c.getBBox().height;\n            }\n            return !1;\n          },\n          l = () => {\n            c && b && c.attr({\n              translateX: c.alignAttr.translateX + (d.axisOffset[1] >= -a ? 0 : -a),\n              translateY: c.alignAttr.translateY + b.getBBox().height + 10\n            });\n          };\n        if (b) {\n          if (\"always\" === f) {\n            this.collapseButtons(a);\n            k(g()) && l();\n            return;\n          }\n          \"never\" === f && this.expandButtons();\n        }\n        c && b ? h.align === e.align || k(this.initialButtonGroupWidth + 20) ? \"responsive\" === f ? (this.collapseButtons(a), k(g()) && l()) : l() : \"responsive\" === f && this.expandButtons() : b && \"responsive\" === f && (this.initialButtonGroupWidth > d.plotWidth ? this.collapseButtons(a) : this.expandButtons());\n      }\n      collapseButtons(a) {\n        const {\n            buttons: d,\n            buttonOptions: b,\n            chart: c,\n            dropdown: f,\n            options: h,\n            zoomText: g\n          } = this,\n          k = c.userOptions.rangeSelector && c.userOptions.rangeSelector.buttonTheme || {},\n          l = a => ({\n            text: a ? `${a} \\u25be` : \"\\u25be\",\n            width: \"auto\",\n            paddingLeft: e(h.buttonTheme.paddingLeft, k.padding, 8),\n            paddingRight: e(h.buttonTheme.paddingRight, k.padding, 8)\n          });\n        g && g.hide();\n        let m = !1;\n        b.forEach((a, b) => {\n          b = d[b];\n          2 !== b.state ? b.hide() : (b.show(), b.attr(l(a.text)), m = !0);\n        });\n        m || (f && (f.selectedIndex = 0), d[0].show(), d[0].attr(l(this.zoomText && this.zoomText.textStr)));\n        const {\n          align: q\n        } = h.buttonPosition;\n        this.positionButtons();\n        \"right\" !== q && \"center\" !== q || this.alignButtonGroup(a, d[this.currentButtonIndex()].getBBox().width);\n        this.showDropdown();\n      }\n      expandButtons() {\n        const {\n          buttons: a,\n          buttonOptions: d,\n          options: b,\n          zoomText: c\n        } = this;\n        this.hideDropdown();\n        c && c.show();\n        d.forEach((c, d) => {\n          d = a[d];\n          d.show();\n          d.attr({\n            text: c.text,\n            width: b.buttonTheme.width || 28,\n            paddingLeft: e(b.buttonTheme.paddingLeft, \"unset\"),\n            paddingRight: e(b.buttonTheme.paddingRight, \"unset\")\n          });\n          2 > d.state && d.setState(0);\n        });\n        this.positionButtons();\n      }\n      currentButtonIndex() {\n        const {\n          dropdown: a\n        } = this;\n        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;\n      }\n      showDropdown() {\n        const {\n          buttonGroup: a,\n          buttons: d,\n          chart: b,\n          dropdown: c\n        } = this;\n        if (a && c) {\n          const {\n              translateX: e,\n              translateY: f\n            } = a,\n            h = d[this.currentButtonIndex()].getBBox();\n          g(c, {\n            left: b.plotLeft + e + \"px\",\n            top: f + .5 + \"px\",\n            width: h.width + \"px\",\n            height: h.height + \"px\"\n          });\n          this.hasVisibleDropdown = !0;\n        }\n      }\n      hideDropdown() {\n        const {\n          dropdown: a\n        } = this;\n        a && (g(a, {\n          top: \"-9999em\",\n          width: \"1px\",\n          height: \"1px\"\n        }), this.hasVisibleDropdown = !1);\n      }\n      getHeight() {\n        var a = this.options,\n          d = this.group;\n        const b = a.y,\n          c = a.buttonPosition.y,\n          e = a.inputPosition.y;\n        if (a.height) return a.height;\n        this.alignElements();\n        a = d ? d.getBBox(!0).height + 13 + b : 0;\n        d = Math.min(e, c);\n        if (0 > e && 0 > c || 0 < e && 0 < c) a += Math.abs(d);\n        return a;\n      }\n      titleCollision(a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      }\n      update(a) {\n        const d = this.chart;\n        x(!0, d.options.rangeSelector, a);\n        this.destroy();\n        this.init(d);\n        this.render();\n      }\n      destroy() {\n        const a = this,\n          d = a.minInput,\n          b = a.maxInput;\n        a.eventsToUnbind && (a.eventsToUnbind.forEach(a => a()), a.eventsToUnbind = void 0);\n        v(a.buttons);\n        d && (d.onfocus = d.onblur = d.onchange = null);\n        b && (b.onfocus = b.onblur = b.onchange = null);\n        J(a, function (b, d) {\n          b && \"chart\" !== d && (b instanceof A ? b.destroy() : b instanceof W.HTMLElement && l(b));\n          b !== q.prototype[d] && (a[d] = null);\n        }, this);\n      }\n    }\n    m(q.prototype, {\n      defaultButtons: [{\n        type: \"month\",\n        count: 1,\n        text: \"1m\",\n        title: \"View 1 month\"\n      }, {\n        type: \"month\",\n        count: 3,\n        text: \"3m\",\n        title: \"View 3 months\"\n      }, {\n        type: \"month\",\n        count: 6,\n        text: \"6m\",\n        title: \"View 6 months\"\n      }, {\n        type: \"ytd\",\n        text: \"YTD\",\n        title: \"View year to date\"\n      }, {\n        type: \"year\",\n        count: 1,\n        text: \"1y\",\n        title: \"View 1 year\"\n      }, {\n        type: \"all\",\n        text: \"All\",\n        title: \"View all\"\n      }],\n      inputTypeFormats: {\n        \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n        date: \"%Y-%m-%d\",\n        time: \"%H:%M:%S\"\n      }\n    });\n    \"\";\n    return q;\n  });\n  L(a, \"Series/XRange/XRangeSeriesDefaults.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      correctFloat: y,\n      isNumber: F,\n      isObject: H\n    } = a;\n    \"\";\n    return {\n      colorByPoint: !0,\n      dataLabels: {\n        formatter: function () {\n          let a = this.point.partialFill;\n          H(a) && (a = a.amount);\n          if (F(a) && 0 < a) return y(100 * a) + \"%\";\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      tooltip: {\n        headerFormat: '<span style=\"font-size: 0.8em\">{point.x} - {point.x2}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.yCategory}</b><br/>'\n      },\n      borderRadius: 3,\n      pointRange: 0\n    };\n  });\n  L(a, \"Series/XRange/XRangePoint.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    const {\n      series: {\n        prototype: {\n          pointClass: {\n            prototype: y\n          }\n        }\n      },\n      seriesTypes: {\n        column: {\n          prototype: {\n            pointClass: H\n          }\n        }\n      }\n    } = a;\n    ({\n      extend: a\n    } = z);\n    class A extends H {\n      constructor() {\n        super(...arguments);\n        this.series = this.options = void 0;\n      }\n      static getColorByCategory(a, y) {\n        const z = a.options.colors || a.chart.options.colors;\n        a = y.y % (z ? z.length : a.chart.options.chart.colorCount);\n        return {\n          colorIndex: a,\n          color: z && z[a]\n        };\n      }\n      resolveColor() {\n        const a = this.series;\n        if (a.options.colorByPoint && !this.options.color) {\n          const y = A.getColorByCategory(a, this);\n          a.chart.styledMode || (this.color = y.color);\n          this.options.colorIndex || (this.colorIndex = y.colorIndex);\n        } else this.color || (this.color = a.color);\n      }\n      init() {\n        y.init.apply(this, arguments);\n        this.y || (this.y = 0);\n        return this;\n      }\n      setState() {\n        y.setState.apply(this, arguments);\n        this.series.drawPoint(this, this.series.getAnimationVerb());\n      }\n      getLabelConfig() {\n        const a = y.getLabelConfig.call(this),\n          z = this.series.yAxis.categories;\n        a.x2 = this.x2;\n        a.yCategory = this.yCategory = z && z[this.y];\n        return a;\n      }\n      isValid() {\n        return \"number\" === typeof this.x && \"number\" === typeof this.x2;\n      }\n    }\n    a(A.prototype, {\n      ttBelow: !1,\n      tooltipDateKeys: [\"x\", \"x2\"]\n    });\n    \"\";\n    return A;\n  });\n  L(a, \"Series/XRange/XRangeSeries.js\", [a[\"Core/Globals.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"], a[\"Series/XRange/XRangeSeriesDefaults.js\"], a[\"Series/XRange/XRangePoint.js\"]], function (a, z, F, H, A, D) {\n    function y() {\n      let a, e;\n      if (this.isXAxis) {\n        a = J(this.dataMax, -Number.MAX_VALUE);\n        for (const f of this.series) if (f.x2Data) for (const h of f.x2Data) h && h > a && (a = h, e = !0);\n        e && (this.dataMax = a);\n      }\n    }\n    ({\n      noop: a\n    } = a);\n    const {\n        parse: B\n      } = z,\n      {\n        series: {\n          prototype: t\n        },\n        seriesTypes: {\n          column: r\n        }\n      } = F,\n      {\n        addEvent: g,\n        clamp: p,\n        defined: v,\n        extend: l,\n        find: m,\n        isNumber: f,\n        isObject: k,\n        merge: x,\n        pick: J\n      } = H,\n      C = [];\n    class e extends r {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      static compose(a) {\n        H.pushUnique(C, a) && g(a, \"afterGetSeriesExtremes\", y);\n      }\n      init() {\n        super.init.apply(this, arguments);\n        this.options.stacking = void 0;\n      }\n      getColumnMetrics() {\n        const a = () => {\n          for (const a of this.chart.series) {\n            const e = a.xAxis;\n            a.xAxis = a.yAxis;\n            a.yAxis = e;\n          }\n        };\n        a();\n        const e = super.getColumnMetrics();\n        a();\n        return e;\n      }\n      cropData(a, e, f, g) {\n        e = t.cropData.call(this, this.x2Data, e, f, g);\n        e.xData = a.slice(e.start, e.end);\n        return e;\n      }\n      findPointIndex(a) {\n        const {\n            cropStart: e,\n            points: h\n          } = this,\n          {\n            id: g\n          } = a;\n        if (g) var d = (d = m(h, a => a.id === g)) ? d.index : void 0;\n        \"undefined\" === typeof d && (d = (d = m(h, b => b.x === a.x && b.x2 === a.x2 && !b.touched)) ? d.index : void 0);\n        this.cropped && f(d) && f(e) && d >= e && (d -= e);\n        return d;\n      }\n      alignDataLabel(a) {\n        const e = a.plotX;\n        a.plotX = J(a.dlBox && a.dlBox.centerX, a.plotX);\n        super.alignDataLabel.apply(this, arguments);\n        a.plotX = e;\n      }\n      translatePoint(a) {\n        const e = this.xAxis;\n        var h = this.yAxis,\n          g = this.columnMetrics,\n          d = this.options,\n          {\n            borderRadius: b\n          } = d,\n          c = d.minPointLength || 0,\n          l = (a.shapeArgs && a.shapeArgs.width || 0) / 2,\n          m = this.pointXOffset = g.offset,\n          r = J(a.x2, a.x + (a.len || 0));\n        let t = a.plotX;\n        var y = e.translate(r, 0, 0, 0, 1);\n        r = Math.abs(y - t);\n        const z = this.chart.inverted,\n          B = J(d.borderWidth, 1) % 2 / 2;\n        let C = g.offset,\n          A = Math.round(g.width);\n        c && (c -= r, 0 > c && (c = 0), t -= c / 2, y += c / 2);\n        t = Math.max(t, -10);\n        y = p(y, -10, e.len + 10);\n        v(a.options.pointWidth) && (C -= (Math.ceil(a.options.pointWidth) - A) / 2, A = Math.ceil(a.options.pointWidth));\n        d.pointPlacement && f(a.plotY) && h.categories && (a.plotY = h.translate(a.y, 0, 1, 0, 1, d.pointPlacement));\n        d = Math.floor(Math.min(t, y)) + B;\n        d = {\n          x: d,\n          y: Math.floor(a.plotY + C) + B,\n          width: Math.floor(Math.max(t, y)) + B - d,\n          height: A\n        };\n        a.shapeArgs = d;\n        f(b) && (a.shapeArgs.r = b);\n        z ? a.tooltipPos[1] += m + l : a.tooltipPos[0] -= l + m - d.width / 2;\n        l = d.x;\n        m = l + d.width;\n        0 > l || m > e.len ? (l = p(l, 0, e.len), m = p(m, 0, e.len), y = m - l, a.dlBox = x(d, {\n          x: l,\n          width: m - l,\n          centerX: y ? y / 2 : null\n        })) : a.dlBox = null;\n        l = a.tooltipPos;\n        m = z ? 1 : 0;\n        y = z ? 0 : 1;\n        g = this.columnMetrics ? this.columnMetrics.offset : -g.width / 2;\n        l[m] = z ? l[m] + d.width / 2 : p(l[m] + (e.reversed ? -1 : 0) * d.width, 0, e.len - 1);\n        l[y] = p(l[y] + (z ? -1 : 1) * g, 0, h.len - 1);\n        if (h = a.partialFill) k(h) && (h = h.amount), f(h) || (h = 0), f(b) && (a.partShapeArgs = x(d, {\n          r: b\n        })), b = Math.max(Math.round(r * h + a.plotX - t), 0), a.clipRectArgs = {\n          x: e.reversed ? d.x + r - b : d.x,\n          y: d.y,\n          width: b,\n          height: d.height\n        };\n      }\n      translate() {\n        super.translate.apply(this, arguments);\n        for (const a of this.points) this.translatePoint(a);\n      }\n      drawPoint(a, e) {\n        const f = this.options,\n          g = this.chart.renderer,\n          d = a.shapeType,\n          b = a.shapeArgs,\n          c = a.partShapeArgs,\n          h = a.clipRectArgs;\n        var l = a.state,\n          m = f.states[l || \"normal\"] || {};\n        const p = \"undefined\" === typeof l ? \"attr\" : e;\n        l = this.pointAttribs(a, l);\n        m = J(this.chart.options.chart.animation, m.animation);\n        let r = a.graphic,\n          w = a.partialFill;\n        if (a.isNull || !1 === a.visible) r && (a.graphic = r.destroy());else {\n          if (r) r.rect[e](b);else a.graphic = r = g.g(\"point\").addClass(a.getClassName()).add(a.group || this.group), r.rect = g[d](x(b)).addClass(a.getClassName()).addClass(\"highcharts-partfill-original\").add(r);\n          c && (r.partRect ? (r.partRect[e](x(c)), r.partialClipRect[e](x(h))) : (r.partialClipRect = g.clipRect(h.x, h.y, h.width, h.height), r.partRect = g[d](c).addClass(\"highcharts-partfill-overlay\").add(r).clip(r.partialClipRect)));\n          this.chart.styledMode || (r.rect[e](l, m).shadow(f.shadow), c && (k(w) || (w = {}), k(f.partialFill) && (w = x(f.partialFill, w)), a = w.fill || B(l.fill).brighten(-.3).get() || B(a.color || this.color).brighten(-.3).get(), l.fill = a, r.partRect[p](l, m).shadow(f.shadow)));\n        }\n      }\n      drawPoints() {\n        const a = this.getAnimationVerb();\n        for (const e of this.points) this.drawPoint(e, a);\n      }\n      getAnimationVerb() {\n        return this.chart.pointCount < (this.options.animationLimit || 250) ? \"animate\" : \"attr\";\n      }\n      isPointInside(a) {\n        const e = a.shapeArgs,\n          f = a.plotX,\n          g = a.plotY;\n        return e ? \"undefined\" !== typeof f && \"undefined\" !== typeof g && 0 <= g && g <= this.yAxis.len && 0 <= (e.x || 0) + (e.width || 0) && f <= this.xAxis.len : super.isPointInside.apply(this, arguments);\n      }\n    }\n    e.defaultOptions = x(r.defaultOptions, A);\n    l(e.prototype, {\n      pointClass: D,\n      cropShoulder: 1,\n      getExtremesFromAll: !0,\n      parallelArrays: [\"x\", \"x2\", \"y\"],\n      requireSorting: !1,\n      type: \"xrange\",\n      animate: t.animate,\n      autoIncrement: a,\n      buildKDTree: a\n    });\n    F.registerSeriesType(\"xrange\", e);\n    return e;\n  });\n  L(a, \"Series/Gantt/GanttPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    ({\n      seriesTypes: {\n        xrange: {\n          prototype: {\n            pointClass: a\n          }\n        }\n      }\n    } = a);\n    const {\n      pick: y\n    } = z;\n    class H extends a {\n      constructor() {\n        super(...arguments);\n        this.series = this.options = void 0;\n      }\n      static setGanttPointAliases(a) {\n        function z(y, z) {\n          \"undefined\" !== typeof z && (a[y] = z);\n        }\n        z(\"x\", y(a.start, a.x));\n        z(\"x2\", y(a.end, a.x2));\n        z(\"partialFill\", y(a.completed, a.partialFill));\n      }\n      applyOptions(a, y) {\n        a = super.applyOptions.call(this, a, y);\n        H.setGanttPointAliases(a);\n        return a;\n      }\n      isValid() {\n        return (\"number\" === typeof this.start || \"number\" === typeof this.x) && (\"number\" === typeof this.end || \"number\" === typeof this.x2 || this.milestone);\n      }\n    }\n    return H;\n  });\n  L(a, \"Core/Axis/BrokenAxis.js\", [a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    const {\n      addEvent: y,\n      find: H,\n      fireEvent: A,\n      isArray: D,\n      isNumber: E,\n      pick: B\n    } = z;\n    var t;\n    (function (r) {\n      function g() {\n        \"undefined\" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n      function p() {\n        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);\n      }\n      function t() {\n        const a = this.brokenAxis;\n        if (a && a.hasBreaks) {\n          const e = this.tickPositions,\n            f = this.tickPositions.info,\n            g = [];\n          for (let f = 0; f < e.length; f++) a.isInAnyBreak(e[f]) || g.push(e[f]);\n          this.tickPositions = g;\n          this.tickPositions.info = f;\n        }\n      }\n      function l() {\n        this.brokenAxis || (this.brokenAxis = new C(this));\n      }\n      function m() {\n        const {\n          isDirty: a,\n          options: {\n            connectNulls: f\n          },\n          points: g,\n          xAxis: k,\n          yAxis: l\n        } = this;\n        if (a) {\n          let a = g.length;\n          for (; a--;) {\n            const b = g[a],\n              c = !(null === b.y && !1 === f) && (k && k.brokenAxis && k.brokenAxis.isInAnyBreak(b.x, !0) || l && l.brokenAxis && l.brokenAxis.isInAnyBreak(b.y, !0));\n            b.visible = c ? !1 : !1 !== b.options.visible;\n          }\n        }\n      }\n      function f() {\n        this.drawBreaks(this.xAxis, [\"x\"]);\n        this.drawBreaks(this.yAxis, B(this.pointArrayMap, [\"y\"]));\n      }\n      function k(a, f) {\n        const e = this,\n          g = e.points;\n        let h, d, b, c;\n        if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {\n          const k = a.brokenAxis;\n          f.forEach(function (f) {\n            h = k && k.breakArray || [];\n            d = a.isXAxis ? a.min : B(e.options.threshold, a.min);\n            g.forEach(function (e) {\n              c = B(e[\"stack\" + f.toUpperCase()], e[f]);\n              h.forEach(function (f) {\n                if (E(d) && E(c)) {\n                  b = !1;\n                  if (d < f.from && c > f.to || d > f.from && c < f.from) b = \"pointBreak\";else if (d < f.from && c > f.from && c < f.to || d > f.from && c > f.to && c < f.from) b = \"pointInBreak\";\n                  b && A(a, b, {\n                    point: e,\n                    brk: f\n                  });\n                }\n              });\n            });\n          });\n        }\n      }\n      function x() {\n        var e = this.currentDataGrouping,\n          f = e && e.gapSize;\n        e = this.points.slice();\n        const g = this.yAxis;\n        let k = this.options.gapSize,\n          l = e.length - 1;\n        var d;\n        if (k && 0 < l) for (\"value\" !== this.options.gapUnit && (k *= this.basePointRange), f && f > k && f >= this.basePointRange && (k = f); l--;) d && !1 !== d.visible || (d = e[l + 1]), f = e[l], !1 !== d.visible && !1 !== f.visible && (d.x - f.x > k && (d = (f.x + d.x) / 2, e.splice(l + 1, 0, {\n          isNull: !0,\n          x: d\n        }), g.stacking && this.options.stacking && (d = g.stacking.stacks[this.stackKey][d] = new a(g, g.options.stackLabels, !1, d, this.stack), d.total = 0)), d = f);\n        return this.getGraphPath(e);\n      }\n      const J = [];\n      r.compose = function (a, h) {\n        z.pushUnique(J, a) && (a.keepProps.push(\"brokenAxis\"), y(a, \"init\", l), y(a, \"afterInit\", g), y(a, \"afterSetTickPositions\", t), y(a, \"afterSetOptions\", p));\n        if (z.pushUnique(J, h)) {\n          const a = h.prototype;\n          a.drawBreaks = k;\n          a.gappedPath = x;\n          y(h, \"afterGeneratePoints\", m);\n          y(h, \"afterRender\", f);\n        }\n        return a;\n      };\n      class C {\n        static isInBreak(a, f) {\n          const e = a.repeat || Infinity,\n            g = a.from,\n            h = a.to - a.from;\n          f = f >= g ? (f - g) % e : e - (g - f) % e;\n          return a.inclusive ? f <= h : f < h && 0 !== f;\n        }\n        static lin2Val(a) {\n          var e = this.brokenAxis;\n          e = e && e.breakArray;\n          if (!e || !E(a)) return a;\n          let f, g;\n          for (g = 0; g < e.length && !(f = e[g], f.from >= a); g++) f.to < a ? a += f.len : C.isInBreak(f, a) && (a += f.len);\n          return a;\n        }\n        static val2Lin(a) {\n          var e = this.brokenAxis;\n          e = e && e.breakArray;\n          if (!e || !E(a)) return a;\n          let f = a,\n            g,\n            k;\n          for (k = 0; k < e.length; k++) if (g = e[k], g.to <= a) f -= g.len;else if (g.from >= a) break;else if (C.isInBreak(g, a)) {\n            f -= a - g.from;\n            break;\n          }\n          return f;\n        }\n        constructor(a) {\n          this.hasBreaks = !1;\n          this.axis = a;\n        }\n        findBreakAt(a, f) {\n          return H(f, function (e) {\n            return e.from < a && a < e.to;\n          });\n        }\n        isInAnyBreak(a, f) {\n          const e = this.axis,\n            g = e.options.breaks || [];\n          let h = g.length,\n            d,\n            b,\n            c;\n          if (h && E(a)) {\n            for (; h--;) C.isInBreak(g[h], a) && (d = !0, b || (b = B(g[h].showPoints, !e.isXAxis)));\n            c = d && f ? d && !b : d;\n          }\n          return c;\n        }\n        setBreaks(a, f) {\n          const e = this,\n            g = e.axis,\n            h = D(a) && !!a.length;\n          g.isDirty = e.hasBreaks !== h;\n          e.hasBreaks = h;\n          g.options.breaks = g.userOptions.breaks = a;\n          g.forceRedraw = !0;\n          g.series.forEach(function (a) {\n            a.isDirty = !0;\n          });\n          h || g.val2lin !== C.val2Lin || (delete g.val2lin, delete g.lin2val);\n          h && (g.userOptions.ordinal = !1, g.lin2val = C.lin2Val, g.val2lin = C.val2Lin, g.setExtremes = function (a, b, c, f, h) {\n            if (e.hasBreaks) {\n              const c = this.options.breaks || [];\n              let d;\n              for (; d = e.findBreakAt(a, c);) a = d.to;\n              for (; d = e.findBreakAt(b, c);) b = d.from;\n              b < a && (b = a);\n            }\n            g.constructor.prototype.setExtremes.call(this, a, b, c, f, h);\n          }, g.setAxisTranslation = function () {\n            g.constructor.prototype.setAxisTranslation.call(this);\n            e.unitLength = void 0;\n            if (e.hasBreaks) {\n              const a = g.options.breaks || [],\n                b = [],\n                c = [],\n                f = B(g.pointRangePadding, 0);\n              let h = 0,\n                k,\n                l,\n                m = g.userMin || g.min,\n                q = g.userMax || g.max,\n                p,\n                r;\n              a.forEach(function (a) {\n                l = a.repeat || Infinity;\n                E(m) && E(q) && (C.isInBreak(a, m) && (m += a.to % l - m % l), C.isInBreak(a, q) && (q -= q % l - a.from % l));\n              });\n              a.forEach(function (a) {\n                p = a.from;\n                l = a.repeat || Infinity;\n                if (E(m) && E(q)) {\n                  for (; p - l > m;) p -= l;\n                  for (; p < m;) p += l;\n                  for (r = p; r < q; r += l) b.push({\n                    value: r,\n                    move: \"in\"\n                  }), b.push({\n                    value: r + a.to - a.from,\n                    move: \"out\",\n                    size: a.breakSize\n                  });\n                }\n              });\n              b.sort(function (a, b) {\n                return a.value === b.value ? (\"in\" === a.move ? 0 : 1) - (\"in\" === b.move ? 0 : 1) : a.value - b.value;\n              });\n              k = 0;\n              p = m;\n              b.forEach(function (a) {\n                k += \"in\" === a.move ? 1 : -1;\n                1 === k && \"in\" === a.move && (p = a.value);\n                0 === k && E(p) && (c.push({\n                  from: p,\n                  to: a.value,\n                  len: a.value - p - (a.size || 0)\n                }), h += a.value - p - (a.size || 0));\n              });\n              e.breakArray = c;\n              E(m) && E(q) && E(g.min) && (e.unitLength = q - m - h + f, A(g, \"afterBreaks\"), g.staticScale ? g.transA = g.staticScale : e.unitLength && (g.transA *= (q - g.min + f) / e.unitLength), f && (g.minPixelPadding = g.transA * (g.minPointOffset || 0)), g.min = m, g.max = q);\n            }\n          });\n          B(f, !0) && g.chart.redraw();\n        }\n      }\n      r.Additions = C;\n    })(t || (t = {}));\n    return t;\n  });\n  L(a, \"Core/Axis/GridAxis.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    function y(a, c) {\n      const d = {\n        width: 0,\n        height: 0\n      };\n      c.forEach(function (c) {\n        c = a[c];\n        let e, f;\n        F.isObject(c, !0) && (f = F.isObject(c.label, !0) ? c.label : {}, c = f.getBBox ? f.getBBox().height : 0, f.textStr && !b(f.textPxLength) && (f.textPxLength = f.getBBox().width), e = b(f.textPxLength) ? Math.round(f.textPxLength) : 0, f.textStr && (e = Math.round(f.getBBox().width)), d.height = Math.max(c, d.height), d.width = Math.max(e, d.width));\n      });\n      \"treegrid\" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode && (d.width += this.options.labels.indentation * ((this.treeGrid.mapOfPosToGridNode[-1].height || 0) - 1));\n      return d;\n    }\n    function A() {\n      const {\n        grid: a\n      } = this;\n      (a && a.columns || []).forEach(function (a) {\n        a.getOffset();\n      });\n    }\n    function D(a) {\n      if (!0 === (this.options.grid || {}).enabled) {\n        const {\n          axisTitle: c,\n          height: d,\n          horiz: e,\n          left: f,\n          offset: g,\n          opposite: h,\n          options: k,\n          top: l,\n          width: m\n        } = this;\n        var b = this.tickSize();\n        const q = c && c.getBBox().width,\n          p = k.title.x,\n          r = k.title.y,\n          t = n(k.title.margin, e ? 5 : 10),\n          u = c ? this.chart.renderer.fontMetrics(c).f : 0;\n        b = (e ? l + d : f) + (e ? 1 : -1) * (h ? -1 : 1) * (b ? b[0] / 2 : 0) + (this.side === K.bottom ? u : 0);\n        a.titlePosition.x = e ? f - (q || 0) / 2 - t + p : b + (h ? m : 0) + g + p;\n        a.titlePosition.y = e ? b - (h ? d : 0) + (h ? u : -u) / 2 + g + r : l - t + r;\n      }\n    }\n    function E() {\n      const {\n        chart: b,\n        options: {\n          grid: d = {}\n        },\n        userOptions: e\n      } = this;\n      if (d.enabled) {\n        var f = this.options;\n        f.labels.align = n(f.labels.align, \"center\");\n        this.categories || (f.showLastLabel = !1);\n        this.labelRotation = 0;\n        f.labels.rotation = 0;\n      }\n      if (d.columns) {\n        f = this.grid.columns = [];\n        let h = this.grid.columnIndex = 0;\n        for (; ++h < d.columns.length;) {\n          var g = c(e, d.columns[d.columns.length - h - 1], {\n            linkedTo: 0,\n            type: \"category\",\n            scrollbar: {\n              enabled: !1\n            }\n          });\n          delete g.grid.columns;\n          g = new a(this.chart, g);\n          g.grid.isColumn = !0;\n          g.grid.columnIndex = h;\n          q(b.axes, g);\n          q(b[this.coll], g);\n          f.push(g);\n        }\n      }\n    }\n    function B() {\n      var a = this.grid,\n        b = this.options;\n      if (!0 === (b.grid || {}).enabled) {\n        var c = this.min || 0;\n        const h = this.max || 0;\n        this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions);\n        this.rightWall && this.rightWall.destroy();\n        if (this.grid && this.grid.isOuterAxis() && this.axisLine) {\n          var d = b.lineWidth;\n          if (d) {\n            d = this.getLinePath(d);\n            var e = d[0],\n              f = d[1],\n              g = ((this.tickSize(\"tick\") || [1])[0] - 1) * (this.side === K.top || this.side === K.left ? -1 : 1);\n            \"M\" === e[0] && \"L\" === f[0] && (this.horiz ? (e[2] += g, f[2] += g) : (e[1] += g, f[1] += g));\n            !this.horiz && this.chart.marginRight && (e = [e, [\"L\", this.left, e[2] || 0]], g = [\"L\", this.chart.chartWidth - this.chart.marginRight, this.toPixels(h + this.tickmarkOffset)], f = [[\"M\", f[1] || 0, this.toPixels(h + this.tickmarkOffset)], g], this.grid.upperBorder || 0 === c % 1 || (this.grid.upperBorder = this.grid.renderBorder(e)), this.grid.upperBorder && (this.grid.upperBorder.attr({\n              stroke: b.lineColor,\n              \"stroke-width\": b.lineWidth\n            }), this.grid.upperBorder.animate({\n              d: e\n            })), this.grid.lowerBorder || 0 === h % 1 || (this.grid.lowerBorder = this.grid.renderBorder(f)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({\n              stroke: b.lineColor,\n              \"stroke-width\": b.lineWidth\n            }), this.grid.lowerBorder.animate({\n              d: f\n            })));\n            this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({\n              stroke: b.lineColor,\n              \"stroke-width\": b.lineWidth\n            }), this.grid.axisLineExtra.animate({\n              d\n            })) : this.grid.axisLineExtra = this.grid.renderBorder(d);\n            this.axisLine[this.showAxis ? \"show\" : \"hide\"]();\n          }\n        }\n        (a && a.columns || []).forEach(a => a.render());\n        if (!this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar)) {\n          a = this.tickmarkOffset;\n          b = this.tickPositions[this.tickPositions.length - 1];\n          d = this.tickPositions[0];\n          let e, f;\n          for (; (e = this.hiddenLabels.pop()) && e.element;) e.show();\n          for (; (f = this.hiddenMarks.pop()) && f.element;) f.show();\n          (e = this.ticks[d].label) && (c - d > a ? this.hiddenLabels.push(e.hide()) : e.show());\n          (e = this.ticks[b].label) && (b - h > a ? this.hiddenLabels.push(e.hide()) : e.show());\n          (c = this.ticks[b].mark) && b - h < a && 0 < b - h && this.ticks[b].isLast && this.hiddenMarks.push(c.hide());\n        }\n      }\n    }\n    function t() {\n      const a = this.tickPositions && this.tickPositions.info,\n        b = this.options,\n        c = this.userOptions.labels || {};\n      (b.grid || {}).enabled && (this.horiz ? (this.series.forEach(a => {\n        a.options.pointRange = 0;\n      }), a && b.dateTimeLabelFormats && b.labels && !w(c.align) && (!1 === b.dateTimeLabelFormats[a.unitName].range || 1 < a.count) && (b.labels.align = \"left\", w(c.x) || (b.labels.x = 3))) : \"treegrid\" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));\n    }\n    function r(a) {\n      const d = this.options;\n      a = a.userOptions;\n      const e = d && F.isObject(d.grid, !0) ? d.grid : {};\n      let f;\n      !0 === e.enabled && (f = c(!0, {\n        className: \"highcharts-grid-axis \" + (a.className || \"\"),\n        dateTimeLabelFormats: {\n          hour: {\n            list: [\"%H:%M\", \"%H\"]\n          },\n          day: {\n            list: [\"%A, %e. %B\", \"%a, %e. %b\", \"%E\"]\n          },\n          week: {\n            list: [\"Week %W\", \"W%W\"]\n          },\n          month: {\n            list: [\"%B\", \"%b\", \"%o\"]\n          }\n        },\n        grid: {\n          borderWidth: 1\n        },\n        labels: {\n          padding: 2,\n          style: {\n            fontSize: \"0.9em\"\n          }\n        },\n        margin: 0,\n        title: {\n          text: null,\n          reserveSpace: !1,\n          rotation: 0\n        },\n        units: [[\"millisecond\", [1, 10, 100]], [\"second\", [1, 10]], [\"minute\", [1, 5, 15]], [\"hour\", [1, 6]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1]], [\"year\", null]]\n      }, a), \"xAxis\" === this.coll && (w(a.linkedTo) && !w(a.tickPixelInterval) && (f.tickPixelInterval = 350), w(a.tickPixelInterval) || !w(a.linkedTo) || w(a.tickPositioner) || w(a.tickInterval) || (f.tickPositioner = function (a, c) {\n        var d = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;\n        if (d) {\n          var e = f.units || [];\n          let h;\n          var g = 1;\n          let k = \"year\";\n          for (let a = 0; a < e.length; a++) {\n            const b = e[a];\n            if (b && b[0] === d.unitName) {\n              h = a;\n              break;\n            }\n          }\n          (e = b(h) && e[h + 1]) ? (k = e[0] || \"year\", g = (g = e[1]) && g[0] || 1) : \"year\" === d.unitName && (g = 10 * d.count);\n          d = G[k];\n          this.tickInterval = d * g;\n          return this.chart.time.getTimeTicks({\n            unitRange: d,\n            count: g,\n            unitName: k\n          }, a, c, this.options.startOfWeek);\n        }\n      })), c(!0, this.options, f), this.horiz && (d.minPadding = n(a.minPadding, 0), d.maxPadding = n(a.maxPadding, 0)), b(d.grid.borderWidth) && (d.tickWidth = d.lineWidth = e.borderWidth));\n    }\n    function g(a) {\n      a = (a = a.userOptions) && a.grid || {};\n      const b = a.columns;\n      a.enabled && b && c(!0, this.options, b[b.length - 1]);\n    }\n    function p() {\n      (this.grid.columns || []).forEach(a => a.setScale());\n    }\n    function v(a) {\n      const {\n        horiz: b,\n        maxLabelDimensions: c,\n        options: {\n          grid: e = {}\n        }\n      } = this;\n      if (e.enabled && c) {\n        var f = 2 * this.options.labels.distance;\n        f = b ? e.cellHeight || f + c.height : f + c.width;\n        d(a.tickSize) ? a.tickSize[0] = f : a.tickSize = [f, 0];\n      }\n    }\n    function l() {\n      this.axes.forEach(a => {\n        (a.grid && a.grid.columns || []).forEach(a => {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n      });\n    }\n    function m(a) {\n      const {\n        grid: b\n      } = this;\n      (b.columns || []).forEach(b => b.destroy(a.keepEvents));\n      b.columns = void 0;\n    }\n    function f(a) {\n      a = a.userOptions || {};\n      const b = a.grid || {};\n      b.enabled && w(b.borderColor) && (a.tickColor = a.lineColor = b.borderColor);\n      this.grid || (this.grid = new R(this));\n      this.hiddenLabels = [];\n      this.hiddenMarks = [];\n    }\n    function k(a) {\n      var c = this.label;\n      const d = this.axis;\n      var e = d.reversed,\n        f = d.chart,\n        g = d.options.grid || {};\n      const h = d.options.labels,\n        k = h.align;\n      var l = K[d.side],\n        m = a.tickmarkOffset,\n        n = d.tickPositions;\n      const q = this.pos - m;\n      n = b(n[a.index + 1]) ? n[a.index + 1] - m : (d.max || 0) + m;\n      var p = d.tickSize(\"tick\");\n      m = p ? p[0] : 0;\n      p = p ? p[1] / 2 : 0;\n      if (!0 === g.enabled) {\n        let b;\n        \"top\" === l ? (g = d.top + d.offset, b = g - m) : \"bottom\" === l ? (b = f.chartHeight - d.bottom + d.offset, g = b + m) : (g = d.top + d.len - (d.translate(e ? n : q) || 0), b = d.top + d.len - (d.translate(e ? q : n) || 0));\n        \"right\" === l ? (l = f.chartWidth - d.right + d.offset, e = l + m) : \"left\" === l ? (e = d.left + d.offset, l = e - m) : (l = Math.round(d.left + (d.translate(e ? n : q) || 0)) - p, e = Math.min(Math.round(d.left + (d.translate(e ? q : n) || 0)) - p, d.left + d.len));\n        this.slotWidth = e - l;\n        a.pos.x = \"left\" === k ? l : \"right\" === k ? e : l + (e - l) / 2;\n        a.pos.y = b + (g - b) / 2;\n        c && (f = f.renderer.fontMetrics(c), c = c.getBBox().height, a.pos.y = h.useHTML ? a.pos.y + (f.b + -(c / 2)) : a.pos.y + ((f.b - (f.h - f.f)) / 2 + -((Math.round(c / f.h) - 1) * f.h / 2)));\n        a.pos.x += d.horiz && h.x || 0;\n      }\n    }\n    function x(a) {\n      const {\n        axis: b,\n        value: d\n      } = a;\n      if (b.options.grid && b.options.grid.enabled) {\n        var e = b.tickPositions;\n        const f = (b.linkedParent || b).series[0],\n          g = d === e[0];\n        e = d === e[e.length - 1];\n        const h = f && u(f.options.data, function (a) {\n          return a[b.isXAxis ? \"x\" : \"y\"] === d;\n        });\n        let k;\n        h && f.is(\"gantt\") && (k = c(h), z.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(k));\n        a.isFirst = g;\n        a.isLast = e;\n        a.point = k;\n      }\n    }\n    function J() {\n      const a = this.options,\n        b = this.categories,\n        c = this.tickPositions,\n        d = c[0],\n        e = c[c.length - 1],\n        f = this.linkedParent && this.linkedParent.min || this.min,\n        g = this.linkedParent && this.linkedParent.max || this.max,\n        h = this.tickInterval;\n      !0 !== (a.grid || {}).enabled || b || !this.horiz && !this.isLinked || (d < f && d + h > f && !a.startOnTick && (c[0] = f), e > g && e - h < g && !a.endOnTick && (c[c.length - 1] = g));\n    }\n    function C(a) {\n      const {\n        options: {\n          grid: b = {}\n        }\n      } = this;\n      return !0 === b.enabled && this.categories ? this.tickInterval : a.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n    const {\n        dateFormats: e\n      } = z,\n      {\n        addEvent: h,\n        defined: w,\n        erase: q,\n        find: u,\n        isArray: d,\n        isNumber: b,\n        merge: c,\n        pick: n,\n        timeUnits: G,\n        wrap: I\n      } = F;\n    var K = /*#__PURE__*/(() => {\n      (function (a) {\n        a[a.top = 0] = \"top\";\n        a[a.right = 1] = \"right\";\n        a[a.bottom = 2] = \"bottom\";\n        a[a.left = 3] = \"left\";\n      })(K || (K = {}));\n      return K;\n    })();\n    const L = [];\n    class R {\n      constructor(a) {\n        this.axis = a;\n      }\n      isOuterAxis() {\n        const a = this.axis,\n          c = a.grid.columnIndex,\n          d = a.linkedParent && a.linkedParent.grid.columns || a.grid.columns,\n          e = c ? a.linkedParent : a;\n        let f = -1,\n          g = 0;\n        (a.chart[a.coll] || []).forEach((b, c) => {\n          b.side !== a.side || b.options.isInternal || (g = c, b === e && (f = c));\n        });\n        return g === f && (b(c) ? d.length === c : !0);\n      }\n      renderBorder(a) {\n        const b = this.axis,\n          c = b.chart.renderer,\n          d = b.options;\n        a = c.path(a).addClass(\"highcharts-axis-line\").add(b.axisBorder);\n        c.styledMode || a.attr({\n          stroke: d.lineColor,\n          \"stroke-width\": d.lineWidth,\n          zIndex: 7\n        });\n        return a;\n      }\n    }\n    e.E = function (a) {\n      return this.dateFormat(\"%a\", a, !0).charAt(0);\n    };\n    e.W = function (a) {\n      const b = this,\n        c = new this.Date(a);\n      [\"Hours\", \"Milliseconds\", \"Minutes\", \"Seconds\"].forEach(function (a) {\n        b.set(a, c, 0);\n      });\n      var d = (this.get(\"Day\", c) + 6) % 7;\n      a = new this.Date(c.valueOf());\n      this.set(\"Date\", a, this.get(\"Date\", c) - d + 3);\n      d = new this.Date(this.get(\"FullYear\", a), 0, 1);\n      4 !== this.get(\"Day\", d) && (this.set(\"Month\", c, 0), this.set(\"Date\", c, 1 + (11 - this.get(\"Day\", d)) % 7));\n      return (1 + Math.floor((a.valueOf() - d.valueOf()) / 6048E5)).toString();\n    };\n    \"\";\n    return {\n      compose: function (a, b, c) {\n        F.pushUnique(L, a) && (a.keepProps.push(\"grid\"), a.prototype.getMaxLabelDimensions = y, I(a.prototype, \"unsquish\", C), h(a, \"init\", f), h(a, \"afterGetOffset\", A), h(a, \"afterGetTitlePosition\", D), h(a, \"afterInit\", E), h(a, \"afterRender\", B), h(a, \"afterSetAxisTranslation\", t), h(a, \"afterSetOptions\", r), h(a, \"afterSetOptions\", g), h(a, \"afterSetScale\", p), h(a, \"afterTickSize\", v), h(a, \"trimTicks\", J), h(a, \"destroy\", m));\n        F.pushUnique(L, b) && h(b, \"afterSetChartSize\", l);\n        F.pushUnique(L, c) && (h(c, \"afterGetLabelPosition\", k), h(c, \"labelFormat\", x));\n        return a;\n      }\n    };\n  });\n  L(a, \"Gantt/Tree.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n        extend: y,\n        isNumber: F,\n        pick: H\n      } = a,\n      A = function (a, y) {\n        const t = a.reduce(function (a, g) {\n          const p = H(g.parent, \"\");\n          \"undefined\" === typeof a[p] && (a[p] = []);\n          a[p].push(g);\n          return a;\n        }, {});\n        Object.keys(t).forEach(function (a, g) {\n          const p = t[a];\n          \"\" !== a && -1 === y.indexOf(a) && (p.forEach(function (a) {\n            g[\"\"].push(a);\n          }), delete g[a]);\n        });\n        return t;\n      },\n      D = function (a, z, t, r, g, p) {\n        let v = 0,\n          l = 0,\n          m = p && p.after;\n        var f = p && p.before;\n        z = {\n          data: r,\n          depth: t - 1,\n          id: a,\n          level: t,\n          parent: z\n        };\n        let k, x;\n        \"function\" === typeof f && f(z, p);\n        f = (g[a] || []).map(function (f) {\n          const m = D(f.id, a, t + 1, f, g, p),\n            e = f.start;\n          f = !0 === f.milestone ? e : f.end;\n          k = !F(k) || e < k ? e : k;\n          x = !F(x) || f > x ? f : x;\n          v = v + 1 + m.descendants;\n          l = Math.max(m.height + 1, l);\n          return m;\n        });\n        r && (r.start = H(r.start, k), r.end = H(r.end, x));\n        y(z, {\n          children: f,\n          descendants: v,\n          height: l\n        });\n        \"function\" === typeof m && m(z, p);\n        return z;\n      };\n    return {\n      getListOfParents: A,\n      getNode: D,\n      getTree: function (a, y) {\n        const t = a.map(function (a) {\n          return a.id;\n        });\n        a = A(a, t);\n        return D(\"\", null, 1, null, a, y);\n      }\n    };\n  });\n  L(a, \"Core/Axis/TreeGrid/TreeGridTick.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function y() {\n      this.treeGrid || (this.treeGrid = new p(this));\n    }\n    function F(a, g) {\n      a = a.treeGrid;\n      const l = !a.labelIcon,\n        f = g.renderer;\n      var k = g.xy;\n      const p = g.options,\n        r = p.width || 0,\n        v = p.height || 0;\n      var e = k.x - r / 2 - (p.padding || 0);\n      k = k.y - v / 2;\n      const h = g.collapsed ? 90 : 180,\n        w = g.show && B(k);\n      let q = a.labelIcon;\n      q || (a.labelIcon = q = f.path(f.symbols[p.type](p.x || 0, p.y || 0, r, v)).addClass(\"highcharts-label-icon\").add(g.group));\n      q[w ? \"show\" : \"hide\"]();\n      f.styledMode || q.attr({\n        cursor: \"pointer\",\n        fill: t(g.color, \"#666666\"),\n        \"stroke-width\": 1,\n        stroke: p.lineColor,\n        strokeWidth: p.lineWidth || 0\n      });\n      q[l ? \"attr\" : \"animate\"]({\n        translateX: e,\n        translateY: k,\n        rotation: h\n      });\n    }\n    function H(a, g, m, f, k, p, r, y, e) {\n      var h = t(this.options && this.options.labels, p);\n      p = this.pos;\n      var l = this.axis;\n      const q = \"treegrid\" === l.options.type;\n      a = a.apply(this, [g, m, f, k, h, r, y, e]);\n      q && (g = h && E(h.symbol, !0) ? h.symbol : {}, h = h && B(h.indentation) ? h.indentation : 0, p = (p = (l = l.treeGrid.mapOfPosToGridNode) && l[p]) && p.depth || 1, a.x += (g.width || 0) + 2 * (g.padding || 0) + (p - 1) * h);\n      return a;\n    }\n    function A(a) {\n      const g = this;\n      var m = g.pos,\n        f = g.axis;\n      const k = g.label;\n      var p = f.treeGrid.mapOfPosToGridNode,\n        r = f.options;\n      const v = t(g.options && g.options.labels, r && r.labels);\n      var e = v && E(v.symbol, !0) ? v.symbol : {};\n      const h = (p = p && p[m]) && p.depth;\n      r = \"treegrid\" === r.type;\n      const w = -1 < f.tickPositions.indexOf(m);\n      m = f.chart.styledMode;\n      r && p && k && k.element && k.addClass(\"highcharts-treegrid-node-level-\" + h);\n      a.apply(g, Array.prototype.slice.call(arguments, 1));\n      r && k && k.element && p && p.descendants && 0 < p.descendants && (f = f.treeGrid.isCollapsed(p), F(g, {\n        color: !m && k.styles && k.styles.color || \"\",\n        collapsed: f,\n        group: k.parentGroup,\n        options: e,\n        renderer: k.renderer,\n        show: w,\n        xy: k.xy\n      }), e = \"highcharts-treegrid-node-\" + (f ? \"expanded\" : \"collapsed\"), k.addClass(\"highcharts-treegrid-node-\" + (f ? \"collapsed\" : \"expanded\")).removeClass(e), m || k.css({\n        cursor: \"pointer\"\n      }), [k, g.treeGrid.labelIcon].forEach(a => {\n        a && !a.attachedTreeGridEvents && (D(a.element, \"mouseover\", function () {\n          k.addClass(\"highcharts-treegrid-node-active\");\n          k.renderer.styledMode || k.css({\n            textDecoration: \"underline\"\n          });\n        }), D(a.element, \"mouseout\", function () {\n          {\n            const a = E(v.style) ? v.style : {};\n            k.removeClass(\"highcharts-treegrid-node-active\");\n            k.renderer.styledMode || k.css({\n              textDecoration: a.textDecoration\n            });\n          }\n        }), D(a.element, \"click\", function () {\n          g.treeGrid.toggleCollapse();\n        }), a.attachedTreeGridEvents = !0);\n      }));\n    }\n    const {\n        addEvent: D,\n        isObject: E,\n        isNumber: B,\n        pick: t,\n        wrap: r\n      } = a,\n      g = [];\n    class p {\n      static compose(p) {\n        a.pushUnique(g, p) && (D(p, \"init\", y), r(p.prototype, \"getLabelPosition\", H), r(p.prototype, \"renderLabel\", A), p.prototype.collapse = function (a) {\n          this.treeGrid.collapse(a);\n        }, p.prototype.expand = function (a) {\n          this.treeGrid.expand(a);\n        }, p.prototype.toggleCollapse = function (a) {\n          this.treeGrid.toggleCollapse(a);\n        });\n      }\n      constructor(a) {\n        this.tick = a;\n      }\n      collapse(a) {\n        var g = this.tick;\n        const m = g.axis,\n          f = m.brokenAxis;\n        f && m.treeGrid.mapOfPosToGridNode && (g = m.treeGrid.collapse(m.treeGrid.mapOfPosToGridNode[g.pos]), f.setBreaks(g, t(a, !0)));\n      }\n      destroy() {\n        this.labelIcon && this.labelIcon.destroy();\n      }\n      expand(a) {\n        var g = this.tick;\n        const m = g.axis,\n          f = m.brokenAxis;\n        f && m.treeGrid.mapOfPosToGridNode && (g = m.treeGrid.expand(m.treeGrid.mapOfPosToGridNode[g.pos]), f.setBreaks(g, t(a, !0)));\n      }\n      toggleCollapse(a) {\n        var g = this.tick;\n        const m = g.axis,\n          f = m.brokenAxis;\n        f && m.treeGrid.mapOfPosToGridNode && (g = m.treeGrid.toggleCollapse(m.treeGrid.mapOfPosToGridNode[g.pos]), f.setBreaks(g, t(a, !0)));\n      }\n    }\n    return p;\n  });\n  L(a, \"Series/TreeUtilities.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Utilities.js\"]], function (a, z) {\n    function y(a, g) {\n      var p = g.before;\n      const r = g.idRoot,\n        l = g.mapIdToNode[r],\n        m = g.points[a.i],\n        f = m && m.options || {},\n        k = [];\n      let x = 0;\n      a.levelDynamic = a.level - (!1 !== g.levelIsConstant ? 0 : l.level);\n      a.name = t(m && m.name, \"\");\n      a.visible = r === a.id || !0 === g.visible;\n      \"function\" === typeof p && (a = p(a, g));\n      a.children.forEach((f, l) => {\n        const e = H({}, g);\n        H(e, {\n          index: l,\n          siblings: a.children.length,\n          visible: a.visible\n        });\n        f = y(f, e);\n        k.push(f);\n        f.visible && (x += f.val);\n      });\n      p = t(f.value, x);\n      a.visible = 0 <= p && (0 < x || a.visible);\n      a.children = k;\n      a.childrenTotal = x;\n      a.isLeaf = a.visible && !x;\n      a.val = p;\n      return a;\n    }\n    const {\n      extend: H,\n      isArray: A,\n      isNumber: D,\n      isObject: E,\n      merge: B,\n      pick: t\n    } = z;\n    return {\n      getColor: function (r, g) {\n        const p = g.index;\n        var v = g.mapOptionsToLevel;\n        const l = g.parentColor,\n          m = g.parentColorIndex,\n          f = g.series;\n        var k = g.colors;\n        const x = g.siblings;\n        var y = f.points,\n          z = f.chart.options.chart;\n        let e;\n        var h;\n        let w;\n        if (r) {\n          y = y[r.i];\n          r = v[r.level] || {};\n          if (v = y && r.colorByPoint) {\n            e = y.index % (k ? k.length : z.colorCount);\n            var q = k && k[e];\n          }\n          if (!f.chart.styledMode) {\n            k = y && y.options.color;\n            z = r && r.color;\n            if (h = l) h = (h = r && r.colorVariation) && \"brightness\" === h.key && p && x ? a.parse(l).brighten(p / x * h.to).get() : l;\n            h = t(k, z, q, h, f.color);\n          }\n          w = t(y && y.options.colorIndex, r && r.colorIndex, e, m, g.colorIndex);\n        }\n        return {\n          color: h,\n          colorIndex: w\n        };\n      },\n      getLevelOptions: function (a) {\n        let g = {},\n          p,\n          r,\n          l;\n        if (E(a)) {\n          l = D(a.from) ? a.from : 1;\n          var m = a.levels;\n          r = {};\n          p = E(a.defaults) ? a.defaults : {};\n          A(m) && (r = m.reduce((a, g) => {\n            let f, k;\n            E(g) && D(g.level) && (k = B({}, g), f = t(k.levelIsConstant, p.levelIsConstant), delete k.levelIsConstant, delete k.level, g = g.level + (f ? 0 : l - 1), E(a[g]) ? B(!0, a[g], k) : a[g] = k);\n            return a;\n          }, {}));\n          m = D(a.to) ? a.to : 1;\n          for (a = 0; a <= m; a++) g[a] = B({}, p, E(r[a]) ? r[a] : {});\n        }\n        return g;\n      },\n      setTreeValues: y,\n      updateRootId: function (a) {\n        if (E(a)) {\n          var g = E(a.options) ? a.options : {};\n          g = t(a.rootNode, g.rootId, \"\");\n          E(a.userOptions) && (a.userOptions.rootId = g);\n          a.rootNode = g;\n        }\n        return g;\n      }\n    };\n  });\n  L(a, \"Core/Axis/TreeGrid/TreeGridAxis.js\", [a[\"Core/Axis/BrokenAxis.js\"], a[\"Core/Axis/GridAxis.js\"], a[\"Gantt/Tree.js\"], a[\"Core/Axis/TreeGrid/TreeGridTick.js\"], a[\"Series/TreeUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H, A, D) {\n    function y(a, b) {\n      const c = a.collapseEnd || 0;\n      a = a.collapseStart || 0;\n      c >= b && (a -= .5);\n      return {\n        from: a,\n        to: c,\n        showPoints: !1\n      };\n    }\n    function B(a, b, c) {\n      const d = [],\n        e = [],\n        f = {},\n        g = \"boolean\" === typeof b ? b : !1;\n      let h = {},\n        k = -1;\n      a = F.getTree(a, {\n        after: function (a) {\n          a = h[a.pos];\n          let b = 0,\n            c = 0;\n          a.children.forEach(function (a) {\n            c += (a.descendants || 0) + 1;\n            b = Math.max((a.height || 0) + 1, b);\n          });\n          a.descendants = c;\n          a.height = b;\n          a.collapsed && e.push(a);\n        },\n        before: function (a) {\n          const b = x(a.data, !0) ? a.data : {},\n            c = J(b.name) ? b.name : \"\";\n          var e = f[a.parent];\n          e = x(e, !0) ? h[e.pos] : null;\n          var l = function (a) {\n            return a.name === c;\n          };\n          let n;\n          g && x(e, !0) && (n = m(e.children, l)) ? (l = n.pos, n.nodes.push(a)) : l = k++;\n          h[l] || (h[l] = n = {\n            depth: e ? e.depth + 1 : 0,\n            name: c,\n            id: b.id,\n            nodes: [a],\n            children: [],\n            pos: l\n          }, -1 !== l && d.push(c), x(e, !0) && e.children.push(n));\n          J(a.id) && (f[a.id] = a);\n          n && !0 === b.collapsed && (n.collapsed = !0);\n          a.pos = l;\n        }\n      });\n      h = function (a, b) {\n        const c = function (a, d, e) {\n          let f = d + (-1 === d ? 0 : b - 1);\n          const g = (f - d) / 2,\n            h = d + g;\n          a.nodes.forEach(function (a) {\n            const b = a.data;\n            x(b, !0) && (b.y = d + (b.seriesIndex || 0), delete b.seriesIndex);\n            a.pos = h;\n          });\n          e[h] = a;\n          a.pos = h;\n          a.tickmarkOffset = g + .5;\n          a.collapseStart = f + .5;\n          a.children.forEach(function (a) {\n            c(a, f + 1, e);\n            f = (a.collapseEnd || 0) - .5;\n          });\n          a.collapseEnd = f + .5;\n          return e;\n        };\n        return c(a[\"-1\"], -1, {});\n      }(h, c);\n      return {\n        categories: d,\n        mapOfIdToNode: f,\n        mapOfPosToGridNode: h,\n        collapsedNodes: e,\n        tree: a\n      };\n    }\n    function t(a) {\n      a.target.axes.filter(function (a) {\n        return \"treegrid\" === a.options.type;\n      }).forEach(function (b) {\n        var c = b.options || {};\n        const d = c.labels,\n          e = c.uniqueNames;\n        c = c.max;\n        let f = 0,\n          g;\n        if (!b.treeGrid.mapOfPosToGridNode || b.series.some(function (a) {\n          return !a.hasRendered || a.isDirtyData || a.isDirty;\n        })) {\n          g = b.series.reduce(function (a, b) {\n            b.visible && ((b.options.data || []).forEach(function (c) {\n              b.options.keys && b.options.keys.length && (c = b.pointClass.prototype.optionsToObject.call({\n                series: b\n              }, c), b.pointClass.setGanttPointAliases(c));\n              x(c, !0) && (c.seriesIndex = f, a.push(c));\n            }), !0 === e && f++);\n            return a;\n          }, []);\n          if (c && g.length < c) for (let a = g.length; a <= c; a++) g.push({\n            name: a + \"\\u200b\"\n          });\n          c = B(g, e || !1, !0 === e ? f : 1);\n          b.categories = c.categories;\n          b.treeGrid.mapOfPosToGridNode = c.mapOfPosToGridNode;\n          b.hasNames = !0;\n          b.treeGrid.tree = c.tree;\n          b.series.forEach(function (a) {\n            const b = (a.options.data || []).map(function (b) {\n              k(b) && a.options.keys && a.options.keys.length && g.forEach(function (a) {\n                0 <= b.indexOf(a.x) && 0 <= b.indexOf(a.x2) && (b = a);\n              });\n              return x(b, !0) ? C(b) : b;\n            });\n            a.visible && a.setData(b, !1);\n          });\n          b.treeGrid.mapOptionsToLevel = v({\n            defaults: d,\n            from: 1,\n            levels: d && d.levels,\n            to: b.treeGrid.tree && b.treeGrid.tree.height\n          });\n          \"beforeRender\" === a.type && (b.treeGrid.collapsedNodes = c.collapsedNodes);\n        }\n      });\n    }\n    function r(a, b) {\n      var c = this.treeGrid.mapOptionsToLevel || {};\n      const d = this.ticks;\n      let e = d[b],\n        f,\n        g;\n      \"treegrid\" === this.options.type && this.treeGrid.mapOfPosToGridNode ? (g = this.treeGrid.mapOfPosToGridNode[b], (c = c[g.depth]) && (f = {\n        labels: c\n      }), !e && q ? d[b] = new q(this, b, void 0, void 0, {\n        category: g.name,\n        tickmarkOffset: g.tickmarkOffset,\n        options: f\n      }) : (e.parameters.category = g.name, e.options = f, e.addLabel())) : a.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n    function g(a, b, c) {\n      const d = this,\n        e = \"treegrid\" === c.type;\n      d.treeGrid || (d.treeGrid = new u(d));\n      e && (l(b, \"beforeRender\", t), l(b, \"beforeRedraw\", t), l(b, \"addSeries\", function (a) {\n        a.options.data && (a = B(a.options.data, c.uniqueNames || !1, 1), d.treeGrid.collapsedNodes = (d.treeGrid.collapsedNodes || []).concat(a.collapsedNodes));\n      }), l(d, \"foundExtremes\", function () {\n        d.treeGrid.collapsedNodes && d.treeGrid.collapsedNodes.forEach(function (a) {\n          const b = d.treeGrid.collapse(a);\n          d.brokenAxis && (d.brokenAxis.setBreaks(b, !1), d.treeGrid.collapsedNodes && (d.treeGrid.collapsedNodes = d.treeGrid.collapsedNodes.filter(b => a.collapseStart !== b.collapseStart || a.collapseEnd !== b.collapseEnd)));\n        });\n      }), l(d, \"afterBreaks\", function () {\n        \"yAxis\" === d.coll && !d.staticScale && d.chart.options.chart.height && (d.isDirty = !0);\n      }), c = C({\n        grid: {\n          enabled: !0\n        },\n        labels: {\n          align: \"left\",\n          levels: [{\n            level: void 0\n          }, {\n            level: 1,\n            style: {\n              fontWeight: \"bold\"\n            }\n          }],\n          symbol: {\n            type: \"triangle\",\n            x: -5,\n            y: -5,\n            height: 10,\n            width: 10,\n            padding: 5\n          }\n        },\n        uniqueNames: !1\n      }, c, {\n        reversed: !0,\n        grid: {\n          columns: void 0\n        }\n      }));\n      a.apply(d, [b, c]);\n      e && (d.hasNames = !0, d.options.showLastLabel = !0);\n    }\n    function p(a) {\n      const b = this.options;\n      \"treegrid\" === b.type ? (this.min = e(this.userMin, b.min, this.dataMin), this.max = e(this.userMax, b.max, this.dataMax), f(this, \"foundExtremes\"), this.setAxisTranslation(), this.tickmarkOffset = .5, this.tickInterval = 1, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : []) : a.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n    const {\n        getLevelOptions: v\n      } = A,\n      {\n        addEvent: l,\n        find: m,\n        fireEvent: f,\n        isArray: k,\n        isObject: x,\n        isString: J,\n        merge: C,\n        pick: e,\n        wrap: h\n      } = D,\n      w = [];\n    let q;\n    class u {\n      static compose(d, b, c, e) {\n        if (D.pushUnique(w, d)) {\n          -1 === d.keepProps.indexOf(\"treeGrid\") && d.keepProps.push(\"treeGrid\");\n          const a = d.prototype;\n          h(a, \"generateTick\", r);\n          h(a, \"init\", g);\n          h(a, \"setTickInterval\", p);\n          a.utils = {\n            getNode: F.getNode\n          };\n        }\n        D.pushUnique(w, e) && (q || (q = e));\n        z.compose(d, b, e);\n        a.compose(d, c);\n        H.compose(e);\n        return d;\n      }\n      constructor(a) {\n        this.axis = a;\n      }\n      setCollapsedStatus(a) {\n        const b = this.axis,\n          c = b.chart;\n        b.series.forEach(function (b) {\n          const d = b.options.data;\n          if (a.id && d) {\n            const e = c.get(a.id);\n            b = d[b.data.indexOf(e)];\n            e && b && (e.collapsed = a.collapsed, b.collapsed = a.collapsed);\n          }\n        });\n      }\n      collapse(a) {\n        const b = this.axis,\n          c = b.options.breaks || [],\n          d = y(a, b.max);\n        c.push(d);\n        a.collapsed = !0;\n        b.treeGrid.setCollapsedStatus(a);\n        return c;\n      }\n      expand(a) {\n        const b = this.axis,\n          c = b.options.breaks || [],\n          d = y(a, b.max);\n        a.collapsed = !1;\n        b.treeGrid.setCollapsedStatus(a);\n        return c.reduce(function (a, b) {\n          b.to === d.to && b.from === d.from || a.push(b);\n          return a;\n        }, []);\n      }\n      getTickPositions() {\n        const a = this.axis,\n          b = Math.floor(a.min / a.tickInterval) * a.tickInterval,\n          c = Math.ceil(a.max / a.tickInterval) * a.tickInterval;\n        return Object.keys(a.treeGrid.mapOfPosToGridNode || {}).reduce(function (d, e) {\n          e = +e;\n          !(e >= b && e <= c) || a.brokenAxis && a.brokenAxis.isInAnyBreak(e) || d.push(e);\n          return d;\n        }, []);\n      }\n      isCollapsed(a) {\n        const b = this.axis,\n          c = b.options.breaks || [],\n          d = y(a, b.max);\n        return c.some(function (a) {\n          return a.from === d.from && a.to === d.to;\n        });\n      }\n      toggleCollapse(a) {\n        return this.isCollapsed(a) ? this.expand(a) : this.collapse(a);\n      }\n    }\n    return u;\n  });\n  L(a, \"Extensions/StaticScale.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n      addEvent: y,\n      defined: A,\n      isNumber: D,\n      pick: E\n    } = F;\n    y(a, \"afterSetOptions\", function () {\n      const a = this.chart.options.chart;\n      !this.horiz && D(this.options.staticScale) && (!a.height || a.scrollablePlotArea && a.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);\n    });\n    z.prototype.adjustHeight = function () {\n      \"adjustHeight\" !== this.redrawTrigger && ((this.axes || []).forEach(function (a) {\n        let t = a.chart,\n          r = !!t.initiatedScale && t.options.animation;\n        var g = a.options.staticScale;\n        let p;\n        a.staticScale && A(a.min) && (p = E(a.brokenAxis && a.brokenAxis.unitLength, a.max + a.tickInterval - a.min) * g, p = Math.max(p, g), g = p - t.plotHeight, !t.scrollablePixelsY && 1 <= Math.abs(g) && (t.plotHeight = p, t.redrawTrigger = \"adjustHeight\", t.setSize(void 0, t.chartHeight + g, r)), a.series.forEach(function (a) {\n          (a = a.sharedClipKey && t.sharedClips[a.sharedClipKey]) && a.attr(t.inverted ? {\n            width: t.plotHeight\n          } : {\n            height: t.plotHeight\n          });\n        }));\n      }), this.initiatedScale = !0);\n      this.redrawTrigger = null;\n    };\n    y(z, \"render\", z.prototype.adjustHeight);\n  });\n  L(a, \"Gantt/Connection.js\", [a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, z, F, H) {\n    function y(a) {\n      var f = a.shapeArgs;\n      return f ? {\n        xMin: f.x || 0,\n        xMax: (f.x || 0) + (f.width || 0),\n        yMin: f.y || 0,\n        yMax: (f.y || 0) + (f.height || 0)\n      } : (f = a.graphic && a.graphic.getBBox()) ? {\n        xMin: a.plotX - f.width / 2,\n        xMax: a.plotX + f.width / 2,\n        yMin: a.plotY - f.height / 2,\n        yMax: a.plotY + f.height / 2\n      } : null;\n    }\n    ({\n      defaultOptions: a\n    } = a);\n    const {\n      defined: D,\n      error: E,\n      extend: B,\n      merge: t,\n      objectEach: r\n    } = H;\n    \"\";\n    const g = z.deg2rad,\n      p = Math.max,\n      v = Math.min;\n    B(a, {\n      connectors: {\n        type: \"straight\",\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    });\n    class l {\n      constructor(a, f, g) {\n        this.toPoint = this.pathfinder = this.graphics = this.fromPoint = this.chart = void 0;\n        this.init(a, f, g);\n      }\n      init(a, f, g) {\n        this.fromPoint = a;\n        this.toPoint = f;\n        this.options = g;\n        this.chart = a.series.chart;\n        this.pathfinder = this.chart.pathfinder;\n      }\n      renderPath(a, f, g) {\n        let k = this.chart,\n          l = k.styledMode,\n          m = k.pathfinder,\n          e = !k.options.chart.forExport && !1 !== g,\n          h = this.graphics && this.graphics.path;\n        m.group || (m.group = k.renderer.g().addClass(\"highcharts-pathfinder-group\").attr({\n          zIndex: -1\n        }).add(k.seriesGroup));\n        m.group.translate(k.plotLeft, k.plotTop);\n        h && h.renderer || (h = k.renderer.path().add(m.group), l || h.attr({\n          opacity: 0\n        }));\n        h.attr(f);\n        a = {\n          d: a\n        };\n        l || (a.opacity = 1);\n        h[e ? \"animate\" : \"attr\"](a, g);\n        this.graphics = this.graphics || {};\n        this.graphics.path = h;\n      }\n      addMarker(a, f, k) {\n        var l = this.fromPoint.series.chart;\n        let m = l.pathfinder;\n        l = l.renderer;\n        let p = \"start\" === a ? this.fromPoint : this.toPoint;\n        var e = p.getPathfinderAnchorPoint(f);\n        let h, r;\n        f.enabled && ((k = \"start\" === a ? k[1] : k[k.length - 2]) && \"M\" === k[0] || \"L\" === k[0]) && (k = {\n          x: k[1],\n          y: k[2]\n        }, k = p.getRadiansToVector(k, e), e = p.getMarkerVector(k, f.radius, e), k = -k / g, f.width && f.height ? (h = f.width, r = f.height) : h = r = 2 * f.radius, this.graphics = this.graphics || {}, e = {\n          x: e.x - h / 2,\n          y: e.y - r / 2,\n          width: h,\n          height: r,\n          rotation: k,\n          rotationOriginX: e.x,\n          rotationOriginY: e.y\n        }, this.graphics[a] ? this.graphics[a].animate(e) : (this.graphics[a] = l.symbol(f.symbol).addClass(\"highcharts-point-connecting-path-\" + a + \"-marker\").attr(e).add(m.group), l.styledMode || this.graphics[a].attr({\n          fill: f.color || this.fromPoint.color,\n          stroke: f.lineColor,\n          \"stroke-width\": f.lineWidth,\n          opacity: 0\n        }).animate({\n          opacity: 1\n        }, p.series.options.animation)));\n      }\n      getPath(a) {\n        let f = this.pathfinder,\n          g = this.chart,\n          l = f.algorithms[a.type],\n          m = f.chartObstacles;\n        if (\"function\" !== typeof l) return E('\"' + a.type + '\" is not a Pathfinder algorithm.'), {\n          path: [],\n          obstacles: []\n        };\n        l.requiresObstacles && !m && (m = f.chartObstacles = f.getChartObstacles(a), g.options.connectors.algorithmMargin = a.algorithmMargin, f.chartObstacleMetrics = f.getObstacleMetrics(m));\n        return l(this.fromPoint.getPathfinderAnchorPoint(a.startMarker), this.toPoint.getPathfinderAnchorPoint(a.endMarker), t({\n          chartObstacles: m,\n          lineObstacles: f.lineObstacles || [],\n          obstacleMetrics: f.chartObstacleMetrics,\n          hardBounds: {\n            xMin: 0,\n            xMax: g.plotWidth,\n            yMin: 0,\n            yMax: g.plotHeight\n          },\n          obstacleOptions: {\n            margin: a.algorithmMargin\n          },\n          startDirectionX: f.getAlgorithmStartDirection(a.startMarker)\n        }, a));\n      }\n      render() {\n        var a = this.fromPoint;\n        let f = a.series;\n        var g = f.chart;\n        let l = g.pathfinder,\n          r = t(g.options.connectors, f.options.connectors, a.options.connectors, this.options),\n          y = {};\n        g.styledMode || (y.stroke = r.lineColor || a.color, y[\"stroke-width\"] = r.lineWidth, r.dashStyle && (y.dashstyle = r.dashStyle));\n        y[\"class\"] = \"highcharts-point-connecting-path highcharts-color-\" + a.colorIndex;\n        r = t(y, r);\n        D(r.marker.radius) || (r.marker.radius = v(p(Math.ceil((r.algorithmMargin || 8) / 2) - 1, 1), 5));\n        a = this.getPath(r);\n        g = a.path;\n        a.obstacles && (l.lineObstacles = l.lineObstacles || [], l.lineObstacles = l.lineObstacles.concat(a.obstacles));\n        this.renderPath(g, y, f.options.animation);\n        this.addMarker(\"start\", t(r.marker, r.startMarker), g);\n        this.addMarker(\"end\", t(r.marker, r.endMarker), g);\n      }\n      destroy() {\n        this.graphics && (r(this.graphics, function (a) {\n          a.destroy();\n        }), delete this.graphics);\n      }\n    }\n    z.Connection = l;\n    B(F.prototype, {\n      getPathfinderAnchorPoint: function (a) {\n        let f = y(this),\n          g,\n          l;\n        switch (a.align) {\n          case \"right\":\n            g = \"xMax\";\n            break;\n          case \"left\":\n            g = \"xMin\";\n        }\n        switch (a.verticalAlign) {\n          case \"top\":\n            l = \"yMin\";\n            break;\n          case \"bottom\":\n            l = \"yMax\";\n        }\n        return {\n          x: g ? f[g] : (f.xMin + f.xMax) / 2,\n          y: l ? f[l] : (f.yMin + f.yMax) / 2\n        };\n      },\n      getRadiansToVector: function (a, f) {\n        let g;\n        D(f) || (g = y(this)) && (f = {\n          x: (g.xMin + g.xMax) / 2,\n          y: (g.yMin + g.yMax) / 2\n        });\n        return Math.atan2(f.y - a.y, a.x - f.x);\n      },\n      getMarkerVector: function (a, f, g) {\n        var k = 2 * Math.PI,\n          l = y(this),\n          m = l.xMax - l.xMin;\n        let e = l.yMax - l.yMin,\n          h = Math.atan2(e, m),\n          p = !1;\n        m /= 2;\n        let q = e / 2,\n          r = l.xMin + m;\n        l = l.yMin + q;\n        var d = r,\n          b = l;\n        let c = 1,\n          n = 1;\n        for (; a < -Math.PI;) a += k;\n        for (; a > Math.PI;) a -= k;\n        k = Math.tan(a);\n        a > -h && a <= h ? (n = -1, p = !0) : a > h && a <= Math.PI - h ? n = -1 : a > Math.PI - h || a <= -(Math.PI - h) ? (c = -1, p = !0) : c = -1;\n        p ? (d += c * m, b += n * m * k) : (d += e / (2 * k) * c, b += n * q);\n        g.x !== r && (d = g.x);\n        g.y !== l && (b = g.y);\n        return {\n          x: d + f * Math.cos(a),\n          y: b - f * Math.sin(a)\n        };\n      }\n    });\n    return l;\n  });\n  L(a, \"Gantt/PathfinderAlgorithms.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function y(a, p, r) {\n      r = r || 0;\n      let g = a.length - 1;\n      p -= 1e-7;\n      let m, f;\n      for (; r <= g;) if (m = g + r >> 1, f = p - a[m].xMin, 0 < f) r = m + 1;else if (0 > f) g = m - 1;else return m;\n      return 0 < r ? r - 1 : 0;\n    }\n    function F(a, p) {\n      let g = y(a, p.x + 1) + 1;\n      for (; g--;) {\n        var l;\n        if (l = a[g].xMax >= p.x) l = a[g], l = p.x <= l.xMax && p.x >= l.xMin && p.y <= l.yMax && p.y >= l.yMin;\n        if (l) return g;\n      }\n      return -1;\n    }\n    function H(a) {\n      const g = [];\n      if (a.length) {\n        g.push([\"M\", a[0].start.x, a[0].start.y]);\n        for (let p = 0; p < a.length; ++p) g.push([\"L\", a[p].end.x, a[p].end.y]);\n      }\n      return g;\n    }\n    function A(a, p) {\n      a.yMin = B(a.yMin, p.yMin);\n      a.yMax = E(a.yMax, p.yMax);\n      a.xMin = B(a.xMin, p.xMin);\n      a.xMax = E(a.xMax, p.xMax);\n    }\n    const {\n        pick: D\n      } = a,\n      {\n        min: E,\n        max: B,\n        abs: t\n      } = Math;\n    a = function (a, p, r) {\n      function g(a, e, f, g, d) {\n        a = {\n          x: a.x,\n          y: a.y\n        };\n        a[e] = f[g || e] + (d || 0);\n        return a;\n      }\n      function m(a, e, f) {\n        const h = t(e[f] - a[f + \"Min\"]) > t(e[f] - a[f + \"Max\"]);\n        return g(e, f, a, f + (h ? \"Max\" : \"Min\"), h ? 1 : -1);\n      }\n      let f = [];\n      var k = D(r.startDirectionX, t(p.x - a.x) > t(p.y - a.y)) ? \"x\" : \"y\",\n        v = r.chartObstacles;\n      let y = F(v, a);\n      r = F(v, p);\n      let z;\n      if (-1 < r) {\n        var e = v[r];\n        r = m(e, p, k);\n        e = {\n          start: r,\n          end: p\n        };\n        z = r;\n      } else z = p;\n      -1 < y && (v = v[y], r = m(v, a, k), f.push({\n        start: a,\n        end: r\n      }), r[k] >= a[k] === r[k] >= z[k] && (k = \"y\" === k ? \"x\" : \"y\", p = a[k] < p[k], f.push({\n        start: r,\n        end: g(r, k, v, k + (p ? \"Max\" : \"Min\"), p ? 1 : -1)\n      }), k = \"y\" === k ? \"x\" : \"y\"));\n      a = f.length ? f[f.length - 1].end : a;\n      r = g(a, k, z);\n      f.push({\n        start: a,\n        end: r\n      });\n      k = g(r, \"y\" === k ? \"x\" : \"y\", z);\n      f.push({\n        start: r,\n        end: k\n      });\n      f.push(e);\n      return {\n        path: H(f),\n        obstacles: f\n      };\n    };\n    a.requiresObstacles = !0;\n    const r = function (a, p, r) {\n      function g(a, b, d) {\n        let e,\n          f,\n          g,\n          h,\n          k,\n          l = a.x < b.x ? 1 : -1;\n        a.x < b.x ? (e = a, f = b) : (e = b, f = a);\n        a.y < b.y ? (h = a, g = b) : (h = b, g = a);\n        for (k = 0 > l ? E(y(c, f.x), c.length - 1) : 0; c[k] && (0 < l && c[k].xMin <= f.x || 0 > l && c[k].xMax >= e.x);) {\n          if (c[k].xMin <= f.x && c[k].xMax >= e.x && c[k].yMin <= g.y && c[k].yMax >= h.y) return d ? {\n            y: a.y,\n            x: a.x < b.x ? c[k].xMin - 1 : c[k].xMax + 1,\n            obstacle: c[k]\n          } : {\n            x: a.x,\n            y: a.y < b.y ? c[k].yMin - 1 : c[k].yMax + 1,\n            obstacle: c[k]\n          };\n          k += l;\n        }\n        return b;\n      }\n      function m(a, b, c, d, e) {\n        var f = e.soft,\n          h = e.hard;\n        let k = d ? \"x\" : \"y\",\n          l = {\n            x: b.x,\n            y: b.y\n          },\n          m = {\n            x: b.x,\n            y: b.y\n          };\n        e = a[k + \"Max\"] >= f[k + \"Max\"];\n        f = a[k + \"Min\"] <= f[k + \"Min\"];\n        let n = a[k + \"Max\"] >= h[k + \"Max\"];\n        h = a[k + \"Min\"] <= h[k + \"Min\"];\n        let p = t(a[k + \"Min\"] - b[k]),\n          q = t(a[k + \"Max\"] - b[k]);\n        c = 10 > t(p - q) ? b[k] < c[k] : q < p;\n        m[k] = a[k + \"Min\"];\n        l[k] = a[k + \"Max\"];\n        a = g(b, m, d)[k] !== m[k];\n        b = g(b, l, d)[k] !== l[k];\n        c = a ? b ? c : !0 : b ? !1 : c;\n        c = f ? e ? c : !0 : e ? !1 : c;\n        return h ? n ? c : !0 : n ? !1 : c;\n      }\n      function f(a, e, k) {\n        if (a.x === e.x && a.y === e.y) return [];\n        var l = k ? \"x\" : \"y\";\n        let n,\n          p,\n          t,\n          w = r.obstacleOptions.margin;\n        var v = {\n          soft: {\n            xMin: q,\n            xMax: u,\n            yMin: d,\n            yMax: b\n          },\n          hard: r.hardBounds\n        };\n        n = F(c, a);\n        -1 < n ? (n = c[n], v = m(n, a, e, k, v), A(n, r.hardBounds), t = k ? {\n          y: a.y,\n          x: n[v ? \"xMax\" : \"xMin\"] + (v ? 1 : -1)\n        } : {\n          x: a.x,\n          y: n[v ? \"yMax\" : \"yMin\"] + (v ? 1 : -1)\n        }, p = F(c, t), -1 < p && (p = c[p], A(p, r.hardBounds), t[l] = v ? B(n[l + \"Max\"] - w + 1, (p[l + \"Min\"] + n[l + \"Max\"]) / 2) : E(n[l + \"Min\"] + w - 1, (p[l + \"Max\"] + n[l + \"Min\"]) / 2), a.x === t.x && a.y === t.y ? (h && (t[l] = v ? B(n[l + \"Max\"], p[l + \"Max\"]) + 1 : E(n[l + \"Min\"], p[l + \"Min\"]) - 1), h = !h) : h = !1), a = [{\n          start: a,\n          end: t\n        }]) : (l = g(a, {\n          x: k ? e.x : a.x,\n          y: k ? a.y : e.y\n        }, k), a = [{\n          start: a,\n          end: {\n            x: l.x,\n            y: l.y\n          }\n        }], l[k ? \"x\" : \"y\"] !== e[k ? \"x\" : \"y\"] && (v = m(l.obstacle, l, e, !k, v), A(l.obstacle, r.hardBounds), v = {\n          x: k ? l.x : l.obstacle[v ? \"xMax\" : \"xMin\"] + (v ? 1 : -1),\n          y: k ? l.obstacle[v ? \"yMax\" : \"yMin\"] + (v ? 1 : -1) : l.y\n        }, k = !k, a = a.concat(f({\n          x: l.x,\n          y: l.y\n        }, v, k))));\n        return a = a.concat(f(a[a.length - 1].end, e, !k));\n      }\n      function k(a, b, c) {\n        const d = E(a.xMax - b.x, b.x - a.xMin) < E(a.yMax - b.y, b.y - a.yMin);\n        c = m(a, b, c, d, {\n          soft: r.hardBounds,\n          hard: r.hardBounds\n        });\n        return d ? {\n          y: b.y,\n          x: a[c ? \"xMax\" : \"xMin\"] + (c ? 1 : -1)\n        } : {\n          x: b.x,\n          y: a[c ? \"yMax\" : \"yMin\"] + (c ? 1 : -1)\n        };\n      }\n      let v = D(r.startDirectionX, t(p.x - a.x) > t(p.y - a.y)),\n        z = v ? \"x\" : \"y\";\n      let C,\n        e = [],\n        h = !1;\n      var w = r.obstacleMetrics;\n      let q = E(a.x, p.x) - w.maxWidth - 10,\n        u = B(a.x, p.x) + w.maxWidth + 10,\n        d = E(a.y, p.y) - w.maxHeight - 10,\n        b = B(a.y, p.y) + w.maxHeight + 10,\n        c = r.chartObstacles;\n      var n = y(c, q);\n      w = y(c, u);\n      c = c.slice(n, w + 1);\n      -1 < (w = F(c, p)) && (C = k(c[w], p, a), e.push({\n        end: p,\n        start: C\n      }), p = C);\n      for (; -1 < (w = F(c, p));) n = 0 > p[z] - a[z], C = {\n        x: p.x,\n        y: p.y\n      }, C[z] = c[w][n ? z + \"Max\" : z + \"Min\"] + (n ? 1 : -1), e.push({\n        end: p,\n        start: C\n      }), p = C;\n      a = f(a, p, v);\n      a = a.concat(e.reverse());\n      return {\n        path: H(a),\n        obstacles: a\n      };\n    };\n    r.requiresObstacles = !0;\n    return {\n      fastAvoid: r,\n      straight: function (a, p) {\n        return {\n          path: [[\"M\", a.x, a.y], [\"L\", p.x, p.y]],\n          obstacles: [{\n            start: a,\n            end: p\n          }]\n        };\n      },\n      simpleConnect: a\n    };\n  });\n  L(a, \"Gantt/Pathfinder.js\", [a[\"Gantt/Connection.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"], a[\"Gantt/PathfinderAlgorithms.js\"]], function (a, z, F, H, A, D, E) {\n    function y(a) {\n      var e = a.shapeArgs;\n      return e ? {\n        xMin: e.x || 0,\n        xMax: (e.x || 0) + (e.width || 0),\n        yMin: e.y || 0,\n        yMax: (e.y || 0) + (e.height || 0)\n      } : (e = a.graphic && a.graphic.getBBox()) ? {\n        xMin: a.plotX - e.width / 2,\n        xMax: a.plotX + e.width / 2,\n        yMin: a.plotY - e.height / 2,\n        yMax: a.plotY + e.height / 2\n      } : null;\n    }\n    function t(a) {\n      let e = a.length,\n        g = 0,\n        k,\n        l,\n        d = [],\n        b = function (a, d, e) {\n          e = f(e, 10);\n          const c = a.yMax + e > d.yMin - e && a.yMin - e < d.yMax + e,\n            g = a.xMax + e > d.xMin - e && a.xMin - e < d.xMax + e,\n            h = c ? a.xMin > d.xMax ? a.xMin - d.xMax : d.xMin - a.xMax : Infinity,\n            k = g ? a.yMin > d.yMax ? a.yMin - d.yMax : d.yMin - a.yMax : Infinity;\n          return g && c ? e ? b(a, d, Math.floor(e / 2)) : Infinity : J(h, k);\n        };\n      for (; g < e; ++g) for (k = g + 1; k < e; ++k) l = b(a[g], a[k]), 80 > l && d.push(l);\n      d.push(80);\n      return x(Math.floor(d.sort(function (a, b) {\n        return a - b;\n      })[Math.floor(d.length / 10)] / 2 - 1), 1);\n    }\n    function r(a) {\n      if (a.options.pathfinder || a.series.reduce(function (a, e) {\n        e.options && m(!0, e.options.connectors = e.options.connectors || {}, e.options.pathfinder);\n        return a || e.options && e.options.pathfinder;\n      }, !1)) m(!0, a.options.connectors = a.options.connectors || {}, a.options.pathfinder), v('WARNING: Pathfinder options have been renamed. Use \"chart.connectors\" or \"series.connectors\" instead.');\n    }\n    ({\n      defaultOptions: F\n    } = F);\n    const {\n      addEvent: g,\n      defined: p,\n      error: v,\n      extend: l,\n      merge: m,\n      pick: f,\n      splat: k\n    } = D;\n    \"\";\n    const x = Math.max,\n      J = Math.min;\n    l(F, {\n      connectors: {\n        type: \"straight\",\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    });\n    class C {\n      constructor(a) {\n        this.lineObstacles = this.group = this.connections = this.chartObstacleMetrics = this.chartObstacles = this.chart = void 0;\n        this.init(a);\n      }\n      init(a) {\n        this.chart = a;\n        this.connections = [];\n        g(a, \"redraw\", function () {\n          this.pathfinder.update();\n        });\n      }\n      update(e) {\n        const f = this.chart,\n          g = this,\n          l = g.connections;\n        g.connections = [];\n        f.series.forEach(function (e) {\n          e.visible && !e.options.isInternal && e.points.forEach(function (d) {\n            var b = d.options;\n            b && b.dependency && (b.connect = b.dependency);\n            let c;\n            b = d.options && d.options.connect && k(d.options.connect);\n            d.visible && !1 !== d.isInside && b && b.forEach(function (b) {\n              c = f.get(\"string\" === typeof b ? b : b.to);\n              c instanceof A && c.series.visible && c.visible && !1 !== c.isInside && g.connections.push(new a(d, c, \"string\" === typeof b ? {} : b));\n            });\n          });\n        });\n        for (let a = 0, d, b, c = l.length, e = g.connections.length; a < c; ++a) {\n          b = !1;\n          const c = l[a];\n          for (d = 0; d < e; ++d) {\n            const a = g.connections[d];\n            if ((c.options && c.options.type) === (a.options && a.options.type) && c.fromPoint === a.fromPoint && c.toPoint === a.toPoint) {\n              a.graphics = c.graphics;\n              b = !0;\n              break;\n            }\n          }\n          b || c.destroy();\n        }\n        delete this.chartObstacles;\n        delete this.lineObstacles;\n        g.renderConnections(e);\n      }\n      renderConnections(a) {\n        a ? this.chart.series.forEach(function (a) {\n          const e = function () {\n            const e = a.chart.pathfinder;\n            (e && e.connections || []).forEach(function (e) {\n              e.fromPoint && e.fromPoint.series === a && e.render();\n            });\n            a.pathfinderRemoveRenderEvent && (a.pathfinderRemoveRenderEvent(), delete a.pathfinderRemoveRenderEvent);\n          };\n          !1 === a.options.animation ? e() : a.pathfinderRemoveRenderEvent = g(a, \"afterAnimate\", e);\n        }) : this.connections.forEach(function (a) {\n          a.render();\n        });\n      }\n      getChartObstacles(a) {\n        let e = [],\n          g = this.chart.series,\n          k = f(a.algorithmMargin, 0),\n          l;\n        for (let a = 0, b = g.length; a < b; ++a) if (g[a].visible && !g[a].options.isInternal) for (let b = 0, d = g[a].points.length, f, h; b < d; ++b) h = g[a].points[b], h.visible && (f = y(h)) && e.push({\n          xMin: f.xMin - k,\n          xMax: f.xMax + k,\n          yMin: f.yMin - k,\n          yMax: f.yMax + k\n        });\n        e = e.sort(function (a, b) {\n          return a.xMin - b.xMin;\n        });\n        p(a.algorithmMargin) || (l = a.algorithmMargin = t(e), e.forEach(function (a) {\n          a.xMin -= l;\n          a.xMax += l;\n          a.yMin -= l;\n          a.yMax += l;\n        }));\n        return e;\n      }\n      getObstacleMetrics(a) {\n        let e = 0,\n          f = 0,\n          g,\n          k,\n          d = a.length;\n        for (; d--;) g = a[d].xMax - a[d].xMin, k = a[d].yMax - a[d].yMin, e < g && (e = g), f < k && (f = k);\n        return {\n          maxHeight: f,\n          maxWidth: e\n        };\n      }\n      getAlgorithmStartDirection(a) {\n        let e = \"top\" !== a.verticalAlign && \"bottom\" !== a.verticalAlign;\n        return \"left\" !== a.align && \"right\" !== a.align ? e ? void 0 : !1 : e ? !0 : void 0;\n      }\n    }\n    C.prototype.algorithms = E;\n    H.Pathfinder = C;\n    l(A.prototype, {\n      getPathfinderAnchorPoint: function (a) {\n        let e = y(this),\n          f,\n          g;\n        switch (a.align) {\n          case \"right\":\n            f = \"xMax\";\n            break;\n          case \"left\":\n            f = \"xMin\";\n        }\n        switch (a.verticalAlign) {\n          case \"top\":\n            g = \"yMin\";\n            break;\n          case \"bottom\":\n            g = \"yMax\";\n        }\n        return {\n          x: f ? e[f] : (e.xMin + e.xMax) / 2,\n          y: g ? e[g] : (e.yMin + e.yMax) / 2\n        };\n      },\n      getRadiansToVector: function (a, f) {\n        let e;\n        p(f) || (e = y(this)) && (f = {\n          x: (e.xMin + e.xMax) / 2,\n          y: (e.yMin + e.yMax) / 2\n        });\n        return Math.atan2(f.y - a.y, a.x - f.x);\n      },\n      getMarkerVector: function (a, f, g) {\n        var e = 2 * Math.PI,\n          h = y(this),\n          d = h.xMax - h.xMin;\n        let b = h.yMax - h.yMin,\n          c = Math.atan2(b, d),\n          k = !1;\n        d /= 2;\n        let l = b / 2,\n          m = h.xMin + d;\n        h = h.yMin + l;\n        var p = m,\n          r = h;\n        let t = 1,\n          v = 1;\n        for (; a < -Math.PI;) a += e;\n        for (; a > Math.PI;) a -= e;\n        e = Math.tan(a);\n        a > -c && a <= c ? (v = -1, k = !0) : a > c && a <= Math.PI - c ? v = -1 : a > Math.PI - c || a <= -(Math.PI - c) ? (t = -1, k = !0) : t = -1;\n        k ? (p += t * d, r += v * d * e) : (p += b / (2 * e) * t, r += v * l);\n        g.x !== m && (p = g.x);\n        g.y !== h && (r = g.y);\n        return {\n          x: p + f * Math.cos(a),\n          y: r - f * Math.sin(a)\n        };\n      }\n    });\n    z.prototype.callbacks.push(function (a) {\n      !1 !== a.options.connectors.enabled && (r(a), this.pathfinder = new C(this), this.pathfinder.update(!0));\n    });\n    return C;\n  });\n  L(a, \"Series/Gantt/GanttSeries.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Series/Gantt/GanttPoint.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Utilities.js\"], a[\"Core/Axis/TreeGrid/TreeGridAxis.js\"]], function (a, z, F, H, A, D, E) {\n    const {\n        series: y,\n        seriesTypes: {\n          xrange: t\n        }\n      } = H,\n      {\n        extend: r,\n        isNumber: g,\n        merge: p\n      } = D;\n    E.compose(a, z, y, A);\n    class v extends t {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawPoint(a, m) {\n        let f = this.options,\n          k = this.chart.renderer;\n        var l = a.shapeArgs;\n        let p = a.plotY,\n          r = a.graphic,\n          e = a.selected && \"select\",\n          h = f.stacking && !f.borderRadius;\n        if (a.options.milestone) {\n          if (g(p) && null !== a.y && !1 !== a.visible) {\n            l = k.symbols.diamond(l.x || 0, l.y || 0, l.width || 0, l.height || 0);\n            if (r) r[m]({\n              d: l\n            });else a.graphic = k.path(l).addClass(a.getClassName(), !0).add(a.group || this.group);\n            this.chart.styledMode || a.graphic.attr(this.pointAttribs(a, e)).shadow(f.shadow, null, h);\n          } else r && (a.graphic = r.destroy());\n        } else t.prototype.drawPoint.call(this, a, m);\n      }\n      translatePoint(a) {\n        let g, f;\n        t.prototype.translatePoint.call(this, a);\n        a.options.milestone && (g = a.shapeArgs, f = g.height || 0, a.shapeArgs = {\n          x: (g.x || 0) - f / 2,\n          y: g.y,\n          width: f,\n          height: f\n        });\n      }\n    }\n    v.defaultOptions = p(t.defaultOptions, {\n      grouping: !1,\n      dataLabels: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"font-size: 0.8em\">{series.name}</span><br/>',\n        pointFormat: null,\n        pointFormatter: function () {\n          var a = this.series,\n            m = a.xAxis;\n          let f = a.tooltipOptions.dateTimeLabelFormats,\n            k = m.options.startOfWeek,\n            p = a.tooltipOptions,\n            r = p.xDateFormat,\n            t = this.options.milestone,\n            e = \"<b>\" + (this.name || this.yCategory) + \"</b>\";\n          if (p.pointFormat) return this.tooltipFormatter(p.pointFormat);\n          !r && g(this.start) && (r = a.chart.time.getDateFormat(m.closestPointRange, this.start, k, f || {}));\n          m = a.chart.time.dateFormat(r, this.start);\n          a = a.chart.time.dateFormat(r, this.end);\n          e += \"<br/>\";\n          return t ? e + (m + \"<br/>\") : e + (\"Start: \" + m + \"<br/>End: \") + (a + \"<br/>\");\n        }\n      },\n      connectors: {\n        type: \"simpleConnect\",\n        animation: {\n          reversed: !0\n        },\n        startMarker: {\n          enabled: !0,\n          symbol: \"arrow-filled\",\n          radius: 4,\n          fill: \"#fa0\",\n          align: \"left\"\n        },\n        endMarker: {\n          enabled: !1,\n          align: \"right\"\n        }\n      }\n    });\n    r(v.prototype, {\n      pointArrayMap: [\"start\", \"end\", \"y\"],\n      pointClass: F,\n      setData: y.prototype.setData\n    });\n    H.registerSeriesType(\"gantt\", v);\n    \"\";\n    return v;\n  });\n  L(a, \"Core/Chart/GanttChart.js\", [a[\"Core/Chart/Chart.js\"], a[\"Core/Defaults.js\"], a[\"Core/Utilities.js\"]], function (a, z, F) {\n    const {\n        getOptions: y\n      } = z,\n      {\n        isArray: A,\n        merge: D,\n        splat: E\n      } = F;\n    class B extends a {\n      init(a, r) {\n        const g = y(),\n          p = a.xAxis,\n          t = a.yAxis;\n        let l;\n        a.xAxis = a.yAxis = void 0;\n        const m = D(!0, {\n          chart: {\n            type: \"gantt\"\n          },\n          title: {\n            text: null\n          },\n          legend: {\n            enabled: !1\n          },\n          navigator: {\n            series: {\n              type: \"gantt\"\n            },\n            yAxis: {\n              type: \"category\"\n            }\n          }\n        }, a, {\n          isGantt: !0\n        });\n        a.xAxis = p;\n        a.yAxis = t;\n        m.xAxis = (A(a.xAxis) ? a.xAxis : [a.xAxis || {}, {}]).map(function (a, k) {\n          1 === k && (l = 0);\n          return D(g.xAxis, {\n            grid: {\n              enabled: !0\n            },\n            opposite: !0,\n            linkedTo: l\n          }, a, {\n            type: \"datetime\"\n          });\n        });\n        m.yAxis = E(a.yAxis || {}).map(function (a) {\n          return D(g.yAxis, {\n            grid: {\n              enabled: !0\n            },\n            staticScale: 50,\n            reversed: !0,\n            type: a.categories ? a.type : \"treegrid\"\n          }, a);\n        });\n        super.init(m, r);\n      }\n    }\n    (function (a) {\n      a.ganttChart = function (r, g, p) {\n        return new a(r, g, p);\n      };\n    })(B || (B = {}));\n    return B;\n  });\n  L(a, \"Extensions/ArrowSymbols.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function y(a, y, t, r) {\n      return [[\"M\", a, y + r / 2], [\"L\", a + t, y], [\"L\", a, y + r / 2], [\"L\", a + t, y + r]];\n    }\n    function F(a, z, t, r) {\n      return y(a, z, t / 2, r);\n    }\n    function H(a, y, t, r) {\n      return [[\"M\", a + t, y], [\"L\", a, y + r / 2], [\"L\", a + t, y + r], [\"Z\"]];\n    }\n    function A(a, y, t, r) {\n      return H(a, y, t / 2, r);\n    }\n    const D = [];\n    return {\n      compose: function (z) {\n        a.pushUnique(D, z) && (z = z.prototype.symbols, z.arrow = y, z[\"arrow-filled\"] = H, z[\"arrow-filled-half\"] = A, z[\"arrow-half\"] = F, z[\"triangle-left\"] = H, z[\"triangle-left-half\"] = A);\n      }\n    };\n  });\n  L(a, \"Extensions/CurrentDateIndication.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function y() {\n      const a = this.options;\n      var g = a.currentDateIndicator;\n      g && (g = \"object\" === typeof g ? D(t, g) : D(t), g.value = Date.now(), g.className = \"highcharts-current-date-indicator\", a.plotLines || (a.plotLines = []), a.plotLines.push(g));\n    }\n    function F() {\n      this.label && this.label.attr({\n        text: this.getLabelText(this.options.label)\n      });\n    }\n    function H(a, g) {\n      const p = this.options;\n      return p && p.className && -1 !== p.className.indexOf(\"highcharts-current-date-indicator\") && p.label && \"function\" === typeof p.label.formatter ? (p.value = Date.now(), p.label.formatter.call(this, p.value, p.label.format)) : a.call(this, g);\n    }\n    const {\n        addEvent: A,\n        merge: D,\n        wrap: E\n      } = a,\n      B = [],\n      t = {\n        color: \"#ccd3ff\",\n        width: 2,\n        label: {\n          format: \"%a, %b %d %Y, %H:%M\",\n          formatter: function (a, g) {\n            return this.axis.chart.time.dateFormat(g || \"\", a);\n          },\n          rotation: 0,\n          style: {\n            fontSize: \"0.7em\"\n          }\n        }\n      };\n    return {\n      compose: function (r, g) {\n        a.pushUnique(B, r) && A(r, \"afterSetOptions\", y);\n        a.pushUnique(B, g) && (A(g, \"render\", F), E(g.prototype, \"getLabelText\", H));\n      }\n    };\n  });\n  L(a, \"masters/modules/gantt.src.js\", [a[\"Core/Globals.js\"], a[\"Stock/Navigator/Navigator.js\"], a[\"Stock/Scrollbar/Scrollbar.js\"], a[\"Stock/RangeSelector/RangeSelector.js\"], a[\"Series/XRange/XRangeSeries.js\"], a[\"Core/Chart/GanttChart.js\"], a[\"Extensions/ArrowSymbols.js\"], a[\"Extensions/CurrentDateIndication.js\"]], function (a, z, F, H, A, D, E, B) {\n    a.GanttChart = D;\n    a.ganttChart = D.ganttChart;\n    a.Navigator = z;\n    a.RangeSelector = H;\n    a.Scrollbar = F;\n    E.compose(a.SVGRenderer);\n    B.compose(a.Axis, a.PlotLineOrBand);\n    z.compose(a.Axis, a.Chart, a.Series);\n    H.compose(a.Axis, a.Chart);\n    F.compose(a.Axis);\n    A.compose(a.Axis);\n  });\n  L(a, \"masters/highcharts-gantt.src.js\", [a[\"masters/highcharts.src.js\"]], function (a) {\n    a.product = \"Highcharts Gantt\";\n    return a;\n  });\n  a[\"masters/highcharts-gantt.src.js\"]._modules = a;\n  return a[\"masters/highcharts-gantt.src.js\"];\n});\n//# sourceMappingURL=highcharts-gantt.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
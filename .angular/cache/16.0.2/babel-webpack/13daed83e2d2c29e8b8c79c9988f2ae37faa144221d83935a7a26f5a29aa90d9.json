{"ast":null,"code":"/*\n Highstock JS v11.0.1 (2023-05-08)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\n(function (V, M) {\n  \"object\" === typeof module && module.exports ? (M[\"default\"] = M, module.exports = V.document ? M(V) : M) : \"function\" === typeof define && define.amd ? define(\"highcharts/highstock\", function () {\n    return M(V);\n  }) : (V.Highcharts && V.Highcharts.error(16, !0), V.Highcharts = M(V));\n})(\"undefined\" !== typeof window ? window : this, function (V) {\n  function M(a, A, H, I) {\n    a.hasOwnProperty(A) || (a[A] = I.apply(null, H), \"function\" === typeof CustomEvent && V.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: A,\n        module: a[A]\n      }\n    })));\n  }\n  var a = {};\n  M(a, \"Core/Globals.js\", [], function () {\n    var a;\n    (function (a) {\n      a.SVG_NS = \"http://www.w3.org/2000/svg\";\n      a.product = \"Highcharts\";\n      a.version = \"11.0.1\";\n      a.win = \"undefined\" !== typeof V ? V : {};\n      a.doc = a.win.document;\n      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, \"svg\").createSVGRect;\n      a.userAgent = a.win.navigator && a.win.navigator.userAgent || \"\";\n      a.isChrome = -1 !== a.userAgent.indexOf(\"Chrome\");\n      a.isFirefox = -1 !== a.userAgent.indexOf(\"Firefox\");\n      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;\n      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf(\"Safari\");\n      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);\n      a.isWebKit = -1 !== a.userAgent.indexOf(\"AppleWebKit\");\n      a.deg2rad = 2 * Math.PI / 360;\n      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split(\"Firefox/\")[1], 10);\n      a.hasTouch = !!a.win.TouchEvent;\n      a.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"];\n      a.noop = function () {};\n      a.supportsPassiveEvents = function () {\n        let u = !1;\n        if (!a.isMS) {\n          const A = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              u = !0;\n            }\n          });\n          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener(\"testPassive\", a.noop, A), a.win.removeEventListener(\"testPassive\", a.noop, A));\n        }\n        return u;\n      }();\n      a.charts = [];\n      a.dateFormats = {};\n      a.seriesTypes = {};\n      a.symbolSizes = {};\n      a.chartCount = 0;\n    })(a || (a = {}));\n    \"\";\n    return a;\n  });\n  M(a, \"Core/Utilities.js\", [a[\"Core/Globals.js\"]], function (a) {\n    function u(c, b, g, J) {\n      const f = b ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === c && (c = `${f}: Deprecated member`);\n      const x = r(c);\n      let q = x ? `${f} #${c}: www.highcharts.com/errors/${c}/` : c.toString();\n      if (\"undefined\" !== typeof J) {\n        let c = \"\";\n        x && (q += \"?\");\n        L(J, function (b, f) {\n          c += `\\n - ${f}: ${b}`;\n          x && (q += encodeURI(f) + \"=\" + encodeURI(b));\n        });\n        q += c;\n      }\n      e(a, \"displayError\", {\n        chart: g,\n        code: c,\n        message: q,\n        params: J\n      }, function () {\n        if (b) throw Error(q);\n        l.console && -1 === u.messages.indexOf(q) && console.warn(q);\n      });\n      u.messages.push(q);\n    }\n    function H(c, b) {\n      const f = {};\n      L(c, function (g, z) {\n        if (C(c[z], !0) && !c.nodeType && b[z]) g = H(c[z], b[z]), Object.keys(g).length && (f[z] = g);else if (C(c[z]) || c[z] !== b[z] || z in c && !(z in b)) f[z] = c[z];\n      });\n      return f;\n    }\n    function I(c, b) {\n      return parseInt(c, b || 10);\n    }\n    function F(c) {\n      return \"string\" === typeof c;\n    }\n    function G(c) {\n      c = Object.prototype.toString.call(c);\n      return \"[object Array]\" === c || \"[object Array Iterator]\" === c;\n    }\n    function C(c, b) {\n      return !!c && \"object\" === typeof c && (!b || !G(c));\n    }\n    function B(c) {\n      return C(c) && \"number\" === typeof c.nodeType;\n    }\n    function t(c) {\n      const b = c && c.constructor;\n      return !(!C(c, !0) || B(c) || !b || !b.name || \"Object\" === b.name);\n    }\n    function r(c) {\n      return \"number\" === typeof c && !isNaN(c) && Infinity > c && -Infinity < c;\n    }\n    function d(c) {\n      return \"undefined\" !== typeof c && null !== c;\n    }\n    function p(c, b, g) {\n      const f = F(b) && !d(g);\n      let z;\n      const x = (b, g) => {\n        d(b) ? c.setAttribute(g, b) : f ? (z = c.getAttribute(g)) || \"class\" !== g || (z = c.getAttribute(g + \"Name\")) : c.removeAttribute(g);\n      };\n      F(b) ? x(g, b) : L(b, x);\n      return z;\n    }\n    function m(c, b) {\n      let f;\n      c || (c = {});\n      for (f in b) c[f] = b[f];\n      return c;\n    }\n    function k() {\n      const c = arguments,\n        b = c.length;\n      for (let f = 0; f < b; f++) {\n        const b = c[f];\n        if (\"undefined\" !== typeof b && null !== b) return b;\n      }\n    }\n    function v(c, b) {\n      a.isMS && !a.svg && b && d(b.opacity) && (b.filter = `alpha(opacity=${100 * b.opacity})`);\n      m(c.style, b);\n    }\n    function n(c) {\n      return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));\n    }\n    function h(c, b) {\n      return 1E14 < c ? c : parseFloat(c.toPrecision(b || 14));\n    }\n    function D(c, b, g) {\n      let f;\n      if (\"width\" === b) return b = Math.min(c.offsetWidth, c.scrollWidth), g = c.getBoundingClientRect && c.getBoundingClientRect().width, g < b && g >= b - 1 && (b = Math.floor(g)), Math.max(0, b - (D(c, \"padding-left\", !0) || 0) - (D(c, \"padding-right\", !0) || 0));\n      if (\"height\" === b) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (D(c, \"padding-top\", !0) || 0) - (D(c, \"padding-bottom\", !0) || 0));\n      if (c = l.getComputedStyle(c, void 0)) f = c.getPropertyValue(b), k(g, \"opacity\" !== b) && (f = I(f));\n      return f;\n    }\n    function L(c, b, g) {\n      for (const f in c) Object.hasOwnProperty.call(c, f) && b.call(g || c[f], c[f], f, c);\n    }\n    function E(c, b, g) {\n      function f(b, f) {\n        const g = c.removeEventListener;\n        g && g.call(c, b, f, !1);\n      }\n      function z(g) {\n        let z, N;\n        c.nodeName && (b ? (z = {}, z[b] = !0) : z = g, L(z, function (c, b) {\n          if (g[b]) for (N = g[b].length; N--;) f(b, g[b][N].fn);\n        }));\n      }\n      var l = \"function\" === typeof c && c.prototype || c;\n      if (Object.hasOwnProperty.call(l, \"hcEvents\")) {\n        const c = l.hcEvents;\n        b ? (l = c[b] || [], g ? (c[b] = l.filter(function (c) {\n          return g !== c.fn;\n        }), f(b, g)) : (z(c), c[b] = [])) : (z(c), delete l.hcEvents);\n      }\n    }\n    function e(c, b, g, l) {\n      g = g || {};\n      if (y.createEvent && (c.dispatchEvent || c.fireEvent && c !== a)) {\n        var f = y.createEvent(\"Events\");\n        f.initEvent(b, !0, !0);\n        g = m(f, g);\n        c.dispatchEvent ? c.dispatchEvent(g) : c.fireEvent(b, g);\n      } else if (c.hcEvents) {\n        g.target || m(g, {\n          preventDefault: function () {\n            g.defaultPrevented = !0;\n          },\n          target: c,\n          type: b\n        });\n        f = [];\n        let z = c,\n          l = !1;\n        for (; z.hcEvents;) Object.hasOwnProperty.call(z, \"hcEvents\") && z.hcEvents[b] && (f.length && (l = !0), f.unshift.apply(f, z.hcEvents[b])), z = Object.getPrototypeOf(z);\n        l && f.sort((c, b) => c.order - b.order);\n        f.forEach(b => {\n          !1 === b.fn.call(c, g) && g.preventDefault();\n        });\n      }\n      l && !g.defaultPrevented && l.call(c, g);\n    }\n    const {\n      charts: q,\n      doc: y,\n      win: l\n    } = a;\n    (u || (u = {})).messages = [];\n    Math.easeInOutSine = function (c) {\n      return -.5 * (Math.cos(Math.PI * c) - 1);\n    };\n    var w = Array.prototype.find ? function (c, b) {\n      return c.find(b);\n    } : function (c, b) {\n      let f;\n      const g = c.length;\n      for (f = 0; f < g; f++) if (b(c[f], f)) return c[f];\n    };\n    L({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (c, b) {\n      a[b] = function (f) {\n        u(32, !1, void 0, {\n          [`Highcharts.${b}`]: `use Array.${c}`\n        });\n        return Array.prototype[c].apply(f, [].slice.call(arguments, 1));\n      };\n    });\n    let g;\n    const b = function () {\n      const c = Math.random().toString(36).substring(2, 9) + \"-\";\n      let b = 0;\n      return function () {\n        return \"highcharts-\" + (g ? \"\" : c) + b++;\n      };\n    }();\n    l.jQuery && (l.jQuery.fn.highcharts = function () {\n      const c = [].slice.call(arguments);\n      if (this[0]) return c[0] ? (new a[F(c[0]) ? c.shift() : \"Chart\"](this[0], c[0], c[1]), this) : q[p(this[0], \"data-highcharts-chart\")];\n    });\n    w = {\n      addEvent: function (c, b, g, l = {}) {\n        var f = \"function\" === typeof c && c.prototype || c;\n        Object.hasOwnProperty.call(f, \"hcEvents\") || (f.hcEvents = {});\n        f = f.hcEvents;\n        a.Point && c instanceof a.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = !0);\n        const e = c.addEventListener;\n        e && e.call(c, b, g, a.supportsPassiveEvents ? {\n          passive: void 0 === l.passive ? -1 !== b.indexOf(\"touch\") : l.passive,\n          capture: !1\n        } : !1);\n        f[b] || (f[b] = []);\n        f[b].push({\n          fn: g,\n          order: \"number\" === typeof l.order ? l.order : Infinity\n        });\n        f[b].sort((c, b) => c.order - b.order);\n        return function () {\n          E(c, b, g);\n        };\n      },\n      arrayMax: function (c) {\n        let b = c.length,\n          g = c[0];\n        for (; b--;) c[b] > g && (g = c[b]);\n        return g;\n      },\n      arrayMin: function (b) {\n        let c = b.length,\n          g = b[0];\n        for (; c--;) b[c] < g && (g = b[c]);\n        return g;\n      },\n      attr: p,\n      clamp: function (b, f, g) {\n        return b > f ? b < g ? b : g : f;\n      },\n      cleanRecursively: H,\n      clearTimeout: function (b) {\n        d(b) && clearTimeout(b);\n      },\n      correctFloat: h,\n      createElement: function (b, f, g, l, z) {\n        b = y.createElement(b);\n        f && m(b, f);\n        z && v(b, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        });\n        g && v(b, g);\n        l && l.appendChild(b);\n        return b;\n      },\n      css: v,\n      defined: d,\n      destroyObjectProperties: function (b, f) {\n        L(b, function (c, g) {\n          c && c !== f && c.destroy && c.destroy();\n          delete b[g];\n        });\n      },\n      discardElement: function (b) {\n        b && b.parentElement && b.parentElement.removeChild(b);\n      },\n      erase: function (b, f) {\n        let c = b.length;\n        for (; c--;) if (b[c] === f) {\n          b.splice(c, 1);\n          break;\n        }\n      },\n      error: u,\n      extend: m,\n      extendClass: function (b, f) {\n        const c = function () {};\n        c.prototype = new b();\n        m(c.prototype, f);\n        return c;\n      },\n      find: w,\n      fireEvent: e,\n      getMagnitude: n,\n      getNestedProperty: function (b, f) {\n        for (b = b.split(\".\"); b.length && d(f);) {\n          const c = b.shift();\n          if (\"undefined\" === typeof c || \"__proto__\" === c) return;\n          f = f[c];\n          if (!d(f) || \"function\" === typeof f || \"number\" === typeof f.nodeType || f === l) return;\n        }\n        return f;\n      },\n      getStyle: D,\n      inArray: function (b, f, g) {\n        u(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return f.indexOf(b, g);\n      },\n      isArray: G,\n      isClass: t,\n      isDOMElement: B,\n      isFunction: function (b) {\n        return \"function\" === typeof b;\n      },\n      isNumber: r,\n      isObject: C,\n      isString: F,\n      keys: function (b) {\n        u(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(b);\n      },\n      merge: function () {\n        let b,\n          f = arguments,\n          g = {};\n        const l = function (b, c) {\n          \"object\" !== typeof b && (b = {});\n          L(c, function (f, g) {\n            \"__proto__\" !== g && \"constructor\" !== g && (!C(f, !0) || t(f) || B(f) ? b[g] = c[g] : b[g] = l(b[g] || {}, f));\n          });\n          return b;\n        };\n        !0 === f[0] && (g = f[1], f = Array.prototype.slice.call(f, 2));\n        const z = f.length;\n        for (b = 0; b < z; b++) g = l(g, f[b]);\n        return g;\n      },\n      normalizeTickInterval: function (b, f, g, l, z) {\n        let c = b;\n        g = k(g, n(b));\n        const e = b / g;\n        f || (f = z ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === l && (1 === g ? f = f.filter(function (b) {\n          return 0 === b % 1;\n        }) : .1 >= g && (f = [1 / g])));\n        for (l = 0; l < f.length && !(c = f[l], z && c * g >= b || !z && e <= (f[l] + (f[l + 1] || f[l])) / 2); l++);\n        return c = h(c * g, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: L,\n      offset: function (b) {\n        const c = y.documentElement;\n        b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: b.top + (l.pageYOffset || c.scrollTop) - (c.clientTop || 0),\n          left: b.left + (l.pageXOffset || c.scrollLeft) - (c.clientLeft || 0),\n          width: b.width,\n          height: b.height\n        };\n      },\n      pad: function (b, f, g) {\n        return Array((f || 2) + 1 - String(b).replace(\"-\", \"\").length).join(g || \"0\") + b;\n      },\n      pick: k,\n      pInt: I,\n      pushUnique: function (b, f) {\n        return 0 > b.indexOf(f) && !!b.push(f);\n      },\n      relativeLength: function (b, f, g) {\n        return /%$/.test(b) ? f * parseFloat(b) / 100 + (g || 0) : parseFloat(b);\n      },\n      removeEvent: E,\n      splat: function (b) {\n        return G(b) ? b : [b];\n      },\n      stableSort: function (b, f) {\n        const c = b.length;\n        let g, z;\n        for (z = 0; z < c; z++) b[z].safeI = z;\n        b.sort(function (b, c) {\n          g = f(b, c);\n          return 0 === g ? b.safeI - c.safeI : g;\n        });\n        for (z = 0; z < c; z++) delete b[z].safeI;\n      },\n      syncTimeout: function (b, f, g) {\n        if (0 < f) return setTimeout(b, f, g);\n        b.call(0, g);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: b,\n      useSerialIds: function (b) {\n        return g = k(b, g);\n      },\n      wrap: function (b, f, g) {\n        const c = b[f];\n        b[f] = function () {\n          const b = arguments,\n            f = this;\n          return g.apply(this, [function () {\n            return c.apply(f, arguments.length ? arguments : b);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n    \"\";\n    return w;\n  });\n  M(a, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {\n          zIndex: 6\n        },\n        position: {\n          align: \"right\",\n          x: -10,\n          y: 10\n        }\n      },\n      reflow: !0,\n      type: \"line\",\n      zoomBySingleTouch: !1,\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#334eff\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  });\n  M(a, \"Core/Color/Color.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    const {\n      isNumber: u,\n      merge: I,\n      pInt: F\n    } = A;\n    class G {\n      static parse(a) {\n        return a ? new G(a) : G.None;\n      }\n      constructor(u) {\n        this.rgba = [NaN, NaN, NaN, NaN];\n        this.input = u;\n        const B = a.Color;\n        if (B && B !== G) return new B(u);\n        this.init(u);\n      }\n      init(a) {\n        let B;\n        let t;\n        if (\"object\" === typeof a && \"undefined\" !== typeof a.stops) this.stops = a.stops.map(d => new G(d[1]));else if (\"string\" === typeof a) {\n          this.input = a = G.names[a.toLowerCase()] || a;\n          if (\"#\" === a.charAt(0)) {\n            var r = a.length;\n            var d = parseInt(a.substr(1), 16);\n            7 === r ? B = [(d & 16711680) >> 16, (d & 65280) >> 8, d & 255, 1] : 4 === r && (B = [(d & 3840) >> 4 | (d & 3840) >> 8, (d & 240) >> 4 | d & 240, (d & 15) << 4 | d & 15, 1]);\n          }\n          if (!B) for (d = G.parsers.length; d-- && !B;) t = G.parsers[d], (r = t.regex.exec(a)) && (B = t.parse(r));\n        }\n        B && (this.rgba = B);\n      }\n      get(a) {\n        const B = this.input,\n          t = this.rgba;\n        if (\"object\" === typeof B && \"undefined\" !== typeof this.stops) {\n          const r = I(B);\n          r.stops = [].slice.call(r.stops);\n          this.stops.forEach((d, p) => {\n            r.stops[p] = [r.stops[p][0], d.get(a)];\n          });\n          return r;\n        }\n        return t && u(t[0]) ? \"rgb\" === a || !a && 1 === t[3] ? \"rgb(\" + t[0] + \",\" + t[1] + \",\" + t[2] + \")\" : \"a\" === a ? `${t[3]}` : \"rgba(\" + t.join(\",\") + \")\" : B;\n      }\n      brighten(a) {\n        const B = this.rgba;\n        if (this.stops) this.stops.forEach(function (t) {\n          t.brighten(a);\n        });else if (u(a) && 0 !== a) for (let t = 0; 3 > t; t++) B[t] += F(255 * a), 0 > B[t] && (B[t] = 0), 255 < B[t] && (B[t] = 255);\n        return this;\n      }\n      setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      }\n      tweenTo(a, B) {\n        const t = this.rgba,\n          r = a.rgba;\n        if (!u(t[0]) || !u(r[0])) return a.input || \"none\";\n        a = 1 !== r[3] || 1 !== t[3];\n        return (a ? \"rgba(\" : \"rgb(\") + Math.round(r[0] + (t[0] - r[0]) * (1 - B)) + \",\" + Math.round(r[1] + (t[1] - r[1]) * (1 - B)) + \",\" + Math.round(r[2] + (t[2] - r[2]) * (1 - B)) + (a ? \",\" + (r[3] + (t[3] - r[3]) * (1 - B)) : \"\") + \")\";\n      }\n    }\n    G.names = {\n      white: \"#ffffff\",\n      black: \"#000000\"\n    };\n    G.parsers = [{\n      regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n      parse: function (a) {\n        return [F(a[1]), F(a[2]), F(a[3]), parseFloat(a[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n      parse: function (a) {\n        return [F(a[1]), F(a[2]), F(a[3]), 1];\n      }\n    }];\n    G.None = new G(\"\");\n    \"\";\n    return G;\n  });\n  M(a, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: \"#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1\".split(\" \")\n    };\n  });\n  M(a, \"Core/Time.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    const {\n        win: u\n      } = a,\n      {\n        defined: I,\n        error: F,\n        extend: G,\n        isObject: C,\n        merge: B,\n        objectEach: t,\n        pad: r,\n        pick: d,\n        splat: p,\n        timeUnits: m\n      } = A,\n      k = a.isSafari && u.Intl && u.Intl.DateTimeFormat.prototype.formatRange,\n      v = a.isSafari && u.Intl && !u.Intl.DateTimeFormat.prototype.formatRange;\n    class n {\n      constructor(h) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = u.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(h);\n      }\n      get(h, k) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          const n = k.getTime(),\n            d = n - this.getTimezoneOffset(k);\n          k.setTime(d);\n          h = k[\"getUTC\" + h]();\n          k.setTime(n);\n          return h;\n        }\n        return this.useUTC ? k[\"getUTC\" + h]() : k[\"get\" + h]();\n      }\n      set(h, n, d) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === h || \"Seconds\" === h || \"Minutes\" === h && 0 === this.getTimezoneOffset(n) % 36E5) return n[\"setUTC\" + h](d);\n          var D = this.getTimezoneOffset(n);\n          D = n.getTime() - D;\n          n.setTime(D);\n          n[\"setUTC\" + h](d);\n          h = this.getTimezoneOffset(n);\n          D = n.getTime() + h;\n          return n.setTime(D);\n        }\n        return this.useUTC || k && \"FullYear\" === h ? n[\"setUTC\" + h](d) : n[\"set\" + h](d);\n      }\n      update(h = {}) {\n        const n = d(h.useUTC, !0);\n        this.options = h = B(!0, this.options, h);\n        this.Date = h.Date || u.Date || Date;\n        this.timezoneOffset = (this.useUTC = n) && h.timezoneOffset || void 0;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = n && !(!h.getTimezoneOffset && !h.timezone);\n      }\n      makeTime(h, n, k, m, e, q) {\n        let y, l, w;\n        this.useUTC ? (y = this.Date.UTC.apply(0, arguments), l = this.getTimezoneOffset(y), y += l, w = this.getTimezoneOffset(y), l !== w ? y += w - l : l - 36E5 !== this.getTimezoneOffset(y - 36E5) || v || (y -= 36E5)) : y = new this.Date(h, n, d(k, 1), d(m, 0), d(e, 0), d(q, 0)).getTime();\n        return y;\n      }\n      timezoneOffsetFunction() {\n        const h = this,\n          n = this.options,\n          k = n.getTimezoneOffset,\n          d = n.moment || u.moment;\n        if (!this.useUTC) return function (e) {\n          return 6E4 * new Date(e.toString()).getTimezoneOffset();\n        };\n        if (n.timezone) {\n          if (d) return function (e) {\n            return 6E4 * -d.tz(e, n.timezone).utcOffset();\n          };\n          F(25);\n        }\n        return this.useUTC && k ? function (e) {\n          return 6E4 * k(e.valueOf());\n        } : function () {\n          return 6E4 * (h.timezoneOffset || 0);\n        };\n      }\n      dateFormat(h, n, k) {\n        if (!I(n) || isNaN(n)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || \"\";\n        h = d(h, \"%Y-%m-%d %H:%M:%S\");\n        const m = this;\n        var e = new this.Date(n);\n        const q = this.get(\"Hours\", e),\n          y = this.get(\"Day\", e),\n          l = this.get(\"Date\", e),\n          w = this.get(\"Month\", e),\n          g = this.get(\"FullYear\", e),\n          b = a.defaultOptions.lang,\n          c = b && b.weekdays,\n          f = b && b.shortWeekdays;\n        e = G({\n          a: f ? f[y] : c[y].substr(0, 3),\n          A: c[y],\n          d: r(l),\n          e: r(l, 2, \" \"),\n          w: y,\n          b: b.shortMonths[w],\n          B: b.months[w],\n          m: r(w + 1),\n          o: w + 1,\n          y: g.toString().substr(2, 2),\n          Y: g,\n          H: r(q),\n          k: q,\n          I: r(q % 12 || 12),\n          l: q % 12 || 12,\n          M: r(this.get(\"Minutes\", e)),\n          p: 12 > q ? \"AM\" : \"PM\",\n          P: 12 > q ? \"am\" : \"pm\",\n          S: r(e.getSeconds()),\n          L: r(Math.floor(n % 1E3), 3)\n        }, a.dateFormats);\n        t(e, function (b, c) {\n          for (; -1 !== h.indexOf(\"%\" + c);) h = h.replace(\"%\" + c, \"function\" === typeof b ? b.call(m, n) : b);\n        });\n        return k ? h.substr(0, 1).toUpperCase() + h.substr(1) : h;\n      }\n      resolveDTLFormat(h) {\n        return C(h, !0) ? h : (h = p(h), {\n          main: h[0],\n          from: h[1],\n          to: h[2]\n        });\n      }\n      getTimeTicks(h, n, k, a) {\n        const e = this,\n          q = [],\n          y = {};\n        var l = new e.Date(n);\n        const w = h.unitRange,\n          g = h.count || 1;\n        let b;\n        a = d(a, 1);\n        if (I(n)) {\n          e.set(\"Milliseconds\", l, w >= m.second ? 0 : g * Math.floor(e.get(\"Milliseconds\", l) / g));\n          w >= m.second && e.set(\"Seconds\", l, w >= m.minute ? 0 : g * Math.floor(e.get(\"Seconds\", l) / g));\n          w >= m.minute && e.set(\"Minutes\", l, w >= m.hour ? 0 : g * Math.floor(e.get(\"Minutes\", l) / g));\n          w >= m.hour && e.set(\"Hours\", l, w >= m.day ? 0 : g * Math.floor(e.get(\"Hours\", l) / g));\n          w >= m.day && e.set(\"Date\", l, w >= m.month ? 1 : Math.max(1, g * Math.floor(e.get(\"Date\", l) / g)));\n          if (w >= m.month) {\n            e.set(\"Month\", l, w >= m.year ? 0 : g * Math.floor(e.get(\"Month\", l) / g));\n            var c = e.get(\"FullYear\", l);\n          }\n          w >= m.year && e.set(\"FullYear\", l, c - c % g);\n          w === m.week && (c = e.get(\"Day\", l), e.set(\"Date\", l, e.get(\"Date\", l) - c + a + (c < a ? -7 : 0)));\n          c = e.get(\"FullYear\", l);\n          a = e.get(\"Month\", l);\n          const f = e.get(\"Date\", l),\n            x = e.get(\"Hours\", l);\n          n = l.getTime();\n          !e.variableTimezone && e.useUTC || !I(k) || (b = k - n > 4 * m.month || e.getTimezoneOffset(n) !== e.getTimezoneOffset(k));\n          n = l.getTime();\n          for (l = 1; n < k;) q.push(n), n = w === m.year ? e.makeTime(c + l * g, 0) : w === m.month ? e.makeTime(c, a + l * g) : !b || w !== m.day && w !== m.week ? b && w === m.hour && 1 < g ? e.makeTime(c, a, f, x + l * g) : n + w * g : e.makeTime(c, a, f + l * g * (w === m.day ? 1 : 7)), l++;\n          q.push(n);\n          w <= m.hour && 1E4 > q.length && q.forEach(function (b) {\n            0 === b % 18E5 && \"000000000\" === e.dateFormat(\"%H%M%S%L\", b) && (y[b] = \"day\");\n          });\n        }\n        q.info = G(h, {\n          higherRanks: y,\n          totalRange: w * g\n        });\n        return q;\n      }\n      getDateFormat(h, n, k, d) {\n        const e = this.dateFormat(\"%m-%d %H:%M:%S.%L\", n),\n          q = {\n            millisecond: 15,\n            second: 12,\n            minute: 9,\n            hour: 6,\n            day: 3\n          };\n        let y,\n          l = \"millisecond\";\n        for (y in m) {\n          if (h === m.week && +this.dateFormat(\"%w\", n) === k && \"00:00:00.000\" === e.substr(6)) {\n            y = \"week\";\n            break;\n          }\n          if (m[y] > h) {\n            y = l;\n            break;\n          }\n          if (q[y] && e.substr(q[y]) !== \"01-01 00:00:00.000\".substr(q[y])) break;\n          \"week\" !== y && (l = y);\n        }\n        return this.resolveDTLFormat(d[y]).main;\n      }\n    }\n    \"\";\n    return n;\n  });\n  M(a, \"Core/Defaults.js\", [a[\"Core/Chart/ChartDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Color/Palettes.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G) {\n    const {\n        isTouchDevice: u,\n        svg: B\n      } = H,\n      {\n        merge: t\n      } = G,\n      r = {\n        colors: I.colors,\n        symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n        lang: {\n          loading: \"Loading...\",\n          months: \"January February March April May June July August September October November December\".split(\" \"),\n          shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n          weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n          decimalPoint: \".\",\n          numericSymbols: \"kMGTPE\".split(\"\"),\n          resetZoom: \"Reset zoom\",\n          resetZoomTitle: \"Reset zoom level 1:1\",\n          thousandsSep: \" \"\n        },\n        global: {},\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: a,\n        title: {\n          text: \"Chart title\",\n          align: \"center\",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          text: \"\",\n          align: \"center\",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          text: \"\",\n          align: \"left\",\n          verticalAlign: \"bottom\"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: \"center\",\n          alignColumns: !0,\n          className: \"highcharts-no-tooltip\",\n          layout: \"horizontal\",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function () {\n            return this.name;\n          },\n          borderColor: \"#999999\",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: \"0.8em\"\n            },\n            activeColor: \"#0022ff\",\n            inactiveColor: \"#cccccc\"\n          },\n          itemStyle: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            textDecoration: \"none\",\n            textOverflow: \"ellipsis\"\n          },\n          itemHoverStyle: {\n            color: \"#000000\"\n          },\n          itemHiddenStyle: {\n            color: \"#666666\",\n            textDecoration: \"line-through\"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: \"absolute\",\n            width: \"13px\",\n            height: \"13px\"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: \"0.8em\",\n              fontWeight: \"bold\"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: \"bold\",\n            position: \"relative\",\n            top: \"45%\"\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#ffffff\",\n            opacity: .5,\n            textAlign: \"center\"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: B,\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n            second: \"%A, %e %b, %H:%M:%S\",\n            minute: \"%A, %e %b, %H:%M\",\n            hour: \"%A, %e %b, %H:%M\",\n            day: \"%A, %e %b %Y\",\n            week: \"Week from %A, %e %b %Y\",\n            month: \"%B %Y\",\n            year: \"%Y\"\n          },\n          footerFormat: \"\",\n          headerShape: \"callout\",\n          hideDelay: 500,\n          padding: 8,\n          shape: \"callout\",\n          shared: !1,\n          snap: u ? 25 : 10,\n          headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n          backgroundColor: \"#ffffff\",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: \"https://www.highcharts.com?credits\",\n          position: {\n            align: \"right\",\n            x: -10,\n            verticalAlign: \"bottom\",\n            y: -5\n          },\n          style: {\n            cursor: \"pointer\",\n            color: \"#999999\",\n            fontSize: \"0.6em\"\n          },\n          text: \"Highcharts.com\"\n        }\n      };\n    r.chart.styledMode = !1;\n    \"\";\n    const d = new F(r.time);\n    a = {\n      defaultOptions: r,\n      defaultTime: d,\n      getOptions: function () {\n        return r;\n      },\n      setOptions: function (a) {\n        t(!0, r, a);\n        if (a.time || a.global) H.time ? H.time.update(t(r.global, r.time, a.global, a.time)) : H.time = d;\n        return r;\n      }\n    };\n    \"\";\n    return a;\n  });\n  M(a, \"Core/Animation/Fx.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        parse: u\n      } = a,\n      {\n        win: F\n      } = A,\n      {\n        isNumber: G,\n        objectEach: C\n      } = H;\n    let B = /*#__PURE__*/(() => {\n      class B {\n        constructor(a, r, d) {\n          this.pos = NaN;\n          this.options = r;\n          this.elem = a;\n          this.prop = d;\n        }\n        dSetter() {\n          var a = this.paths;\n          const r = a && a[0];\n          a = a && a[1];\n          const d = this.now || 0;\n          let p = [];\n          if (1 !== d && r && a) {\n            if (r.length === a.length && 1 > d) for (let m = 0; m < a.length; m++) {\n              const k = r[m],\n                v = a[m],\n                n = [];\n              for (let h = 0; h < v.length; h++) {\n                const m = k[h],\n                  a = v[h];\n                G(m) && G(a) && (\"A\" !== v[0] || 4 !== h && 5 !== h) ? n[h] = m + d * (a - m) : n[h] = a;\n              }\n              p.push(n);\n            } else p = a;\n          } else p = this.toD || [];\n          this.elem.attr(\"d\", p, void 0, !0);\n        }\n        update() {\n          const a = this.elem,\n            r = this.prop,\n            d = this.now,\n            p = this.options.step;\n          if (this[r + \"Setter\"]) this[r + \"Setter\"]();else a.attr ? a.element && a.attr(r, d, null, !0) : a.style[r] = d + this.unit;\n          p && p.call(a, d, this);\n        }\n        run(a, r, d) {\n          const p = this,\n            m = p.options,\n            k = function (h) {\n              return k.stopped ? !1 : p.step(h);\n            },\n            v = F.requestAnimationFrame || function (h) {\n              setTimeout(h, 13);\n            },\n            n = function () {\n              for (let h = 0; h < B.timers.length; h++) B.timers[h]() || B.timers.splice(h--, 1);\n              B.timers.length && v(n);\n            };\n          a !== r || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = a, this.end = r, this.unit = d, this.now = this.start, this.pos = 0, k.elem = this.elem, k.prop = this.prop, k() && 1 === B.timers.push(k) && v(n)) : (delete m.curAnim[this.prop], m.complete && 0 === Object.keys(m.curAnim).length && m.complete.call(this.elem));\n        }\n        step(a) {\n          const r = +new Date(),\n            d = this.options,\n            p = this.elem,\n            m = d.complete,\n            k = d.duration,\n            v = d.curAnim;\n          let n;\n          p.attr && !p.element ? a = !1 : a || r >= k + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), n = v[this.prop] = !0, C(v, function (h) {\n            !0 !== h && (n = !1);\n          }), n && m && m.call(p), a = !1) : (this.pos = d.easing((r - this.startTime) / k), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0);\n          return a;\n        }\n        initPath(a, r, d) {\n          function p(e, q) {\n            for (; e.length < L;) {\n              var h = e[0];\n              const l = q[L - e.length];\n              l && \"M\" === h[0] && (e[0] = \"C\" === l[0] ? [\"C\", h[1], h[2], h[1], h[2], h[1], h[2]] : [\"L\", h[1], h[2]]);\n              e.unshift(h);\n              n && (h = e.pop(), e.push(e[e.length - 1], h));\n            }\n          }\n          function m(e, q) {\n            for (; e.length < L;) if (q = e[Math.floor(e.length / h) - 1].slice(), \"C\" === q[0] && (q[1] = q[5], q[2] = q[6]), n) {\n              const n = e[Math.floor(e.length / h)].slice();\n              e.splice(e.length / 2, 0, q, n);\n            } else e.push(q);\n          }\n          const k = a.startX,\n            v = a.endX;\n          d = d.slice();\n          const n = a.isArea,\n            h = n ? 2 : 1;\n          let D, L, E;\n          r = r && r.slice();\n          if (!r) return [d, d];\n          if (k && v && v.length) {\n            for (a = 0; a < k.length; a++) if (k[a] === v[0]) {\n              D = a;\n              break;\n            } else if (k[0] === v[v.length - k.length + a]) {\n              D = a;\n              E = !0;\n              break;\n            } else if (k[k.length - 1] === v[v.length - k.length + a]) {\n              D = k.length - a;\n              break;\n            }\n            \"undefined\" === typeof D && (r = []);\n          }\n          r.length && G(D) && (L = d.length + D * h, E ? (p(r, d), m(d, r)) : (p(d, r), m(r, d)));\n          return [r, d];\n        }\n        fillSetter() {\n          B.prototype.strokeSetter.apply(this, arguments);\n        }\n        strokeSetter() {\n          this.elem.attr(this.prop, u(this.start).tweenTo(u(this.end), this.pos), void 0, !0);\n        }\n      }\n      B.timers = [];\n      return B;\n    })();\n    return B;\n  });\n  M(a, \"Core/Animation/AnimationUtilities.js\", [a[\"Core/Animation/Fx.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    function u(a) {\n      return t(a) ? r({\n        duration: 500,\n        defer: 0\n      }, a) : {\n        duration: a ? 500 : 0,\n        defer: 0\n      };\n    }\n    function I(d, k) {\n      let m = a.timers.length;\n      for (; m--;) a.timers[m].elem !== d || k && k !== a.timers[m].prop || (a.timers[m].stopped = !0);\n    }\n    const {\n      defined: F,\n      getStyle: G,\n      isArray: C,\n      isNumber: B,\n      isObject: t,\n      merge: r,\n      objectEach: d,\n      pick: p\n    } = A;\n    return {\n      animate: function (m, k, v) {\n        let n,\n          h = \"\",\n          D,\n          p,\n          E;\n        t(v) || (E = arguments, v = {\n          duration: E[2],\n          easing: E[3],\n          complete: E[4]\n        });\n        B(v.duration) || (v.duration = 400);\n        v.easing = \"function\" === typeof v.easing ? v.easing : Math[v.easing] || Math.easeInOutSine;\n        v.curAnim = r(k);\n        d(k, function (e, q) {\n          I(m, q);\n          p = new a(m, v, q);\n          D = void 0;\n          \"d\" === q && C(k.d) ? (p.paths = p.initPath(m, m.pathArray, k.d), p.toD = k.d, n = 0, D = 1) : m.attr ? n = m.attr(q) : (n = parseFloat(G(m, q)) || 0, \"opacity\" !== q && (h = \"px\"));\n          D || (D = e);\n          \"string\" === typeof D && D.match(\"px\") && (D = D.replace(/px/g, \"\"));\n          p.run(n, D, h);\n        });\n      },\n      animObject: u,\n      getDeferredAnimation: function (a, k, d) {\n        const n = u(k);\n        let h = 0,\n          m = 0;\n        (d ? [d] : a.series).forEach(a => {\n          a = u(a.options.animation);\n          h = k && F(k.defer) ? n.defer : Math.max(h, a.duration + a.defer);\n          m = Math.min(n.duration, a.duration);\n        });\n        a.renderer.forExport && (h = 0);\n        return {\n          defer: Math.max(0, h - m),\n          duration: Math.min(h, m)\n        };\n      },\n      setAnimation: function (a, k) {\n        k.renderer.globalAnimation = p(a, k.options.chart.animation, !0);\n      },\n      stop: I\n    };\n  });\n  M(a, \"Core/Renderer/HTML/AST.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    const {\n        SVG_NS: u,\n        win: I\n      } = a,\n      {\n        attr: F,\n        createElement: G,\n        css: C,\n        error: B,\n        isFunction: t,\n        isString: r,\n        objectEach: d,\n        splat: p\n      } = A;\n    ({\n      trustedTypes: A\n    } = I);\n    const m = A && t(A.createPolicy) && A.createPolicy(\"highcharts\", {\n      createHTML: h => h\n    });\n    A = m ? m.createHTML(\"\") : \"\";\n    try {\n      var k = !!new DOMParser().parseFromString(A, \"text/html\");\n    } catch (h) {\n      k = !1;\n    }\n    const v = k;\n    class n {\n      static filterUserAttributes(h) {\n        d(h, (a, k) => {\n          let d = !0;\n          -1 === n.allowedAttributes.indexOf(k) && (d = !1);\n          -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(k) && (d = r(a) && n.allowedReferences.some(e => 0 === a.indexOf(e)));\n          d || (B(33, !1, void 0, {\n            \"Invalid attribute in config\": `${k}`\n          }), delete h[k]);\n          r(a) && h[k] && (h[k] = a.replace(/</g, \"&lt;\"));\n        });\n        return h;\n      }\n      static parseStyle(h) {\n        return h.split(\";\").reduce((h, n) => {\n          n = n.split(\":\").map(e => e.trim());\n          const k = n.shift();\n          k && n.length && (h[k.replace(/-([a-z])/g, e => e[1].toUpperCase())] = n.join(\":\"));\n          return h;\n        }, {});\n      }\n      static setElementHTML(h, k) {\n        h.innerHTML = n.emptyHTML;\n        k && new n(k).addToDOM(h);\n      }\n      constructor(h) {\n        this.nodes = \"string\" === typeof h ? this.parseMarkup(h) : h;\n      }\n      addToDOM(h) {\n        function k(h, m) {\n          let e;\n          p(h).forEach(function (q) {\n            var h = q.tagName;\n            const l = q.textContent ? a.doc.createTextNode(q.textContent) : void 0,\n              w = n.bypassHTMLFiltering;\n            let g;\n            if (h) if (\"#text\" === h) g = l;else if (-1 !== n.allowedTags.indexOf(h) || w) {\n              h = a.doc.createElementNS(\"svg\" === h ? u : m.namespaceURI || u, h);\n              const b = q.attributes || {};\n              d(q, function (c, f) {\n                \"tagName\" !== f && \"attributes\" !== f && \"children\" !== f && \"style\" !== f && \"textContent\" !== f && (b[f] = c);\n              });\n              F(h, w ? b : n.filterUserAttributes(b));\n              q.style && C(h, q.style);\n              l && h.appendChild(l);\n              k(q.children || [], h);\n              g = h;\n            } else B(33, !1, void 0, {\n              \"Invalid tagName in config\": h\n            });\n            g && m.appendChild(g);\n            e = g;\n          });\n          return e;\n        }\n        return k(this.nodes, h);\n      }\n      parseMarkup(h) {\n        const k = [];\n        h = h.trim().replace(/ style=([\"'])/g, \" data-style=$1\");\n        if (v) h = new DOMParser().parseFromString(m ? m.createHTML(h) : h, \"text/html\");else {\n          const n = G(\"div\");\n          n.innerHTML = h;\n          h = {\n            body: n\n          };\n        }\n        const a = (h, e) => {\n          var q = h.nodeName.toLowerCase();\n          const k = {\n            tagName: q\n          };\n          \"#text\" === q && (k.textContent = h.textContent || \"\");\n          if (q = h.attributes) {\n            const l = {};\n            [].forEach.call(q, e => {\n              \"data-style\" === e.name ? k.style = n.parseStyle(e.value) : l[e.name] = e.value;\n            });\n            k.attributes = l;\n          }\n          if (h.childNodes.length) {\n            const l = [];\n            [].forEach.call(h.childNodes, e => {\n              a(e, l);\n            });\n            l.length && (k.children = l);\n          }\n          e.push(k);\n        };\n        [].forEach.call(h.body.childNodes, h => a(h, k));\n        return k;\n      }\n    }\n    n.allowedAttributes = \"alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex\".split(\" \");\n    n.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n    n.allowedTags = \"a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text\".split(\" \");\n    n.emptyHTML = A;\n    n.bypassHTMLFiltering = !1;\n    \"\";\n    return n;\n  });\n  M(a, \"Core/FormatUtilities.js\", [a[\"Core/Defaults.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    function u(a, d, p, m) {\n      a = +a || 0;\n      d = +d;\n      const k = I.lang;\n      var v = (a.toString().split(\".\")[1] || \"\").split(\"e\")[0].length;\n      const n = a.toString().split(\"e\"),\n        h = d;\n      if (-1 === d) d = Math.min(v, 20);else if (!C(d)) d = 2;else if (d && n[1] && 0 > n[1]) {\n        var r = d + +n[1];\n        0 <= r ? (n[0] = (+n[0]).toExponential(r).split(\"e\")[0], d = r) : (n[0] = n[0].split(\".\")[0] || 0, a = 20 > d ? (n[0] * Math.pow(10, n[1])).toFixed(d) : 0, n[1] = 0);\n      }\n      r = (Math.abs(n[1] ? n[0] : a) + Math.pow(10, -Math.max(d, v) - 1)).toFixed(d);\n      v = String(t(r));\n      const L = 3 < v.length ? v.length % 3 : 0;\n      p = B(p, k.decimalPoint);\n      m = B(m, k.thousandsSep);\n      a = (0 > a ? \"-\" : \"\") + (L ? v.substr(0, L) + m : \"\");\n      a = 0 > +n[1] && !h ? \"0\" : a + v.substr(L).replace(/(\\d{3})(?=\\d)/g, \"$1\" + m);\n      d && (a += p + r.slice(-d));\n      n[1] && 0 !== +a && (a += \"e\" + n[1]);\n      return a;\n    }\n    const {\n        defaultOptions: I,\n        defaultTime: F\n      } = a,\n      {\n        getNestedProperty: G,\n        isNumber: C,\n        pick: B,\n        pInt: t\n      } = A;\n    return {\n      dateFormat: function (a, d, p) {\n        return F.dateFormat(a, d, p);\n      },\n      format: function (a, d, p) {\n        var m = \"{\";\n        let k = !1;\n        let v;\n        const n = /f$/,\n          h = /\\.([0-9])/,\n          r = I.lang,\n          L = p && p.time || F;\n        p = p && p.numberFormatter || u;\n        const E = [];\n        for (; a;) {\n          v = a.indexOf(m);\n          if (-1 === v) break;\n          var e = a.slice(0, v);\n          if (k) {\n            e = e.split(\":\");\n            m = G(e.shift() || \"\", d);\n            if (e.length && \"number\" === typeof m) if (e = e.join(\":\"), n.test(e)) {\n              const q = parseInt((e.match(h) || [\"\", \"-1\"])[1], 10);\n              null !== m && (m = p(m, q, r.decimalPoint, -1 < e.indexOf(\",\") ? r.thousandsSep : \"\"));\n            } else m = L.dateFormat(e, m);\n            E.push(m);\n          } else E.push(e);\n          a = a.slice(v + 1);\n          m = (k = !k) ? \"}\" : \"{\";\n        }\n        E.push(a);\n        return E.join(\"\");\n      },\n      numberFormat: u\n    };\n  });\n  M(a, \"Core/Renderer/RendererUtilities.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      clamp: u,\n      pick: H,\n      stableSort: I\n    } = a;\n    var F;\n    (function (a) {\n      function A(a, t, r) {\n        const d = a;\n        var p = d.reducedLen || t,\n          m = (a, h) => (h.rank || 0) - (a.rank || 0);\n        const k = (a, h) => a.target - h.target;\n        let v,\n          n = !0,\n          h = [],\n          D = 0;\n        for (v = a.length; v--;) D += a[v].size;\n        if (D > p) {\n          I(a, m);\n          for (D = v = 0; D <= p;) D += a[v].size, v++;\n          h = a.splice(v - 1, a.length);\n        }\n        I(a, k);\n        for (a = a.map(a => ({\n          size: a.size,\n          targets: [a.target],\n          align: H(a.align, .5)\n        })); n;) {\n          for (v = a.length; v--;) p = a[v], m = (Math.min.apply(0, p.targets) + Math.max.apply(0, p.targets)) / 2, p.pos = u(m - p.size * p.align, 0, t - p.size);\n          v = a.length;\n          for (n = !1; v--;) 0 < v && a[v - 1].pos + a[v - 1].size > a[v].pos && (a[v - 1].size += a[v].size, a[v - 1].targets = a[v - 1].targets.concat(a[v].targets), a[v - 1].align = .5, a[v - 1].pos + a[v - 1].size > t && (a[v - 1].pos = t - a[v - 1].size), a.splice(v, 1), n = !0);\n        }\n        d.push.apply(d, h);\n        v = 0;\n        a.some(a => {\n          let h = 0;\n          return (a.targets || []).some(() => {\n            d[v].pos = a.pos + h;\n            if (\"undefined\" !== typeof r && Math.abs(d[v].pos - d[v].target) > r) return d.slice(0, v + 1).forEach(e => delete e.pos), d.reducedLen = (d.reducedLen || t) - .1 * t, d.reducedLen > .1 * t && A(d, t, r), !0;\n            h += d[v].size;\n            v++;\n            return !1;\n          });\n        });\n        I(d, k);\n        return d;\n      }\n      a.distribute = A;\n    })(F || (F = {}));\n    return F;\n  });\n  M(a, \"Core/Renderer/SVG/SVGElement.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I) {\n    const {\n        animate: u,\n        animObject: G,\n        stop: C\n      } = a,\n      {\n        deg2rad: B,\n        doc: t,\n        svg: r,\n        SVG_NS: d,\n        win: p\n      } = H,\n      {\n        addEvent: m,\n        attr: k,\n        createElement: v,\n        css: n,\n        defined: h,\n        erase: D,\n        extend: L,\n        fireEvent: E,\n        isArray: e,\n        isFunction: q,\n        isObject: y,\n        isString: l,\n        merge: w,\n        objectEach: g,\n        pick: b,\n        pInt: c,\n        syncTimeout: f,\n        uniqueKey: x\n      } = I;\n    class J {\n      constructor() {\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = d;\n      }\n      _defaultGetter(c) {\n        c = b(this[c + \"Value\"], this[c], this.element ? this.element.getAttribute(c) : null, 0);\n        /^[\\-0-9\\.]+$/.test(c) && (c = parseFloat(c));\n        return c;\n      }\n      _defaultSetter(b, c, f) {\n        f.setAttribute(c, b);\n      }\n      add(b) {\n        const c = this.renderer,\n          f = this.element;\n        let g;\n        b && (this.parentGroup = b);\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && c.buildText(this);\n        this.added = !0;\n        if (!b || b.handleZ || this.zIndex) g = this.zIndexSetter();\n        g || (b ? b.element : c.box).appendChild(f);\n        if (this.onAdd) this.onAdd();\n        return this;\n      }\n      addClass(b, c) {\n        const f = c ? \"\" : this.attr(\"class\") || \"\";\n        b = (b || \"\").split(/ /g).reduce(function (b, c) {\n          -1 === f.indexOf(c) && b.push(c);\n          return b;\n        }, f ? [f] : []).join(\" \");\n        b !== f && this.attr(\"class\", b);\n        return this;\n      }\n      afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      }\n      align(c, f, g) {\n        const z = {};\n        var N = this.renderer,\n          e = N.alignedObjects,\n          q;\n        let x, a;\n        if (c) {\n          if (this.alignOptions = c, this.alignByTranslate = f, !g || l(g)) this.alignTo = q = g || \"renderer\", D(e, this), e.push(this), g = void 0;\n        } else c = this.alignOptions, f = this.alignByTranslate, q = this.alignTo;\n        g = b(g, N[q], \"scrollablePlotBox\" === q ? N.plotBox : void 0, N);\n        q = c.align;\n        const K = c.verticalAlign;\n        N = (g.x || 0) + (c.x || 0);\n        e = (g.y || 0) + (c.y || 0);\n        \"right\" === q ? x = 1 : \"center\" === q && (x = 2);\n        x && (N += (g.width - (c.width || 0)) / x);\n        z[f ? \"translateX\" : \"x\"] = Math.round(N);\n        \"bottom\" === K ? a = 1 : \"middle\" === K && (a = 2);\n        a && (e += (g.height - (c.height || 0)) / a);\n        z[f ? \"translateY\" : \"y\"] = Math.round(e);\n        this[this.placed ? \"animate\" : \"attr\"](z);\n        this.placed = !0;\n        this.alignAttr = z;\n        return this;\n      }\n      alignSetter(b) {\n        const c = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        c[b] && (this.alignValue = b, this.element.setAttribute(\"text-anchor\", c[b]));\n      }\n      animate(c, l, e) {\n        const z = G(b(l, this.renderer.globalAnimation, !0));\n        l = z.defer;\n        t.hidden && (z.duration = 0);\n        0 !== z.duration ? (e && (z.complete = e), f(() => {\n          this.element && u(this, c, z);\n        }, l)) : (this.attr(c, void 0, e || z.complete), g(c, function (b, c) {\n          z.step && z.step.call(this, b, {\n            prop: c,\n            pos: 1,\n            elem: this\n          });\n        }, this));\n        return this;\n      }\n      applyTextOutline(b) {\n        const c = this.element;\n        -1 !== b.indexOf(\"contrast\") && (b = b.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));\n        var f = b.split(\" \");\n        b = f[f.length - 1];\n        if ((f = f[0]) && \"none\" !== f && H.svg) {\n          this.fakeTS = !0;\n          f = f.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, c, f) {\n            return 2 * Number(c) + f;\n          });\n          this.removeTextOutline();\n          const g = t.createElementNS(d, \"tspan\");\n          k(g, {\n            \"class\": \"highcharts-text-outline\",\n            fill: b,\n            stroke: b,\n            \"stroke-width\": f,\n            \"stroke-linejoin\": \"round\"\n          });\n          b = c.querySelector(\"textPath\") || c;\n          [].forEach.call(b.childNodes, b => {\n            const c = b.cloneNode(!0);\n            c.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(b => c.removeAttribute(b));\n            g.appendChild(c);\n          });\n          let z = 0;\n          [].forEach.call(b.querySelectorAll(\"text tspan\"), b => {\n            z += Number(b.getAttribute(\"dy\"));\n          });\n          f = t.createElementNS(d, \"tspan\");\n          f.textContent = \"\\u200b\";\n          k(f, {\n            x: Number(c.getAttribute(\"x\")),\n            dy: -z\n          });\n          g.appendChild(f);\n          b.insertBefore(g, b.firstChild);\n        }\n      }\n      attr(b, c, f, l) {\n        const z = this.element,\n          e = J.symbolCustomAttribs;\n        let q,\n          x,\n          a = this,\n          K,\n          w;\n        \"string\" === typeof b && \"undefined\" !== typeof c && (q = b, b = {}, b[q] = c);\n        \"string\" === typeof b ? a = (this[b + \"Getter\"] || this._defaultGetter).call(this, b, z) : (g(b, function (c, f) {\n          K = !1;\n          l || C(this, f);\n          this.symbolName && -1 !== e.indexOf(f) && (x || (this.symbolAttr(b), x = !0), K = !0);\n          !this.rotation || \"x\" !== f && \"y\" !== f || (this.doTransform = !0);\n          K || (w = this[f + \"Setter\"] || this._defaultSetter, w.call(this, c, f, z));\n        }, this), this.afterSetters());\n        f && f.call(this);\n        return a;\n      }\n      clip(b) {\n        return this.attr(\"clip-path\", b ? \"url(\" + this.renderer.url + \"#\" + b.id + \")\" : \"none\");\n      }\n      crisp(b, c) {\n        c = c || b.strokeWidth || 0;\n        const f = Math.round(c) % 2 / 2;\n        b.x = Math.floor(b.x || this.x || 0) + f;\n        b.y = Math.floor(b.y || this.y || 0) + f;\n        b.width = Math.floor((b.width || this.width || 0) - 2 * f);\n        b.height = Math.floor((b.height || this.height || 0) - 2 * f);\n        h(b.strokeWidth) && (b.strokeWidth = c);\n        return b;\n      }\n      complexColor(b, c, f) {\n        const l = this.renderer;\n        let z,\n          O,\n          q,\n          a,\n          J,\n          K,\n          n,\n          k,\n          d,\n          y,\n          m = [],\n          p;\n        E(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          b.radialGradient ? O = \"radialGradient\" : b.linearGradient && (O = \"linearGradient\");\n          if (O) {\n            q = b[O];\n            J = l.gradients;\n            K = b.stops;\n            d = f.radialReference;\n            e(q) && (b[O] = q = {\n              x1: q[0],\n              y1: q[1],\n              x2: q[2],\n              y2: q[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === O && d && !h(q.gradientUnits) && (a = q, q = w(q, l.getRadialAttr(d, a), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            g(q, function (b, c) {\n              \"id\" !== c && m.push(c, b);\n            });\n            g(K, function (b) {\n              m.push(b);\n            });\n            m = m.join(\",\");\n            if (J[m]) y = J[m].attr(\"id\");else {\n              q.id = y = x();\n              const b = J[m] = l.createElement(O).attr(q).add(l.defs);\n              b.radAttr = a;\n              b.stops = [];\n              K.forEach(function (c) {\n                0 === c[1].indexOf(\"rgba\") ? (z = A.parse(c[1]), n = z.get(\"rgb\"), k = z.get(\"a\")) : (n = c[1], k = 1);\n                c = l.createElement(\"stop\").attr({\n                  offset: c[0],\n                  \"stop-color\": n,\n                  \"stop-opacity\": k\n                }).add(b);\n                b.stops.push(c);\n              });\n            }\n            p = \"url(\" + l.url + \"#\" + y + \")\";\n            f.setAttribute(c, p);\n            f.gradient = m;\n            b.toString = function () {\n              return p;\n            };\n          }\n        });\n      }\n      css(b) {\n        const f = this.styles,\n          l = {},\n          e = this.element;\n        let z,\n          q = !f;\n        b.color && (b.fill = b.color);\n        f && g(b, function (b, c) {\n          f && f[c] !== b && (l[c] = b, q = !0);\n        });\n        if (q) {\n          f && (b = L(f, l));\n          null === b.width || \"auto\" === b.width ? delete this.textWidth : \"text\" === e.nodeName.toLowerCase() && b.width && (z = this.textWidth = c(b.width));\n          this.styles = b;\n          z && !r && this.renderer.forExport && delete b.width;\n          const g = w(b);\n          e.namespaceURI === this.SVG_NS && [\"textOutline\", \"textOverflow\", \"width\"].forEach(b => g && delete g[b]);\n          n(e, g);\n        }\n        this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), b.textOutline && this.applyTextOutline(b.textOutline));\n        return this;\n      }\n      dashstyleSetter(f) {\n        let g = this[\"stroke-width\"];\n        \"inherit\" === g && (g = 1);\n        if (f = f && f.toLowerCase()) {\n          const l = f.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n          for (f = l.length; f--;) l[f] = \"\" + c(l[f]) * b(g, NaN);\n          f = l.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", f);\n        }\n      }\n      destroy() {\n        const b = this;\n        var c = b.element || {};\n        const f = b.renderer;\n        var l = c.ownerSVGElement;\n        let e = \"SPAN\" === c.nodeName && b.parentGroup || void 0;\n        c.onclick = c.onmouseout = c.onmouseover = c.onmousemove = c.point = null;\n        C(b);\n        if (b.clipPath && l) {\n          const c = b.clipPath;\n          [].forEach.call(l.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (b) {\n            -1 < b.getAttribute(\"clip-path\").indexOf(c.element.id) && b.removeAttribute(\"clip-path\");\n          });\n          b.clipPath = c.destroy();\n        }\n        if (b.stops) {\n          for (l = 0; l < b.stops.length; l++) b.stops[l].destroy();\n          b.stops.length = 0;\n          b.stops = void 0;\n        }\n        for (b.safeRemoveChild(c); e && e.div && 0 === e.div.childNodes.length;) c = e.parentGroup, b.safeRemoveChild(e.div), delete e.div, e = c;\n        b.alignTo && D(f.alignedObjects, b);\n        g(b, function (c, f) {\n          b[f] && b[f].parentGroup === b && b[f].destroy && b[f].destroy();\n          delete b[f];\n        });\n      }\n      dSetter(b, c, f) {\n        e(b) && (\"string\" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce((b, c, f) => c && c.join ? (f ? b + \" \" : \"\") + c.join(\" \") : (c || \"\").toString(), \"\"));\n        /(NaN| {2}|^$)/.test(b) && (b = \"M 0 0\");\n        this[c] !== b && (f.setAttribute(c, b), this[c] = b);\n      }\n      fadeOut(c) {\n        const f = this;\n        f.animate({\n          opacity: 0\n        }, {\n          duration: b(c, 150),\n          complete: function () {\n            f.hide();\n          }\n        });\n      }\n      fillSetter(b, c, f) {\n        \"string\" === typeof b ? f.setAttribute(c, b) : b && this.complexColor(b, c, f);\n      }\n      getBBox(c, f) {\n        const {\n            alignValue: g,\n            element: l,\n            renderer: e,\n            styles: z,\n            textStr: x\n          } = this,\n          {\n            cache: a,\n            cacheKeys: w\n          } = e;\n        var K = l.namespaceURI === this.SVG_NS;\n        f = b(f, this.rotation, 0);\n        var k = e.styledMode ? l && J.prototype.getStyle.call(l, \"font-size\") : z && z.fontSize;\n        let d;\n        let y;\n        h(x) && (y = x.toString(), -1 === y.indexOf(\"<\") && (y = y.replace(/[0-9]/g, \"0\")), y += [\"\", e.rootFontSize, k, f, this.textWidth, g, z && z.textOverflow, z && z.fontWeight].join());\n        y && !c && (d = a[y]);\n        if (!d) {\n          if (K || e.forExport) {\n            try {\n              var m = this.fakeTS && function (b) {\n                const c = l.querySelector(\".highcharts-text-outline\");\n                c && n(c, {\n                  display: b\n                });\n              };\n              q(m) && m(\"none\");\n              d = l.getBBox ? L({}, l.getBBox()) : {\n                width: l.offsetWidth,\n                height: l.offsetHeight,\n                x: 0,\n                y: 0\n              };\n              q(m) && m(\"\");\n            } catch (fa) {\n              \"\";\n            }\n            if (!d || 0 > d.width) d = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n          } else d = this.htmlGetBBox();\n          m = d.width;\n          c = d.height;\n          K && (d.height = c = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[`${k || \"\"},${Math.round(c)}`] || c);\n          if (f) {\n            K = Number(l.getAttribute(\"y\") || 0) - d.y;\n            k = {\n              right: 1,\n              center: .5\n            }[g || 0] || 0;\n            var p = f * B,\n              r = (f - 90) * B,\n              v = m * Math.cos(p);\n            f = m * Math.sin(p);\n            var D = Math.cos(r);\n            p = Math.sin(r);\n            m = d.x + k * (m - v) + K * D;\n            r = m + v;\n            D = r - c * D;\n            v = D - v;\n            K = d.y + K - k * f + K * p;\n            k = K + f;\n            c = k - c * p;\n            f = c - f;\n            d.x = Math.min(m, r, D, v);\n            d.y = Math.min(K, k, c, f);\n            d.width = Math.max(m, r, D, v) - d.x;\n            d.height = Math.max(K, k, c, f) - d.y;\n          }\n        }\n        if (y && (\"\" === x || 0 < d.height)) {\n          for (; 250 < w.length;) delete a[w.shift()];\n          a[y] || w.push(y);\n          a[y] = d;\n        }\n        return d;\n      }\n      getStyle(b) {\n        return p.getComputedStyle(this.element || this, \"\").getPropertyValue(b);\n      }\n      hasClass(b) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(b);\n      }\n      hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      }\n      htmlGetBBox() {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      }\n      init(b, c) {\n        this.element = \"span\" === c ? v(c) : t.createElementNS(this.SVG_NS, c);\n        this.renderer = b;\n        E(this, \"afterInit\");\n      }\n      on(b, c) {\n        const {\n          onEvents: f\n        } = this;\n        if (f[b]) f[b]();\n        f[b] = m(this.element, b, c);\n        return this;\n      }\n      opacitySetter(b, c, f) {\n        this.opacity = b = Number(Number(b).toFixed(3));\n        f.setAttribute(c, b);\n      }\n      removeClass(b) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(l(b) ? new RegExp(`(^| )${b}( |$)`) : b, \" \").replace(/ +/g, \" \").trim());\n      }\n      removeTextOutline() {\n        const b = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        b && this.safeRemoveChild(b);\n      }\n      safeRemoveChild(b) {\n        const c = b.parentNode;\n        c && c.removeChild(b);\n      }\n      setRadialReference(b) {\n        const c = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = b;\n        c && c.radAttr && c.animate(this.renderer.getRadialAttr(b, c.radAttr));\n        return this;\n      }\n      setTextPath(b, c) {\n        c = w(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, c);\n        const f = this.renderer.url,\n          g = this.text || this,\n          l = g.textPath,\n          {\n            attributes: e,\n            enabled: q\n          } = c;\n        b = b || l && l.path;\n        l && l.undo();\n        b && q ? (c = m(g, \"afterModifyTree\", c => {\n          if (b && q) {\n            let N = b.attr(\"id\");\n            N || b.attr(\"id\", N = x());\n            var l = {\n              x: 0,\n              y: 0\n            };\n            h(e.dx) && (l.dx = e.dx, delete e.dx);\n            h(e.dy) && (l.dy = e.dy, delete e.dy);\n            g.attr(l);\n            this.attr({\n              transform: \"\"\n            });\n            this.box && (this.box = this.box.destroy());\n            l = c.nodes.slice(0);\n            c.nodes.length = 0;\n            c.nodes[0] = {\n              tagName: \"textPath\",\n              attributes: L(e, {\n                \"text-anchor\": e.textAnchor,\n                href: `${f}#${N}`\n              }),\n              children: l\n            };\n          }\n        }), g.textPath = {\n          path: b,\n          undo: c\n        }) : (g.attr({\n          dx: 0,\n          dy: 0\n        }), delete g.textPath);\n        this.added && (g.textCache = \"\", this.renderer.buildText(g));\n        return this;\n      }\n      shadow(b) {\n        var c;\n        const {\n            renderer: f\n          } = this,\n          g = w(90 === (null === (c = this.parentGroup) || void 0 === c ? void 0 : c.rotation) ? {\n            offsetX: -1,\n            offsetY: -1\n          } : {}, y(b) ? b : {});\n        c = f.shadowDefinition(g);\n        return this.attr({\n          filter: b ? `url(${f.url}#${c})` : \"none\"\n        });\n      }\n      show(b = !0) {\n        return this.attr({\n          visibility: b ? \"inherit\" : \"visible\"\n        });\n      }\n      [\"stroke-widthSetter\"](b, c, f) {\n        this[c] = b;\n        f.setAttribute(c, b);\n      }\n      strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        const b = this.getStyle(\"stroke-width\");\n        let f = 0,\n          g;\n        b.indexOf(\"px\") === b.length - 2 ? f = c(b) : \"\" !== b && (g = t.createElementNS(d, \"rect\"), k(g, {\n          width: b,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(g), f = g.getBBox().width, g.parentNode.removeChild(g));\n        return f;\n      }\n      symbolAttr(c) {\n        const f = this;\n        J.symbolCustomAttribs.forEach(function (g) {\n          f[g] = b(c[g], f[g]);\n        });\n        f.attr({\n          d: f.renderer.symbols[f.symbolName](f.x, f.y, f.width, f.height, f)\n        });\n      }\n      textSetter(b) {\n        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));\n      }\n      titleSetter(c) {\n        const f = this.element,\n          g = f.getElementsByTagName(\"title\")[0] || t.createElementNS(this.SVG_NS, \"title\");\n        f.insertBefore ? f.insertBefore(g, f.firstChild) : f.appendChild(g);\n        g.textContent = String(b(c, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      }\n      toFront() {\n        const b = this.element;\n        b.parentNode.appendChild(b);\n        return this;\n      }\n      translate(b, c) {\n        return this.attr({\n          translateX: b,\n          translateY: c\n        });\n      }\n      updateTransform() {\n        const {\n            element: c,\n            matrix: f,\n            rotation: g = 0,\n            scaleX: l,\n            scaleY: e,\n            translateX: q = 0,\n            translateY: x = 0\n          } = this,\n          a = [\"translate(\" + q + \",\" + x + \")\"];\n        h(f) && a.push(\"matrix(\" + f.join(\",\") + \")\");\n        g && a.push(\"rotate(\" + g + \" \" + b(this.rotationOriginX, c.getAttribute(\"x\"), 0) + \" \" + b(this.rotationOriginY, c.getAttribute(\"y\") || 0) + \")\");\n        (h(l) || h(e)) && a.push(\"scale(\" + b(l, 1) + \" \" + b(e, 1) + \")\");\n        a.length && !(this.text || this).textPath && c.setAttribute(\"transform\", a.join(\" \"));\n      }\n      visibilitySetter(b, c, f) {\n        \"inherit\" === b ? f.removeAttribute(c) : this[c] !== b && f.setAttribute(c, b);\n        this[c] = b;\n      }\n      xGetter(b) {\n        \"circle\" === this.element.nodeName && (\"x\" === b ? b = \"cx\" : \"y\" === b && (b = \"cy\"));\n        return this._defaultGetter(b);\n      }\n      zIndexSetter(b, f) {\n        var g = this.renderer,\n          l = this.parentGroup;\n        const e = (l || g).element || g.box,\n          q = this.element;\n        g = e === g.box;\n        let a = !1,\n          x;\n        var w = this.added;\n        let K;\n        h(b) ? (q.setAttribute(\"data-z-index\", b), b = +b, this[f] === b && (w = !1)) : h(this[f]) && q.removeAttribute(\"data-z-index\");\n        this[f] = b;\n        if (w) {\n          (b = this.zIndex) && l && (l.handleZ = !0);\n          f = e.childNodes;\n          for (K = f.length - 1; 0 <= K && !a; K--) if (l = f[K], w = l.getAttribute(\"data-z-index\"), x = !h(w), l !== q) if (0 > b && x && !g && !K) e.insertBefore(q, f[K]), a = !0;else if (c(w) <= b || x && (!h(b) || 0 <= b)) e.insertBefore(q, f[K + 1]), a = !0;\n          a || (e.insertBefore(q, f[g ? 3 : 0]), a = !0);\n        }\n        return a;\n      }\n    }\n    J.symbolCustomAttribs = \"anchorX anchorY clockwise end height innerR r start width x y\".split(\" \");\n    J.prototype.strokeSetter = J.prototype.fillSetter;\n    J.prototype.yGetter = J.prototype.xGetter;\n    J.prototype.matrixSetter = J.prototype.rotationOriginXSetter = J.prototype.rotationOriginYSetter = J.prototype.rotationSetter = J.prototype.scaleXSetter = J.prototype.scaleYSetter = J.prototype.translateXSetter = J.prototype.translateYSetter = J.prototype.verticalAlignSetter = function (b, c) {\n      this[c] = b;\n      this.doTransform = !0;\n    };\n    \"\";\n    return J;\n  });\n  M(a, \"Core/Renderer/RendererRegistry.js\", [a[\"Core/Globals.js\"]], function (a) {\n    var u;\n    (function (u) {\n      u.rendererTypes = {};\n      let A;\n      u.getRendererType = function (a = A) {\n        return u.rendererTypes[a] || u.rendererTypes[A];\n      };\n      u.registerRendererType = function (F, G, C) {\n        u.rendererTypes[F] = G;\n        if (!A || C) A = F, a.Renderer = G;\n      };\n    })(u || (u = {}));\n    return u;\n  });\n  M(a, \"Core/Renderer/SVG/SVGLabel.js\", [a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    const {\n      defined: u,\n      extend: I,\n      isNumber: F,\n      merge: G,\n      pick: C,\n      removeEvent: B\n    } = A;\n    class t extends a {\n      constructor(a, d, p, m, k, v, n, h, D, L) {\n        super();\n        this.paddingRightSetter = this.paddingLeftSetter = this.paddingSetter;\n        this.init(a, \"g\");\n        this.textStr = d;\n        this.x = p;\n        this.y = m;\n        this.anchorX = v;\n        this.anchorY = n;\n        this.baseline = D;\n        this.className = L;\n        this.addClass(\"button\" === L ? \"highcharts-no-tooltip\" : \"highcharts-label\");\n        L && this.addClass(\"highcharts-\" + L);\n        this.text = a.text(void 0, 0, 0, h).attr({\n          zIndex: 1\n        });\n        let r;\n        \"string\" === typeof k && ((r = /^url\\((.*?)\\)$/.test(k)) || this.renderer.symbols[k]) && (this.symbolKey = k);\n        this.bBox = t.emptyBBox;\n        this.padding = 3;\n        this.baselineOffset = 0;\n        this.needsBox = a.styledMode || r;\n        this.deferredAttr = {};\n        this.alignFactor = 0;\n      }\n      alignSetter(a) {\n        a = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[a];\n        a !== this.alignFactor && (this.alignFactor = a, this.bBox && F(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      }\n      anchorXSetter(a, d) {\n        this.anchorX = a;\n        this.boxAttr(d, Math.round(a) - this.getCrispAdjust() - this.xSetting);\n      }\n      anchorYSetter(a, d) {\n        this.anchorY = a;\n        this.boxAttr(d, a - this.ySetting);\n      }\n      boxAttr(a, d) {\n        this.box ? this.box.attr(a, d) : this.deferredAttr[a] = d;\n      }\n      css(r) {\n        if (r) {\n          const a = {};\n          r = G(r);\n          t.textProps.forEach(d => {\n            \"undefined\" !== typeof r[d] && (a[d] = r[d], delete r[d]);\n          });\n          this.text.css(a);\n          \"fontSize\" in a || \"fontWeight\" in a ? this.updateTextPadding() : (\"width\" in a || \"textOverflow\" in a) && this.updateBoxSize();\n        }\n        return a.prototype.css.call(this, r);\n      }\n      destroy() {\n        B(this.element, \"mouseenter\");\n        B(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        a.prototype.destroy.call(this);\n      }\n      fillSetter(a, d) {\n        a && (this.needsBox = !0);\n        this.fill = a;\n        this.boxAttr(d, a);\n      }\n      getBBox() {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        const a = this.padding,\n          d = C(this.paddingLeft, a);\n        return {\n          width: this.width,\n          height: this.height,\n          x: this.bBox.x - d,\n          y: this.bBox.y - a\n        };\n      }\n      getCrispAdjust() {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      }\n      heightSetter(a) {\n        this.heightSetting = a;\n      }\n      onAdd() {\n        this.text.add(this);\n        this.attr({\n          text: C(this.textStr, \"\"),\n          x: this.x || 0,\n          y: this.y || 0\n        });\n        this.box && u(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      }\n      paddingSetter(a, d) {\n        F(a) ? a !== this[d] && (this[d] = a, this.updateTextPadding()) : this[d] = void 0;\n      }\n      rSetter(a, d) {\n        this.boxAttr(d, a);\n      }\n      strokeSetter(a, d) {\n        this.stroke = a;\n        this.boxAttr(d, a);\n      }\n      [\"stroke-widthSetter\"](a, d) {\n        a && (this.needsBox = !0);\n        this[\"stroke-width\"] = a;\n        this.boxAttr(d, a);\n      }\n      [\"text-alignSetter\"](a) {\n        this.textAlign = a;\n      }\n      textSetter(a) {\n        \"undefined\" !== typeof a && this.text.attr({\n          text: a\n        });\n        this.updateTextPadding();\n      }\n      updateBoxSize() {\n        var a = this.text;\n        const d = {},\n          p = this.padding,\n          m = this.bBox = F(this.widthSetting) && F(this.heightSetting) && !this.textAlign || !u(a.textStr) ? t.emptyBBox : a.getBBox();\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || m.height || 0) + 2 * p;\n        const k = this.renderer.fontMetrics(a);\n        this.baselineOffset = p + Math.min((this.text.firstLineMetrics || k).b, m.height || Infinity);\n        this.heightSetting && (this.baselineOffset += (this.heightSetting - k.h) / 2);\n        this.needsBox && !a.textPath && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), a.add(this)), a = this.getCrispAdjust(), d.x = a, d.y = (this.baseline ? -this.baselineOffset : 0) + a, d.width = Math.round(this.width), d.height = Math.round(this.height), this.box.attr(I(d, this.deferredAttr)), this.deferredAttr = {});\n      }\n      updateTextPadding() {\n        const a = this.text;\n        if (!a.textPath) {\n          this.updateBoxSize();\n          const d = this.baseline ? 0 : this.baselineOffset;\n          let p = C(this.paddingLeft, this.padding);\n          u(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (p += {\n            center: .5,\n            right: 1\n          }[this.textAlign] * (this.widthSetting - this.bBox.width));\n          if (p !== a.x || d !== a.y) a.attr(\"x\", p), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)), \"undefined\" !== typeof d && a.attr(\"y\", d);\n          a.x = p;\n          a.y = d;\n        }\n      }\n      widthSetter(a) {\n        this.widthSetting = F(a) ? a : void 0;\n      }\n      getPaddedWidth() {\n        var a = this.padding;\n        const d = C(this.paddingLeft, a);\n        a = C(this.paddingRight, a);\n        return (this.widthSetting || this.bBox.width || 0) + d + a;\n      }\n      xSetter(a) {\n        this.x = a;\n        this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(a);\n        this.attr(\"translateX\", this.xSetting);\n      }\n      ySetter(a) {\n        this.ySetting = this.y = Math.round(a);\n        this.attr(\"translateY\", this.ySetting);\n      }\n    }\n    t.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n    t.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width\".split(\" \");\n    return t;\n  });\n  M(a, \"Core/Renderer/SVG/Symbols.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function u(a, t, r, d, p) {\n      const m = [];\n      if (p) {\n        const k = p.start || 0,\n          v = C(p.r, r);\n        r = C(p.r, d || r);\n        d = (p.end || 0) - .001;\n        const n = p.innerR,\n          h = C(p.open, .001 > Math.abs((p.end || 0) - k - 2 * Math.PI)),\n          D = Math.cos(k),\n          L = Math.sin(k),\n          E = Math.cos(d),\n          e = Math.sin(d),\n          q = C(p.longArc, .001 > d - k - Math.PI ? 0 : 1);\n        let y = [\"A\", v, r, 0, q, C(p.clockwise, 1), a + v * E, t + r * e];\n        y.params = {\n          start: k,\n          end: d,\n          cx: a,\n          cy: t\n        };\n        m.push([\"M\", a + v * D, t + r * L], y);\n        F(n) && (y = [\"A\", n, n, 0, q, F(p.clockwise) ? 1 - p.clockwise : 0, a + n * D, t + n * L], y.params = {\n          start: d,\n          end: k,\n          cx: a,\n          cy: t\n        }, m.push(h ? [\"M\", a + n * E, t + n * e] : [\"L\", a + n * E, t + n * e], y));\n        h || m.push([\"Z\"]);\n      }\n      return m;\n    }\n    function H(a, t, r, d, p) {\n      return p && p.r ? I(a, t, r, d, p) : [[\"M\", a, t], [\"L\", a + r, t], [\"L\", a + r, t + d], [\"L\", a, t + d], [\"Z\"]];\n    }\n    function I(a, t, r, d, p) {\n      p = (null === p || void 0 === p ? void 0 : p.r) || 0;\n      return [[\"M\", a + p, t], [\"L\", a + r - p, t], [\"A\", p, p, 0, 0, 1, a + r, t + p], [\"L\", a + r, t + d - p], [\"A\", p, p, 0, 0, 1, a + r - p, t + d], [\"L\", a + p, t + d], [\"A\", p, p, 0, 0, 1, a, t + d - p], [\"L\", a, t + p], [\"A\", p, p, 0, 0, 1, a + p, t], [\"Z\"]];\n    }\n    const {\n      defined: F,\n      isNumber: G,\n      pick: C\n    } = a;\n    return {\n      arc: u,\n      callout: function (a, t, r, d, p) {\n        const m = Math.min(p && p.r || 0, r, d),\n          k = m + 6,\n          v = p && p.anchorX;\n        p = p && p.anchorY || 0;\n        const n = I(a, t, r, d, {\n          r: m\n        });\n        if (!G(v)) return n;\n        a + v >= r ? p > t + k && p < t + d - k ? n.splice(3, 1, [\"L\", a + r, p - 6], [\"L\", a + r + 6, p], [\"L\", a + r, p + 6], [\"L\", a + r, t + d - m]) : n.splice(3, 1, [\"L\", a + r, d / 2], [\"L\", v, p], [\"L\", a + r, d / 2], [\"L\", a + r, t + d - m]) : 0 >= a + v ? p > t + k && p < t + d - k ? n.splice(7, 1, [\"L\", a, p + 6], [\"L\", a - 6, p], [\"L\", a, p - 6], [\"L\", a, t + m]) : n.splice(7, 1, [\"L\", a, d / 2], [\"L\", v, p], [\"L\", a, d / 2], [\"L\", a, t + m]) : p && p > d && v > a + k && v < a + r - k ? n.splice(5, 1, [\"L\", v + 6, t + d], [\"L\", v, t + d + 6], [\"L\", v - 6, t + d], [\"L\", a + m, t + d]) : p && 0 > p && v > a + k && v < a + r - k && n.splice(1, 1, [\"L\", v - 6, t], [\"L\", v, t - 6], [\"L\", v + 6, t], [\"L\", r - m, t]);\n        return n;\n      },\n      circle: function (a, t, r, d) {\n        return u(a + r / 2, t + d / 2, r / 2, d / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (a, t, r, d) {\n        return [[\"M\", a + r / 2, t], [\"L\", a + r, t + d / 2], [\"L\", a + r / 2, t + d], [\"L\", a, t + d / 2], [\"Z\"]];\n      },\n      rect: H,\n      roundedRect: I,\n      square: H,\n      triangle: function (a, t, r, d) {\n        return [[\"M\", a + r / 2, t], [\"L\", a + r, t + d], [\"L\", a, t + d], [\"Z\"]];\n      },\n      \"triangle-down\": function (a, t, r, d) {\n        return [[\"M\", a, t], [\"L\", a + r, t], [\"L\", a + r / 2, t + d], [\"Z\"]];\n      }\n    };\n  });\n  M(a, \"Core/Renderer/SVG/TextBuilder.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        doc: u,\n        SVG_NS: F,\n        win: G\n      } = A,\n      {\n        attr: C,\n        extend: B,\n        fireEvent: t,\n        isString: r,\n        objectEach: d,\n        pick: p\n      } = H;\n    class m {\n      constructor(a) {\n        const k = a.styles;\n        this.renderer = a.renderer;\n        this.svgElement = a;\n        this.width = a.textWidth;\n        this.textLineHeight = k && k.lineHeight;\n        this.textOutline = k && k.textOutline;\n        this.ellipsis = !(!k || \"ellipsis\" !== k.textOverflow);\n        this.noWrap = !(!k || \"nowrap\" !== k.whiteSpace);\n      }\n      buildSVG() {\n        const k = this.svgElement,\n          d = k.element;\n        var n = k.renderer,\n          h = p(k.textStr, \"\").toString();\n        const m = -1 !== h.indexOf(\"<\"),\n          L = d.childNodes;\n        n = !k.added && n.box;\n        const E = /<br.*?>/g;\n        var e = [h, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, k.getStyle(\"font-size\"), this.width].join();\n        if (e !== k.textCache) {\n          k.textCache = e;\n          delete k.actualWidth;\n          for (e = L.length; e--;) d.removeChild(L[e]);\n          m || this.ellipsis || this.width || k.textPath || -1 !== h.indexOf(\" \") && (!this.noWrap || E.test(h)) ? \"\" !== h && (n && n.appendChild(d), h = new a(h), this.modifyTree(h.nodes), h.addToDOM(d), this.modifyDOM(), this.ellipsis && -1 !== (d.textContent || \"\").indexOf(\"\\u2026\") && k.attr(\"title\", this.unescapeEntities(k.textStr || \"\", [\"&lt;\", \"&gt;\"])), n && n.removeChild(d)) : d.appendChild(u.createTextNode(this.unescapeEntities(h)));\n          r(this.textOutline) && k.applyTextOutline && k.applyTextOutline(this.textOutline);\n        }\n      }\n      modifyDOM() {\n        const a = this.svgElement,\n          d = C(a.element, \"x\");\n        a.firstLineMetrics = void 0;\n        let n;\n        for (; n = a.element.firstChild;) if (/^[\\s\\u200B]*$/.test(n.textContent || \" \")) a.element.removeChild(n);else break;\n        [].forEach.call(a.element.querySelectorAll(\"tspan.highcharts-br\"), (h, e) => {\n          h.nextSibling && h.previousSibling && (0 === e && 1 === h.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(h.previousSibling)), C(h, {\n            dy: this.getLineHeight(h.nextSibling),\n            x: d\n          }));\n        });\n        const h = this.width || 0;\n        if (h) {\n          var m = (n, e) => {\n              var q = n.textContent || \"\";\n              const k = q.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n              var l = !this.noWrap && (1 < k.length || 1 < a.element.childNodes.length);\n              const w = this.getLineHeight(e);\n              let g = 0,\n                b = a.actualWidth;\n              if (this.ellipsis) q && this.truncate(n, q, void 0, 0, Math.max(0, h - .8 * w), (b, f) => b.substring(0, f) + \"\\u2026\");else if (l) {\n                q = [];\n                for (l = []; e.firstChild && e.firstChild !== n;) l.push(e.firstChild), e.removeChild(e.firstChild);\n                for (; k.length;) k.length && !this.noWrap && 0 < g && (q.push(n.textContent || \"\"), n.textContent = k.join(\" \").replace(/- /g, \"-\")), this.truncate(n, void 0, k, 0 === g ? b || 0 : 0, h, (b, f) => k.slice(0, f).join(\" \").replace(/- /g, \"-\")), b = a.actualWidth, g++;\n                l.forEach(b => {\n                  e.insertBefore(b, n);\n                });\n                q.forEach(b => {\n                  e.insertBefore(u.createTextNode(b), n);\n                  b = u.createElementNS(F, \"tspan\");\n                  b.textContent = \"\\u200b\";\n                  C(b, {\n                    dy: w,\n                    x: d\n                  });\n                  e.insertBefore(b, n);\n                });\n              }\n            },\n            p = h => {\n              [].slice.call(h.childNodes).forEach(e => {\n                e.nodeType === G.Node.TEXT_NODE ? m(e, h) : (-1 !== e.className.baseVal.indexOf(\"highcharts-br\") && (a.actualWidth = 0), p(e));\n              });\n            };\n          p(a.element);\n        }\n      }\n      getLineHeight(a) {\n        a = a.nodeType === G.Node.TEXT_NODE ? a.parentElement : a;\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a || this.svgElement.element).h;\n      }\n      modifyTree(a) {\n        const k = (n, h) => {\n          const {\n              attributes: d = {},\n              children: m,\n              style: p = {},\n              tagName: e\n            } = n,\n            q = this.renderer.styledMode;\n          if (\"b\" === e || \"strong\" === e) q ? d[\"class\"] = \"highcharts-strong\" : p.fontWeight = \"bold\";else if (\"i\" === e || \"em\" === e) q ? d[\"class\"] = \"highcharts-emphasized\" : p.fontStyle = \"italic\";\n          p && p.color && (p.fill = p.color);\n          \"br\" === e ? (d[\"class\"] = \"highcharts-br\", n.textContent = \"\\u200b\", (h = a[h + 1]) && h.textContent && (h.textContent = h.textContent.replace(/^ +/gm, \"\"))) : \"a\" === e && m && m.some(a => \"#text\" === a.tagName) && (n.children = [{\n            children: m,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== e && \"a\" !== e && (n.tagName = \"tspan\");\n          B(n, {\n            attributes: d,\n            style: p\n          });\n          m && m.filter(a => \"#text\" !== a.tagName).forEach(k);\n        };\n        a.forEach(k);\n        t(this.svgElement, \"afterModifyTree\", {\n          nodes: a\n        });\n      }\n      truncate(a, d, n, h, m, p) {\n        const k = this.svgElement,\n          {\n            rotation: e\n          } = k,\n          q = [];\n        let y = n ? 1 : 0,\n          l = (d || n || \"\").length,\n          w = l,\n          g,\n          b;\n        const c = function (b, c) {\n          b = c || b;\n          if ((c = a.parentNode) && \"undefined\" === typeof q[b] && c.getSubStringLength) try {\n            q[b] = h + c.getSubStringLength(0, n ? b + 1 : b);\n          } catch (J) {\n            \"\";\n          }\n          return q[b];\n        };\n        k.rotation = 0;\n        b = c(a.textContent.length);\n        if (h + b > m) {\n          for (; y <= l;) w = Math.ceil((y + l) / 2), n && (g = p(n, w)), b = c(w, g && g.length - 1), y === l ? y = l + 1 : b > m ? l = w - 1 : y = w;\n          0 === l ? a.textContent = \"\" : d && l === d.length - 1 || (a.textContent = g || p(d || n, w));\n        }\n        n && n.splice(0, w);\n        k.actualWidth = b;\n        k.rotation = e;\n      }\n      unescapeEntities(a, m) {\n        d(this.renderer.escapes, function (n, h) {\n          m && -1 !== m.indexOf(n) || (a = a.toString().replace(new RegExp(n, \"g\"), h));\n        });\n        return a;\n      }\n    }\n    return m;\n  });\n  M(a, \"Core/Renderer/SVG/SVGRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGLabel.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Renderer/SVG/TextBuilder.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C, B, t) {\n    const {\n        charts: r,\n        deg2rad: d,\n        doc: p,\n        isFirefox: m,\n        isMS: k,\n        isWebKit: v,\n        noop: n,\n        SVG_NS: h,\n        symbolSizes: D,\n        win: L\n      } = H,\n      {\n        addEvent: E,\n        attr: e,\n        createElement: q,\n        css: y,\n        defined: l,\n        destroyObjectProperties: w,\n        extend: g,\n        isArray: b,\n        isNumber: c,\n        isObject: f,\n        isString: x,\n        merge: J,\n        pick: z,\n        pInt: Q,\n        uniqueKey: S\n      } = t;\n    let R;\n    class N {\n      constructor(b, c, f, g, a, l, e) {\n        this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, c, f, g, a, l, e);\n      }\n      init(b, c, f, g, a, l, N) {\n        const q = this.createElement(\"svg\").attr({\n            version: \"1.1\",\n            \"class\": \"highcharts-root\"\n          }),\n          K = q.element;\n        N || q.css(this.getStyle(g));\n        b.appendChild(K);\n        e(b, \"dir\", \"ltr\");\n        -1 === b.innerHTML.indexOf(\"xmlns\") && e(K, \"xmlns\", this.SVG_NS);\n        this.box = K;\n        this.boxWrapper = q;\n        this.alignedObjects = [];\n        this.url = this.getReferenceURL();\n        this.createElement(\"desc\").add().element.appendChild(p.createTextNode(\"Created with Highcharts 11.0.1\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = l;\n        this.forExport = a;\n        this.styledMode = N;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.rootFontSize = q.getStyle(\"font-size\");\n        this.setSize(c, f, !1);\n        let x;\n        m && b.getBoundingClientRect && (c = function () {\n          y(b, {\n            left: 0,\n            top: 0\n          });\n          x = b.getBoundingClientRect();\n          y(b, {\n            left: Math.ceil(x.left) - x.left + \"px\",\n            top: Math.ceil(x.top) - x.top + \"px\"\n          });\n        }, c(), this.unSubPixelFix = E(L, \"resize\", c));\n      }\n      definition(b) {\n        return new a([b]).addToDOM(this.defs.element);\n      }\n      getReferenceURL() {\n        if ((m || v) && p.getElementsByTagName(\"base\").length) {\n          if (!l(R)) {\n            var b = S();\n            b = new a([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: b\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": `url(#${b})`,\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(p.body);\n            y(b, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9E5\n            });\n            const c = p.elementFromPoint(6, 6);\n            R = \"hitme\" === (c && c.id);\n            p.body.removeChild(b);\n          }\n          if (R) return L.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n        return \"\";\n      }\n      getStyle(b) {\n        return this.style = g({\n          fontFamily: \"Helvetica, Arial, sans-serif\",\n          fontSize: \"1rem\"\n        }, b);\n      }\n      setStyle(b) {\n        this.boxWrapper.css(this.getStyle(b));\n      }\n      isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      }\n      destroy() {\n        const b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        w(this.gradients || {});\n        this.gradients = null;\n        this.defs = b.destroy();\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      }\n      createElement(b) {\n        const c = new this.Element();\n        c.init(this, b);\n        return c;\n      }\n      getRadialAttr(b, c) {\n        return {\n          cx: b[0] - b[2] / 2 + (c.cx || 0) * b[2],\n          cy: b[1] - b[2] / 2 + (c.cy || 0) * b[2],\n          r: (c.r || 0) * b[2]\n        };\n      }\n      shadowDefinition(b) {\n        const c = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(b).map(c => b[c])].join(\"-\").replace(/[^a-z0-9\\-]/g, \"\"),\n          f = J({\n            color: \"#000000\",\n            offsetX: 1,\n            offsetY: 1,\n            opacity: .15,\n            width: 5\n          }, b);\n        this.defs.element.querySelector(`#${c}`) || this.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: c\n          },\n          children: [{\n            tagName: \"feDropShadow\",\n            attributes: {\n              dx: f.offsetX,\n              dy: f.offsetY,\n              \"flood-color\": f.color,\n              \"flood-opacity\": Math.min(5 * f.opacity, 1),\n              stdDeviation: f.width / 2\n            }\n          }]\n        });\n        return c;\n      }\n      buildText(b) {\n        new B(b).buildSVG();\n      }\n      getContrast(b) {\n        b = A.parse(b).rgba.map(b => {\n          b /= 255;\n          return .03928 >= b ? b / 12.92 : Math.pow((b + .055) / 1.055, 2.4);\n        });\n        b = .2126 * b[0] + .7152 * b[1] + .0722 * b[2];\n        return 1.05 / (b + .05) > (b + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n      }\n      button(b, c, l, e, N = {}, q, x, w, h, z) {\n        const K = this.label(b, c, l, h, void 0, void 0, z, void 0, \"button\"),\n          n = this.styledMode;\n        b = N.states || {};\n        let d = 0;\n        N = J(N);\n        delete N.states;\n        const O = J({\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\",\n          fontWeight: \"normal\"\n        }, N.style);\n        delete N.style;\n        let y = a.filterUserAttributes(N);\n        K.attr(J({\n          padding: 8,\n          r: 2\n        }, y));\n        let m, P, p;\n        n || (y = J({\n          fill: \"#f7f7f7\",\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1\n        }, y), q = J(y, {\n          fill: \"#e6e6e6\"\n        }, a.filterUserAttributes(q || b.hover || {})), m = q.style, delete q.style, x = J(y, {\n          fill: \"#e6e9ff\",\n          style: {\n            color: \"#000000\",\n            fontWeight: \"bold\"\n          }\n        }, a.filterUserAttributes(x || b.select || {})), P = x.style, delete x.style, w = J(y, {\n          style: {\n            color: \"#cccccc\"\n          }\n        }, a.filterUserAttributes(w || b.disabled || {})), p = w.style, delete w.style);\n        E(K.element, k ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== d && K.setState(1);\n        });\n        E(K.element, k ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== d && K.setState(d);\n        });\n        K.setState = function (b) {\n          1 !== b && (K.state = d = b);\n          K.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          n || (K.attr([y, q, x, w][b || 0]), b = [O, m, P, p][b || 0], f(b) && K.css(b));\n        };\n        n || (K.attr(y).css(g({\n          cursor: \"default\"\n        }, O)), z && K.text.css({\n          pointerEvents: \"none\"\n        }));\n        return K.on(\"touchstart\", b => b.stopPropagation()).on(\"click\", function (b) {\n          3 !== d && e.call(K, b);\n        });\n      }\n      crispLine(b, c, f = \"round\") {\n        const g = b[0],\n          a = b[1];\n        l(g[1]) && g[1] === a[1] && (g[1] = a[1] = Math[f](g[1]) - c % 2 / 2);\n        l(g[2]) && g[2] === a[2] && (g[2] = a[2] = Math[f](g[2]) + c % 2 / 2);\n        return b;\n      }\n      path(c) {\n        const a = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        b(c) ? a.d = c : f(c) && g(a, c);\n        return this.createElement(\"path\").attr(a);\n      }\n      circle(b, c, g) {\n        b = f(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: c,\n          r: g\n        };\n        c = this.createElement(\"circle\");\n        c.xSetter = c.ySetter = function (b, c, f) {\n          f.setAttribute(\"c\" + c, b);\n        };\n        return c.attr(b);\n      }\n      arc(b, c, g, a, l, e) {\n        f(b) ? (a = b, c = a.y, g = a.r, b = a.x) : a = {\n          innerR: a,\n          start: l,\n          end: e\n        };\n        b = this.symbol(\"arc\", b, c, g, g, a);\n        b.r = g;\n        return b;\n      }\n      rect(b, c, a, l, N, q) {\n        b = f(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: c,\n          r: N,\n          width: Math.max(a || 0, 0),\n          height: Math.max(l || 0, 0)\n        };\n        const x = this.createElement(\"rect\");\n        this.styledMode || (\"undefined\" !== typeof q && (b[\"stroke-width\"] = q, g(b, x.crisp(b))), b.fill = \"none\");\n        x.rSetter = function (b, c, f) {\n          x.r = b;\n          e(f, {\n            rx: b,\n            ry: b\n          });\n        };\n        x.rGetter = function () {\n          return x.r || 0;\n        };\n        return x.attr(b);\n      }\n      roundedRect(b) {\n        return this.symbol(\"roundedRect\").attr(b);\n      }\n      setSize(b, c, f) {\n        this.width = b;\n        this.height = c;\n        this.boxWrapper.animate({\n          width: b,\n          height: c\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: z(f, !0) ? void 0 : 0\n        });\n        this.alignElements();\n      }\n      g(b) {\n        const c = this.createElement(\"g\");\n        return b ? c.attr({\n          \"class\": \"highcharts-\" + b\n        }) : c;\n      }\n      image(b, f, g, a, l, e) {\n        const N = {\n            preserveAspectRatio: \"none\"\n          },\n          q = function (b, c) {\n            b.setAttributeNS ? b.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", c) : b.setAttribute(\"hc-svg-href\", c);\n          };\n        c(f) && (N.x = f);\n        c(g) && (N.y = g);\n        c(a) && (N.width = a);\n        c(l) && (N.height = l);\n        const x = this.createElement(\"image\").attr(N);\n        f = function (c) {\n          q(x.element, b);\n          e.call(x, c);\n        };\n        e ? (q(x.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), g = new L.Image(), E(g, \"load\", f), g.src = b, g.complete && f({})) : q(x.element, b);\n        return x;\n      }\n      symbol(b, c, f, a, N, x) {\n        const K = this,\n          w = /^url\\((.*?)\\)$/,\n          h = w.test(b),\n          n = !h && (this.symbols[b] ? b : \"circle\"),\n          d = n && this.symbols[n];\n        let J, k, m, O;\n        if (d) \"number\" === typeof c && (k = d.call(this.symbols, Math.round(c || 0), Math.round(f || 0), a || 0, N || 0, x)), J = this.path(k), K.styledMode || J.attr(\"fill\", \"none\"), g(J, {\n          symbolName: n || void 0,\n          x: c,\n          y: f,\n          width: a,\n          height: N\n        }), x && g(J, x);else if (h) {\n          m = b.match(w)[1];\n          const g = J = this.image(m);\n          g.imgwidth = z(x && x.width, D[m] && D[m].width);\n          g.imgheight = z(x && x.height, D[m] && D[m].height);\n          O = b => b.attr({\n            width: b.width,\n            height: b.height\n          });\n          [\"width\", \"height\"].forEach(function (b) {\n            g[b + \"Setter\"] = function (b, c) {\n              this[c] = b;\n              const {\n                alignByTranslate: f,\n                element: g,\n                width: a,\n                height: N,\n                imgwidth: q,\n                imgheight: K\n              } = this;\n              b = this[\"img\" + c];\n              if (l(b)) {\n                let l = 1;\n                x && \"within\" === x.backgroundSize && a && N ? (l = Math.min(a / q, N / K), e(g, {\n                  width: Math.round(q * l),\n                  height: Math.round(K * l)\n                })) : g && g.setAttribute(c, b);\n                f || this.translate(((a || 0) - q * l) / 2, ((N || 0) - K * l) / 2);\n              }\n            };\n          });\n          l(c) && g.attr({\n            x: c,\n            y: f\n          });\n          g.isImg = !0;\n          l(g.imgwidth) && l(g.imgheight) ? O(g) : (g.attr({\n            width: 0,\n            height: 0\n          }), q(\"img\", {\n            onload: function () {\n              const b = r[K.chartIndex];\n              0 === this.width && (y(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), p.body.appendChild(this));\n              D[m] = {\n                width: this.width,\n                height: this.height\n              };\n              g.imgwidth = this.width;\n              g.imgheight = this.height;\n              g.element && O(g);\n              this.parentNode && this.parentNode.removeChild(this);\n              K.imgCount--;\n              if (!K.imgCount && b && !b.hasLoaded) b.onload();\n            },\n            src: m\n          }), this.imgCount++);\n        }\n        return J;\n      }\n      clipRect(b, c, f, g) {\n        const a = S() + \"-\",\n          l = this.createElement(\"clipPath\").attr({\n            id: a\n          }).add(this.defs);\n        b = this.rect(b, c, f, g, 0).add(l);\n        b.id = a;\n        b.clipPath = l;\n        b.count = 0;\n        return b;\n      }\n      text(b, c, f, g) {\n        const a = {};\n        if (g && (this.allowHTML || !this.forExport)) return this.html(b, c, f);\n        a.x = Math.round(c || 0);\n        f && (a.y = Math.round(f));\n        l(b) && (a.text = b);\n        b = this.createElement(\"text\").attr(a);\n        if (!g || this.forExport && !this.allowHTML) b.xSetter = function (b, c, f) {\n          const g = f.getElementsByTagName(\"tspan\"),\n            a = f.getAttribute(c);\n          for (let f = 0, l; f < g.length; f++) l = g[f], l.getAttribute(c) === a && l.setAttribute(c, b);\n          f.setAttribute(c, b);\n        };\n        return b;\n      }\n      fontMetrics(b) {\n        b = Q(F.prototype.getStyle.call(b, \"font-size\") || 0);\n        const c = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: c,\n          b: Math.round(.8 * c),\n          f: b\n        };\n      }\n      rotCorr(b, c, f) {\n        let g = b;\n        c && f && (g = Math.max(g * Math.cos(c * d), 4));\n        return {\n          x: -b / 3 * Math.sin(c * d),\n          y: g\n        };\n      }\n      pathToSegments(b) {\n        const f = [],\n          g = [],\n          a = {\n            A: 8,\n            C: 7,\n            H: 2,\n            L: 3,\n            M: 3,\n            Q: 5,\n            S: 5,\n            T: 3,\n            V: 2\n          };\n        for (let l = 0; l < b.length; l++) x(g[0]) && c(b[l]) && g.length === a[g[0].toUpperCase()] && b.splice(l, 0, g[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[l] && (g.length && f.push(g.slice(0)), g.length = 0), g.push(b[l]);\n        f.push(g.slice(0));\n        return f;\n      }\n      label(b, c, f, g, a, l, e, N, q) {\n        return new G(this, b, c, f, g, a, l, e, N, q);\n      }\n      alignElements() {\n        this.alignedObjects.forEach(b => b.align());\n      }\n    }\n    g(N.prototype, {\n      Element: F,\n      SVG_NS: h,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: C,\n      draw: n\n    });\n    I.registerRendererType(\"svg\", N, !0);\n    \"\";\n    return N;\n  });\n  M(a, \"Core/Renderer/HTML/HTMLElement.js\", [a[\"Core/Globals.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        isFirefox: u,\n        isMS: F,\n        isWebKit: G,\n        win: C\n      } = a,\n      {\n        css: B,\n        defined: t,\n        extend: r,\n        pick: d,\n        pInt: p\n      } = H,\n      m = [];\n    class k extends A {\n      static compose(a) {\n        if (H.pushUnique(m, a)) {\n          const n = k.prototype,\n            h = a.prototype;\n          h.getSpanCorrection = n.getSpanCorrection;\n          h.htmlCss = n.htmlCss;\n          h.htmlGetBBox = n.htmlGetBBox;\n          h.htmlUpdateTransform = n.htmlUpdateTransform;\n          h.setSpanRotation = n.setSpanRotation;\n        }\n        return a;\n      }\n      getSpanCorrection(a, n, h) {\n        this.xCorr = -a * h;\n        this.yCorr = -n;\n      }\n      htmlCss(a) {\n        const n = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n          h = d(n && a.width, void 0);\n        let k;\n        n && (delete a.width, this.textWidth = h, k = !0);\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = r(this.styles, a);\n        B(this.element, a);\n        k && this.htmlUpdateTransform();\n        return this;\n      }\n      htmlGetBBox() {\n        const a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      }\n      htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n            n = this.element,\n            h = this.x || 0,\n            d = this.y || 0,\n            k = this.textAlign || \"left\",\n            m = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[k],\n            e = this.styles,\n            q = e && e.whiteSpace;\n          B(n, {\n            marginLeft: this.translateX || 0,\n            marginTop: this.translateY || 0\n          });\n          if (\"SPAN\" === n.tagName) {\n            e = this.rotation;\n            const l = this.textWidth && p(this.textWidth),\n              w = [e, k, n.innerHTML, this.textWidth, this.textAlign].join();\n            let g = !1;\n            if (l !== this.oldTextWidth) {\n              if (this.textPxLength) var y = this.textPxLength;else B(n, {\n                width: \"\",\n                whiteSpace: q || \"nowrap\"\n              }), y = n.offsetWidth;\n              (l > this.oldTextWidth || y > l) && (/[ \\-]/.test(n.textContent || n.innerText) || \"ellipsis\" === n.style.textOverflow) && (B(n, {\n                width: y > l || e ? l + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: q || \"normal\"\n              }), this.oldTextWidth = l, g = !0);\n            }\n            this.hasBoxWidthChanged = g;\n            w !== this.cTT && (a = a.fontMetrics(n).b, !t(e) || e === (this.oldRotation || 0) && k === this.oldAlign || this.setSpanRotation(e, m, a), this.getSpanCorrection(!t(e) && this.textPxLength || n.offsetWidth, a, m, e, k));\n            B(n, {\n              left: h + (this.xCorr || 0) + \"px\",\n              top: d + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = w;\n            this.oldRotation = e;\n            this.oldAlign = k;\n          }\n        } else this.alignOnAdd = !0;\n      }\n      setSpanRotation(a, n, h) {\n        const d = {},\n          k = F && !/Edge/.test(C.navigator.userAgent) ? \"-ms-transform\" : G ? \"-webkit-transform\" : u ? \"MozTransform\" : C.opera ? \"-o-transform\" : void 0;\n        k && (d[k] = d.transform = \"rotate(\" + a + \"deg)\", d[k + (u ? \"Origin\" : \"-origin\")] = d.transformOrigin = 100 * n + \"% \" + h + \"px\", B(this.element, d));\n      }\n    }\n    return k;\n  });\n  M(a, \"Core/Renderer/HTML/HTMLRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I) {\n    const {\n        attr: u,\n        createElement: G,\n        extend: C,\n        pick: B\n      } = I,\n      t = [];\n    class r extends H {\n      static compose(a) {\n        I.pushUnique(t, a) && (a.prototype.html = r.prototype.html);\n        return a;\n      }\n      html(d, p, m) {\n        const k = this.createElement(\"span\"),\n          v = k.element,\n          n = k.renderer,\n          h = function (a, h) {\n            [\"opacity\", \"visibility\"].forEach(function (n) {\n              a[n + \"Setter\"] = function (e, q, d) {\n                const l = a.div ? a.div.style : h;\n                A.prototype[n + \"Setter\"].call(this, e, q, d);\n                l && (l[q] = e);\n              };\n            });\n            a.addedSetters = !0;\n          };\n        k.textSetter = function (h) {\n          h !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, B(h, \"\")), this.textStr = h, k.doTransform = !0);\n        };\n        h(k, k.element.style);\n        k.xSetter = k.ySetter = k.alignSetter = k.rotationSetter = function (a, h) {\n          \"align\" === h ? k.alignValue = k.textAlign = a : k[h] = a;\n          k.doTransform = !0;\n        };\n        k.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n        k.attr({\n          text: d,\n          x: Math.round(p),\n          y: Math.round(m)\n        }).css({\n          position: \"absolute\"\n        });\n        n.styledMode || k.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        v.style.whiteSpace = \"nowrap\";\n        k.css = k.htmlCss;\n        k.add = function (a) {\n          const d = n.box.parentNode,\n            m = [];\n          let e;\n          if (this.parentGroup = a) {\n            if (e = a.div, !e) {\n              for (; a;) m.push(a), a = a.parentGroup;\n              m.reverse().forEach(function (a) {\n                function q(b, c) {\n                  a[c] = b;\n                  \"translateX\" === c ? g.left = b + \"px\" : g.top = b + \"px\";\n                  a.doTransform = !0;\n                }\n                const l = u(a.element, \"class\"),\n                  w = a.styles || {};\n                e = a.div = a.div || G(\"div\", l ? {\n                  className: l\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  visibility: a.visibility\n                }, e || d);\n                const g = e.style;\n                C(a, {\n                  classSetter: function (b) {\n                    return function (c) {\n                      this.element.setAttribute(\"class\", c);\n                      b.className = c;\n                    };\n                  }(e),\n                  css: function (b) {\n                    k.css.call(a, b);\n                    [\"cursor\", \"pointerEvents\"].forEach(c => {\n                      b[c] && (g[c] = b[c]);\n                    });\n                    return a;\n                  },\n                  on: function () {\n                    m[0].div && k.on.apply({\n                      element: m[0].div,\n                      onEvents: a.onEvents\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: q,\n                  translateYSetter: q\n                });\n                a.addedSetters || h(a);\n                a.css(w);\n              });\n            }\n          } else e = d;\n          e.appendChild(v);\n          k.added = !0;\n          k.alignOnAdd && k.htmlUpdateTransform();\n          return k;\n        };\n        return k;\n      }\n    }\n    return r;\n  });\n  M(a, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var a = /*#__PURE__*/(() => {\n      a = a || {};\n      a.defaultXAxisOptions = {\n        alignTicks: !0,\n        allowDecimals: void 0,\n        panningEnabled: !0,\n        zIndex: 2,\n        zoomEnabled: !0,\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e %b\"\n          },\n          week: {\n            main: \"%e %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        gridLineDashStyle: \"Solid\",\n        gridZIndex: 1,\n        labels: {\n          autoRotation: void 0,\n          autoRotationLimit: 80,\n          distance: 15,\n          enabled: !0,\n          indentation: 10,\n          overflow: \"justify\",\n          padding: 5,\n          reserveSpace: void 0,\n          rotation: void 0,\n          staggerLines: 0,\n          step: 0,\n          useHTML: !1,\n          zIndex: 7,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          }\n        },\n        maxPadding: .01,\n        minorGridLineDashStyle: \"Solid\",\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minorTicksPerMajor: 5,\n        minPadding: .01,\n        offset: void 0,\n        opposite: !1,\n        reversed: void 0,\n        reversedStacks: !1,\n        showEmpty: !0,\n        showFirstLabel: !0,\n        showLastLabel: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          rotation: 0,\n          useHTML: !1,\n          x: 0,\n          y: 0,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          }\n        },\n        type: \"linear\",\n        uniqueNames: !0,\n        visible: !0,\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#333333\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        gridLineWidth: void 0,\n        tickColor: \"#333333\"\n      };\n      a.defaultYAxisOptions = {\n        reversedStacks: !0,\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: void 0\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          animation: {},\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function () {\n            const {\n              numberFormatter: a\n            } = this.axis.chart;\n            return a(this.total || 0, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      a.defaultLeftAxisOptions = {\n        title: {\n          rotation: 270\n        }\n      };\n      a.defaultRightAxisOptions = {\n        title: {\n          rotation: 90\n        }\n      };\n      a.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      a.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      return a;\n    })();\n    return a;\n  });\n  M(a, \"Core/Foundation.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: u,\n      isFunction: H,\n      objectEach: I,\n      removeEvent: F\n    } = a;\n    var G = /*#__PURE__*/(() => {\n      (function (a) {\n        a.registerEventOptions = function (a, t) {\n          a.eventOptions = a.eventOptions || {};\n          I(t.events, function (r, d) {\n            a.eventOptions[d] !== r && (a.eventOptions[d] && (F(a, d, a.eventOptions[d]), delete a.eventOptions[d]), H(r) && (a.eventOptions[d] = r, u(a, d, r, {\n              order: 0\n            })));\n          });\n        };\n      })(G || (G = {}));\n      return G;\n    })();\n    return G;\n  });\n  M(a, \"Core/Axis/Tick.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        deg2rad: u\n      } = A,\n      {\n        clamp: F,\n        correctFloat: G,\n        defined: C,\n        destroyObjectProperties: B,\n        extend: t,\n        fireEvent: r,\n        isNumber: d,\n        merge: p,\n        objectEach: m,\n        pick: k\n      } = H;\n    class v {\n      constructor(a, h, d, k, m) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = a;\n        this.pos = h;\n        this.type = d || \"\";\n        this.parameters = m || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        r(this, \"init\");\n        d || k || this.addLabel();\n      }\n      addLabel() {\n        const n = this,\n          h = n.axis;\n        var m = h.options;\n        const p = h.chart;\n        var v = h.categories;\n        const e = h.logarithmic,\n          q = h.names,\n          y = n.pos,\n          l = k(n.options && n.options.labels, m.labels);\n        var w = h.tickPositions;\n        const g = y === w[0],\n          b = y === w[w.length - 1],\n          c = (!l.step || 1 === l.step) && 1 === h.tickInterval;\n        w = w.info;\n        let f = n.label,\n          x,\n          J,\n          z;\n        v = this.parameters.category || (v ? k(v[y], q[y], y) : y);\n        e && d(v) && (v = G(e.lin2log(v)));\n        h.dateTime && (w ? (J = p.time.resolveDTLFormat(m.dateTimeLabelFormats[!m.grid && w.higherRanks[y] || w.unitName]), x = J.main) : d(v) && (x = h.dateTime.getXDateFormat(v, m.dateTimeLabelFormats || {})));\n        n.isFirst = g;\n        n.isLast = b;\n        const Q = {\n          axis: h,\n          chart: p,\n          dateTimeLabelFormat: x,\n          isFirst: g,\n          isLast: b,\n          pos: y,\n          tick: n,\n          tickPositionInfo: w,\n          value: v\n        };\n        r(this, \"labelFormat\", Q);\n        const S = b => l.formatter ? l.formatter.call(b, b) : l.format ? (b.text = h.defaultLabelFormatter.call(b, b), a.format(l.format, b, p)) : h.defaultLabelFormatter.call(b, b);\n        m = S.call(Q, Q);\n        const R = J && J.list;\n        n.shortenLabel = R ? function () {\n          for (z = 0; z < R.length; z++) if (t(Q, {\n            dateTimeLabelFormat: R[z]\n          }), f.attr({\n            text: S.call(Q, Q)\n          }), f.getBBox().width < h.getSlotWidth(n) - 2 * l.padding) return;\n          f.attr({\n            text: \"\"\n          });\n        } : void 0;\n        c && h._addedPlotLB && n.moveLabel(m, l);\n        C(f) || n.movedLabel ? f && f.textStr !== m && !c && (!f.textWidth || l.style.width || f.styles.width || f.css({\n          width: null\n        }), f.attr({\n          text: m\n        }), f.textPxLength = f.getBBox().width) : (n.label = f = n.createLabel({\n          x: 0,\n          y: 0\n        }, m, l), n.rotation = 0);\n      }\n      createLabel(a, h, d) {\n        const n = this.axis,\n          k = n.chart;\n        if (a = C(h) && d.enabled ? k.renderer.text(h, a.x, a.y, d.useHTML).add(n.labelGroup) : null) k.styledMode || a.css(p(d.style)), a.textPxLength = a.getBBox().width;\n        return a;\n      }\n      destroy() {\n        B(this, this.axis);\n      }\n      getPosition(a, h, d, k) {\n        const n = this.axis,\n          e = n.chart,\n          q = k && e.oldChartHeight || e.chartHeight;\n        a = {\n          x: a ? G(n.translate(h + d, void 0, void 0, k) + n.transB) : n.left + n.offset + (n.opposite ? (k && e.oldChartWidth || e.chartWidth) - n.right - n.left : 0),\n          y: a ? q - n.bottom + n.offset - (n.opposite ? n.height : 0) : G(q - n.translate(h + d, void 0, void 0, k) - n.transB)\n        };\n        a.y = F(a.y, -1E5, 1E5);\n        r(this, \"afterGetPosition\", {\n          pos: a\n        });\n        return a;\n      }\n      getLabelPosition(a, h, d, m, p, e, q, y) {\n        const l = this.axis,\n          w = l.transA,\n          g = l.isLinked && l.linkedParent ? l.linkedParent.reversed : l.reversed,\n          b = l.staggerLines,\n          c = l.tickRotCorr || {\n            x: 0,\n            y: 0\n          },\n          f = m || l.reserveSpaceDefault ? 0 : -l.labelOffset * (\"center\" === l.labelAlign ? .5 : 1),\n          x = p.distance,\n          n = {};\n        d = 0 === l.side ? d.rotation ? -x : -d.getBBox().height : 2 === l.side ? c.y + x : Math.cos(d.rotation * u) * (c.y - d.getBBox(!1, 0).height / 2);\n        C(p.y) && (d = 0 === l.side && l.horiz ? p.y + d : p.y);\n        a = a + k(p.x, [0, 1, 0, -1][l.side] * x) + f + c.x - (e && m ? e * w * (g ? -1 : 1) : 0);\n        h = h + d - (e && !m ? e * w * (g ? 1 : -1) : 0);\n        b && (m = q / (y || 1) % b, l.opposite && (m = b - m - 1), h += l.labelOffset / b * m);\n        n.x = a;\n        n.y = Math.round(h);\n        r(this, \"afterGetLabelPosition\", {\n          pos: n,\n          tickmarkOffset: e,\n          index: q\n        });\n        return n;\n      }\n      getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      }\n      getMarkPath(a, h, d, k, m, e) {\n        return e.crispLine([[\"M\", a, h], [\"L\", a + (m ? 0 : -d), h + (m ? d : 0)]], k);\n      }\n      handleOverflow(a) {\n        const h = this.axis,\n          d = h.options.labels,\n          n = a.x;\n        var m = h.chart.chartWidth,\n          e = h.chart.spacing;\n        const q = k(h.labelLeft, Math.min(h.pos, e[3]));\n        e = k(h.labelRight, Math.max(h.isRadial ? 0 : h.pos + h.len, m - e[1]));\n        const y = this.label,\n          l = this.rotation,\n          w = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[h.labelAlign || y.attr(\"align\")],\n          g = y.getBBox().width,\n          b = h.getSlotWidth(this),\n          c = {};\n        let f = b,\n          x = 1,\n          J;\n        if (l || \"justify\" !== d.overflow) 0 > l && n - w * g < q ? J = Math.round(n / Math.cos(l * u) - q) : 0 < l && n + w * g > e && (J = Math.round((m - n) / Math.cos(l * u)));else if (m = n + (1 - w) * g, n - w * g < q ? f = a.x + f * (1 - w) - q : m > e && (f = e - a.x + f * w, x = -1), f = Math.min(b, f), f < b && \"center\" === h.labelAlign && (a.x += x * (b - f - w * (b - Math.min(g, f)))), g > f || h.autoRotation && (y.styles || {}).width) J = f;\n        J && (this.shortenLabel ? this.shortenLabel() : (c.width = Math.floor(J) + \"px\", (d.style || {}).textOverflow || (c.textOverflow = \"ellipsis\"), y.css(c)));\n      }\n      moveLabel(a, h) {\n        const d = this;\n        var k = d.label;\n        const n = d.axis;\n        let e = !1;\n        k && k.textStr === a ? (d.movedLabel = k, e = !0, delete d.label) : m(n.ticks, function (q) {\n          e || q.isNew || q === d || !q.label || q.label.textStr !== a || (d.movedLabel = q.label, e = !0, q.labelPos = d.movedLabel.xy, delete q.label);\n        });\n        e || !d.labelPos && !k || (k = d.labelPos || k.xy, d.movedLabel = d.createLabel(k, a, h), d.movedLabel && d.movedLabel.attr({\n          opacity: 0\n        }));\n      }\n      render(a, h, d) {\n        var n = this.axis,\n          m = n.horiz,\n          e = this.pos,\n          q = k(this.tickmarkOffset, n.tickmarkOffset);\n        e = this.getPosition(m, e, q, h);\n        q = e.x;\n        const y = e.y;\n        n = m && q === n.pos + n.len || !m && y === n.pos ? -1 : 1;\n        m = k(d, this.label && this.label.newOpacity, 1);\n        d = k(d, 1);\n        this.isActive = !0;\n        this.renderGridLine(h, d, n);\n        this.renderMark(e, d, n);\n        this.renderLabel(e, h, m, a);\n        this.isNew = !1;\n        r(this, \"afterRender\");\n      }\n      renderGridLine(a, d, m) {\n        const h = this.axis,\n          n = h.options,\n          e = {},\n          q = this.pos,\n          y = this.type,\n          l = k(this.tickmarkOffset, h.tickmarkOffset),\n          w = h.chart.renderer;\n        let g = this.gridLine,\n          b = n.gridLineWidth,\n          c = n.gridLineColor,\n          f = n.gridLineDashStyle;\n        \"minor\" === this.type && (b = n.minorGridLineWidth, c = n.minorGridLineColor, f = n.minorGridLineDashStyle);\n        g || (h.chart.styledMode || (e.stroke = c, e[\"stroke-width\"] = b || 0, e.dashstyle = f), y || (e.zIndex = 1), a && (d = 0), this.gridLine = g = w.path().attr(e).addClass(\"highcharts-\" + (y ? y + \"-\" : \"\") + \"grid-line\").add(h.gridGroup));\n        if (g && (m = h.getPlotLinePath({\n          value: q + l,\n          lineWidth: g.strokeWidth() * m,\n          force: \"pass\",\n          old: a,\n          acrossPanes: !1\n        }))) g[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: m,\n          opacity: d\n        });\n      }\n      renderMark(a, d, m) {\n        const h = this.axis;\n        var n = h.options;\n        const e = h.chart.renderer,\n          q = this.type,\n          y = h.tickSize(q ? q + \"Tick\" : \"tick\"),\n          l = a.x;\n        a = a.y;\n        const w = k(n[\"minor\" !== q ? \"tickWidth\" : \"minorTickWidth\"], !q && h.isXAxis ? 1 : 0);\n        n = n[\"minor\" !== q ? \"tickColor\" : \"minorTickColor\"];\n        let g = this.mark;\n        const b = !g;\n        y && (h.opposite && (y[0] = -y[0]), g || (this.mark = g = e.path().addClass(\"highcharts-\" + (q ? q + \"-\" : \"\") + \"tick\").add(h.axisGroup), h.chart.styledMode || g.attr({\n          stroke: n,\n          \"stroke-width\": w\n        })), g[b ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(l, a, y[0], g.strokeWidth() * m, h.horiz, e),\n          opacity: d\n        }));\n      }\n      renderLabel(a, h, m, p) {\n        var n = this.axis;\n        const e = n.horiz,\n          q = n.options,\n          y = this.label,\n          l = q.labels,\n          w = l.step;\n        n = k(this.tickmarkOffset, n.tickmarkOffset);\n        const g = a.x;\n        a = a.y;\n        let b = !0;\n        y && d(g) && (y.xy = a = this.getLabelPosition(g, a, y, e, l, n, p, w), this.isFirst && !this.isLast && !q.showFirstLabel || this.isLast && !this.isFirst && !q.showLastLabel ? b = !1 : !e || l.step || l.rotation || h || 0 === m || this.handleOverflow(a), w && p % w && (b = !1), b && d(a.y) ? (a.opacity = m, y[this.isNewLabel ? \"attr\" : \"animate\"](a).show(!0), this.isNewLabel = !1) : (y.hide(), this.isNewLabel = !0));\n      }\n      replaceMovedLabel() {\n        const a = this.label,\n          h = this.axis;\n        a && !this.isNew && (a.animate({\n          opacity: 0\n        }, void 0, a.destroy), delete this.label);\n        h.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      }\n    }\n    \"\";\n    return v;\n  });\n  M(a, \"Core/Axis/Axis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/AxisDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C, B) {\n    const {\n        animObject: t\n      } = a,\n      {\n        defaultOptions: r\n      } = I,\n      {\n        registerEventOptions: d\n      } = F,\n      {\n        deg2rad: p\n      } = G,\n      {\n        arrayMax: m,\n        arrayMin: k,\n        clamp: v,\n        correctFloat: n,\n        defined: h,\n        destroyObjectProperties: D,\n        erase: u,\n        error: E,\n        extend: e,\n        fireEvent: q,\n        isArray: y,\n        isNumber: l,\n        isString: w,\n        merge: g,\n        normalizeTickInterval: b,\n        objectEach: c,\n        pick: f,\n        relativeLength: x,\n        removeEvent: J,\n        splat: z,\n        syncTimeout: Q\n      } = B,\n      S = (c, g) => b(g, void 0, void 0, f(c.options.allowDecimals, .5 > g || void 0 !== c.tickAmount), !!c.tickAmount);\n    class R {\n      constructor(b, c) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;\n        this.init(b, c);\n      }\n      init(b, c) {\n        const g = c.isX;\n        this.chart = b;\n        this.horiz = b.inverted && !this.isZAxis ? !g : g;\n        this.isXAxis = g;\n        this.coll = this.coll || (g ? \"xAxis\" : \"yAxis\");\n        q(this, \"init\", {\n          userOptions: c\n        });\n        this.opposite = f(c.opposite, this.opposite);\n        this.side = f(c.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n        this.setOptions(c);\n        const a = this.options,\n          e = a.labels,\n          N = a.type;\n        this.userOptions = c;\n        this.minPixelPadding = 0;\n        this.reversed = f(a.reversed, this.reversed);\n        this.visible = a.visible;\n        this.zoomEnabled = a.zoomEnabled;\n        this.hasNames = \"category\" === N || !0 === a.categories;\n        this.categories = a.categories || (this.hasNames ? [] : void 0);\n        this.names || (this.names = [], this.names.keys = {});\n        this.plotLinesAndBandsGroups = {};\n        this.positiveValuesOnly = !!this.logarithmic;\n        this.isLinked = h(a.linkedTo);\n        this.ticks = {};\n        this.labelEdge = [];\n        this.minorTicks = {};\n        this.plotLinesAndBands = [];\n        this.alternateBands = {};\n        this.len = 0;\n        this.minRange = this.userMinRange = a.minRange || a.maxZoom;\n        this.range = a.range;\n        this.offset = a.offset || 0;\n        this.min = this.max = null;\n        c = f(a.crosshair, z(b.options.tooltip.crosshairs)[g ? 0 : 1]);\n        this.crosshair = !0 === c ? {} : c;\n        -1 === b.axes.indexOf(this) && (g ? b.axes.splice(b.xAxis.length, 0, this) : b.axes.push(this), b[this.coll].push(this));\n        this.series = this.series || [];\n        b.inverted && !this.isZAxis && g && \"undefined\" === typeof this.reversed && (this.reversed = !0);\n        this.labelRotation = l(e.rotation) ? e.rotation : void 0;\n        d(this, a);\n        q(this, \"afterInit\");\n      }\n      setOptions(b) {\n        this.options = g(A.defaultXAxisOptions, \"yAxis\" === this.coll && A.defaultYAxisOptions, [A.defaultTopAxisOptions, A.defaultRightAxisOptions, A.defaultBottomAxisOptions, A.defaultLeftAxisOptions][this.side], g(r[this.coll], b));\n        q(this, \"afterSetOptions\", {\n          userOptions: b\n        });\n      }\n      defaultLabelFormatter(b) {\n        var c = this.axis;\n        ({\n          numberFormatter: b\n        } = this.chart);\n        const f = l(this.value) ? this.value : NaN,\n          g = c.chart.time,\n          a = this.dateTimeLabelFormat;\n        var e = r.lang;\n        const N = e.numericSymbols;\n        e = e.numericSymbolMagnitude || 1E3;\n        const q = c.logarithmic ? Math.abs(f) : c.tickInterval;\n        let x = N && N.length,\n          h;\n        if (c.categories) h = `${this.value}`;else if (a) h = g.dateFormat(a, f);else if (x && 1E3 <= q) for (; x-- && \"undefined\" === typeof h;) c = Math.pow(e, x + 1), q >= c && 0 === 10 * f % c && null !== N[x] && 0 !== f && (h = b(f / c, -1) + N[x]);\n        \"undefined\" === typeof h && (h = 1E4 <= Math.abs(f) ? b(f, -1) : b(f, -1, void 0, \"\"));\n        return h;\n      }\n      getSeriesExtremes() {\n        const b = this,\n          c = b.chart;\n        let g;\n        q(this, \"getSeriesExtremes\", null, function () {\n          b.hasVisibleSeries = !1;\n          b.dataMin = b.dataMax = b.threshold = null;\n          b.softThreshold = !b.isXAxis;\n          b.series.forEach(function (a) {\n            if (a.visible || !c.options.chart.ignoreHiddenSeries) {\n              var e = a.options;\n              let c = e.threshold,\n                q,\n                x;\n              b.hasVisibleSeries = !0;\n              b.positiveValuesOnly && 0 >= c && (c = null);\n              if (b.isXAxis) (e = a.xData) && e.length && (e = b.logarithmic ? e.filter(b => 0 < b) : e, g = a.getXExtremes(e), q = g.min, x = g.max, l(q) || q instanceof Date || (e = e.filter(l), g = a.getXExtremes(e), q = g.min, x = g.max), e.length && (b.dataMin = Math.min(f(b.dataMin, q), q), b.dataMax = Math.max(f(b.dataMax, x), x)));else if (a = a.applyExtremes(), l(a.dataMin) && (q = a.dataMin, b.dataMin = Math.min(f(b.dataMin, q), q)), l(a.dataMax) && (x = a.dataMax, b.dataMax = Math.max(f(b.dataMax, x), x)), h(c) && (b.threshold = c), !e.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;\n            }\n          });\n        });\n        q(this, \"afterGetSeriesExtremes\");\n      }\n      translate(b, c, f, g, a, e) {\n        const q = this.linkedParent || this,\n          x = g && q.old ? q.old.min : q.min;\n        if (!l(x)) return NaN;\n        const N = q.minPixelPadding;\n        a = (q.isOrdinal || q.brokenAxis && q.brokenAxis.hasBreaks || q.logarithmic && a) && q.lin2val;\n        let h = 1,\n          d = 0;\n        g = g && q.old ? q.old.transA : q.transA;\n        g || (g = q.transA);\n        f && (h *= -1, d = q.len);\n        q.reversed && (h *= -1, d -= h * (q.sector || q.len));\n        c ? (e = (b * h + d - N) / g + x, a && (e = q.lin2val(e))) : (a && (b = q.val2lin(b)), b = h * (b - x) * g, e = (q.isRadial ? b : n(b)) + d + h * N + (l(e) ? g * e : 0));\n        return e;\n      }\n      toPixels(b, c) {\n        return this.translate(b, !1, !this.horiz, void 0, !0) + (c ? 0 : this.pos);\n      }\n      toValue(b, c) {\n        return this.translate(b - (c ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      }\n      getPlotLinePath(b) {\n        function c(b, c, f) {\n          \"pass\" !== m && (b < c || b > f) && (m ? b = v(b, c, f) : D = !0);\n          return b;\n        }\n        const g = this,\n          a = g.chart,\n          e = g.left,\n          x = g.top,\n          h = b.old,\n          N = b.value,\n          d = b.lineWidth,\n          w = h && a.oldChartHeight || a.chartHeight,\n          k = h && a.oldChartWidth || a.chartWidth,\n          n = g.transB;\n        let z = b.translatedValue,\n          m = b.force,\n          J,\n          y,\n          p,\n          r,\n          D;\n        b = {\n          value: N,\n          lineWidth: d,\n          old: h,\n          force: m,\n          acrossPanes: b.acrossPanes,\n          translatedValue: z\n        };\n        q(this, \"getPlotLinePath\", b, function (b) {\n          z = f(z, g.translate(N, void 0, void 0, h));\n          z = v(z, -1E5, 1E5);\n          J = p = Math.round(z + n);\n          y = r = Math.round(w - z - n);\n          l(z) ? g.horiz ? (y = x, r = w - g.bottom, J = p = c(J, e, e + g.width)) : (J = e, p = k - g.right, y = r = c(y, x, x + g.height)) : (D = !0, m = !1);\n          b.path = D && !m ? null : a.renderer.crispLine([[\"M\", J, y], [\"L\", p, r]], d || 1);\n        });\n        return b.path;\n      }\n      getLinearTickPositions(b, c, f) {\n        const g = n(Math.floor(c / b) * b);\n        f = n(Math.ceil(f / b) * b);\n        const a = [];\n        let l, e;\n        n(g + b) === g && (e = 20);\n        if (this.single) return [c];\n        for (c = g; c <= f;) {\n          a.push(c);\n          c = n(c + b, e);\n          if (c === l) break;\n          l = c;\n        }\n        return a;\n      }\n      getMinorTickInterval() {\n        const b = this.options;\n        return !0 === b.minorTicks ? f(b.minorTickInterval, \"auto\") : !1 === b.minorTicks ? null : b.minorTickInterval;\n      }\n      getMinorTickPositions() {\n        var b = this.options;\n        const c = this.tickPositions,\n          f = this.minorTickInterval;\n        var g = this.pointRangePadding || 0;\n        const a = this.min - g;\n        g = this.max + g;\n        const l = g - a;\n        let e = [];\n        if (l && l / f < this.len / 3) {\n          const l = this.logarithmic;\n          if (l) this.paddedTicks.forEach(function (b, c, g) {\n            c && e.push.apply(e, l.getLogTickPositions(f, g[c - 1], g[c], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) e = e.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(f), a, g, b.startOfWeek));else for (b = a + (c[0] - a) % f; b <= g && b !== e[0]; b += f) e.push(b);\n        }\n        0 !== e.length && this.trimTicks(e);\n        return e;\n      }\n      adjustForMinRange() {\n        const b = this.options,\n          c = this.logarithmic;\n        let g = this.min;\n        var a = this.max;\n        let l,\n          e = 0,\n          q,\n          x,\n          d,\n          w,\n          z;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !c && (h(b.min) || h(b.max) || h(b.floor) || h(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {\n          d = b.xData;\n          w = b.xIncrement ? 1 : d.length - 1;\n          if (1 < d.length) for (q = w; 0 < q; q--) if (x = d[q] - d[q - 1], !e || x < e) e = x;\n        }), this.minRange = Math.min(5 * e, this.dataMax - this.dataMin)));\n        if (a - g < this.minRange) {\n          l = this.dataMax - this.dataMin >= this.minRange;\n          z = this.minRange;\n          var n = (z - a + g) / 2;\n          n = [g - n, f(b.min, g - n)];\n          l && (n[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          g = m(n);\n          a = [g + z, f(b.max, g + z)];\n          l && (a[2] = c ? c.log2lin(this.dataMax) : this.dataMax);\n          a = k(a);\n          a - g < z && (n[0] = a - z, n[1] = f(b.min, a - z), g = m(n));\n        }\n        this.min = g;\n        this.max = a;\n      }\n      getClosest() {\n        let b;\n        this.categories ? b = 1 : this.series.forEach(function (c) {\n          const f = c.closestPointRange,\n            g = c.visible || !c.chart.options.chart.ignoreHiddenSeries;\n          !c.noSharedTooltip && h(f) && g && (b = h(b) ? Math.min(b, f) : f);\n        });\n        return b;\n      }\n      nameToX(b) {\n        const c = y(this.options.categories),\n          g = c ? this.categories : this.names;\n        let a = b.options.x,\n          l;\n        b.series.requireSorting = !1;\n        h(a) || (a = this.options.uniqueNames && g ? c ? g.indexOf(b.name) : f(g.keys[b.name], -1) : b.series.autoIncrement());\n        -1 === a ? !c && g && (l = g.length) : l = a;\n        \"undefined\" !== typeof l ? (this.names[l] = b.name, this.names.keys[b.name] = l) : b.x && (l = b.x);\n        return l;\n      }\n      updateNames() {\n        const b = this,\n          c = this.names;\n        0 < c.length && (Object.keys(c.keys).forEach(function (b) {\n          delete c.keys[b];\n        }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (c) {\n          c.xIncrement = null;\n          if (!c.points || c.isDirtyData) b.max = Math.max(b.max, c.xData.length - 1), c.processData(), c.generatePoints();\n          c.data.forEach(function (f, g) {\n            let a;\n            f && f.options && \"undefined\" !== typeof f.name && (a = b.nameToX(f), \"undefined\" !== typeof a && a !== f.x && (f.x = a, c.xData[g] = a));\n          });\n        }));\n      }\n      setAxisTranslation() {\n        const b = this,\n          c = b.max - b.min;\n        var g = b.linkedParent;\n        const a = !!b.categories,\n          l = b.isXAxis;\n        let e = b.axisPointRange || 0,\n          x,\n          h = 0,\n          d = 0,\n          z = b.transA;\n        if (l || a || e) x = b.getClosest(), g ? (h = g.minPointOffset, d = g.pointRangePadding) : b.series.forEach(function (c) {\n          const g = a ? 1 : l ? f(c.options.pointRange, x, 0) : b.axisPointRange || 0,\n            q = c.options.pointPlacement;\n          e = Math.max(e, g);\n          if (!b.single || a) c = c.is(\"xrange\") ? !l : l, h = Math.max(h, c && w(q) ? 0 : g / 2), d = Math.max(d, c && \"on\" === q ? 0 : g);\n        }), g = b.ordinal && b.ordinal.slope && x ? b.ordinal.slope / x : 1, b.minPointOffset = h *= g, b.pointRangePadding = d *= g, b.pointRange = Math.min(e, b.single && a ? 1 : c), l && (b.closestPointRange = x);\n        b.translationSlope = b.transA = z = b.staticScale || b.len / (c + d || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = z * h;\n        q(this, \"afterSetAxisTranslation\");\n      }\n      minFromRange() {\n        return this.max - this.range;\n      }\n      setTickInterval(b) {\n        var c = this.chart;\n        const g = this.logarithmic,\n          a = this.options,\n          e = this.isXAxis,\n          x = this.isLinked,\n          d = a.tickPixelInterval,\n          w = this.categories,\n          z = this.softThreshold;\n        let k = a.maxPadding,\n          m = a.minPadding;\n        let J = l(a.tickInterval) && 0 <= a.tickInterval ? a.tickInterval : void 0,\n          N = l(this.threshold) ? this.threshold : null,\n          y,\n          p,\n          v;\n        this.dateTime || w || x || this.getTickAmount();\n        p = f(this.userMin, a.min);\n        v = f(this.userMax, a.max);\n        if (x) {\n          this.linkedParent = c[this.coll][a.linkedTo];\n          var r = this.linkedParent.getExtremes();\n          this.min = f(r.min, r.dataMin);\n          this.max = f(r.max, r.dataMax);\n          a.type !== this.linkedParent.options.type && E(11, 1, c);\n        } else z && h(N) && (this.dataMin >= N ? (r = N, m = 0) : this.dataMax <= N && (y = N, k = 0)), this.min = f(p, r, this.dataMin), this.max = f(v, y, this.dataMax);\n        g && (this.positiveValuesOnly && !b && 0 >= Math.min(this.min, f(this.dataMin, this.min)) && E(10, 1, c), this.min = n(g.log2lin(this.min), 16), this.max = n(g.log2lin(this.max), 16));\n        this.range && h(this.max) && (this.userMin = this.min = p = Math.max(this.dataMin, this.minFromRange()), this.userMax = v = this.max, this.range = null);\n        q(this, \"foundExtremes\");\n        this.beforePadding && this.beforePadding();\n        this.adjustForMinRange();\n        !(w || this.axisPointRange || this.stacking && this.stacking.usePercentage || x) && h(this.min) && h(this.max) && (c = this.max - this.min) && (!h(p) && m && (this.min -= c * m), !h(v) && k && (this.max += c * k));\n        l(this.userMin) || (l(a.softMin) && a.softMin < this.min && (this.min = p = a.softMin), l(a.floor) && (this.min = Math.max(this.min, a.floor)));\n        l(this.userMax) || (l(a.softMax) && a.softMax > this.max && (this.max = v = a.softMax), l(a.ceiling) && (this.max = Math.min(this.max, a.ceiling)));\n        z && h(this.dataMin) && (N = N || 0, !h(p) && this.min < N && this.dataMin >= N ? this.min = this.options.minRange ? Math.min(N, this.max - this.minRange) : N : !h(v) && this.max > N && this.dataMax <= N && (this.max = this.options.minRange ? Math.max(N, this.min + this.minRange) : N));\n        l(this.min) && l(this.max) && !this.chart.polar && this.min > this.max && (h(this.options.min) ? this.max = this.min : h(this.options.max) && (this.min = this.max));\n        this.tickInterval = this.min === this.max || \"undefined\" === typeof this.min || \"undefined\" === typeof this.max ? 1 : x && this.linkedParent && !J && d === this.linkedParent.options.tickPixelInterval ? J = this.linkedParent.tickInterval : f(J, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, w ? 1 : (this.max - this.min) * d / Math.max(this.len, d));\n        if (e && !b) {\n          const b = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n          this.series.forEach(function (c) {\n            c.forceCrop = c.forceCropping && c.forceCropping();\n            c.processData(b);\n          });\n          q(this, \"postProcessData\", {\n            hasExtremesChanged: b\n          });\n        }\n        this.setAxisTranslation();\n        q(this, \"initialAxisTranslation\");\n        this.pointRange && !J && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        b = f(a.minTickInterval, this.dateTime && !this.series.some(b => b.noSharedTooltip) ? this.closestPointRange : 0);\n        !J && this.tickInterval < b && (this.tickInterval = b);\n        this.dateTime || this.logarithmic || J || (this.tickInterval = S(this, this.tickInterval));\n        this.tickAmount || (this.tickInterval = this.unsquish());\n        this.setTickPositions();\n      }\n      setTickPositions() {\n        var b = this.options;\n        const c = b.tickPositions,\n          f = b.tickPositioner;\n        var g = this.getMinorTickInterval(),\n          a = this.hasVerticalPanning(),\n          e = \"colorAxis\" === this.coll;\n        const x = (e || !a) && b.startOnTick;\n        a = (e || !a) && b.endOnTick;\n        e = [];\n        let d;\n        this.tickmarkOffset = this.categories && \"between\" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === g && this.tickInterval ? this.tickInterval / b.minorTicksPerMajor : g;\n        this.single = this.min === this.max && h(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);\n        if (c) e = c.slice();else if (l(this.min) && l(this.max)) {\n          if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {\n            if (this.dateTime) e = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) e = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (g = b = this.tickInterval; g <= 2 * b;) if (e = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && e.length > this.tickAmount) this.tickInterval = S(this, g *= 1.1);else break;\n          } else e = [this.min, this.max], E(19, !1, this.chart);\n          e.length > this.len && (e = [e[0], e[e.length - 1]], e[0] === e[1] && (e.length = 1));\n          f && (this.tickPositions = e, (d = f.apply(this, [this.min, this.max])) && (e = d));\n        }\n        this.tickPositions = e;\n        this.paddedTicks = e.slice(0);\n        this.trimTicks(e, x, a);\n        !this.isLinked && l(this.min) && l(this.max) && (this.single && 2 > e.length && !this.categories && !this.series.some(b => b.is(\"heatmap\") && \"between\" === b.options.pointPlacement) && (this.min -= .5, this.max += .5), c || d || this.adjustTickAmount());\n        q(this, \"afterSetTickPositions\");\n      }\n      trimTicks(b, c, f) {\n        const g = b[0],\n          a = b[b.length - 1],\n          l = !this.isOrdinal && this.minPointOffset || 0;\n        q(this, \"trimTicks\");\n        if (!this.isLinked) {\n          if (c && -Infinity !== g) this.min = g;else for (; this.min - l > b[0];) b.shift();\n          if (f) this.max = a;else for (; this.max + l < b[b.length - 1];) b.pop();\n          0 === b.length && h(g) && !this.options.tickPositions && b.push((a + g) / 2);\n        }\n      }\n      alignToOthers() {\n        const b = this,\n          c = [this],\n          f = b.options,\n          g = \"yAxis\" === this.coll && this.chart.options.chart.alignThresholds,\n          a = [];\n        let e;\n        b.thresholdAlignment = void 0;\n        if ((!1 !== this.chart.options.chart.alignTicks && f.alignTicks || g) && !1 !== f.startOnTick && !1 !== f.endOnTick && !b.logarithmic) {\n          const f = b => {\n              const {\n                horiz: c,\n                options: f\n              } = b;\n              return [c ? f.left : f.top, f.width, f.height, f.pane].join();\n            },\n            g = f(this);\n          this.chart[this.coll].forEach(function (a) {\n            const {\n              series: l\n            } = a;\n            l.length && l.some(b => b.visible) && a !== b && f(a) === g && (e = !0, c.push(a));\n          });\n        }\n        if (e && g) {\n          c.forEach(c => {\n            c = c.getThresholdAlignment(b);\n            l(c) && a.push(c);\n          });\n          const f = 1 < a.length ? a.reduce((b, c) => b + c, 0) / a.length : void 0;\n          c.forEach(b => {\n            b.thresholdAlignment = f;\n          });\n        }\n        return e;\n      }\n      getThresholdAlignment(b) {\n        (!l(this.dataMin) || this !== b && this.series.some(b => b.isDirty || b.isDirtyData)) && this.getSeriesExtremes();\n        if (l(this.threshold)) return b = v((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (b = 1 - b), b;\n      }\n      getTickAmount() {\n        const b = this.options,\n          c = b.tickPixelInterval;\n        let f = b.tickAmount;\n        !h(b.tickInterval) && !f && this.len < c && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (f = 2);\n        !f && this.alignToOthers() && (f = Math.ceil(this.len / c) + 1);\n        4 > f && (this.finalTickAmt = f, f = 5);\n        this.tickAmount = f;\n      }\n      adjustTickAmount() {\n        const b = this,\n          {\n            finalTickAmt: c,\n            max: g,\n            min: a,\n            options: e,\n            tickPositions: q,\n            tickAmount: x,\n            thresholdAlignment: d\n          } = b,\n          w = q && q.length;\n        var z = f(b.threshold, b.softThreshold ? 0 : null);\n        var k = b.tickInterval;\n        let m;\n        l(d) && (m = .5 > d ? Math.ceil(d * (x - 1)) : Math.floor(d * (x - 1)), e.reversed && (m = x - 1 - m));\n        if (b.hasData() && l(a) && l(g)) {\n          const f = () => {\n            b.transA *= (w - 1) / (x - 1);\n            b.min = e.startOnTick ? q[0] : Math.min(a, q[0]);\n            b.max = e.endOnTick ? q[q.length - 1] : Math.max(g, q[q.length - 1]);\n          };\n          if (l(m) && l(b.threshold)) {\n            for (; q[m] !== z || q.length !== x || q[0] > a || q[q.length - 1] < g;) {\n              q.length = 0;\n              for (q.push(b.threshold); q.length < x;) void 0 === q[m] || q[m] > b.threshold ? q.unshift(n(q[0] - k)) : q.push(n(q[q.length - 1] + k));\n              if (k > 8 * b.tickInterval) break;\n              k *= 2;\n            }\n            f();\n          } else if (w < x) {\n            for (; q.length < x;) q.length % 2 || a === z ? q.push(n(q[q.length - 1] + k)) : q.unshift(n(q[0] - k));\n            f();\n          }\n          if (h(c)) {\n            for (k = z = q.length; k--;) (3 === c && 1 === k % 2 || 2 >= c && 0 < k && k < z - 1) && q.splice(k, 1);\n            b.finalTickAmt = void 0;\n          }\n        }\n      }\n      setScale() {\n        let b = !1,\n          c = !1;\n        this.series.forEach(function (f) {\n          b = b || f.isDirtyData || f.isDirty;\n          c = c || f.xAxis && f.xAxis.isDirty || !1;\n        });\n        this.setAxisSize();\n        const f = this.len !== (this.old && this.old.len);\n        f || b || c || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = f || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();\n        b && this.panningState && (this.panningState.isDirty = !0);\n        q(this, \"afterSetScale\");\n      }\n      setExtremes(b, c, g, a, l) {\n        const x = this,\n          d = x.chart;\n        g = f(g, !0);\n        x.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        l = e(l, {\n          min: b,\n          max: c\n        });\n        q(x, \"setExtremes\", l, function () {\n          x.userMin = b;\n          x.userMax = c;\n          x.eventArgs = l;\n          g && d.redraw(a);\n        });\n      }\n      zoom(b, c) {\n        const g = this,\n          a = this.dataMin,\n          l = this.dataMax,\n          e = this.options,\n          x = Math.min(a, f(e.min, a)),\n          d = Math.max(l, f(e.max, l));\n        b = {\n          newMin: b,\n          newMax: c\n        };\n        q(this, \"zoom\", b, function (b) {\n          let c = b.newMin,\n            f = b.newMax;\n          if (c !== g.min || f !== g.max) g.allowZoomOutside || (h(a) && (c < x && (c = x), c > d && (c = d)), h(l) && (f < x && (f = x), f > d && (f = d))), g.displayBtn = \"undefined\" !== typeof c || \"undefined\" !== typeof f, g.setExtremes(c, f, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return b.zoomed;\n      }\n      setAxisSize() {\n        const b = this.chart;\n        var c = this.options;\n        const g = c.offsets || [0, 0, 0, 0],\n          a = this.horiz,\n          l = this.width = Math.round(x(f(c.width, b.plotWidth - g[3] + g[1]), b.plotWidth)),\n          e = this.height = Math.round(x(f(c.height, b.plotHeight - g[0] + g[2]), b.plotHeight)),\n          q = this.top = Math.round(x(f(c.top, b.plotTop + g[0]), b.plotHeight, b.plotTop));\n        c = this.left = Math.round(x(f(c.left, b.plotLeft + g[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - e - q;\n        this.right = b.chartWidth - l - c;\n        this.len = Math.max(a ? l : e, 0);\n        this.pos = a ? c : q;\n      }\n      getExtremes() {\n        const b = this.logarithmic;\n        return {\n          min: b ? n(b.lin2log(this.min)) : this.min,\n          max: b ? n(b.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      }\n      getThreshold(b) {\n        var c = this.logarithmic;\n        const f = c ? c.lin2log(this.min) : this.min;\n        c = c ? c.lin2log(this.max) : this.max;\n        null === b || -Infinity === b ? b = f : Infinity === b ? b = c : f > b ? b = f : c < b && (b = c);\n        return this.translate(b, 0, 1, 0, 1);\n      }\n      autoLabelAlign(b) {\n        const c = (f(b, 0) - 90 * this.side + 720) % 360;\n        b = {\n          align: \"center\"\n        };\n        q(this, \"autoLabelAlign\", b, function (b) {\n          15 < c && 165 > c ? b.align = \"right\" : 195 < c && 345 > c && (b.align = \"left\");\n        });\n        return b.align;\n      }\n      tickSize(b) {\n        const c = this.options,\n          g = f(c[\"tick\" === b ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === b && this.isXAxis && !this.categories ? 1 : 0);\n        let a = c[\"tick\" === b ? \"tickLength\" : \"minorTickLength\"],\n          l;\n        g && a && (\"inside\" === c[b + \"Position\"] && (a = -a), l = [a, g]);\n        b = {\n          tickSize: l\n        };\n        q(this, \"afterTickSize\", b);\n        return b.tickSize;\n      }\n      labelMetrics() {\n        const b = this.chart.renderer;\n        var c = this.ticks;\n        c = c[Object.keys(c)[0]] || {};\n        return this.chart.renderer.fontMetrics(c.label || c.movedLabel || b.box);\n      }\n      unsquish() {\n        const b = this.options.labels;\n        var c = this.horiz;\n        const g = this.tickInterval,\n          a = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / g),\n          e = b.rotation,\n          q = .75 * this.labelMetrics().h,\n          x = Math.max(this.max - this.min, 0),\n          d = function (b) {\n            let c = b / (a || 1);\n            c = 1 < c ? Math.ceil(c) : 1;\n            c * g > x && Infinity !== b && Infinity !== a && x && (c = Math.ceil(x / g));\n            return n(c * g);\n          };\n        let h = g,\n          w,\n          k = Number.MAX_VALUE,\n          z;\n        if (c) {\n          if (b.staggerLines || (l(e) ? z = [e] : a < b.autoRotationLimit && (z = b.autoRotation)), z) {\n            let b;\n            for (const f of z) if (f === e || f && -90 <= f && 90 >= f) c = d(Math.abs(q / Math.sin(p * f))), b = c + Math.abs(f / 360), b < k && (k = b, w = f, h = c);\n          }\n        } else h = d(q);\n        this.autoRotation = z;\n        this.labelRotation = f(w, l(e) ? e : 0);\n        return b.step ? g : h;\n      }\n      getSlotWidth(b) {\n        const c = this.chart,\n          f = this.horiz,\n          g = this.options.labels,\n          a = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n          e = c.margin[3];\n        if (b && l(b.slotWidth)) return b.slotWidth;\n        if (f && 2 > g.step) return g.rotation ? 0 : (this.staggerLines || 1) * this.len / a;\n        if (!f) {\n          b = g.style.width;\n          if (void 0 !== b) return parseInt(String(b), 10);\n          if (e) return e - c.spacing[3];\n        }\n        return .33 * c.chartWidth;\n      }\n      renderUnsquish() {\n        const b = this.chart,\n          c = b.renderer,\n          f = this.tickPositions,\n          g = this.ticks,\n          a = this.options.labels,\n          l = a.style,\n          e = this.horiz,\n          q = this.getSlotWidth();\n        var x = Math.max(1, Math.round(q - 2 * a.padding));\n        const d = {},\n          h = this.labelMetrics(),\n          z = l.textOverflow;\n        let k,\n          m,\n          n = 0;\n        w(a.rotation) || (d.rotation = a.rotation || 0);\n        f.forEach(function (b) {\n          b = g[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > n && (n = b.label.textPxLength);\n        });\n        this.maxLabelLength = n;\n        if (this.autoRotation) n > x && n > h.h ? d.rotation = this.labelRotation : this.labelRotation = 0;else if (q && (k = x, !z)) for (m = \"clip\", x = f.length; !e && x--;) {\n          var J = f[x];\n          if (J = g[J].label) J.styles && \"ellipsis\" === J.styles.textOverflow ? J.css({\n            textOverflow: \"clip\"\n          }) : J.textPxLength > q && J.css({\n            width: q + \"px\"\n          }), J.getBBox().height > this.len / f.length - (h.h - h.f) && (J.specificTextOverflow = \"ellipsis\");\n        }\n        d.rotation && (k = n > .5 * b.chartHeight ? .33 * b.chartHeight : n, z || (m = \"ellipsis\"));\n        if (this.labelAlign = a.align || this.autoLabelAlign(this.labelRotation)) d.align = this.labelAlign;\n        f.forEach(function (b) {\n          const c = (b = g[b]) && b.label,\n            f = l.width,\n            a = {};\n          c && (c.attr(d), b.shortenLabel ? b.shortenLabel() : k && !f && \"nowrap\" !== l.whiteSpace && (k < c.textPxLength || \"SPAN\" === c.element.tagName) ? (a.width = k + \"px\", z || (a.textOverflow = c.specificTextOverflow || m), c.css(a)) : c.styles && c.styles.width && !a.width && !f && c.css({\n            width: null\n          }), delete c.specificTextOverflow, b.rotation = d.rotation);\n        }, this);\n        this.tickRotCorr = c.rotCorr(h.b, this.labelRotation || 0, 0 !== this.side);\n      }\n      hasData() {\n        return this.series.some(function (b) {\n          return b.hasData();\n        }) || this.options.showEmpty && h(this.min) && h(this.max);\n      }\n      addTitle(b) {\n        const c = this.chart.renderer,\n          f = this.horiz,\n          a = this.opposite,\n          l = this.options.title,\n          e = this.chart.styledMode;\n        let q;\n        this.axisTitle || ((q = l.textAlign) || (q = (f ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: a ? \"right\" : \"left\",\n          middle: \"center\",\n          high: a ? \"left\" : \"right\"\n        })[l.align]), this.axisTitle = c.text(l.text || \"\", 0, 0, l.useHTML).attr({\n          zIndex: 7,\n          rotation: l.rotation,\n          align: q\n        }).addClass(\"highcharts-axis-title\"), e || this.axisTitle.css(g(l.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        e || l.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[b ? \"show\" : \"hide\"](b);\n      }\n      generateTick(b) {\n        const c = this.ticks;\n        c[b] ? c[b].addLabel() : c[b] = new C(this, b);\n      }\n      getOffset() {\n        const b = this,\n          {\n            chart: g,\n            horiz: a,\n            options: e,\n            side: x,\n            ticks: d,\n            tickPositions: w,\n            coll: z,\n            axisParent: k\n          } = b,\n          n = g.renderer,\n          m = g.inverted && !b.isZAxis ? [1, 0, 3, 2][x] : x;\n        var J = b.hasData();\n        const y = e.title;\n        var p = e.labels;\n        const v = l(e.crossing);\n        var r = g.axisOffset;\n        const D = g.clipOffset,\n          Q = [-1, 1, 1, -1][x],\n          t = e.className;\n        let S,\n          R = 0,\n          E;\n        var u = 0;\n        let L = 0;\n        b.showAxis = S = J || e.showEmpty;\n        b.staggerLines = b.horiz && p.staggerLines || void 0;\n        if (!b.axisGroup) {\n          const c = (b, c, f) => n.g(b).attr({\n            zIndex: f\n          }).addClass(`highcharts-${z.toLowerCase()}${c} ` + (this.isRadial ? `highcharts-radial-axis${c} ` : \"\") + (t || \"\")).add(k);\n          b.gridGroup = c(\"grid\", \"-grid\", e.gridZIndex);\n          b.axisGroup = c(\"axis\", \"\", e.zIndex);\n          b.labelGroup = c(\"axis-labels\", \"-labels\", p.zIndex);\n        }\n        J || b.isLinked ? (w.forEach(function (c) {\n          b.generateTick(c);\n        }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === x || 2 === x || {\n          1: \"left\",\n          3: \"right\"\n        }[x] === b.labelAlign, f(p.reserveSpace, v ? !1 : null, \"center\" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && w.forEach(function (b) {\n          L = Math.max(d[b].getLabelSize(), L);\n        }), b.staggerLines && (L *= b.staggerLines), b.labelOffset = L * (b.opposite ? -1 : 1)) : c(d, function (b, c) {\n          b.destroy();\n          delete d[c];\n        });\n        y && y.text && !1 !== y.enabled && (b.addTitle(S), S && !v && !1 !== y.reserveSpace && (b.titleOffset = R = b.axisTitle.getBBox()[a ? \"height\" : \"width\"], E = y.offset, u = h(E) ? 0 : f(y.margin, a ? 5 : 10)));\n        b.renderLine();\n        b.offset = Q * f(e.offset, r[x] ? r[x] + (e.margin || 0) : 0);\n        b.tickRotCorr = b.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        J = 0 === x ? -b.labelMetrics().h : 2 === x ? b.tickRotCorr.y : 0;\n        u = Math.abs(L) + u;\n        L && (u = u - J + Q * (a ? f(p.y, b.tickRotCorr.y + Q * p.distance) : f(p.x, Q * p.distance)));\n        b.axisTitleMargin = f(E, u);\n        b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(d, w));\n        \"colorAxis\" !== z && (p = this.tickSize(\"tick\"), r[x] = Math.max(r[x], (b.axisTitleMargin || 0) + R + Q * b.offset, u, w && w.length && p ? p[0] + Q * b.offset : 0), r = !b.axisLine || e.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2), D[m] = Math.max(D[m], r));\n        q(this, \"afterGetOffset\");\n      }\n      getLinePath(b) {\n        const c = this.chart,\n          f = this.opposite;\n        var g = this.offset;\n        const a = this.horiz,\n          l = this.left + (f ? this.width : 0) + g;\n        g = c.chartHeight - this.bottom - (f ? this.height : 0) + g;\n        f && (b *= -1);\n        return c.renderer.crispLine([[\"M\", a ? this.left : l, a ? g : this.top], [\"L\", a ? c.chartWidth - this.right : l, a ? g : c.chartHeight - this.bottom]], b);\n      }\n      renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      }\n      getTitlePosition(b) {\n        var c = this.horiz,\n          f = this.left;\n        const g = this.top;\n        var a = this.len;\n        const l = this.options.title,\n          e = c ? f : g,\n          x = this.opposite,\n          d = this.offset,\n          h = l.x,\n          w = l.y,\n          z = this.chart.renderer.fontMetrics(b);\n        b = b ? Math.max(b.getBBox(!1, 0).height - z.h - 1, 0) : 0;\n        a = {\n          low: e + (c ? 0 : a),\n          middle: e + a / 2,\n          high: e + (c ? a : 0)\n        }[l.align];\n        f = (c ? g + this.height : f) + (c ? 1 : -1) * (x ? -1 : 1) * (this.axisTitleMargin || 0) + [-b, b, z.f, -b][this.side];\n        c = {\n          x: c ? a + h : f + (x ? this.width : 0) + d + h,\n          y: c ? f + w - (x ? this.height : 0) + d : a + w\n        };\n        q(this, \"afterGetTitlePosition\", {\n          titlePosition: c\n        });\n        return c;\n      }\n      renderMinorTick(b, c) {\n        const f = this.minorTicks;\n        f[b] || (f[b] = new C(this, b, \"minor\"));\n        c && f[b].isNew && f[b].render(null, !0);\n        f[b].render(null, !1, 1);\n      }\n      renderTick(b, c, f) {\n        const g = this.ticks;\n        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) g[b] || (g[b] = new C(this, b)), f && g[b].isNew && g[b].render(c, !0, -1), g[b].render(c);\n      }\n      render() {\n        const b = this,\n          f = b.chart,\n          g = b.logarithmic,\n          a = b.options,\n          e = b.isLinked,\n          x = b.tickPositions,\n          d = b.axisTitle,\n          h = b.ticks,\n          w = b.minorTicks,\n          z = b.alternateBands,\n          k = a.stackLabels,\n          n = a.alternateGridColor,\n          m = a.crossing,\n          J = b.tickmarkOffset,\n          y = b.axisLine,\n          p = b.showAxis,\n          v = t(f.renderer.globalAnimation);\n        let r, D;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        [h, w, z].forEach(function (b) {\n          c(b, function (b) {\n            b.isActive = !1;\n          });\n        });\n        if (l(m)) {\n          const b = this.isXAxis ? f.yAxis[0] : f.xAxis[0],\n            c = [1, -1, -1, 1][this.side];\n          b && (this.offset = c * b.toPixels(m, !0));\n        }\n        if (b.hasData() || e) {\n          const c = b.chart.hasRendered && b.old && l(b.old.min);\n          b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (f) {\n            b.renderMinorTick(f, c);\n          });\n          x.length && (x.forEach(function (f, g) {\n            b.renderTick(f, g, c);\n          }), J && (0 === b.min || b.single) && (h[-1] || (h[-1] = new C(b, -1, null, !0)), h[-1].render(-1)));\n          n && x.forEach(function (c, a) {\n            D = \"undefined\" !== typeof x[a + 1] ? x[a + 1] + J : b.max - J;\n            0 === a % 2 && c < b.max && D <= b.max + (f.polar ? -J : J) && (z[c] || (z[c] = new G.PlotLineOrBand(b)), r = c + J, z[c].options = {\n              from: g ? g.lin2log(r) : r,\n              to: g ? g.lin2log(D) : D,\n              color: n,\n              className: \"highcharts-alternate-grid\"\n            }, z[c].render(), z[c].isActive = !0);\n          });\n          b._addedPlotLB || (b._addedPlotLB = !0, (a.plotLines || []).concat(a.plotBands || []).forEach(function (c) {\n            b.addPlotBandOrLine(c);\n          }));\n        }\n        [h, w, z].forEach(function (b) {\n          const g = [],\n            a = v.duration;\n          c(b, function (b, c) {\n            b.isActive || (b.render(c, !1, 0), b.isActive = !1, g.push(c));\n          });\n          Q(function () {\n            let c = g.length;\n            for (; c--;) b[g[c]] && !b[g[c]].isActive && (b[g[c]].destroy(), delete b[g[c]]);\n          }, b !== z && f.hasRendered && a ? a : 0);\n        });\n        y && (y[y.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(y.strokeWidth())\n        }), y.isPlaced = !0, y[p ? \"show\" : \"hide\"](p));\n        d && p && (d[d.isNew ? \"attr\" : \"animate\"](b.getTitlePosition(d)), d.isNew = !1);\n        k && k.enabled && b.stacking && b.stacking.renderStackTotals();\n        b.old = {\n          len: b.len,\n          max: b.max,\n          min: b.min,\n          transA: b.transA,\n          userMax: b.userMax,\n          userMin: b.userMin\n        };\n        b.isDirty = !1;\n        q(this, \"afterRender\");\n      }\n      redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {\n          b.render();\n        }));\n        this.series.forEach(function (b) {\n          b.isDirty = !0;\n        });\n      }\n      getKeepProps() {\n        return this.keepProps || R.keepProps;\n      }\n      destroy(b) {\n        const f = this,\n          g = f.plotLinesAndBands,\n          a = this.eventOptions;\n        q(this, \"destroy\", {\n          keepEvents: b\n        });\n        b || J(f);\n        [f.ticks, f.minorTicks, f.alternateBands].forEach(function (b) {\n          D(b);\n        });\n        if (g) for (b = g.length; b--;) g[b].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (b) {\n          f[b] && (f[b] = f[b].destroy());\n        });\n        for (const b in f.plotLinesAndBandsGroups) f.plotLinesAndBandsGroups[b] = f.plotLinesAndBandsGroups[b].destroy();\n        c(f, function (b, c) {\n          -1 === f.getKeepProps().indexOf(c) && delete f[c];\n        });\n        this.eventOptions = a;\n      }\n      drawCrosshair(b, c) {\n        const g = this.crosshair;\n        var a = f(g && g.snap, !0);\n        const l = this.chart;\n        let x,\n          d = this.cross;\n        q(this, \"drawCrosshair\", {\n          e: b,\n          point: c\n        });\n        b || (b = this.cross && this.cross.e);\n        if (g && !1 !== (h(c) || !a)) {\n          a ? h(c) && (x = f(\"colorAxis\" !== this.coll ? c.crosshairPos : null, this.isXAxis ? c.plotX : this.len - c.plotY)) : x = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);\n          if (h(x)) {\n            var w = {\n              value: c && (this.isXAxis ? c.x : f(c.stackY, c.y)),\n              translatedValue: x\n            };\n            l.polar && e(w, {\n              isCrosshair: !0,\n              chartX: b && b.chartX,\n              chartY: b && b.chartY,\n              point: c\n            });\n            w = this.getPlotLinePath(w) || null;\n          }\n          if (!h(w)) {\n            this.hideCrosshair();\n            return;\n          }\n          a = this.categories && !this.isRadial;\n          d || (this.cross = d = l.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (a ? \"category \" : \"thin \") + (g.className || \"\")).attr({\n            zIndex: f(g.zIndex, 2)\n          }).add(), l.styledMode || (d.attr({\n            stroke: g.color || (a ? H.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": f(g.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), g.dashStyle && d.attr({\n            dashstyle: g.dashStyle\n          })));\n          d.show().attr({\n            d: w\n          });\n          a && !g.width && d.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = b;\n        } else this.hideCrosshair();\n        q(this, \"afterDrawCrosshair\", {\n          e: b,\n          point: c\n        });\n      }\n      hideCrosshair() {\n        this.cross && this.cross.hide();\n        q(this, \"afterHideCrosshair\");\n      }\n      hasVerticalPanning() {\n        const b = this.chart.options.chart.panning;\n        return !!(b && b.enabled && /y/.test(b.type));\n      }\n      update(b, c) {\n        const a = this.chart;\n        b = g(this.userOptions, b);\n        this.destroy(!0);\n        this.init(a, b);\n        a.isDirtyBox = !0;\n        f(c, !0) && a.redraw();\n      }\n      remove(b) {\n        const c = this.chart,\n          g = this.coll,\n          a = this.series;\n        let l = a.length;\n        for (; l--;) a[l] && a[l].remove(!1);\n        u(c.axes, this);\n        u(c[g], this);\n        c[g].forEach(function (b, c) {\n          b.options.index = b.userOptions.index = c;\n        });\n        this.destroy();\n        c.isDirtyBox = !0;\n        f(b, !0) && c.redraw();\n      }\n      setTitle(b, c) {\n        this.update({\n          title: b\n        }, c);\n      }\n      setCategories(b, c) {\n        this.update({\n          categories: b\n        }, c);\n      }\n    }\n    R.defaultOptions = A.defaultXAxisOptions;\n    R.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n    \"\";\n    return R;\n  });\n  M(a, \"Core/Axis/DateTimeAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: u,\n      getMagnitude: H,\n      normalizeTickInterval: I,\n      timeUnits: F\n    } = a;\n    var G;\n    (function (C) {\n      function B() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function t(a) {\n        \"datetime\" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new d(this));\n      }\n      const r = [];\n      C.compose = function (d) {\n        a.pushUnique(r, d) && (d.keepProps.push(\"dateTime\"), d.prototype.getTimeTicks = B, u(d, \"init\", t));\n        return d;\n      };\n      class d {\n        constructor(a) {\n          this.axis = a;\n        }\n        normalizeTimeTickInterval(a, d) {\n          const k = d || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n          d = k[k.length - 1];\n          let m = F[d[0]],\n            n = d[1],\n            h;\n          for (h = 0; h < k.length && !(d = k[h], m = F[d[0]], n = d[1], k[h + 1] && a <= (m * n[n.length - 1] + F[k[h + 1][0]]) / 2); h++);\n          m === F.year && a < 5 * m && (n = [1, 2, 5]);\n          a = I(a / m, n, \"year\" === d[0] ? Math.max(H(a / m), 1) : 1);\n          return {\n            unitRange: m,\n            count: a,\n            unitName: d[0]\n          };\n        }\n        getXDateFormat(a, d) {\n          const {\n              axis: k\n            } = this,\n            m = k.chart.time;\n          return k.closestPointRange ? m.getDateFormat(k.closestPointRange, a, k.options.startOfWeek, d) || m.resolveDTLFormat(d.year).main : m.resolveDTLFormat(d.day).main;\n        }\n      }\n      C.Additions = d;\n    })(G || (G = {}));\n    return G;\n  });\n  M(a, \"Core/Axis/LogarithmicAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: u,\n      normalizeTickInterval: H,\n      pick: I\n    } = a;\n    var F;\n    (function (A) {\n      function C(a) {\n        let d = this.logarithmic;\n        \"logarithmic\" !== a.userOptions.type ? this.logarithmic = void 0 : d || (this.logarithmic = new r(this));\n      }\n      function B() {\n        const a = this.logarithmic;\n        a && (this.lin2val = function (d) {\n          return a.lin2log(d);\n        }, this.val2lin = function (d) {\n          return a.log2lin(d);\n        });\n      }\n      const t = [];\n      A.compose = function (d) {\n        a.pushUnique(t, d) && (d.keepProps.push(\"logarithmic\"), u(d, \"init\", C), u(d, \"afterInit\", B));\n        return d;\n      };\n      class r {\n        constructor(a) {\n          this.axis = a;\n        }\n        getLogTickPositions(a, p, m, k) {\n          const d = this.axis;\n          var n = d.len,\n            h = d.options;\n          let r = [];\n          k || (this.minorAutoInterval = void 0);\n          if (.5 <= a) a = Math.round(a), r = d.getLinearTickPositions(a, p, m);else if (.08 <= a) {\n            h = Math.floor(p);\n            let d, v, e, q, y;\n            for (n = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; h < m + 1 && !y; h++) for (v = n.length, d = 0; d < v && !y; d++) e = this.log2lin(this.lin2log(h) * n[d]), e > p && (!k || q <= m) && \"undefined\" !== typeof q && r.push(q), q > m && (y = !0), q = e;\n          } else p = this.lin2log(p), m = this.lin2log(m), a = k ? d.getMinorTickInterval() : h.tickInterval, a = I(\"auto\" === a ? null : a, this.minorAutoInterval, h.tickPixelInterval / (k ? 5 : 1) * (m - p) / ((k ? n / d.tickPositions.length : n) || 1)), a = H(a), r = d.getLinearTickPositions(a, p, m).map(this.log2lin), k || (this.minorAutoInterval = a / 5);\n          k || (d.tickInterval = a);\n          return r;\n        }\n        lin2log(a) {\n          return Math.pow(10, a);\n        }\n        log2lin(a) {\n          return Math.log(a) / Math.LN10;\n        }\n      }\n      A.Additions = r;\n    })(F || (F = {}));\n    return F;\n  });\n  M(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      erase: u,\n      extend: H,\n      isNumber: I\n    } = a;\n    var F;\n    (function (A) {\n      function C(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      }\n      function B(a, d) {\n        const h = this.userOptions;\n        let k = new v(this, a);\n        this.visible && (k = k.render());\n        if (k) {\n          this._addedPlotLB || (this._addedPlotLB = !0, (h.plotLines || []).concat(h.plotBands || []).forEach(a => {\n            this.addPlotBandOrLine(a);\n          }));\n          if (d) {\n            const k = h[d] || [];\n            k.push(a);\n            h[d] = k;\n          }\n          this.plotLinesAndBands.push(k);\n        }\n        return k;\n      }\n      function t(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      }\n      function r(a, d, k = this.options) {\n        const h = this.getPlotLinePath({\n            value: d,\n            force: !0,\n            acrossPanes: k.acrossPanes\n          }),\n          m = [],\n          e = this.horiz;\n        d = !I(this.min) || !I(this.max) || a < this.min && d < this.min || a > this.max && d > this.max;\n        a = this.getPlotLinePath({\n          value: a,\n          force: !0,\n          acrossPanes: k.acrossPanes\n        });\n        k = 1;\n        let q;\n        if (a && h) for (d && (q = a.toString() === h.toString(), k = 0), d = 0; d < a.length; d += 2) {\n          const n = a[d],\n            l = a[d + 1],\n            w = h[d],\n            g = h[d + 1];\n          \"M\" !== n[0] && \"L\" !== n[0] || \"M\" !== l[0] && \"L\" !== l[0] || \"M\" !== w[0] && \"L\" !== w[0] || \"M\" !== g[0] && \"L\" !== g[0] || (e && w[1] === n[1] ? (w[1] += k, g[1] += k) : e || w[2] !== n[2] || (w[2] += k, g[2] += k), m.push([\"M\", n[1], n[2]], [\"L\", l[1], l[2]], [\"L\", g[1], g[2]], [\"L\", w[1], w[2]], [\"Z\"]));\n          m.isFlat = q;\n        }\n        return m;\n      }\n      function d(a) {\n        this.removePlotBandOrLine(a);\n      }\n      function p(a) {\n        const d = this.plotLinesAndBands,\n          k = this.options,\n          m = this.userOptions;\n        if (d) {\n          let h = d.length;\n          for (; h--;) d[h].id === a && d[h].destroy();\n          [k.plotLines || [], m.plotLines || [], k.plotBands || [], m.plotBands || []].forEach(function (e) {\n            for (h = e.length; h--;) (e[h] || {}).id === a && u(e, e[h]);\n          });\n        }\n      }\n      function m(a) {\n        this.removePlotBandOrLine(a);\n      }\n      const k = [];\n      let v;\n      A.compose = function (n, h) {\n        v || (v = n);\n        a.pushUnique(k, h) && H(h.prototype, {\n          addPlotBand: C,\n          addPlotLine: t,\n          addPlotBandOrLine: B,\n          getPlotBandPath: r,\n          removePlotBand: d,\n          removePlotLine: m,\n          removePlotBandOrLine: p\n        });\n        return h;\n      };\n    })(F || (F = {}));\n    return F;\n  });\n  M(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [a[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    const {\n      arrayMax: u,\n      arrayMin: I,\n      defined: F,\n      destroyObjectProperties: G,\n      erase: C,\n      fireEvent: B,\n      merge: t,\n      objectEach: r,\n      pick: d\n    } = A;\n    class p {\n      static compose(d) {\n        return a.compose(p, d);\n      }\n      constructor(a, d) {\n        this.axis = a;\n        d && (this.options = d, this.id = d.id);\n      }\n      render() {\n        B(this, \"render\");\n        const a = this,\n          k = a.axis,\n          p = k.horiz;\n        var n = k.logarithmic;\n        const h = a.options,\n          D = h.color,\n          u = d(h.zIndex, 0),\n          E = h.events,\n          e = {},\n          q = k.chart.renderer;\n        let y = h.label,\n          l = a.label,\n          w = h.to,\n          g = h.from,\n          b = h.value,\n          c = a.svgElem;\n        var f = [];\n        const x = F(g) && F(w);\n        f = F(b);\n        const J = !c,\n          z = {\n            \"class\": \"highcharts-plot-\" + (x ? \"band \" : \"line \") + (h.className || \"\")\n          };\n        let Q = x ? \"bands\" : \"lines\";\n        n && (g = n.log2lin(g), w = n.log2lin(w), b = n.log2lin(b));\n        k.chart.styledMode || (f ? (z.stroke = D || \"#999999\", z[\"stroke-width\"] = d(h.width, 1), h.dashStyle && (z.dashstyle = h.dashStyle)) : x && (z.fill = D || \"#e6e9ff\", h.borderWidth && (z.stroke = h.borderColor, z[\"stroke-width\"] = h.borderWidth)));\n        e.zIndex = u;\n        Q += \"-\" + u;\n        (n = k.plotLinesAndBandsGroups[Q]) || (k.plotLinesAndBandsGroups[Q] = n = q.g(\"plot-\" + Q).attr(e).add());\n        J && (a.svgElem = c = q.path().attr(z).add(n));\n        if (f) f = k.getPlotLinePath({\n          value: b,\n          lineWidth: c.strokeWidth(),\n          acrossPanes: h.acrossPanes\n        });else if (x) f = k.getPlotBandPath(g, w, h);else return;\n        !a.eventsAdded && E && (r(E, function (b, f) {\n          c.on(f, function (b) {\n            E[f].apply(a, [b]);\n          });\n        }), a.eventsAdded = !0);\n        (J || !c.d) && f && f.length ? c.attr({\n          d: f\n        }) : c && (f ? (c.show(), c.animate({\n          d: f\n        })) : c.d && (c.hide(), l && (a.label = l = l.destroy())));\n        y && (F(y.text) || F(y.formatter)) && f && f.length && 0 < k.width && 0 < k.height && !f.isFlat ? (y = t({\n          align: p && x && \"center\",\n          x: p ? !x && 4 : 10,\n          verticalAlign: !p && x && \"middle\",\n          y: p ? x ? 16 : 10 : x ? 6 : -4,\n          rotation: p && !x && 90\n        }, y), this.renderLabel(y, f, x, u)) : l && l.hide();\n        return a;\n      }\n      renderLabel(a, d, p, n) {\n        const h = this.axis;\n        var k = h.chart.renderer;\n        let m = this.label;\n        m || (this.label = m = k.text(this.getLabelText(a), 0, 0, a.useHTML).attr({\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (p ? \"band\" : \"line\") + \"-label \" + (a.className || \"\"),\n          zIndex: n\n        }).add(), h.chart.styledMode || m.css(t({\n          fontSize: \"0.8em\",\n          textOverflow: \"ellipsis\"\n        }, a.style)));\n        n = d.xBounds || [d[0][1], d[1][1], p ? d[2][1] : d[0][1]];\n        d = d.yBounds || [d[0][2], d[1][2], p ? d[2][2] : d[0][2]];\n        p = I(n);\n        k = I(d);\n        m.align(a, !1, {\n          x: p,\n          y: k,\n          width: u(n) - p,\n          height: u(d) - k\n        });\n        m.alignValue && \"left\" !== m.alignValue || (a = a.clip ? h.width : h.chart.chartWidth, m.css({\n          width: (90 === m.rotation ? h.height - (m.alignAttr.y - h.top) : a - (m.alignAttr.x - h.left)) + \"px\"\n        }));\n        m.show(!0);\n      }\n      getLabelText(a) {\n        return F(a.formatter) ? a.formatter.call(this) : a.text;\n      }\n      destroy() {\n        C(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        G(this);\n      }\n    }\n    \"\";\n    \"\";\n    return p;\n  });\n  M(a, \"Core/Tooltip.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F) {\n    const {\n        format: u\n      } = a,\n      {\n        doc: C,\n        isSafari: B\n      } = A,\n      {\n        distribute: t\n      } = H,\n      {\n        addEvent: r,\n        clamp: d,\n        css: p,\n        discardElement: m,\n        extend: k,\n        fireEvent: v,\n        isArray: n,\n        isNumber: h,\n        isString: D,\n        merge: L,\n        pick: E,\n        splat: e,\n        syncTimeout: q\n      } = F;\n    class y {\n      constructor(a, e) {\n        this.allowShared = !0;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = a;\n        this.init(a, e);\n      }\n      bodyFormatter(a) {\n        return a.map(function (a) {\n          const g = a.series.tooltipOptions;\n          return (g[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, g[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      }\n      cleanSplit(a) {\n        this.chart.series.forEach(function (l) {\n          const g = l && l.tt;\n          g && (!g.isActive || a ? l.tt = g.destroy() : g.isActive = !1);\n        });\n      }\n      defaultFormatter(a) {\n        const l = this.points || e(this);\n        let g;\n        g = [a.tooltipFooterHeaderFormatter(l[0])];\n        g = g.concat(a.bodyFormatter(l));\n        g.push(a.tooltipFooterHeaderFormatter(l[0], !0));\n        return g;\n      }\n      destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy()));\n        this.renderer && (this.renderer = this.renderer.destroy(), m(this.container));\n        F.clearTimeout(this.hideTimer);\n        F.clearTimeout(this.tooltipTimeout);\n      }\n      getAnchor(a, q) {\n        var g = this.chart;\n        const b = g.pointer,\n          c = g.inverted,\n          f = g.plotTop;\n        g = g.plotLeft;\n        a = e(a);\n        a[0].series && a[0].series.yAxis && !a[0].series.yAxis.options.reversedStacks && (a = a.slice().reverse());\n        if (this.followPointer && q) \"undefined\" === typeof q.chartX && (q = b.normalize(q)), a = [q.chartX - g, q.chartY - f];else if (a[0].tooltipPos) a = a[0].tooltipPos;else {\n          let b = 0,\n            e = 0;\n          a.forEach(function (c) {\n            if (c = c.pos(!0)) b += c[0], e += c[1];\n          });\n          b /= a.length;\n          e /= a.length;\n          this.shared && 1 < a.length && q && (c ? b = q.chartX : e = q.chartY);\n          a = [b - g, e - f];\n        }\n        return a.map(Math.round);\n      }\n      getClassName(a, e, g) {\n        const b = a.series,\n          c = b.options;\n        return [this.options.className, \"highcharts-label\", g && \"highcharts-tooltip-header\", e ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !g && \"highcharts-color-\" + E(a.colorIndex, b.colorIndex), c && c.className].filter(D).join(\" \");\n      }\n      getLabel() {\n        const a = this,\n          e = this.chart.styledMode,\n          g = this.options,\n          b = this.split && this.allowShared,\n          c = g.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\");\n        let f,\n          q = this.chart.renderer;\n        if (this.label) {\n          var d = !this.label.hasClass(\"highcharts-label\");\n          (!b && d || b && !d) && this.destroy();\n        }\n        if (!this.label) {\n          if (this.outside) {\n            d = this.chart.options.chart.style;\n            const b = I.getRendererType();\n            this.container = f = A.doc.createElement(\"div\");\n            f.className = \"highcharts-tooltip-container\";\n            p(f, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: c,\n              zIndex: Math.max(this.options.style.zIndex || 0, (d && d.zIndex || 0) + 3)\n            });\n            A.doc.body.appendChild(f);\n            this.renderer = q = new b(f, 0, 0, d, void 0, void 0, q.styledMode);\n          }\n          b ? this.label = q.g(\"tooltip\") : (this.label = q.label(\"\", 0, 0, g.shape, void 0, void 0, g.useHTML, void 0, \"tooltip\").attr({\n            padding: g.padding,\n            r: g.borderRadius\n          }), e || this.label.attr({\n            fill: g.backgroundColor,\n            \"stroke-width\": g.borderWidth || 0\n          }).css(g.style).css({\n            pointerEvents: c\n          }));\n          if (a.outside) {\n            const b = this.label,\n              {\n                xSetter: c,\n                ySetter: g\n              } = b;\n            b.xSetter = function (g) {\n              c.call(b, a.distance);\n              f.style.left = g + \"px\";\n            };\n            b.ySetter = function (c) {\n              g.call(b, a.distance);\n              f.style.top = c + \"px\";\n            };\n          }\n          this.label.attr({\n            zIndex: 8\n          }).shadow(g.shadow).add();\n        }\n        return this.label;\n      }\n      getPlayingField() {\n        const {\n            body: a,\n            documentElement: e\n          } = C,\n          {\n            chart: g,\n            distance: b,\n            outside: c\n          } = this;\n        return {\n          width: c ? Math.max(a.scrollWidth, e.scrollWidth, a.offsetWidth, e.offsetWidth, e.clientWidth) - 2 * b : g.chartWidth,\n          height: c ? Math.max(a.scrollHeight, e.scrollHeight, a.offsetHeight, e.offsetHeight, e.clientHeight) : g.chartHeight\n        };\n      }\n      getPosition(a, e, g) {\n        const b = this.chart,\n          c = this.distance,\n          f = {},\n          l = b.inverted && g.h || 0,\n          q = this.outside;\n        var d = this.getPlayingField();\n        const h = d.width,\n          k = d.height,\n          w = b.pointer.getChartPosition();\n        d = f => {\n          const l = \"x\" === f;\n          return [f, l ? h : k, l ? a : e].concat(q ? [l ? a * w.scaleX : e * w.scaleY, l ? w.left - c + (g.plotX + b.plotLeft) * w.scaleX : w.top - c + (g.plotY + b.plotTop) * w.scaleY, 0, l ? h : k] : [l ? a : e, l ? g.plotX + b.plotLeft : g.plotY + b.plotTop, l ? b.plotLeft : b.plotTop, l ? b.plotLeft + b.plotWidth : b.plotTop + b.plotHeight]);\n        };\n        let m = d(\"y\"),\n          n = d(\"x\"),\n          y;\n        d = !!g.negative;\n        !b.polar && b.hoverSeries && b.hoverSeries.yAxis && b.hoverSeries.yAxis.reversed && (d = !d);\n        const p = !this.followPointer && E(g.ttBelow, !b.inverted === d),\n          r = function (b, a, g, e, d, x, h) {\n            const k = q ? \"y\" === b ? c * w.scaleY : c * w.scaleX : c,\n              z = (g - e) / 2,\n              m = e < d - c,\n              n = d + c + e < a,\n              J = d - k - g + z;\n            d = d + k - z;\n            if (p && n) f[b] = d;else if (!p && m) f[b] = J;else if (m) f[b] = Math.min(h - e, 0 > J - l ? J : J - l);else if (n) f[b] = Math.max(x, d + l + g > a ? d : d + l);else return !1;\n          },\n          K = function (b, a, g, e, l) {\n            let d;\n            l < c || l > a - c ? d = !1 : f[b] = l < g / 2 ? 1 : l > a - e / 2 ? a - e - 2 : l - g / 2;\n            return d;\n          },\n          v = function (b) {\n            const c = m;\n            m = n;\n            n = c;\n            y = b;\n          },\n          P = function () {\n            !1 !== r.apply(0, m) ? !1 !== K.apply(0, n) || y || (v(!0), P()) : y ? f.x = f.y = 0 : (v(!0), P());\n          };\n        (b.inverted || 1 < this.len) && v();\n        P();\n        return f;\n      }\n      hide(a) {\n        const e = this;\n        F.clearTimeout(this.hideTimer);\n        a = E(a, this.options.hideDelay);\n        this.isHidden || (this.hideTimer = q(function () {\n          e.getLabel().fadeOut(a ? void 0 : a);\n          e.isHidden = !0;\n        }, a));\n      }\n      init(a, e) {\n        this.chart = a;\n        this.options = e;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = e.split && !a.inverted && !a.polar;\n        this.shared = e.shared || this.split;\n        this.outside = E(e.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n      }\n      shouldStickOnContact(a) {\n        return !(this.followPointer || !this.options.stickOnContact || a && !this.chart.pointer.inClass(a.target, \"highcharts-tooltip\"));\n      }\n      move(a, e, g, b) {\n        const c = this,\n          f = c.now,\n          l = !1 !== c.options.animation && !c.isHidden && (1 < Math.abs(a - f.x) || 1 < Math.abs(e - f.y)),\n          d = c.followPointer || 1 < c.len;\n        k(f, {\n          x: l ? (2 * f.x + a) / 3 : a,\n          y: l ? (f.y + e) / 2 : e,\n          anchorX: d ? void 0 : l ? (2 * f.anchorX + g) / 3 : g,\n          anchorY: d ? void 0 : l ? (f.anchorY + b) / 2 : b\n        });\n        c.getLabel().attr(f);\n        c.drawTracker();\n        l && (F.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          c && c.move(a, e, g, b);\n        }, 32));\n      }\n      refresh(a, d) {\n        const g = this.chart,\n          b = this.options,\n          c = g.pointer,\n          f = e(a),\n          l = f[0],\n          q = [];\n        var h = b.formatter || this.defaultFormatter,\n          k = this.shared;\n        const w = g.styledMode;\n        let m = {};\n        if (b.enabled && l.series) {\n          F.clearTimeout(this.hideTimer);\n          this.allowShared = !(!n(a) && a.series && a.series.noSharedTooltip);\n          this.followPointer = !this.split && l.series.tooltipOptions.followPointer;\n          a = this.getAnchor(a, d);\n          var y = a[0],\n            p = a[1];\n          k && this.allowShared ? (c.applyInactiveState(f), f.forEach(function (b) {\n            b.setState(\"hover\");\n            q.push(b.getLabelConfig());\n          }), m = {\n            x: l.category,\n            y: l.y\n          }, m.points = q) : m = l.getLabelConfig();\n          this.len = q.length;\n          h = h.call(m, this);\n          k = l.series;\n          this.distance = E(k.tooltipOptions.distance, 16);\n          if (!1 === h) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(h, f);else {\n              let e = y,\n                q = p;\n              d && c.isDirectTouch && (e = d.chartX - g.plotLeft, q = d.chartY - g.plotTop);\n              if (g.polar || !1 === k.options.clip || f.some(b => c.isDirectTouch || b.series.shouldShowTooltip(e, q))) d = this.getLabel(), b.style.width && !w || d.css({\n                width: (this.outside ? this.getPlayingField() : g.spacingBox).width + \"px\"\n              }), d.attr({\n                text: h && h.join ? h.join(\"\") : h\n              }), d.addClass(this.getClassName(l), !0), w || d.attr({\n                stroke: b.borderColor || l.color || k.color || \"#666666\"\n              }), this.updatePosition({\n                plotX: y,\n                plotY: p,\n                negative: l.negative,\n                ttBelow: l.ttBelow,\n                h: a[2] || 0\n              });else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show();\n            this.isHidden = !1;\n          }\n          v(this, \"refresh\");\n        }\n      }\n      renderSplit(a, e) {\n        function g(c, a, f, g, e = !0) {\n          f ? (a = X ? 0 : H, c = d(c - g / 2, P.left, P.right - g - (b.outside ? U : 0))) : (a -= F, c = e ? c - g - u : c + u, c = d(c, e ? c : P.left, P.right));\n          return {\n            x: c,\n            y: a\n          };\n        }\n        const b = this,\n          {\n            chart: c,\n            chart: {\n              chartWidth: f,\n              chartHeight: l,\n              plotHeight: q,\n              plotLeft: h,\n              plotTop: m,\n              pointer: w,\n              scrollablePixelsY: n = 0,\n              scrollablePixelsX: y,\n              scrollingContainer: {\n                scrollLeft: p,\n                scrollTop: r\n              } = {\n                scrollLeft: 0,\n                scrollTop: 0\n              },\n              styledMode: v\n            },\n            distance: u,\n            options: K,\n            options: {\n              positioner: Y\n            }\n          } = b,\n          P = b.outside && \"number\" !== typeof y ? C.documentElement.getBoundingClientRect() : {\n            left: p,\n            right: p + f,\n            top: r,\n            bottom: r + l\n          },\n          L = b.getLabel(),\n          T = this.renderer || c.renderer,\n          X = !(!c.xAxis[0] || !c.xAxis[0].opposite),\n          {\n            left: U,\n            top: A\n          } = w.getChartPosition();\n        let F = m + r,\n          G = 0,\n          H = q - n;\n        D(a) && (a = [!1, a]);\n        a = a.slice(0, e.length + 1).reduce(function (c, a, f) {\n          if (!1 !== a && \"\" !== a) {\n            f = e[f - 1] || {\n              isHeader: !0,\n              plotX: e[0].plotX,\n              plotY: q,\n              series: {}\n            };\n            const n = f.isHeader;\n            var l = n ? b : f.series,\n              x;\n            {\n              var k = f;\n              a = a.toString();\n              var w = l.tt;\n              const {\n                isHeader: c,\n                series: g\n              } = k;\n              w || (w = {\n                padding: K.padding,\n                r: K.borderRadius\n              }, v || (w.fill = K.backgroundColor, w[\"stroke-width\"] = null !== (x = K.borderWidth) && void 0 !== x ? x : 1), w = T.label(\"\", 0, 0, K[c ? \"headerShape\" : \"shape\"], void 0, void 0, K.useHTML).addClass(b.getClassName(k, !0, c)).attr(w).add(L));\n              w.isActive = !0;\n              w.attr({\n                text: a\n              });\n              v || w.css(K.style).attr({\n                stroke: K.borderColor || k.color || g.color || \"#333333\"\n              });\n              x = w;\n            }\n            x = l.tt = x;\n            k = x.getBBox();\n            l = k.width + x.strokeWidth();\n            n && (G = k.height, H += G, X && (F -= G));\n            {\n              const {\n                isHeader: b,\n                plotX: c = 0,\n                plotY: g = 0,\n                series: e\n              } = f;\n              if (b) {\n                a = h + c;\n                var z = m + q / 2;\n              } else {\n                const {\n                  xAxis: b,\n                  yAxis: f\n                } = e;\n                a = b.pos + d(c, -u, b.len + u);\n                e.shouldShowTooltip(0, f.pos - m + g, {\n                  ignoreX: !0\n                }) && (z = f.pos + g);\n              }\n              a = d(a, P.left - u, P.right + u);\n              z = {\n                anchorX: a,\n                anchorY: z\n              };\n            }\n            const {\n              anchorX: J,\n              anchorY: y\n            } = z;\n            \"number\" === typeof y ? (z = k.height + 1, k = Y ? Y.call(b, l, z, f) : g(J, y, n, l), c.push({\n              align: Y ? 0 : void 0,\n              anchorX: J,\n              anchorY: y,\n              boxWidth: l,\n              point: f,\n              rank: E(k.rank, n ? 1 : 0),\n              size: z,\n              target: k.y,\n              tt: x,\n              x: k.x\n            })) : x.isActive = !1;\n          }\n          return c;\n        }, []);\n        !Y && a.some(c => {\n          var {\n            outside: a\n          } = b;\n          a = (a ? U : 0) + c.anchorX;\n          return a < P.left && a + c.boxWidth < P.right ? !0 : a < U - P.left + c.boxWidth && P.right - a > a;\n        }) && (a = a.map(b => {\n          const {\n            x: c,\n            y: a\n          } = g(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);\n          return k(b, {\n            target: a,\n            x: c\n          });\n        }));\n        b.cleanSplit();\n        t(a, H);\n        var I = U,\n          ha = U;\n        a.forEach(function (c) {\n          const {\n            x: a,\n            boxWidth: f,\n            isHeader: g\n          } = c;\n          g || (b.outside && U + a < I && (I = U + a), !g && b.outside && I + f > ha && (ha = U + a));\n        });\n        a.forEach(function (c) {\n          const {\n              x: a,\n              anchorX: f,\n              anchorY: g,\n              pos: e,\n              point: {\n                isHeader: l\n              }\n            } = c,\n            d = {\n              visibility: \"undefined\" === typeof e ? \"hidden\" : \"inherit\",\n              x: a,\n              y: (e || 0) + F,\n              anchorX: f,\n              anchorY: g\n            };\n          if (b.outside && a < f) {\n            const b = U - I;\n            0 < b && (l || (d.x = a + b, d.anchorX = f + b), l && (d.x = (ha - I) / 2, d.anchorX = f + b));\n          }\n          c.tt.attr(d);\n        });\n        const {\n          container: ia,\n          outside: ka,\n          renderer: ja\n        } = b;\n        if (ka && ia && ja) {\n          const {\n            width: b,\n            height: c,\n            x: a,\n            y: f\n          } = L.getBBox();\n          ja.setSize(b + a, c + f, !1);\n          ia.style.left = I + \"px\";\n          ia.style.top = A + \"px\";\n        }\n        B && L.attr({\n          opacity: 1 === L.opacity ? .999 : 1\n        });\n      }\n      drawTracker() {\n        if (this.shouldStickOnContact()) {\n          var a = this.chart,\n            e = this.label,\n            g = this.shared ? a.hoverPoints : a.hoverPoint;\n          if (e && g) {\n            var b = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            g = this.getAnchor(g);\n            var c = e.getBBox();\n            g[0] += a.plotLeft - e.translateX;\n            g[1] += a.plotTop - e.translateY;\n            b.x = Math.min(0, g[0]);\n            b.y = Math.min(0, g[1]);\n            b.width = 0 > g[0] ? Math.max(Math.abs(g[0]), c.width - g[0]) : Math.max(Math.abs(g[0]), c.width);\n            b.height = 0 > g[1] ? Math.max(Math.abs(g[1]), c.height - Math.abs(g[1])) : Math.max(Math.abs(g[1]), c.height);\n            this.tracker ? this.tracker.attr(b) : (this.tracker = e.renderer.rect(b).addClass(\"highcharts-tracker\").add(e), a.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        } else this.tracker && (this.tracker = this.tracker.destroy());\n      }\n      styledModeFormat(a) {\n        return a.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n      }\n      tooltipFooterHeaderFormatter(a, e) {\n        const g = a.series,\n          b = g.tooltipOptions;\n        var c = g.xAxis;\n        const f = c && c.dateTime;\n        c = {\n          isFooter: e,\n          labelConfig: a\n        };\n        let l = b.xDateFormat,\n          d = b[e ? \"footerFormat\" : \"headerFormat\"];\n        v(this, \"headerFormatter\", c, function (c) {\n          f && !l && h(a.key) && (l = f.getXDateFormat(a.key, b.dateTimeLabelFormats));\n          f && l && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (b) {\n            d = d.replace(\"{point.\" + b + \"}\", \"{point.\" + b + \":\" + l + \"}\");\n          });\n          g.chart.styledMode && (d = this.styledModeFormat(d));\n          c.text = u(d, {\n            point: a,\n            series: g\n          }, this.chart);\n        });\n        return c.text;\n      }\n      update(a) {\n        this.destroy();\n        L(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, L(!0, this.options, a));\n      }\n      updatePosition(a) {\n        const {\n          chart: e,\n          distance: g,\n          options: b\n        } = this;\n        var c = e.pointer;\n        const f = this.getLabel(),\n          {\n            left: l,\n            top: d,\n            scaleX: q,\n            scaleY: h\n          } = c.getChartPosition();\n        c = (b.positioner || this.getPosition).call(this, f.width, f.height, a);\n        let k = (a.plotX || 0) + e.plotLeft;\n        a = (a.plotY || 0) + e.plotTop;\n        let m;\n        if (this.outside) {\n          b.positioner && (c.x += l - g, c.y += d - g);\n          m = (b.borderWidth || 0) + 2 * g;\n          this.renderer.setSize(f.width + m, f.height + m, !1);\n          if (1 !== q || 1 !== h) p(this.container, {\n            transform: `scale(${q}, ${h})`\n          }), k *= q, a *= h;\n          k += l - c.x;\n          a += d - c.y;\n        }\n        this.move(Math.round(c.x), Math.round(c.y || 0), k, a);\n      }\n    }\n    (function (a) {\n      const e = [];\n      a.compose = function (g) {\n        F.pushUnique(e, g) && r(g, \"afterInit\", function () {\n          const b = this.chart;\n          b.options.tooltip && (b.tooltip = new a(b, b.options.tooltip));\n        });\n      };\n    })(y || (y = {}));\n    \"\";\n    return y;\n  });\n  M(a, \"Core/Series/Point.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F) {\n    const {\n        animObject: u\n      } = A,\n      {\n        defaultOptions: C\n      } = H,\n      {\n        format: B\n      } = I,\n      {\n        addEvent: t,\n        defined: r,\n        erase: d,\n        extend: p,\n        fireEvent: m,\n        getNestedProperty: k,\n        isArray: v,\n        isFunction: n,\n        isNumber: h,\n        isObject: D,\n        merge: L,\n        objectEach: E,\n        pick: e,\n        syncTimeout: q,\n        removeEvent: y,\n        uniqueKey: l\n      } = F;\n    class w {\n      constructor() {\n        this.category = void 0;\n        this.destroyed = !1;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.shapeArgs = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n      animateBeforeDestroy() {\n        const a = this,\n          b = {\n            x: a.startXPos,\n            opacity: 0\n          },\n          c = a.getGraphicalProps();\n        c.singular.forEach(function (c) {\n          a[c] = a[c].animate(\"dataLabel\" === c ? {\n            x: a[c].startXPos,\n            y: a[c].startYPos,\n            opacity: 0\n          } : b);\n        });\n        c.plural.forEach(function (b) {\n          a[b].forEach(function (b) {\n            b.element && b.animate(p({\n              x: a.startXPos\n            }, b.startYPos ? {\n              x: b.startXPos,\n              y: b.startYPos\n            } : {}));\n          });\n        });\n      }\n      applyOptions(a, b) {\n        const c = this.series,\n          f = c.options.pointValKey || c.pointValKey;\n        a = w.prototype.optionsToObject.call(this, a);\n        p(this, a);\n        this.options = this.options ? p(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        f && (this.y = w.prototype.getNestedProperty.call(this, f));\n        this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof b && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && c ? this.x = \"undefined\" === typeof b ? c.autoIncrement() : b : h(a.x) && c.options.relativeXValue && (this.x = c.autoIncrement(a.x));\n        return this;\n      }\n      destroy() {\n        if (!this.destroyed) {\n          const b = this;\n          var a = b.series;\n          const c = a.chart;\n          a = a.options.dataSorting;\n          const f = c.hoverPoints,\n            g = u(b.series.chart.renderer.globalAnimation),\n            e = () => {\n              if (b.graphic || b.graphics || b.dataLabel || b.dataLabels) y(b), b.destroyElements();\n              for (const c in b) delete b[c];\n            };\n          b.legendItem && c.legend.destroyItem(b);\n          f && (b.setState(), d(f, b), f.length || (c.hoverPoints = null));\n          if (b === c.hoverPoint) b.onMouseOut();\n          a && a.enabled ? (this.animateBeforeDestroy(), q(e, g.duration)) : e();\n          c.pointCount--;\n        }\n        this.destroyed = !0;\n      }\n      destroyElements(a) {\n        const b = this;\n        a = b.getGraphicalProps(a);\n        a.singular.forEach(function (c) {\n          b[c] = b[c].destroy();\n        });\n        a.plural.forEach(function (c) {\n          b[c].forEach(function (b) {\n            b && b.element && b.destroy();\n          });\n          delete b[c];\n        });\n      }\n      firePointEvent(a, b, c) {\n        const f = this,\n          g = this.series.options;\n        (g.point.events[a] || f.options && f.options.events && f.options.events[a]) && f.importEvents();\n        \"click\" === a && g.allowPointSelect && (c = function (b) {\n          f.select && f.select(null, b.ctrlKey || b.metaKey || b.shiftKey);\n        });\n        m(f, a, b, c);\n      }\n      getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      }\n      getGraphicalProps(a) {\n        const b = this,\n          c = [],\n          f = {\n            singular: [],\n            plural: []\n          };\n        let g, e;\n        a = a || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        a.graphic && c.push(\"graphic\");\n        a.dataLabel && c.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\", \"connector\");\n        for (e = c.length; e--;) g = c[e], b[g] && f.singular.push(g);\n        [\"graphic\", \"dataLabel\", \"connector\"].forEach(function (c) {\n          const g = c + \"s\";\n          a[c] && b[g] && f.plural.push(g);\n        });\n        return f;\n      }\n      getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      }\n      getNestedProperty(a) {\n        if (a) return 0 === a.indexOf(\"custom.\") ? k(a, this.options) : this[a];\n      }\n      getZone() {\n        var a = this.series;\n        const b = a.zones;\n        a = a.zoneAxis || \"y\";\n        let c,\n          f = 0;\n        for (c = b[f]; this[a] >= c.value;) c = b[++f];\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;\n        return c;\n      }\n      hasNewShapeType() {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      }\n      init(a, b, c) {\n        this.series = a;\n        this.applyOptions(b, c);\n        this.id = r(this.id) ? this.id : l();\n        this.resolveColor();\n        a.chart.pointCount++;\n        m(this, \"afterInit\");\n        return this;\n      }\n      isValid() {\n        return null !== this.x && h(this.y);\n      }\n      optionsToObject(a) {\n        var b = this.series;\n        const c = b.options.keys,\n          f = c || b.pointArrayMap || [\"y\"],\n          g = f.length;\n        let e = {},\n          l = 0,\n          d = 0;\n        if (h(a) || null === a) e[f[0]] = a;else if (v(a)) for (!c && a.length > g && (b = typeof a[0], \"string\" === b ? e.name = a[0] : \"number\" === b && (e.x = a[0]), l++); d < g;) c && \"undefined\" === typeof a[l] || (0 < f[d].indexOf(\".\") ? w.prototype.setNestedProperty(e, a[l], f[d]) : e[f[d]] = a[l]), l++, d++;else \"object\" === typeof a && (e = a, a.dataLabels && (b._hasPointLabels = !0), a.marker && (b._hasPointMarkers = !0));\n        return e;\n      }\n      pos(a, b = this.plotY) {\n        if (!this.destroyed) {\n          const {\n              plotX: c,\n              series: f\n            } = this,\n            {\n              chart: g,\n              xAxis: e,\n              yAxis: l\n            } = f;\n          let d = 0,\n            q = 0;\n          if (h(c) && h(b)) return a && (d = e ? e.pos : g.plotLeft, q = l ? l.pos : g.plotTop), g.inverted && e && l ? [l.len - b + q, e.len - c + d] : [c + d, b + q];\n        }\n      }\n      resolveColor() {\n        const a = this.series;\n        var b = a.chart.styledMode;\n        let c;\n        var f = a.chart.options.chart.colorCount;\n        delete this.nonZonedColor;\n        a.options.colorByPoint ? (b || (f = a.options.colors || a.chart.options.colors, c = f[a.colorCounter], f = f.length), b = a.colorCounter, a.colorCounter++, a.colorCounter === f && (a.colorCounter = 0)) : (b || (c = a.color), b = a.colorIndex);\n        this.colorIndex = e(this.options.colorIndex, b);\n        this.color = e(this.options.color, c);\n      }\n      setNestedProperty(a, b, c) {\n        c.split(\".\").reduce(function (c, a, g, e) {\n          c[a] = e.length - 1 === g ? b : D(c[a], !0) ? c[a] : {};\n          return c[a];\n        }, a);\n        return a;\n      }\n      shouldDraw() {\n        return !this.isNull;\n      }\n      tooltipFormatter(a) {\n        const b = this.series,\n          c = b.tooltipOptions,\n          f = e(c.valueDecimals, \"\"),\n          g = c.valuePrefix || \"\",\n          l = c.valueSuffix || \"\";\n        b.chart.styledMode && (a = b.chart.tooltip.styledModeFormat(a));\n        (b.pointArrayMap || [\"y\"]).forEach(function (b) {\n          b = \"{point.\" + b;\n          if (g || l) a = a.replace(RegExp(b + \"}\", \"g\"), g + b + \"}\" + l);\n          a = a.replace(RegExp(b + \"}\", \"g\"), b + \":,.\" + f + \"f}\");\n        });\n        return B(a, {\n          point: this,\n          series: this.series\n        }, b.chart);\n      }\n      update(a, b, c, f) {\n        function g() {\n          l.applyOptions(a);\n          var f = q && l.hasMockGraphic;\n          f = null === l.y ? !f : f;\n          q && f && (l.graphic = q.destroy(), delete l.hasMockGraphic);\n          D(a, !0) && (q && q.element && a && a.marker && \"undefined\" !== typeof a.marker.symbol && (l.graphic = q.destroy()), a && a.dataLabels && l.dataLabel && (l.dataLabel = l.dataLabel.destroy()), l.connector && (l.connector = l.connector.destroy()));\n          m = l.index;\n          d.updateParallelArrays(l, m);\n          k.data[m] = D(k.data[m], !0) || D(a, !0) ? l.options : e(a, k.data[m]);\n          d.isDirty = d.isDirtyData = !0;\n          !d.fixedBox && d.hasCartesianSeries && (h.isDirtyBox = !0);\n          \"point\" === k.legendType && (h.isDirtyLegend = !0);\n          b && h.redraw(c);\n        }\n        const l = this,\n          d = l.series,\n          q = l.graphic,\n          h = d.chart,\n          k = d.options;\n        let m;\n        b = e(b, !0);\n        !1 === f ? g() : l.firePointEvent(\"update\", {\n          options: a\n        }, g);\n      }\n      remove(a, b) {\n        this.series.removePoint(this.series.data.indexOf(this), a, b);\n      }\n      select(a, b) {\n        const c = this,\n          f = c.series,\n          g = f.chart;\n        this.selectedStaging = a = e(a, !c.selected);\n        c.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          c.selected = c.options.selected = a;\n          f.options.data[f.data.indexOf(c)] = c.options;\n          c.setState(a && \"select\");\n          b || g.getSelectedPoints().forEach(function (b) {\n            const a = b.series;\n            b.selected && b !== c && (b.selected = b.options.selected = !1, a.options.data[a.data.indexOf(b)] = b.options, b.setState(g.hoverPoints && a.options.inactiveOtherPoints ? \"inactive\" : \"\"), b.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      }\n      onMouseOver(a) {\n        const b = this.series.chart,\n          c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      }\n      onMouseOut() {\n        const a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (b) {\n          b.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      }\n      importEvents() {\n        if (!this.hasImportedEvents) {\n          const a = this,\n            b = L(a.series.options.point, a.options).events;\n          a.events = b;\n          E(b, function (b, f) {\n            n(b) && t(a, f, b);\n          });\n          this.hasImportedEvents = !0;\n        }\n      }\n      setState(g, b) {\n        const c = this.series;\n        var f = this.state,\n          l = c.options.states[g || \"normal\"] || {},\n          d = C.plotOptions[c.type].marker && c.options.marker;\n        const q = d && !1 === d.enabled,\n          k = d && d.states && d.states[g || \"normal\"] || {},\n          n = !1 === k.enabled,\n          w = this.marker || {},\n          y = c.chart,\n          r = d && c.markerAttribs;\n        let v = c.halo;\n        var D;\n        let t;\n        var K = c.stateMarkerGraphic;\n        g = g || \"\";\n        if (!(g === this.state && !b || this.selected && \"select\" !== g || !1 === l.enabled || g && (n || q && !1 === k.enabled) || g && w.states && w.states[g] && !1 === w.states[g].enabled)) {\n          this.state = g;\n          r && (D = c.markerAttribs(this, g));\n          if (this.graphic && !this.hasMockGraphic) {\n            f && this.graphic.removeClass(\"highcharts-point-\" + f);\n            g && this.graphic.addClass(\"highcharts-point-\" + g);\n            if (!y.styledMode) {\n              f = c.pointAttribs(this, g);\n              t = e(y.options.chart.animation, l.animation);\n              const b = f.opacity;\n              c.options.inactiveOtherPoints && h(b) && ((this.dataLabels || []).forEach(function (c) {\n                c && !c.hasClass(\"highcharts-data-label-hidden\") && c.animate({\n                  opacity: b\n                }, t);\n              }), this.connector && this.connector.animate({\n                opacity: b\n              }, t));\n              this.graphic.animate(f, t);\n            }\n            D && this.graphic.animate(D, e(y.options.chart.animation, k.animation, d.animation));\n            K && K.hide();\n          } else {\n            if (g && k) {\n              d = w.symbol || c.symbol;\n              K && K.currentSymbol !== d && (K = K.destroy());\n              if (D) if (K) K[b ? \"animate\" : \"attr\"]({\n                x: D.x,\n                y: D.y\n              });else d && (c.stateMarkerGraphic = K = y.renderer.symbol(d, D.x, D.y, D.width, D.height).add(c.markerGroup), K.currentSymbol = d);\n              !y.styledMode && K && \"inactive\" !== this.state && K.attr(c.pointAttribs(this, g));\n            }\n            K && (K[g && this.isInside ? \"show\" : \"hide\"](), K.element.point = this, K.addClass(this.getClassName(), !0));\n          }\n          l = l.halo;\n          D = (K = this.graphic || K) && K.visibility || \"inherit\";\n          l && l.size && K && \"hidden\" !== D && !this.isCluster ? (v || (c.halo = v = y.renderer.path().add(K.parentGroup)), v.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(l.size)\n          }), v.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + e(this.colorIndex, c.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: D,\n            zIndex: -1\n          }), v.point = this, y.styledMode || v.attr(p({\n            fill: this.color || c.color,\n            \"fill-opacity\": l.opacity\n          }, a.filterUserAttributes(l.attributes || {})))) : v && v.point && v.point.haloPath && v.animate({\n            d: v.point.haloPath(0)\n          }, null, v.hide);\n          m(this, \"afterSetState\", {\n            state: g\n          });\n        }\n      }\n      haloPath(a) {\n        const b = this.pos();\n        return b ? this.series.chart.renderer.symbols.circle(Math.floor(b[0]) - a, b[1] - a, 2 * a, 2 * a) : [];\n      }\n    }\n    \"\";\n    return w;\n  });\n  M(a, \"Core/Pointer.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        parse: u\n      } = a,\n      {\n        charts: F,\n        noop: G\n      } = A,\n      {\n        addEvent: C,\n        attr: B,\n        css: t,\n        defined: r,\n        extend: d,\n        find: p,\n        fireEvent: m,\n        isNumber: k,\n        isObject: v,\n        objectEach: n,\n        offset: h,\n        pick: D,\n        splat: L\n      } = H;\n    class E {\n      constructor(a, d) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.eventsToUnbind = [];\n        this.chart = a;\n        this.hasDragged = !1;\n        this.options = d;\n        this.init(a, d);\n      }\n      applyInactiveState(a) {\n        let e = [],\n          d;\n        (a || []).forEach(function (a) {\n          d = a.series;\n          e.push(d);\n          d.linkedParent && e.push(d.linkedParent);\n          d.linkedSeries && (e = e.concat(d.linkedSeries));\n          d.navigatorSeries && e.push(d.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === e.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      }\n      destroy() {\n        const a = this;\n        this.eventsToUnbind.forEach(a => a());\n        this.eventsToUnbind = [];\n        A.chartCount || (E.unbindDocumentMouseUp && (E.unbindDocumentMouseUp = E.unbindDocumentMouseUp()), E.unbindDocumentTouchEnd && (E.unbindDocumentTouchEnd = E.unbindDocumentTouchEnd()));\n        clearInterval(a.tooltipTimeout);\n        n(a, function (e, d) {\n          a[d] = void 0;\n        });\n      }\n      getSelectionMarkerAttrs(a, d) {\n        const e = {\n          args: {\n            chartX: a,\n            chartY: d\n          },\n          attrs: {},\n          shapeType: \"rect\"\n        };\n        m(this, \"getSelectionMarkerAttrs\", e, e => {\n          const {\n            chart: l,\n            mouseDownX: g = 0,\n            mouseDownY: b = 0,\n            zoomHor: c,\n            zoomVert: f\n          } = this;\n          e = e.attrs;\n          let q;\n          e.x = l.plotLeft;\n          e.y = l.plotTop;\n          e.width = c ? 1 : l.plotWidth;\n          e.height = f ? 1 : l.plotHeight;\n          c && (q = a - g, e.width = Math.abs(q), e.x = (0 < q ? 0 : q) + g);\n          f && (q = d - b, e.height = Math.abs(q), e.y = (0 < q ? 0 : q) + b);\n        });\n        return e;\n      }\n      drag(a) {\n        const e = this.chart,\n          d = e.options.chart;\n        var l = e.plotLeft;\n        const h = e.plotTop,\n          g = e.plotWidth,\n          b = e.plotHeight,\n          c = this.mouseDownX || 0,\n          f = this.mouseDownY || 0,\n          x = v(d.panning) ? d.panning && d.panning.enabled : d.panning,\n          k = d.panKey && a[d.panKey + \"Key\"];\n        let m = a.chartX,\n          n = a.chartY,\n          p = this.selectionMarker;\n        if (!p || !p.touch) if (m < l ? m = l : m > l + g && (m = l + g), n < h ? n = h : n > h + b && (n = h + b), this.hasDragged = Math.sqrt(Math.pow(c - m, 2) + Math.pow(f - n, 2)), 10 < this.hasDragged) {\n          l = e.isInsidePlot(c - l, f - h, {\n            visiblePlotOnly: !0\n          });\n          const {\n            shapeType: b,\n            attrs: g\n          } = this.getSelectionMarkerAttrs(m, n);\n          !e.hasCartesianSeries && !e.mapView || !this.zoomX && !this.zoomY || !l || k || p || (this.selectionMarker = p = e.renderer[b](), p.attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), e.styledMode || p.attr({\n            fill: d.selectionMarkerFill || u(\"#334eff\").setOpacity(.25).get()\n          }));\n          p && p.attr(g);\n          l && !p && x && e.pan(a, d.panning);\n        }\n      }\n      dragStart(a) {\n        const e = this.chart;\n        e.mouseIsDown = a.type;\n        e.cancelClick = !1;\n        e.mouseDownX = this.mouseDownX = a.chartX;\n        e.mouseDownY = this.mouseDownY = a.chartY;\n      }\n      getSelectionBox(a) {\n        const e = {\n          args: {\n            marker: a\n          },\n          result: {}\n        };\n        m(this, \"getSelectionBox\", e, e => {\n          e.result = {\n            x: a.attr ? +a.attr(\"x\") : a.x,\n            y: a.attr ? +a.attr(\"y\") : a.y,\n            width: a.attr ? a.attr(\"width\") : a.width,\n            height: a.attr ? a.attr(\"height\") : a.height\n          };\n        });\n        return e.result;\n      }\n      drop(a) {\n        const e = this,\n          h = this.chart,\n          l = this.hasPinched;\n        if (this.selectionMarker) {\n          const {\n              x: q,\n              y: g,\n              width: b,\n              height: c\n            } = this.getSelectionBox(this.selectionMarker),\n            f = {\n              originalEvent: a,\n              xAxis: [],\n              yAxis: [],\n              x: q,\n              y: g,\n              width: b,\n              height: c\n            };\n          let x = !!h.mapView;\n          if (this.hasDragged || l) h.axes.forEach(function (d) {\n            if (d.zoomEnabled && r(d.min) && (l || e[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[d.coll]]) && k(q) && k(g) && k(b) && k(c)) {\n              var h = d.horiz;\n              const e = \"touchend\" === a.type ? d.minPixelPadding : 0,\n                l = d.toValue((h ? q : g) + e);\n              h = d.toValue((h ? q + b : g + c) - e);\n              f[d.coll].push({\n                axis: d,\n                min: Math.min(l, h),\n                max: Math.max(l, h)\n              });\n              x = !0;\n            }\n          }), x && m(h, \"selection\", f, function (b) {\n            h.zoom(d(b, l ? {\n              animation: !1\n            } : null));\n          });\n          k(h.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          l && this.scaleGroups();\n        }\n        h && k(h.index) && (t(h.container, {\n          cursor: h._cursor\n        }), h.cancelClick = 10 < this.hasDragged, h.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      }\n      findNearestKDPoint(a, d, h) {\n        let e;\n        a.forEach(function (a) {\n          var g = !(a.noSharedTooltip && d) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(h, g);\n          if ((g = v(a, !0) && a.series) && !(g = !v(e, !0))) {\n            {\n              g = e.distX - a.distX;\n              const b = e.dist - a.dist,\n                c = (a.series.group && a.series.group.zIndex) - (e.series.group && e.series.group.zIndex);\n              g = 0 !== g && d ? g : 0 !== b ? b : 0 !== c ? c : e.series.index > a.series.index ? -1 : 1;\n            }\n            g = 0 < g;\n          }\n          g && (e = a);\n        });\n        return e;\n      }\n      getChartCoordinatesFromPoint(a, d) {\n        var e = a.series;\n        const l = e.xAxis;\n        e = e.yAxis;\n        const q = a.shapeArgs;\n        if (l && e) {\n          let g = D(a.clientX, a.plotX),\n            b = a.plotY || 0;\n          a.isNode && q && k(q.x) && k(q.y) && (g = q.x, b = q.y);\n          return d ? {\n            chartX: e.len + e.pos - b,\n            chartY: l.len + l.pos - g\n          } : {\n            chartX: g + l.pos,\n            chartY: b + e.pos\n          };\n        }\n        if (q && q.x && q.y) return {\n          chartX: q.x,\n          chartY: q.y\n        };\n      }\n      getChartPosition() {\n        if (this.chartPosition) return this.chartPosition;\n        var {\n          container: a\n        } = this.chart;\n        const d = h(a);\n        this.chartPosition = {\n          left: d.left,\n          top: d.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        const k = a.offsetWidth;\n        a = a.offsetHeight;\n        2 < k && 2 < a && (this.chartPosition.scaleX = d.width / k, this.chartPosition.scaleY = d.height / a);\n        return this.chartPosition;\n      }\n      getCoordinates(a) {\n        const e = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (d) {\n          e[d.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: d,\n            value: d.toValue(a[d.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return e;\n      }\n      getHoverData(a, d, h, l, k, g) {\n        const b = [];\n        l = !(!l || !a);\n        const c = function (b) {\n          return b.visible && !(!k && b.directTouch) && D(b.options.enableMouseTracking, !0);\n        };\n        let f,\n          e = {\n            chartX: g ? g.chartX : void 0,\n            chartY: g ? g.chartY : void 0,\n            shared: k\n          };\n        m(this, \"beforeGetHoverData\", e);\n        f = d && !d.stickyTracking ? [d] : h.filter(b => b.stickyTracking && (e.filter || c)(b));\n        const q = l || !g ? a : this.findNearestKDPoint(f, k, g);\n        d = q && q.series;\n        q && (k && !d.noSharedTooltip ? (f = h.filter(function (b) {\n          return e.filter ? e.filter(b) : c(b) && !b.noSharedTooltip;\n        }), f.forEach(function (c) {\n          let a = p(c.points, function (b) {\n            return b.x === q.x && !b.isNull;\n          });\n          v(a) && (c.boosted && c.boost && (a = c.boost.getPoint(a)), b.push(a));\n        })) : b.push(q));\n        e = {\n          hoverPoint: q\n        };\n        m(this, \"afterGetHoverData\", e);\n        return {\n          hoverPoint: e.hoverPoint,\n          hoverSeries: d,\n          hoverPoints: b\n        };\n      }\n      getPointFromEvent(a) {\n        a = a.target;\n        let e;\n        for (; a && !e;) e = a.point, a = a.parentNode;\n        return e;\n      }\n      onTrackerMouseOut(a) {\n        a = a.relatedTarget;\n        const e = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!e || !a || e.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + e.index) && this.inClass(a, \"highcharts-tracker\"))) e.onMouseOut();\n      }\n      inClass(a, d) {\n        let e;\n        for (; a;) {\n          if (e = B(a, \"class\")) {\n            if (-1 !== e.indexOf(d)) return !0;\n            if (-1 !== e.indexOf(\"highcharts-container\")) return !1;\n          }\n          a = a.parentElement;\n        }\n      }\n      init(a, d) {\n        this.options = d;\n        this.chart = a;\n        this.runChartClick = !(!d.chart.events || !d.chart.events.click);\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        this.setDOMEvents();\n        m(this, \"afterInit\");\n      }\n      normalize(a, q) {\n        var e = a.touches,\n          l = e ? e.length ? e.item(0) : D(e.changedTouches, a.changedTouches)[0] : a;\n        q || (q = this.getChartPosition());\n        e = l.pageX - q.left;\n        l = l.pageY - q.top;\n        e /= q.scaleX;\n        l /= q.scaleY;\n        return d(a, {\n          chartX: Math.round(e),\n          chartY: Math.round(l)\n        });\n      }\n      onContainerClick(a) {\n        const e = this.chart,\n          h = e.hoverPoint;\n        a = this.normalize(a);\n        const l = e.plotLeft,\n          k = e.plotTop;\n        e.cancelClick || (h && this.inClass(a.target, \"highcharts-tracker\") ? (m(h.series, \"click\", d(a, {\n          point: h\n        })), e.hoverPoint && h.firePointEvent(\"click\", a)) : (d(a, this.getCoordinates(a)), e.isInsidePlot(a.chartX - l, a.chartY - k, {\n          visiblePlotOnly: !0\n        }) && m(e, \"click\", a)));\n      }\n      onContainerMouseDown(a) {\n        const e = 1 === ((a.buttons || a.button) & 1);\n        a = this.normalize(a);\n        if (A.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);\n        if (\"undefined\" === typeof a.button || e) this.zoomOption(a), e && a.preventDefault && a.preventDefault(), this.dragStart(a);\n      }\n      onContainerMouseLeave(a) {\n        const e = F[D(E.hoverChartIndex, -1)];\n        a = this.normalize(a);\n        e && a.relatedTarget && !this.inClass(a.relatedTarget, \"highcharts-tooltip\") && (e.pointer.reset(), e.pointer.chartPosition = void 0);\n      }\n      onContainerMouseEnter(a) {\n        delete this.chartPosition;\n      }\n      onContainerMouseMove(a) {\n        const e = this.chart,\n          d = e.tooltip;\n        a = this.normalize(a);\n        this.setHoverChartIndex();\n        (\"mousedown\" === e.mouseIsDown || this.touchSelect(a)) && this.drag(a);\n        e.openMenu || !this.inClass(a.target, \"highcharts-tracker\") && !e.isInsidePlot(a.chartX - e.plotLeft, a.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        }) || d && d.shouldStickOnContact(a) || (this.inClass(a.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(a));\n      }\n      onDocumentTouchEnd(a) {\n        const e = F[D(E.hoverChartIndex, -1)];\n        e && e.pointer.drop(a);\n      }\n      onContainerTouchMove(a) {\n        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);\n      }\n      onContainerTouchStart(a) {\n        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);\n      }\n      onDocumentMouseMove(a) {\n        const e = this.chart,\n          d = e.tooltip,\n          l = this.chartPosition;\n        a = this.normalize(a, l);\n        !l || e.isInsidePlot(a.chartX - e.plotLeft, a.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        }) || d && d.shouldStickOnContact(a) || this.inClass(a.target, \"highcharts-tracker\") || this.reset();\n      }\n      onDocumentMouseUp(a) {\n        const e = F[D(E.hoverChartIndex, -1)];\n        e && e.pointer.drop(a);\n      }\n      pinch(a) {\n        const e = this,\n          h = e.chart,\n          l = e.pinchDown,\n          k = a.touches || [],\n          g = k.length,\n          b = e.lastValidTouch,\n          c = e.hasZoom,\n          f = {},\n          x = 1 === g && (e.inClass(a.target, \"highcharts-tracker\") && h.runTrackerClick || e.runChartClick),\n          n = {};\n        var z = e.chart.tooltip;\n        z = 1 === g && D(z && z.options.followTouchMove, !0);\n        let p = e.selectionMarker;\n        1 < g ? e.initiated = !0 : z && (e.initiated = !1);\n        c && e.initiated && !x && !1 !== a.cancelable && a.preventDefault();\n        [].map.call(k, function (b) {\n          return e.normalize(b);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(k, function (b, a) {\n          l[a] = {\n            chartX: b.chartX,\n            chartY: b.chartY\n          };\n        }), b.x = [l[0].chartX, l[1] && l[1].chartX], b.y = [l[0].chartY, l[1] && l[1].chartY], h.axes.forEach(function (b) {\n          if (b.zoomEnabled) {\n            const a = h.bounds[b.horiz ? \"h\" : \"v\"],\n              c = b.minPixelPadding,\n              f = b.toPixels(Math.min(D(b.options.min, b.dataMin), b.dataMin)),\n              g = b.toPixels(Math.max(D(b.options.max, b.dataMax), b.dataMax)),\n              e = Math.max(f, g);\n            a.min = Math.min(b.pos, Math.min(f, g) - c);\n            a.max = Math.max(b.pos + b.len, e + c);\n          }\n        }), e.res = !0) : z ? this.runPointActions(e.normalize(a)) : l.length && (m(h, \"touchpan\", {\n          originalEvent: a\n        }, () => {\n          p || (e.selectionMarker = p = d({\n            destroy: G,\n            touch: !0\n          }, h.plotBox));\n          e.pinchTranslate(l, k, f, p, n, b);\n          e.hasPinched = c;\n          e.scaleGroups(f, n);\n        }), e.res && (e.res = !1, this.reset(!1, 0)));\n      }\n      pinchTranslate(a, d, h, l, k, g) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, d, h, l, k, g);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, d, h, l, k, g);\n      }\n      pinchTranslateDirection(a, d, h, l, k, g, b, c) {\n        const f = this.chart,\n          e = a ? \"x\" : \"y\",\n          q = a ? \"X\" : \"Y\",\n          m = \"chart\" + q,\n          n = a ? \"width\" : \"height\",\n          w = f[\"plot\" + (a ? \"Left\" : \"Top\")],\n          p = f.inverted,\n          y = f.bounds[a ? \"h\" : \"v\"],\n          r = 1 === d.length,\n          v = d[0][m],\n          D = !r && d[1][m];\n        d = function () {\n          \"number\" === typeof E && 20 < Math.abs(v - D) && (u = c || Math.abs(P - E) / Math.abs(v - D));\n          K = (w - P) / u + v;\n          t = f[\"plot\" + (a ? \"Width\" : \"Height\")] / u;\n        };\n        let t,\n          K,\n          u = c || 1,\n          P = h[0][m],\n          E = !r && h[1][m],\n          L;\n        d();\n        h = K;\n        h < y.min ? (h = y.min, L = !0) : h + t > y.max && (h = y.max - t, L = !0);\n        L ? (P -= .8 * (P - b[e][0]), \"number\" === typeof E && (E -= .8 * (E - b[e][1])), d()) : b[e] = [P, E];\n        p || (g[e] = K - w, g[n] = t);\n        g = p ? 1 / u : u;\n        k[n] = t;\n        k[e] = h;\n        l[p ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + q] = u;\n        l[\"translate\" + q] = g * w + (P - g * v);\n      }\n      reset(a, d) {\n        const e = this.chart,\n          l = e.hoverSeries,\n          h = e.hoverPoint,\n          g = e.hoverPoints,\n          b = e.tooltip,\n          c = b && b.shared ? g : h;\n        a && c && L(c).forEach(function (b) {\n          b.series.isCartesian && \"undefined\" === typeof b.plotX && (a = !1);\n        });\n        if (a) b && c && L(c).length && (b.refresh(c), b.shared && g ? g.forEach(function (b) {\n          b.setState(b.state, !0);\n          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));\n        }) : h && (h.setState(h.state, !0), e.axes.forEach(function (b) {\n          b.crosshair && h.series[b.coll] === b && b.drawCrosshair(null, h);\n        })));else {\n          if (h) h.onMouseOut();\n          g && g.forEach(function (b) {\n            b.setState();\n          });\n          if (l) l.onMouseOut();\n          b && b.hide(d);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          e.axes.forEach(function (b) {\n            b.hideCrosshair();\n          });\n          this.hoverX = e.hoverPoints = e.hoverPoint = null;\n        }\n      }\n      runPointActions(a, d, h) {\n        const e = this.chart,\n          q = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,\n          g = q ? q.shared : !1;\n        let b = d || e.hoverPoint,\n          c = b && b.series || e.hoverSeries;\n        d = this.getHoverData(b, c, e.series, (!a || \"touchmove\" !== a.type) && (!!d || c && c.directTouch && this.isDirectTouch), g, a);\n        b = d.hoverPoint;\n        c = d.hoverSeries;\n        const f = d.hoverPoints;\n        d = c && c.tooltipOptions.followPointer && !c.tooltipOptions.split;\n        const k = g && c && !c.noSharedTooltip;\n        if (b && (h || b !== e.hoverPoint || q && q.isHidden)) {\n          (e.hoverPoints || []).forEach(function (b) {\n            -1 === f.indexOf(b) && b.setState();\n          });\n          if (e.hoverSeries !== c) c.onMouseOver();\n          this.applyInactiveState(f);\n          (f || []).forEach(function (b) {\n            b.setState(\"hover\");\n          });\n          e.hoverPoint && e.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!b.series) return;\n          e.hoverPoints = f;\n          e.hoverPoint = b;\n          b.firePointEvent(\"mouseOver\", void 0, () => {\n            q && b && q.refresh(k ? f : b, a);\n          });\n        } else d && q && !q.isHidden && (h = q.getAnchor([{}], a), e.isInsidePlot(h[0], h[1], {\n          visiblePlotOnly: !0\n        }) && q.updatePosition({\n          plotX: h[0],\n          plotY: h[1]\n        }));\n        this.unDocMouseMove || (this.unDocMouseMove = C(e.container.ownerDocument, \"mousemove\", function (b) {\n          const a = F[E.hoverChartIndex];\n          if (a) a.pointer.onDocumentMouseMove(b);\n        }), this.eventsToUnbind.push(this.unDocMouseMove));\n        e.axes.forEach(function (b) {\n          const c = D((b.crosshair || {}).snap, !0);\n          let g;\n          c && ((g = e.hoverPoint) && g.series[b.coll] === b || (g = p(f, a => a.series && a.series[b.coll] === b)));\n          g || !c ? b.drawCrosshair(a, g) : b.hideCrosshair();\n        });\n      }\n      scaleGroups(a, d) {\n        const e = this.chart;\n        e.series.forEach(function (l) {\n          const h = a || l.getPlotBox();\n          l.group && (l.xAxis && l.xAxis.zoomEnabled || e.mapView) && (l.group.attr(h), l.markerGroup && (l.markerGroup.attr(h), l.markerGroup.clip(d ? e.clipRect : null)), l.dataLabelsGroup && l.dataLabelsGroup.attr(h));\n        });\n        e.clipRect.attr(d || e.clipBox);\n      }\n      setDOMEvents() {\n        const a = this.chart.container,\n          d = a.ownerDocument;\n        a.onmousedown = this.onContainerMouseDown.bind(this);\n        a.onmousemove = this.onContainerMouseMove.bind(this);\n        a.onclick = this.onContainerClick.bind(this);\n        this.eventsToUnbind.push(C(a, \"mouseenter\", this.onContainerMouseEnter.bind(this)));\n        this.eventsToUnbind.push(C(a, \"mouseleave\", this.onContainerMouseLeave.bind(this)));\n        E.unbindDocumentMouseUp || (E.unbindDocumentMouseUp = C(d, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n        let h = this.chart.renderTo.parentElement;\n        for (; h && \"BODY\" !== h.tagName;) this.eventsToUnbind.push(C(h, \"scroll\", () => {\n          delete this.chartPosition;\n        })), h = h.parentElement;\n        A.hasTouch && (this.eventsToUnbind.push(C(a, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(C(a, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), E.unbindDocumentTouchEnd || (E.unbindDocumentTouchEnd = C(d, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      }\n      setHoverChartIndex() {\n        const a = this.chart,\n          d = A.charts[D(E.hoverChartIndex, -1)];\n        if (d && d !== a) d.pointer.onContainerMouseLeave({\n          relatedTarget: a.container\n        });\n        d && d.mouseIsDown || (E.hoverChartIndex = a.index);\n      }\n      touch(a, d) {\n        const e = this.chart;\n        let l, h;\n        this.setHoverChartIndex();\n        1 === a.touches.length ? (a = this.normalize(a), (h = e.isInsidePlot(a.chartX - e.plotLeft, a.chartY - e.plotTop, {\n          visiblePlotOnly: !0\n        })) && !e.openMenu ? (d && this.runPointActions(a), \"touchmove\" === a.type && (d = this.pinchDown, l = d[0] ? 4 <= Math.sqrt(Math.pow(d[0].chartX - a.chartX, 2) + Math.pow(d[0].chartY - a.chartY, 2)) : !1), D(l, !0) && this.pinch(a)) : d && this.reset()) : 2 === a.touches.length && this.pinch(a);\n      }\n      touchSelect(a) {\n        return !(!this.chart.options.chart.zooming.singleTouch || !a.touches || 1 !== a.touches.length);\n      }\n      zoomOption(a) {\n        var e = this.chart,\n          d = e.options.chart;\n        e = e.inverted;\n        let l = d.zooming.type || \"\";\n        /touch/.test(a.type) && (l = D(d.zooming.pinchType, l));\n        this.zoomX = a = /x/.test(l);\n        this.zoomY = d = /y/.test(l);\n        this.zoomHor = a && !e || d && e;\n        this.zoomVert = d && !e || a && e;\n        this.hasZoom = a || d;\n      }\n    }\n    (function (a) {\n      const e = [],\n        d = [];\n      a.compose = function (e) {\n        H.pushUnique(d, e) && C(e, \"beforeRender\", function () {\n          this.pointer = new a(this, this.options);\n        });\n      };\n      a.dissolve = function () {\n        for (let a = 0, d = e.length; a < d; ++a) e[a]();\n        e.length = 0;\n      };\n    })(E || (E = {}));\n    \"\";\n    return E;\n  });\n  M(a, \"Core/Legend/Legend.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G) {\n    const {\n        animObject: u,\n        setAnimation: B\n      } = a,\n      {\n        format: t\n      } = A,\n      {\n        marginNames: r\n      } = H,\n      {\n        distribute: d\n      } = F,\n      {\n        addEvent: p,\n        createElement: m,\n        css: k,\n        defined: v,\n        discardElement: n,\n        find: h,\n        fireEvent: D,\n        isNumber: L,\n        merge: E,\n        pick: e,\n        relativeLength: q,\n        stableSort: y,\n        syncTimeout: l\n      } = G;\n    class w {\n      constructor(a, b) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = void 0;\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = a;\n        this.init(a, b);\n      }\n      init(a, b) {\n        this.chart = a;\n        this.setOptions(b);\n        b.enabled && (this.render(), p(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), p(this.chart, \"render\", () => {\n          this.proximate && (this.proximatePositions(), this.positionItems());\n        }));\n      }\n      setOptions(a) {\n        const b = e(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = E(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop;\n        this.itemMarginBottom = a.itemMarginBottom;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = e(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      }\n      update(a, b) {\n        const c = this.chart;\n        this.setOptions(E(!0, this.options, a));\n        this.destroy();\n        c.isDirtyLegend = c.isDirtyBox = !0;\n        e(b, !0) && c.redraw();\n        D(this, \"afterUpdate\");\n      }\n      colorizeItem(a, b) {\n        const {\n          group: c,\n          label: f,\n          line: g,\n          symbol: e\n        } = a.legendItem || {};\n        if (c) c[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n        if (!this.chart.styledMode) {\n          var d = this.options;\n          const c = this.itemHiddenStyle.color;\n          d = b ? d.itemStyle.color : c;\n          const l = b ? a.color || c : c,\n            h = a.options && a.options.marker;\n          let k = {\n            fill: l\n          };\n          f && f.css({\n            fill: d\n          });\n          g && g.attr({\n            stroke: l\n          });\n          e && (h && e.isMarker && (k = a.pointAttribs(), b || (k.stroke = k.fill = c)), e.attr(k));\n        }\n        D(this, \"afterColorizeItem\", {\n          item: a,\n          visible: b\n        });\n      }\n      positionItems() {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      }\n      positionItem(a) {\n        const {\n          group: b,\n          x: c = 0,\n          y: f = 0\n        } = a.legendItem || {};\n        var g = this.options,\n          e = g.symbolPadding;\n        const d = !g.rtl;\n        g = a.checkbox;\n        b && b.element && (e = {\n          translateX: d ? c : this.legendWidth - c - 2 * e - 4,\n          translateY: f\n        }, b[v(b.translateY) ? \"animate\" : \"attr\"](e, void 0, () => {\n          D(this, \"afterPositionItem\", {\n            item: a\n          });\n        }));\n        g && (g.x = c, g.y = f);\n      }\n      destroyItem(a) {\n        const b = a.checkbox,\n          c = a.legendItem || {};\n        for (const b of [\"group\", \"label\", \"line\", \"symbol\"]) c[b] && (c[b] = c[b].destroy());\n        b && n(b);\n        a.legendItem = void 0;\n      }\n      destroy() {\n        for (const a of this.getAllItems()) this.destroyItem(a);\n        for (const a of \"clipRect up down pager nav box title group\".split(\" \")) this[a] && (this[a] = this[a].destroy());\n        this.display = null;\n      }\n      positionCheckboxes() {\n        const a = this.group && this.group.alignAttr,\n          b = this.clipHeight || this.legendHeight,\n          c = this.titleHeight;\n        let f;\n        a && (f = a.translateY, this.allItems.forEach(function (g) {\n          const e = g.checkbox;\n          let d;\n          e && (d = f + c + e.y + (this.scrollOffset || 0) + 3, k(e, {\n            left: a.translateX + g.checkboxOffset + e.x - 20 + \"px\",\n            top: d + \"px\",\n            display: this.proximate || d > f - 6 && d < f + b - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      }\n      renderTitle() {\n        var a = this.options;\n        const b = this.padding,\n          c = a.title;\n        let f = 0;\n        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, void 0, void 0, void 0, a.useHTML, void 0, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), f = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: f\n        }));\n        this.titleHeight = f;\n      }\n      setText(a) {\n        const b = this.options;\n        a.legendItem.label.attr({\n          text: b.labelFormat ? t(b.labelFormat, a, this.chart) : b.labelFormatter.call(a)\n        });\n      }\n      renderItem(a) {\n        const b = a.legendItem = a.legendItem || {};\n        var c = this.chart,\n          f = c.renderer;\n        const g = this.options,\n          d = this.symbolWidth,\n          l = g.symbolPadding || 0,\n          h = this.itemStyle,\n          k = this.itemHiddenStyle,\n          q = \"horizontal\" === g.layout ? e(g.itemDistance, 20) : 0,\n          m = !g.rtl,\n          n = !a.series,\n          w = !n && a.series.drawLegendSymbol ? a.series : a;\n        var p = w.options;\n        const y = this.createCheckboxForItem && p && p.showCheckbox,\n          K = g.useHTML,\n          r = a.options.className;\n        let v = b.label;\n        p = d + l + q + (y ? 20 : 0);\n        v || (b.group = f.g(\"legend-item\").addClass(\"highcharts-\" + w.type + \"-series highcharts-color-\" + a.colorIndex + (r ? \" \" + r : \"\") + (n ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), b.label = v = f.text(\"\", m ? d + l : -l, this.baseline || 0, K), c.styledMode || v.css(E(a.visible ? h : k)), v.attr({\n          align: m ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(b.group), this.baseline || (this.fontMetrics = f.fontMetrics(v), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, v.attr(\"y\", this.baseline), this.symbolHeight = e(g.symbolHeight, this.fontMetrics.f), g.squareSymbol && (this.symbolWidth = e(g.symbolWidth, Math.max(this.symbolHeight, 16)), p = this.symbolWidth + l + q + (y ? 20 : 0), m && v.attr(\"x\", this.symbolWidth + l))), w.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, v, K));\n        y && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !c.styledMode && h.width || v.css({\n          width: (g.itemWidth || this.widthOption || c.spacingBox.width) - p + \"px\"\n        });\n        this.setText(a);\n        c = v.getBBox();\n        f = this.fontMetrics && this.fontMetrics.h || 0;\n        a.itemWidth = a.checkboxOffset = g.itemWidth || b.labelWidth || c.width + p;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(b.labelHeight || (c.height > 1.5 * f ? c.height : f));\n      }\n      layoutItem(a) {\n        var b = this.options;\n        const c = this.padding,\n          f = \"horizontal\" === b.layout,\n          g = a.itemHeight,\n          d = this.itemMarginBottom,\n          l = this.itemMarginTop,\n          h = f ? e(b.itemDistance, 20) : 0,\n          k = this.maxLegendWidth;\n        b = b.alignColumns && this.totalItemWidth > k ? this.maxItemWidth : a.itemWidth;\n        const q = a.legendItem || {};\n        f && this.itemX - c + b > k && (this.itemX = c, this.lastLineHeight && (this.itemY += l + this.lastLineHeight + d), this.lastLineHeight = 0);\n        this.lastItemY = l + this.itemY + d;\n        this.lastLineHeight = Math.max(g, this.lastLineHeight);\n        q.x = this.itemX;\n        q.y = this.itemY;\n        f ? this.itemX += b : (this.itemY += l + g + d, this.lastLineHeight = g);\n        this.offsetWidth = this.widthOption || Math.max((f ? this.itemX - c - (a.checkbox ? 0 : h) : b) + c, this.offsetWidth);\n      }\n      getAllItems() {\n        let a = [];\n        this.chart.series.forEach(function (b) {\n          const c = b && b.options;\n          b && e(c.showInLegend, v(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat((b.legendItem || {}).labels || (\"point\" === c.legendType ? b.data : b)));\n        });\n        D(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      }\n      getAlignment() {\n        const a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      }\n      adjustMargins(a, b) {\n        const c = this.chart,\n          f = this.options,\n          g = this.getAlignment();\n        g && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (d, l) {\n          d.test(g) && !v(a[l]) && (c[r[l]] = Math.max(c[r[l]], c.legend[(l + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][l] * f[l % 2 ? \"x\" : \"y\"] + e(f.margin, 12) + b[l] + (c.titleOffset[l] || 0)));\n        });\n      }\n      proximatePositions() {\n        const a = this.chart,\n          b = [],\n          c = \"left\" === this.options.align;\n        this.allItems.forEach(function (f) {\n          var g;\n          var e = c;\n          let d;\n          f.yAxis && (f.xAxis.options.reversed && (e = !e), f.points && (g = h(e ? f.points : f.points.slice(0).reverse(), function (b) {\n            return L(b.plotY);\n          })), e = this.itemMarginTop + f.legendItem.label.getBBox().height + this.itemMarginBottom, d = f.yAxis.top - a.plotTop, f.visible ? (g = g ? g.plotY : f.yAxis.height, g += d - .3 * e) : g = d + f.yAxis.height, b.push({\n            target: g,\n            size: e,\n            item: f\n          }));\n        }, this);\n        let f;\n        for (const c of d(b, a.plotHeight)) f = c.item.legendItem || {}, L(c.pos) && (f.y = a.plotTop - a.spacing[0] + c.pos);\n      }\n      render() {\n        const a = this.chart,\n          b = a.renderer,\n          c = this.options,\n          f = this.padding;\n        var e = this.getAllItems();\n        let d,\n          l = this.group,\n          h = this.box;\n        this.itemX = f;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = q(c.width, a.spacingBox.width - f);\n        var k = a.spacingBox.width - 2 * f - c.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (k /= 2);\n        this.maxLegendWidth = this.widthOption || k;\n        l || (this.group = l = b.g(\"legend\").addClass(c.className || \"\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(l), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        y(e, (b, a) => (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0));\n        c.reversed && e.reverse();\n        this.allItems = e;\n        this.display = k = !!e.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        e.forEach(this.renderItem, this);\n        e.forEach(this.layoutItem, this);\n        e = (this.widthOption || this.offsetWidth) + f;\n        d = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        d = this.handleOverflow(d);\n        d += f;\n        h || (this.box = h = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: c.borderRadius\n        }).add(l));\n        a.styledMode || h.attr({\n          stroke: c.borderColor,\n          \"stroke-width\": c.borderWidth || 0,\n          fill: c.backgroundColor || \"none\"\n        }).shadow(c.shadow);\n        if (0 < e && 0 < d) h[h.placed ? \"animate\" : \"attr\"](h.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: e,\n          height: d\n        }, h.strokeWidth()));\n        l[k ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === l.getStyle(\"display\") && (e = d = 0);\n        this.legendWidth = e;\n        this.legendHeight = d;\n        k && this.align();\n        this.proximate || this.positionItems();\n        D(this, \"afterRender\");\n      }\n      align(a = this.chart.spacingBox) {\n        const b = this.chart,\n          c = this.options;\n        let f = a.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? f += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (f -= b.titleOffset[2]);\n        f !== a.y && (a = E(a, {\n          y: f\n        }));\n        b.hasRendered || (this.group.placed = !1);\n        this.group.align(E(c, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : c.verticalAlign\n        }), !0, a);\n      }\n      handleOverflow(a) {\n        const b = this,\n          c = this.chart,\n          f = c.renderer,\n          g = this.options;\n        var d = g.y;\n        const l = \"top\" === g.verticalAlign,\n          h = this.padding,\n          k = g.maxHeight,\n          q = g.navigation,\n          m = e(q.animation, !0),\n          n = q.arrowSize || 12,\n          w = this.pages,\n          p = this.allItems,\n          y = function (a) {\n            \"number\" === typeof a ? u.attr({\n              height: a\n            }) : u && (b.clipRect = u.destroy(), b.contentGroup.clip());\n            b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + h + \"px,9999px,\" + (h + a) + \"px,0)\" : \"auto\");\n          },\n          K = function (a) {\n            b[a] = f.circle(0, 0, 1.3 * n).translate(n / 2, n / 2).add(t);\n            c.styledMode || b[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n            return b[a];\n          };\n        let v, r, D;\n        d = c.spacingBox.height + (l ? -d : d) - h;\n        let t = this.nav,\n          u = this.clipRect;\n        \"horizontal\" !== g.layout || \"middle\" === g.verticalAlign || g.floating || (d /= 2);\n        k && (d = Math.min(d, k));\n        w.length = 0;\n        a && 0 < d && a > d && !1 !== q.enabled ? (this.clipHeight = v = Math.max(d - 20 - this.titleHeight - h, 0), this.currentPage = e(this.currentPage, 1), this.fullHeight = a, p.forEach((b, a) => {\n          D = b.legendItem || {};\n          b = D.y || 0;\n          const c = Math.round(D.label.getBBox().height);\n          let f = w.length;\n          if (!f || b - w[f - 1] > v && (r || b) !== w[f - 1]) w.push(r || b), f++;\n          D.pageIx = f - 1;\n          r && ((p[a - 1].legendItem || {}).pageIx = f - 1);\n          a === p.length - 1 && b + c - w[f - 1] > v && b > w[f - 1] && (w.push(b), D.pageIx = f);\n          b !== r && (r = b);\n        }), u || (u = b.clipRect = f.clipRect(0, h - 2, 9999, 0), b.contentGroup.clip(u)), y(v), t || (this.nav = t = f.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = f.symbol(\"triangle\", 0, 0, n, n).add(t), K(\"upTracker\").on(\"click\", function () {\n          b.scroll(-1, m);\n        }), this.pager = f.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !c.styledMode && q.style && this.pager.css(q.style), this.pager.add(t), this.down = f.symbol(\"triangle-down\", 0, 0, n, n).add(t), K(\"downTracker\").on(\"click\", function () {\n          b.scroll(1, m);\n        })), b.scroll(0), a = d) : t && (y(), this.nav = t.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      }\n      scroll(a, b) {\n        const c = this.chart,\n          f = this.pages,\n          g = f.length,\n          d = this.clipHeight,\n          h = this.options.navigation,\n          k = this.pager,\n          q = this.padding;\n        let m = this.currentPage + a;\n        m > g && (m = g);\n        0 < m && (\"undefined\" !== typeof b && B(b, c), this.nav.attr({\n          translateX: q,\n          translateY: d + this.padding + 7 + this.titleHeight,\n          visibility: \"inherit\"\n        }), [this.up, this.upTracker].forEach(function (b) {\n          b.attr({\n            \"class\": 1 === m ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), k.attr({\n          text: m + \"/\" + g\n        }), [this.down, this.downTracker].forEach(function (b) {\n          b.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": m === g ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), c.styledMode || (this.up.attr({\n          fill: 1 === m ? h.inactiveColor : h.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === m ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: m === g ? h.inactiveColor : h.activeColor\n        }), this.downTracker.css({\n          cursor: m === g ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -f[m - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = m, this.positionCheckboxes(), a = u(e(b, c.renderer.globalAnimation, !0)), l(() => {\n          D(this, \"afterScroll\", {\n            currentPage: m\n          });\n        }, a.duration));\n      }\n      setItemEvents(a, b, c) {\n        const f = this,\n          g = a.legendItem || {},\n          e = f.chart.renderer.boxWrapper,\n          d = a instanceof I,\n          l = \"highcharts-legend-\" + (d ? \"point\" : \"series\") + \"-active\",\n          h = f.chart.styledMode;\n        c = c ? [b, g.symbol] : [g.group];\n        const k = b => {\n          f.allItems.forEach(c => {\n            a !== c && [c].concat(c.linkedSeries || []).forEach(a => {\n              a.setState(b, !d);\n            });\n          });\n        };\n        for (const g of c) if (g) g.on(\"mouseover\", function () {\n          a.visible && k(\"inactive\");\n          a.setState(\"hover\");\n          a.visible && e.addClass(l);\n          h || b.css(f.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          f.chart.styledMode || b.css(E(a.visible ? f.itemStyle : f.itemHiddenStyle));\n          k(\"\");\n          e.removeClass(l);\n          a.setState();\n        }).on(\"click\", function (b) {\n          const c = function () {\n            a.setVisible && a.setVisible();\n            k(a.visible ? \"inactive\" : \"\");\n          };\n          e.removeClass(l);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : D(a, \"legendItemClick\", b, c);\n        });\n      }\n      createCheckboxForItem(a) {\n        a.checkbox = m(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        p(a.checkbox, \"click\", function (b) {\n          D(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    }\n    (function (a) {\n      const b = [];\n      a.compose = function (c) {\n        G.pushUnique(b, c) && p(c, \"beforeMargins\", function () {\n          this.legend = new a(this, this.options.legend);\n        });\n      };\n    })(w || (w = {}));\n    \"\";\n    return w;\n  });\n  M(a, \"Core/Series/SeriesRegistry.js\", [a[\"Core/Globals.js\"], a[\"Core/Defaults.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I) {\n    const {\n        defaultOptions: u\n      } = A,\n      {\n        extendClass: G,\n        merge: C\n      } = I;\n    var B;\n    (function (t) {\n      function r(a, p) {\n        const d = u.plotOptions || {},\n          k = p.defaultOptions,\n          v = p.prototype;\n        v.type = a;\n        v.pointClass || (v.pointClass = H);\n        k && (d[a] = k);\n        t.seriesTypes[a] = p;\n      }\n      t.seriesTypes = a.seriesTypes;\n      t.registerSeriesType = r;\n      t.seriesType = function (a, p, m, k, v) {\n        const d = u.plotOptions || {};\n        p = p || \"\";\n        d[a] = C(d[p], m);\n        r(a, G(t.seriesTypes[p] || function () {}, k));\n        t.seriesTypes[a].prototype.type = a;\n        v && (t.seriesTypes[a].prototype.pointClass = G(H, v));\n        return t.seriesTypes[a];\n      };\n    })(B || (B = {}));\n    return B;\n  });\n  M(a, \"Core/Chart/Chart.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"], a[\"Core/Renderer/HTML/AST.js\"]], function (a, A, H, I, F, G, C, B, t, r, d, p) {\n    const {\n        animate: m,\n        animObject: k,\n        setAnimation: v\n      } = a,\n      {\n        defaultOptions: n,\n        defaultTime: h\n      } = H,\n      {\n        numberFormat: D\n      } = I,\n      {\n        registerEventOptions: u\n      } = F,\n      {\n        charts: E,\n        doc: e,\n        marginNames: q,\n        svg: y,\n        win: l\n      } = G,\n      {\n        seriesTypes: w\n      } = B,\n      {\n        addEvent: g,\n        attr: b,\n        cleanRecursively: c,\n        createElement: f,\n        css: x,\n        defined: J,\n        discardElement: z,\n        erase: Q,\n        error: S,\n        extend: R,\n        find: N,\n        fireEvent: O,\n        getStyle: ba,\n        isArray: da,\n        isNumber: W,\n        isObject: K,\n        isString: Y,\n        merge: P,\n        objectEach: ca,\n        pick: T,\n        pInt: X,\n        relativeLength: U,\n        removeEvent: Z,\n        splat: ea,\n        syncTimeout: fa,\n        uniqueKey: M\n      } = d;\n    class aa {\n      static chart(b, a, c) {\n        return new aa(b, a, c);\n      }\n      constructor(b, a, c) {\n        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.sharedClips = {};\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;\n        this.getArgs(b, a, c);\n      }\n      getArgs(b, a, c) {\n        Y(b) || b.nodeName ? (this.renderTo = b, this.init(a, c)) : this.init(b, a);\n      }\n      init(b, a) {\n        const c = b.plotOptions || {};\n        O(this, \"init\", {\n          args: arguments\n        }, function () {\n          const f = P(n, b),\n            g = f.chart;\n          ca(f.plotOptions, function (b, a) {\n            K(b) && (b.tooltip = c[a] && P(c[a].tooltip) || void 0);\n          });\n          f.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;\n          this.userOptions = b;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = a;\n          this.isResizing = 0;\n          const e = g.zooming = g.zooming || {};\n          b.chart && !b.chart.zooming && (e.resetButton = g.resetZoomButton);\n          e.key = T(e.key, g.zoomKey);\n          e.pinchType = T(e.pinchType, g.pinchType);\n          e.singleTouch = T(e.singleTouch, g.zoomBySingleTouch);\n          e.type = T(e.type, g.zoomType);\n          this.options = f;\n          this.axes = [];\n          this.series = [];\n          this.time = b.time && Object.keys(b.time).length ? new r(b.time) : G.time;\n          this.numberFormatter = g.numberFormatter || D;\n          this.styledMode = g.styledMode;\n          this.hasCartesianSeries = g.showAxes;\n          this.index = E.length;\n          E.push(this);\n          G.chartCount++;\n          u(this, g);\n          this.xAxis = [];\n          this.yAxis = [];\n          this.pointCount = this.colorCounter = this.symbolCounter = 0;\n          O(this, \"afterInit\");\n          this.firstRender();\n        });\n      }\n      initSeries(b) {\n        var a = this.options.chart;\n        a = b.type || a.type;\n        const c = w[a];\n        c || S(17, !0, this, {\n          missingModuleFor: a\n        });\n        a = new c();\n        \"function\" === typeof a.init && a.init(this, b);\n        return a;\n      }\n      setSeriesData() {\n        this.getSeriesOrderByLinks().forEach(function (b) {\n          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);\n        });\n      }\n      getSeriesOrderByLinks() {\n        return this.series.concat().sort(function (b, a) {\n          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;\n        });\n      }\n      orderSeries(b) {\n        const a = this.series;\n        for (let c = b || 0, f = a.length; c < f; ++c) a[c] && (a[c].index = c, a[c].name = a[c].getName());\n      }\n      isInsidePlot(b, a, c = {}) {\n        const {\n          inverted: f,\n          plotBox: g,\n          plotLeft: e,\n          plotTop: d,\n          scrollablePlotBox: l\n        } = this;\n        var h = 0;\n        let k = 0;\n        c.visiblePlotOnly && this.scrollingContainer && ({\n          scrollLeft: h,\n          scrollTop: k\n        } = this.scrollingContainer);\n        const q = c.series,\n          m = c.visiblePlotOnly && l || g;\n        var n = c.inverted ? a : b;\n        a = c.inverted ? b : a;\n        b = {\n          x: n,\n          y: a,\n          isInsidePlot: !0,\n          options: c\n        };\n        if (!c.ignoreX) {\n          const a = q && (f && !this.polar ? q.yAxis : q.xAxis) || {\n            pos: e,\n            len: Infinity\n          };\n          n = c.paneCoordinates ? a.pos + n : e + n;\n          n >= Math.max(h + e, a.pos) && n <= Math.min(h + e + m.width, a.pos + a.len) || (b.isInsidePlot = !1);\n        }\n        !c.ignoreY && b.isInsidePlot && (h = !f && c.axis && !c.axis.isXAxis && c.axis || q && (f ? q.xAxis : q.yAxis) || {\n          pos: d,\n          len: Infinity\n        }, c = c.paneCoordinates ? h.pos + a : d + a, c >= Math.max(k + d, h.pos) && c <= Math.min(k + d + m.height, h.pos + h.len) || (b.isInsidePlot = !1));\n        O(this, \"afterIsInsidePlot\", b);\n        return b.isInsidePlot;\n      }\n      redraw(b) {\n        O(this, \"beforeRedraw\");\n        const a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n          c = this.series,\n          f = this.pointer,\n          g = this.legend,\n          e = this.userOptions.legend,\n          d = this.renderer,\n          l = d.isHidden(),\n          h = [];\n        let k,\n          q,\n          m = this.isDirtyBox,\n          n = this.isDirtyLegend,\n          x;\n        d.rootFontSize = d.boxWrapper.getStyle(\"font-size\");\n        this.setResponsive && this.setResponsive(!1);\n        v(this.hasRendered ? b : !1, this);\n        l && this.temporaryDisplay();\n        this.layOutTitles();\n        for (b = c.length; b--;) if (x = c[b], x.options.stacking || x.options.centerInCategory) if (q = !0, x.isDirty) {\n          k = !0;\n          break;\n        }\n        if (k) for (b = c.length; b--;) x = c[b], x.options.stacking && (x.isDirty = !0);\n        c.forEach(function (b) {\n          b.isDirty && (\"point\" === b.options.legendType ? (\"function\" === typeof b.updateTotals && b.updateTotals(), n = !0) : e && (e.labelFormatter || e.labelFormat) && (n = !0));\n          b.isDirtyData && O(b, \"updatedData\");\n        });\n        n && g && g.options.enabled && (g.render(), this.isDirtyLegend = !1);\n        q && this.getStacks();\n        a.forEach(function (b) {\n          b.updateNames();\n          b.setScale();\n        });\n        this.getMargins();\n        a.forEach(function (b) {\n          b.isDirty && (m = !0);\n        });\n        a.forEach(function (b) {\n          const a = b.min + \",\" + b.max;\n          b.extKey !== a && (b.extKey = a, h.push(function () {\n            O(b, \"afterSetExtremes\", R(b.eventArgs, b.getExtremes()));\n            delete b.eventArgs;\n          }));\n          (m || q) && b.redraw();\n        });\n        m && this.drawChartBox();\n        O(this, \"predraw\");\n        c.forEach(function (b) {\n          (m || b.isDirty) && b.visible && b.redraw();\n          b.isDirtyData = !1;\n        });\n        f && f.reset(!0);\n        d.draw();\n        O(this, \"redraw\");\n        O(this, \"render\");\n        l && this.temporaryDisplay(!0);\n        h.forEach(function (b) {\n          b.call();\n        });\n      }\n      get(b) {\n        function a(a) {\n          return a.id === b || a.options && a.options.id === b;\n        }\n        const c = this.series;\n        let f = N(this.axes, a) || N(this.series, a);\n        for (let b = 0; !f && b < c.length; b++) f = N(c[b].points || [], a);\n        return f;\n      }\n      getAxes() {\n        const b = this;\n        var a = this.options;\n        const c = a.xAxis = ea(a.xAxis || {});\n        a = a.yAxis = ea(a.yAxis || {});\n        O(this, \"getAxes\");\n        c.forEach(function (b, a) {\n          b.index = a;\n          b.isX = !0;\n        });\n        a.forEach(function (b, a) {\n          b.index = a;\n        });\n        c.concat(a).forEach(function (a) {\n          new A(b, a);\n        });\n        O(this, \"afterGetAxes\");\n      }\n      getSelectedPoints() {\n        return this.series.reduce((b, a) => {\n          a.getPointsCollection().forEach(a => {\n            T(a.selectedStaging, a.selected) && b.push(a);\n          });\n          return b;\n        }, []);\n      }\n      getSelectedSeries() {\n        return this.series.filter(function (b) {\n          return b.selected;\n        });\n      }\n      setTitle(b, a, c) {\n        this.applyDescription(\"title\", b);\n        this.applyDescription(\"subtitle\", a);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(c);\n      }\n      applyDescription(b, a) {\n        const c = this;\n        var f = \"title\" === b ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"1em\" : \"1.2em\",\n          fontWeight: \"bold\"\n        } : {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        };\n        f = this.options[b] = P(!this.styledMode && {\n          style: f\n        }, this.options[b], a);\n        let g = this[b];\n        g && a && (this[b] = g = g.destroy());\n        f && !g && (g = this.renderer.text(f.text, 0, 0, f.useHTML).attr({\n          align: f.align,\n          \"class\": \"highcharts-\" + b,\n          zIndex: f.zIndex || 4\n        }).add(), g.update = function (a) {\n          c[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[b]](a);\n        }, this.styledMode || g.css(f.style), this[b] = g);\n      }\n      layOutTitles(b) {\n        const a = [0, 0, 0],\n          c = this.renderer,\n          f = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (b) {\n          const g = this[b],\n            e = this.options[b],\n            d = e.verticalAlign || \"top\";\n          b = \"title\" === b ? \"top\" === d ? -3 : 0 : \"top\" === d ? a[0] + 2 : 0;\n          if (g) {\n            g.css({\n              width: (e.width || f.width + (e.widthAdjust || 0)) + \"px\"\n            });\n            const l = c.fontMetrics(g).b,\n              h = Math.round(g.getBBox(e.useHTML).height);\n            g.align(R({\n              y: \"bottom\" === d ? l : b + l,\n              height: h\n            }, e), !1, \"spacingBox\");\n            e.floating || (\"top\" === d ? a[0] = Math.ceil(a[0] + h) : \"bottom\" === d && (a[2] = Math.ceil(a[2] + h)));\n          }\n        }, this);\n        a[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (a[0] += this.options.title.margin);\n        a[2] && \"bottom\" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);\n        const g = !this.titleOffset || this.titleOffset.join(\",\") !== a.join(\",\");\n        this.titleOffset = a;\n        O(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && g && (this.isDirtyBox = this.isDirtyLegend = g, this.hasRendered && T(b, !0) && this.isDirtyBox && this.redraw());\n      }\n      getContainerBox() {\n        return {\n          width: ba(this.renderTo, \"width\", !0) || 0,\n          height: ba(this.renderTo, \"height\", !0) || 0\n        };\n      }\n      getChartSize() {\n        var b = this.options.chart;\n        const a = b.width;\n        b = b.height;\n        const c = this.getContainerBox();\n        this.chartWidth = Math.max(0, a || c.width || 600);\n        this.chartHeight = Math.max(0, U(b, this.chartWidth) || (1 < c.height ? c.height : 400));\n        this.containerBox = c;\n      }\n      temporaryDisplay(b) {\n        let a = this.renderTo;\n        if (b) for (; a && a.style;) a.hcOrigStyle && (x(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (e.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {\n          e.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, e.body.appendChild(a));\n          if (\"none\" === ba(a, \"display\", !1) || a.hcOricDetached) a.hcOrigStyle = {\n            display: a.style.display,\n            height: a.style.height,\n            overflow: a.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, a !== this.renderTo && (b.height = 0), x(a, b), a.offsetWidth || a.style.setProperty(\"display\", \"block\", \"important\");\n          a = a.parentNode;\n          if (a === e.body) break;\n        }\n      }\n      setClassName(b) {\n        this.container.className = \"highcharts-container \" + (b || \"\");\n      }\n      getContainer() {\n        const a = this.options,\n          c = a.chart;\n        var g = M();\n        let d,\n          l = this.renderTo;\n        l || (this.renderTo = l = c.renderTo);\n        Y(l) && (this.renderTo = l = e.getElementById(l));\n        l || S(13, !0, this);\n        var h = X(b(l, \"data-highcharts-chart\"));\n        W(h) && E[h] && E[h].hasRendered && E[h].destroy();\n        b(l, \"data-highcharts-chart\", this.index);\n        l.innerHTML = p.emptyHTML;\n        c.skipClone || l.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        h = this.chartWidth;\n        const k = this.chartHeight;\n        x(l, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (d = R({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: h + \"px\",\n          height: k + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\",\n          \"touch-action\": \"manipulation\",\n          outline: \"none\"\n        }, c.style || {}));\n        this.container = g = f(\"div\", {\n          id: g\n        }, d, l);\n        this._cursor = g.style.cursor;\n        this.renderer = new (c.renderer || !y ? C.getRendererType(c.renderer) : t)(g, h, k, void 0, c.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);\n        this.containerBox = this.getContainerBox();\n        v(void 0, this);\n        this.setClassName(c.className);\n        if (this.styledMode) for (const b in a.defs) this.renderer.definition(a.defs[b]);else this.renderer.setStyle(c.style);\n        this.renderer.chartIndex = this.index;\n        O(this, \"afterGetContainer\");\n      }\n      getMargins(b) {\n        const {\n          spacing: a,\n          margin: c,\n          titleOffset: f\n        } = this;\n        this.resetMargins();\n        f[0] && !J(c[0]) && (this.plotTop = Math.max(this.plotTop, f[0] + a[0]));\n        f[2] && !J(c[2]) && (this.marginBottom = Math.max(this.marginBottom, f[2] + a[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(c, a);\n        O(this, \"getMargins\");\n        b || this.getAxisMargins();\n      }\n      getAxisMargins() {\n        const b = this,\n          a = b.axisOffset = [0, 0, 0, 0],\n          c = b.colorAxis,\n          f = b.margin,\n          g = function (b) {\n            b.forEach(function (b) {\n              b.visible && b.getOffset();\n            });\n          };\n        b.hasCartesianSeries ? g(b.axes) : c && c.length && g(c);\n        q.forEach(function (c, g) {\n          J(f[g]) || (b[c] += a[g]);\n        });\n        b.setChartSize();\n      }\n      reflow(b) {\n        const a = this;\n        var c = a.options.chart;\n        c = J(c.width) && J(c.height);\n        const f = a.containerBox,\n          g = a.getContainerBox();\n        delete a.pointer.chartPosition;\n        if (!c && !a.isPrinting && f && g.width) {\n          if (g.width !== f.width || g.height !== f.height) d.clearTimeout(a.reflowTimeout), a.reflowTimeout = fa(function () {\n            a.container && a.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          a.containerBox = g;\n        }\n      }\n      setReflow() {\n        const b = this;\n        var a = a => {\n          var c;\n          (null === (c = b.options) || void 0 === c ? 0 : c.chart.reflow) && b.hasLoaded && b.reflow(a);\n        };\n        \"function\" === typeof ResizeObserver ? new ResizeObserver(a).observe(b.renderTo) : (a = g(l, \"resize\", a), g(this, \"destroy\", a));\n      }\n      setSize(b, a, c) {\n        const f = this,\n          g = f.renderer;\n        f.isResizing += 1;\n        v(c, f);\n        c = g.globalAnimation;\n        f.oldChartHeight = f.chartHeight;\n        f.oldChartWidth = f.chartWidth;\n        \"undefined\" !== typeof b && (f.options.chart.width = b);\n        \"undefined\" !== typeof a && (f.options.chart.height = a);\n        f.getChartSize();\n        f.styledMode || (c ? m : x)(f.container, {\n          width: f.chartWidth + \"px\",\n          height: f.chartHeight + \"px\"\n        }, c);\n        f.setChartSize(!0);\n        g.setSize(f.chartWidth, f.chartHeight, c);\n        f.axes.forEach(function (b) {\n          b.isDirty = !0;\n          b.setScale();\n        });\n        f.isDirtyLegend = !0;\n        f.isDirtyBox = !0;\n        f.layOutTitles();\n        f.getMargins();\n        f.redraw(c);\n        f.oldChartHeight = null;\n        O(f, \"resize\");\n        fa(function () {\n          f && O(f, \"endResize\", null, function () {\n            --f.isResizing;\n          });\n        }, k(c).duration);\n      }\n      setChartSize(b) {\n        var a = this.inverted;\n        const c = this.renderer;\n        var f = this.chartWidth,\n          g = this.chartHeight;\n        const e = this.options.chart,\n          d = this.spacing,\n          l = this.clipOffset;\n        let h, k, q, m;\n        this.plotLeft = h = Math.round(this.plotLeft);\n        this.plotTop = k = Math.round(this.plotTop);\n        this.plotWidth = q = Math.max(0, Math.round(f - h - this.marginRight));\n        this.plotHeight = m = Math.max(0, Math.round(g - k - this.marginBottom));\n        this.plotSizeX = a ? m : q;\n        this.plotSizeY = a ? q : m;\n        this.plotBorderWidth = e.plotBorderWidth || 0;\n        this.spacingBox = c.spacingBox = {\n          x: d[3],\n          y: d[0],\n          width: f - d[3] - d[1],\n          height: g - d[0] - d[2]\n        };\n        this.plotBox = c.plotBox = {\n          x: h,\n          y: k,\n          width: q,\n          height: m\n        };\n        a = 2 * Math.floor(this.plotBorderWidth / 2);\n        f = Math.ceil(Math.max(a, l[3]) / 2);\n        g = Math.ceil(Math.max(a, l[0]) / 2);\n        this.clipBox = {\n          x: f,\n          y: g,\n          width: Math.floor(this.plotSizeX - Math.max(a, l[1]) / 2 - f),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, l[2]) / 2 - g))\n        };\n        b || (this.axes.forEach(function (b) {\n          b.setAxisSize();\n          b.setAxisTranslation();\n        }), c.alignElements());\n        O(this, \"afterSetChartSize\", {\n          skipAxes: b\n        });\n      }\n      resetMargins() {\n        O(this, \"resetMargins\");\n        const b = this,\n          a = b.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (c) {\n          const f = a[c],\n            g = K(f) ? f : [f, f, f, f];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (f, e) {\n            b[c][e] = T(a[c + f], g[e]);\n          });\n        });\n        q.forEach(function (a, c) {\n          b[a] = T(b.margin[c], b.spacing[c]);\n        });\n        b.axisOffset = [0, 0, 0, 0];\n        b.clipOffset = [0, 0, 0, 0];\n      }\n      drawChartBox() {\n        const b = this.options.chart,\n          a = this.renderer,\n          c = this.chartWidth,\n          f = this.chartHeight,\n          g = this.styledMode,\n          e = this.plotBGImage;\n        var d = b.backgroundColor;\n        const l = b.plotBackgroundColor,\n          h = b.plotBackgroundImage,\n          k = this.plotLeft,\n          q = this.plotTop,\n          m = this.plotWidth,\n          n = this.plotHeight,\n          x = this.plotBox,\n          w = this.clipRect,\n          p = this.clipBox;\n        let z = this.chartBackground,\n          K = this.plotBackground,\n          y = this.plotBorder,\n          J,\n          v,\n          r = \"animate\";\n        z || (this.chartBackground = z = a.rect().addClass(\"highcharts-background\").add(), r = \"attr\");\n        if (g) J = v = z.strokeWidth();else {\n          J = b.borderWidth || 0;\n          v = J + (b.shadow ? 8 : 0);\n          d = {\n            fill: d || \"none\"\n          };\n          if (J || z[\"stroke-width\"]) d.stroke = b.borderColor, d[\"stroke-width\"] = J;\n          z.attr(d).shadow(b.shadow);\n        }\n        z[r]({\n          x: v / 2,\n          y: v / 2,\n          width: c - v - J % 2,\n          height: f - v - J % 2,\n          r: b.borderRadius\n        });\n        r = \"animate\";\n        K || (r = \"attr\", this.plotBackground = K = a.rect().addClass(\"highcharts-plot-background\").add());\n        K[r](x);\n        g || (K.attr({\n          fill: l || \"none\"\n        }).shadow(b.plotShadow), h && (e ? (h !== e.attr(\"href\") && e.attr(\"href\", h), e.animate(x)) : this.plotBGImage = a.image(h, k, q, m, n).add()));\n        w ? w.animate({\n          width: p.width,\n          height: p.height\n        }) : this.clipRect = a.clipRect(p);\n        r = \"animate\";\n        y || (r = \"attr\", this.plotBorder = y = a.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        g || y.attr({\n          stroke: b.plotBorderColor,\n          \"stroke-width\": b.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        y[r](y.crisp({\n          x: k,\n          y: q,\n          width: m,\n          height: n\n        }, -y.strokeWidth()));\n        this.isDirtyBox = !1;\n        O(this, \"afterDrawChartBox\");\n      }\n      propFromSeries() {\n        const b = this,\n          a = b.options.chart,\n          c = b.options.series;\n        let f, g, e;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (d) {\n          g = w[a.type];\n          e = a[d] || g && g.prototype[d];\n          for (f = c && c.length; !e && f--;) (g = w[c[f].type]) && g.prototype[d] && (e = !0);\n          b[d] = e;\n        });\n      }\n      linkSeries(b) {\n        const a = this,\n          c = a.series;\n        c.forEach(function (b) {\n          b.linkedSeries.length = 0;\n        });\n        c.forEach(function (b) {\n          let c = b.options.linkedTo;\n          Y(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, c.enabledDataSorting && b.setDataSortingOptions(), b.visible = T(b.options.visible, c.options.visible, b.visible));\n        });\n        O(this, \"afterLinkSeries\", {\n          isUpdating: b\n        });\n      }\n      renderSeries() {\n        this.series.forEach(function (b) {\n          b.translate();\n          b.render();\n        });\n      }\n      render() {\n        const b = this.axes,\n          a = this.colorAxis,\n          c = this.renderer,\n          f = function (b) {\n            b.forEach(function (b) {\n              b.visible && b.render();\n            });\n          };\n        let g = 0;\n        this.setTitle();\n        O(this, \"beforeMargins\");\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        const e = this.plotWidth;\n        b.some(function (b) {\n          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return g = 21, !0;\n        });\n        const d = this.plotHeight = Math.max(this.plotHeight - g, 0);\n        b.forEach(function (b) {\n          b.setScale();\n        });\n        this.getAxisMargins();\n        const l = 1.1 < e / this.plotWidth,\n          h = 1.05 < d / this.plotHeight;\n        if (l || h) b.forEach(function (b) {\n          (b.horiz && l || !b.horiz && h) && b.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? f(b) : a && a.length && f(a);\n        this.seriesGroup || (this.seriesGroup = c.g(\"series-group\").attr({\n          zIndex: 3\n        }).shadow(this.options.chart.seriesGroupShadow).add());\n        this.renderSeries();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      }\n      addCredits(b) {\n        const a = this,\n          c = P(!0, this.options.credits, b);\n        c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          c.href && (l.location.href = c.href);\n        }).attr({\n          align: c.position.align,\n          zIndex: 8\n        }), a.styledMode || this.credits.css(c.style), this.credits.add().align(c.position), this.credits.update = function (b) {\n          a.credits = a.credits.destroy();\n          a.addCredits(b);\n        });\n      }\n      destroy() {\n        const b = this,\n          a = b.axes,\n          c = b.series,\n          f = b.container,\n          g = f && f.parentNode;\n        let e;\n        O(b, \"destroy\");\n        b.renderer.forExport ? Q(E, b) : E[b.index] = void 0;\n        G.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        Z(b);\n        for (e = a.length; e--;) a[e] = a[e].destroy();\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n        for (e = c.length; e--;) c[e] = c[e].destroy();\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          const c = b[a];\n          c && c.destroy && (b[a] = c.destroy());\n        });\n        f && (f.innerHTML = p.emptyHTML, Z(f), g && z(f));\n        ca(b, function (a, c) {\n          delete b[c];\n        });\n      }\n      firstRender() {\n        const b = this,\n          a = b.options;\n        b.getContainer();\n        b.resetMargins();\n        b.setChartSize();\n        b.propFromSeries();\n        b.getAxes();\n        (da(a.series) ? a.series : []).forEach(function (a) {\n          b.initSeries(a);\n        });\n        b.linkSeries();\n        b.setSeriesData();\n        O(b, \"beforeRender\");\n        b.render();\n        b.pointer.getChartPosition();\n        if (!b.renderer.imgCount && !b.hasLoaded) b.onload();\n        b.temporaryDisplay(!0);\n      }\n      onload() {\n        this.callbacks.concat([this.callback]).forEach(function (b) {\n          b && \"undefined\" !== typeof this.index && b.apply(this, [this]);\n        }, this);\n        O(this, \"load\");\n        O(this, \"render\");\n        J(this.index) && this.setReflow();\n        this.warnIfA11yModuleNotLoaded();\n        this.hasLoaded = !0;\n      }\n      warnIfA11yModuleNotLoaded() {\n        const {\n          options: b,\n          title: a\n        } = this;\n        b && !this.accessibility && (this.renderer.boxWrapper.attr({\n          role: \"img\",\n          \"aria-label\": (a && a.element.textContent || \"\").replace(/</g, \"&lt;\")\n        }), b.accessibility && !1 === b.accessibility.enabled || S('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n      }\n      addSeries(b, a, c) {\n        const f = this;\n        let g;\n        b && (a = T(a, !0), O(f, \"addSeries\", {\n          options: b\n        }, function () {\n          g = f.initSeries(b);\n          f.isDirtyLegend = !0;\n          f.linkSeries();\n          g.enabledDataSorting && g.setData(b.data, !1);\n          O(f, \"afterAddSeries\", {\n            series: g\n          });\n          a && f.redraw(c);\n        }));\n        return g;\n      }\n      addAxis(b, a, c, f) {\n        return this.createAxis(a ? \"xAxis\" : \"yAxis\", {\n          axis: b,\n          redraw: c,\n          animation: f\n        });\n      }\n      addColorAxis(b, a, c) {\n        return this.createAxis(\"colorAxis\", {\n          axis: b,\n          redraw: a,\n          animation: c\n        });\n      }\n      createAxis(b, a) {\n        b = new A(this, P(a.axis, {\n          index: this[b].length,\n          isX: \"xAxis\" === b\n        }));\n        T(a.redraw, !0) && this.redraw(a.animation);\n        return b;\n      }\n      showLoading(b) {\n        const a = this,\n          c = a.options,\n          e = c.loading,\n          d = function () {\n            l && x(l, {\n              left: a.plotLeft + \"px\",\n              top: a.plotTop + \"px\",\n              width: a.plotWidth + \"px\",\n              height: a.plotHeight + \"px\"\n            });\n          };\n        let l = a.loadingDiv,\n          h = a.loadingSpan;\n        l || (a.loadingDiv = l = f(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, a.container));\n        h || (a.loadingSpan = h = f(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, l), g(a, \"redraw\", d));\n        l.className = \"highcharts-loading\";\n        p.setElementHTML(h, T(b, c.lang.loading, \"\"));\n        a.styledMode || (x(l, R(e.style, {\n          zIndex: 10\n        })), x(h, e.labelStyle), a.loadingShown || (x(l, {\n          opacity: 0,\n          display: \"\"\n        }), m(l, {\n          opacity: e.style.opacity || .5\n        }, {\n          duration: e.showDuration || 0\n        })));\n        a.loadingShown = !0;\n        d();\n      }\n      hideLoading() {\n        const b = this.options,\n          a = this.loadingDiv;\n        a && (a.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || m(a, {\n          opacity: 0\n        }, {\n          duration: b.loading.hideDuration || 100,\n          complete: function () {\n            x(a, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      }\n      update(b, a, f, g) {\n        const e = this,\n          d = {\n            credits: \"addCredits\",\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          },\n          l = b.isResponsiveOptions,\n          k = [];\n        let q, m;\n        O(e, \"update\", {\n          options: b\n        });\n        l || e.setResponsive(!1, !0);\n        b = c(b, e.options);\n        e.userOptions = P(e.userOptions, b);\n        var n = b.chart;\n        if (n) {\n          P(!0, e.options.chart, n);\n          \"className\" in n && e.setClassName(n.className);\n          if (\"inverted\" in n || \"polar\" in n || \"type\" in n) {\n            e.propFromSeries();\n            var x = !0;\n          }\n          \"alignTicks\" in n && (x = !0);\n          \"events\" in n && u(this, n);\n          ca(n, function (b, a) {\n            -1 !== e.propsRequireUpdateSeries.indexOf(\"chart.\" + a) && (q = !0);\n            -1 !== e.propsRequireDirtyBox.indexOf(a) && (e.isDirtyBox = !0);\n            -1 !== e.propsRequireReflow.indexOf(a) && (l ? e.isDirtyBox = !0 : m = !0);\n          });\n          !e.styledMode && n.style && e.renderer.setStyle(e.options.chart.style || {});\n        }\n        !e.styledMode && b.colors && (this.options.colors = b.colors);\n        b.time && (this.time === h && (this.time = new r(b.time)), P(!0, e.options.time, b.time));\n        ca(b, function (a, c) {\n          if (e[c] && \"function\" === typeof e[c].update) e[c].update(a, !1);else if (\"function\" === typeof e[d[c]]) e[d[c]](a);else \"colors\" !== c && -1 === e.collectionsWithUpdate.indexOf(c) && P(!0, e.options[c], b[c]);\n          \"chart\" !== c && -1 !== e.propsRequireUpdateSeries.indexOf(c) && (q = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          let c;\n          b[a] && (c = [], e[a].forEach(function (b, a) {\n            b.options.isInternal || c.push(T(b.options.index, a));\n          }), ea(b[a]).forEach(function (b, g) {\n            const d = J(b.id);\n            let l;\n            d && (l = e.get(b.id));\n            !l && e[a] && (l = e[a][c ? c[g] : g]) && d && J(l.options.id) && (l = void 0);\n            l && l.coll === a && (l.update(b, !1), f && (l.touched = !0));\n            !l && f && e.collectionsWithInit[a] && (e.collectionsWithInit[a][0].apply(e, [b].concat(e.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);\n          }), f && e[a].forEach(function (b) {\n            b.touched || b.options.isInternal ? delete b.touched : k.push(b);\n          }));\n        });\n        k.forEach(function (b) {\n          b.chart && b.remove && b.remove(!1);\n        });\n        x && e.axes.forEach(function (b) {\n          b.update({}, !1);\n        });\n        q && e.getSeriesOrderByLinks().forEach(function (b) {\n          b.chart && b.update({}, !1);\n        }, this);\n        x = n && n.width;\n        n = n && (Y(n.height) ? U(n.height, x || e.chartWidth) : n.height);\n        m || W(x) && x !== e.chartWidth || W(n) && n !== e.chartHeight ? e.setSize(x, n, g) : T(a, !0) && e.redraw(g);\n        O(e, \"afterUpdate\", {\n          options: b,\n          redraw: a,\n          animation: g\n        });\n      }\n      setSubtitle(b, a) {\n        this.applyDescription(\"subtitle\", b);\n        this.layOutTitles(a);\n      }\n      setCaption(b, a) {\n        this.applyDescription(\"caption\", b);\n        this.layOutTitles(a);\n      }\n      showResetZoom() {\n        function b() {\n          a.zoomOut();\n        }\n        const a = this,\n          c = n.lang,\n          f = a.options.chart.zooming.resetButton,\n          g = f.theme,\n          e = \"chart\" === f.relativeTo || \"spacingBox\" === f.relativeTo ? null : \"scrollablePlotBox\";\n        O(this, \"beforeShowResetZoom\", null, function () {\n          a.resetZoomButton = a.renderer.button(c.resetZoom, null, null, b, g).attr({\n            align: f.position.align,\n            title: c.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(f.position, !1, e);\n        });\n        O(this, \"afterShowResetZoom\");\n      }\n      zoomOut() {\n        O(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      }\n      zoom(b) {\n        const a = this,\n          c = a.pointer;\n        let f = !1,\n          g;\n        !b || b.resetSelection ? (a.axes.forEach(function (b) {\n          g = b.zoom();\n        }), c.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {\n          const e = b.axis;\n          if (c[e.isXAxis ? \"zoomX\" : \"zoomY\"] && J(c.mouseDownX) && J(c.mouseDownY) && a.isInsidePlot(c.mouseDownX - a.plotLeft, c.mouseDownY - a.plotTop, {\n            axis: e\n          }) || !J(a.inverted ? c.mouseDownX : c.mouseDownY)) g = e.zoom(b.min, b.max), e.displayBtn && (f = !0);\n        });\n        const e = a.resetZoomButton;\n        f && !e ? a.showResetZoom() : !f && K(e) && (a.resetZoomButton = e.destroy());\n        g && a.redraw(T(a.options.chart.animation, b && b.animation, 100 > a.pointCount));\n      }\n      pan(b, a) {\n        const c = this,\n          f = c.hoverPoints;\n        a = \"object\" === typeof a ? a : {\n          enabled: a,\n          type: \"x\"\n        };\n        const g = c.options.chart;\n        g && g.panning && (g.panning = a);\n        const e = a.type;\n        let d;\n        O(this, \"pan\", {\n          originalEvent: b\n        }, function () {\n          f && f.forEach(function (b) {\n            b.setState();\n          });\n          let a = c.xAxis;\n          \"xy\" === e ? a = a.concat(c.yAxis) : \"y\" === e && (a = c.yAxis);\n          const g = {};\n          a.forEach(function (a) {\n            if (a.options.panningEnabled && !a.options.isInternal) {\n              var f = a.horiz,\n                l = b[f ? \"chartX\" : \"chartY\"];\n              f = f ? \"mouseDownX\" : \"mouseDownY\";\n              var h = c[f],\n                k = a.minPointOffset || 0,\n                q = a.reversed && !c.inverted || !a.reversed && c.inverted ? -1 : 1,\n                m = a.getExtremes(),\n                n = a.toValue(h - l, !0) + k * q,\n                x = a.toValue(h + a.len - l, !0) - (k * q || a.isXAxis && a.pointRangePadding || 0),\n                w = x < n;\n              q = a.hasVerticalPanning();\n              h = w ? x : n;\n              n = w ? n : x;\n              var p = a.panningState;\n              !q || a.isXAxis || p && !p.isDirty || a.series.forEach(function (b) {\n                var a = b.getProcessedData(!0);\n                a = b.getExtremes(a.yData, !0);\n                p || (p = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                W(a.dataMin) && W(a.dataMax) && (p.startMin = Math.min(T(b.options.threshold, Infinity), a.dataMin, p.startMin), p.startMax = Math.max(T(b.options.threshold, -Infinity), a.dataMax, p.startMax));\n              });\n              q = Math.min(T(p && p.startMin, m.dataMin), k ? m.min : a.toValue(a.toPixels(m.min) - a.minPixelPadding));\n              x = Math.max(T(p && p.startMax, m.dataMax), k ? m.max : a.toValue(a.toPixels(m.max) + a.minPixelPadding));\n              a.panningState = p;\n              a.isOrdinal || (k = q - h, 0 < k && (n += k, h = q), k = n - x, 0 < k && (n = x, h -= k), a.series.length && h !== m.min && n !== m.max && h >= q && n <= x && (a.setExtremes(h, n, !1, !1, {\n                trigger: \"pan\"\n              }), !c.resetZoomButton && h !== q && n !== x && e.match(\"y\") && (c.showResetZoom(), a.displayBtn = !1), d = !0), g[f] = l);\n            }\n          });\n          ca(g, (b, a) => {\n            c[a] = b;\n          });\n          d && c.redraw(!1);\n          x(c.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    }\n    R(aa.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [aa.prototype.addAxis, [!0]],\n        yAxis: [aa.prototype.addAxis, [!1]],\n        series: [aa.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n    \"\";\n    return aa;\n  });\n  M(a, \"Core/Legend/LegendSymbol.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      extend: u,\n      merge: H,\n      pick: I\n    } = a;\n    var F = /*#__PURE__*/(() => {\n      (function (a) {\n        a.lineMarker = function (a, B) {\n          B = this.legendItem = this.legendItem || {};\n          var t = this.options;\n          const r = a.symbolWidth,\n            d = a.symbolHeight,\n            p = d / 2,\n            m = this.chart.renderer,\n            k = B.group;\n          a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n          let v = {},\n            n = t.marker,\n            h = 0;\n          this.chart.styledMode || (v = {\n            \"stroke-width\": Math.min(t.lineWidth || 0, 24)\n          }, t.dashStyle ? v.dashstyle = t.dashStyle : \"square\" !== t.linecap && (v[\"stroke-linecap\"] = \"round\"));\n          B.line = m.path().addClass(\"highcharts-graph\").attr(v).add(k);\n          v[\"stroke-linecap\"] && (h = Math.min(B.line.strokeWidth(), r) / 2);\n          r && B.line.attr({\n            d: [[\"M\", h, a], [\"L\", r - h, a]]\n          });\n          n && !1 !== n.enabled && r && (t = Math.min(I(n.radius, p), p), 0 === this.symbol.indexOf(\"url\") && (n = H(n, {\n            width: d,\n            height: d\n          }), t = 0), B.symbol = B = m.symbol(this.symbol, r / 2 - t, a - t, 2 * t, 2 * t, u({\n            context: \"legend\"\n          }, n)).addClass(\"highcharts-point\").add(k), B.isMarker = !0);\n        };\n        a.rectangle = function (a, u) {\n          u = u.legendItem || {};\n          const t = a.symbolHeight,\n            r = a.options.squareSymbol;\n          u.symbol = this.chart.renderer.rect(r ? (a.symbolWidth - t) / 2 : 0, a.baseline - t + 1, r ? t : a.symbolWidth, t, I(a.options.symbolRadius, t / 2)).addClass(\"highcharts-point\").attr({\n            zIndex: 3\n          }).add(u.group);\n        };\n      })(F || (F = {}));\n      return F;\n    })();\n    return F;\n  });\n  M(a, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 1,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function () {\n          const {\n            numberFormatter: a\n          } = this.series.chart;\n          return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    };\n  });\n  M(a, \"Core/Series/Series.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Legend/LegendSymbol.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/SeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C, B, t, r) {\n    const {\n        animObject: d,\n        setAnimation: p\n      } = a,\n      {\n        defaultOptions: m\n      } = A,\n      {\n        registerEventOptions: k\n      } = H,\n      {\n        hasTouch: v,\n        svg: n,\n        win: h\n      } = I,\n      {\n        seriesTypes: D\n      } = B,\n      {\n        arrayMax: u,\n        arrayMin: E,\n        clamp: e,\n        cleanRecursively: q,\n        correctFloat: y,\n        defined: l,\n        erase: w,\n        error: g,\n        extend: b,\n        find: c,\n        fireEvent: f,\n        getNestedProperty: x,\n        isArray: J,\n        isNumber: z,\n        isString: Q,\n        merge: S,\n        objectEach: R,\n        pick: N,\n        removeEvent: O,\n        splat: ba,\n        syncTimeout: da\n      } = r;\n    class W {\n      constructor() {\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n      init(a, c) {\n        f(this, \"init\", {\n          options: c\n        });\n        const g = this,\n          e = a.series;\n        this.eventsToUnbind = [];\n        g.chart = a;\n        g.options = g.setOptions(c);\n        c = g.options;\n        g.linkedSeries = [];\n        g.bindAxes();\n        b(g, {\n          name: c.name,\n          state: \"\",\n          visible: !1 !== c.visible,\n          selected: !0 === c.selected\n        });\n        k(this, c);\n        const d = c.events;\n        if (d && d.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0;\n        g.getColor();\n        g.getSymbol();\n        g.parallelArrays.forEach(function (b) {\n          g[b + \"Data\"] || (g[b + \"Data\"] = []);\n        });\n        g.isCartesian && (a.hasCartesianSeries = !0);\n        let l;\n        e.length && (l = e[e.length - 1]);\n        g._i = N(l && l._i, -1) + 1;\n        g.opacity = g.options.opacity;\n        a.orderSeries(this.insert(e));\n        c.dataSorting && c.dataSorting.enabled ? g.setDataSortingOptions() : g.points || g.data || g.setData(c.data, !1);\n        f(this, \"afterInit\");\n      }\n      is(b) {\n        return D[b] && this instanceof D[b];\n      }\n      insert(b) {\n        const a = this.options.index;\n        let c;\n        if (z(a)) {\n          for (c = b.length; c--;) if (a >= N(b[c].options.index, b[c]._i)) {\n            b.splice(c + 1, 0, this);\n            break;\n          }\n          -1 === c && b.unshift(this);\n          c += 1;\n        } else b.push(this);\n        return N(c, b.length - 1);\n      }\n      bindAxes() {\n        const b = this,\n          a = b.options,\n          c = b.chart;\n        let e;\n        f(this, \"bindAxes\", null, function () {\n          (b.axisTypes || []).forEach(function (f) {\n            let d = 0;\n            c[f].forEach(function (c) {\n              e = c.options;\n              if (a[f] === d && !e.isInternal || \"undefined\" !== typeof a[f] && a[f] === e.id || \"undefined\" === typeof a[f] && 0 === e.index) b.insert(c.series), b[f] = c, c.isDirty = !0;\n              e.isInternal || d++;\n            });\n            b[f] || b.optionalAxis === f || g(18, !0, c);\n          });\n        });\n        f(this, \"afterBindAxes\");\n      }\n      updateParallelArrays(b, a, c) {\n        const f = b.series,\n          g = z(a) ? function (c) {\n            const g = \"y\" === c && f.toYData ? f.toYData(b) : b[c];\n            f[c + \"Data\"][a] = g;\n          } : function (b) {\n            Array.prototype[a].apply(f[b + \"Data\"], c);\n          };\n        f.parallelArrays.forEach(g);\n      }\n      hasData() {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      }\n      autoIncrement(b) {\n        var a = this.options;\n        const c = a.pointIntervalUnit,\n          f = a.relativeXValue,\n          g = this.chart.time;\n        let e = this.xIncrement,\n          d;\n        e = N(e, a.pointStart, 0);\n        this.pointInterval = d = N(this.pointInterval, a.pointInterval, 1);\n        f && z(b) && (d *= b);\n        c && (a = new g.Date(e), \"day\" === c ? g.set(\"Date\", a, g.get(\"Date\", a) + d) : \"month\" === c ? g.set(\"Month\", a, g.get(\"Month\", a) + d) : \"year\" === c && g.set(\"FullYear\", a, g.get(\"FullYear\", a) + d), d = a.getTime() - e);\n        if (f && z(b)) return e + d;\n        this.xIncrement = e + d;\n        return e;\n      }\n      setDataSortingOptions() {\n        const a = this.options;\n        b(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        l(a.pointRange) || (a.pointRange = 1);\n      }\n      setOptions(b) {\n        var a = this.chart,\n          c = a.options,\n          g = c.plotOptions,\n          e = a.userOptions || {};\n        b = S(b);\n        a = a.styledMode;\n        const d = {\n          plotOptions: g,\n          userOptions: b\n        };\n        f(this, \"setOptions\", d);\n        const h = d.plotOptions[this.type],\n          k = e.plotOptions || {};\n        this.userOptions = d.userOptions;\n        e = S(h, g.series, e.plotOptions && e.plotOptions[this.type], b);\n        this.tooltipOptions = S(m.tooltip, m.plotOptions.series && m.plotOptions.series.tooltip, m.plotOptions[this.type].tooltip, c.tooltip.userOptions, g.series && g.series.tooltip, g[this.type].tooltip, b.tooltip);\n        this.stickyTracking = N(b.stickyTracking, k[this.type] && k[this.type].stickyTracking, k.series && k.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);\n        null === h.marker && delete e.marker;\n        this.zoneAxis = e.zoneAxis;\n        g = this.zones = (e.zones || []).slice();\n        !e.negativeColor && !e.negativeFillColor || e.zones || (c = {\n          value: e[this.zoneAxis + \"Threshold\"] || e.threshold || 0,\n          className: \"highcharts-negative\"\n        }, a || (c.color = e.negativeColor, c.fillColor = e.negativeFillColor), g.push(c));\n        g.length && l(g[g.length - 1].value) && g.push(a ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        f(this, \"afterSetOptions\", {\n          options: e\n        });\n        return e;\n      }\n      getName() {\n        return N(this.options.name, \"Series \" + (this.index + 1));\n      }\n      getCyclic(b, a, c) {\n        const f = this.chart,\n          g = this.userOptions,\n          e = b + \"Index\",\n          d = b + \"Counter\",\n          h = c ? c.length : N(f.options.chart[b + \"Count\"], f[b + \"Count\"]);\n        if (!a) {\n          var k = N(g[e], g[\"_\" + e]);\n          l(k) || (f.series.length || (f[d] = 0), g[\"_\" + e] = k = f[d] % h, f[d] += 1);\n          c && (a = c[k]);\n        }\n        \"undefined\" !== typeof k && (this[e] = k);\n        this[b] = a;\n      }\n      getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || m.plotOptions[this.type].color, this.chart.options.colors);\n      }\n      getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      }\n      getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      }\n      findPointIndex(b, a) {\n        const f = b.id,\n          g = b.x,\n          e = this.points;\n        var d = this.options.dataSorting,\n          l;\n        let h, k;\n        if (f) d = this.chart.get(f), d instanceof G && (l = d);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (l = a => !a.touched && a.index === b.index, d && d.matchByName ? l = a => !a.touched && a.name === b.name : this.options.relativeXValue && (l = a => !a.touched && a.options.x === b.x), l = c(e, l), !l) return;\n        l && (k = l && l.index, \"undefined\" !== typeof k && (h = !0));\n        \"undefined\" === typeof k && z(g) && (k = this.xData.indexOf(g, a));\n        -1 !== k && \"undefined\" !== typeof k && this.cropped && (k = k >= this.cropStart ? k - this.cropStart : k);\n        !h && z(k) && e[k] && e[k].touched && (k = void 0);\n        return k;\n      }\n      updateData(b, a) {\n        const c = this.options,\n          f = c.dataSorting,\n          g = this.points,\n          e = [],\n          d = this.requireSorting,\n          h = b.length === g.length;\n        let k,\n          q,\n          m,\n          n = !0;\n        this.xIncrement = null;\n        b.forEach(function (b, a) {\n          var q = l(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b) || {};\n          const n = q.x;\n          if (q.id || z(n)) {\n            if (q = this.findPointIndex(q, m), -1 === q || \"undefined\" === typeof q ? e.push(b) : g[q] && b !== c.data[q] ? (g[q].update(b, !1, null, !1), g[q].touched = !0, d && (m = q + 1)) : g[q] && (g[q].touched = !0), !h || a !== q || f && f.enabled || this.hasDerivedData) k = !0;\n          } else e.push(b);\n        }, this);\n        if (k) for (b = g.length; b--;) (q = g[b]) && !q.touched && q.remove && q.remove(!1, a);else !h || f && f.enabled ? n = !1 : (b.forEach(function (b, a) {\n          b === g[a].y || g[a].destroyed || g[a].update(b, !1, null, !1);\n        }), e.length = 0);\n        g.forEach(function (b) {\n          b && (b.touched = !1);\n        });\n        if (!n) return !1;\n        e.forEach(function (b) {\n          this.addPoint(b, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = u(this.xData), this.autoIncrement());\n        return !0;\n      }\n      setData(b, a = !0, c, f) {\n        var e;\n        const d = this,\n          l = d.points,\n          h = l && l.length || 0,\n          k = d.options,\n          q = d.chart,\n          n = k.dataSorting,\n          m = d.xAxis,\n          x = k.turboThreshold,\n          w = this.xData,\n          p = this.yData;\n        var y = d.pointArrayMap;\n        y = y && y.length;\n        const r = k.keys;\n        let v,\n          K = 0,\n          D = 1,\n          t = null;\n        if (!q.options.chart.allowMutatingData) {\n          k.data && delete d.options.data;\n          d.userOptions.data && delete d.userOptions.data;\n          var u = S(!0, b);\n        }\n        b = u || b || [];\n        u = b.length;\n        n && n.enabled && (b = this.sortData(b));\n        q.options.chart.allowMutatingData && !1 !== f && u && h && !d.cropped && !d.hasGroupedData && d.visible && !d.boosted && (v = this.updateData(b, c));\n        if (!v) {\n          d.xIncrement = null;\n          d.colorCounter = 0;\n          this.parallelArrays.forEach(function (b) {\n            d[b + \"Data\"].length = 0;\n          });\n          if (x && u > x) {\n            if (t = d.getFirstValidPoint(b), z(t)) for (c = 0; c < u; c++) w[c] = this.autoIncrement(), p[c] = b[c];else if (J(t)) {\n              if (y) {\n                if (t.length === y) for (c = 0; c < u; c++) w[c] = this.autoIncrement(), p[c] = b[c];else for (c = 0; c < u; c++) f = b[c], w[c] = f[0], p[c] = f.slice(1, y + 1);\n              } else if (r && (K = r.indexOf(\"x\"), D = r.indexOf(\"y\"), K = 0 <= K ? K : 0, D = 0 <= D ? D : 1), 1 === t.length && (D = 0), K === D) for (c = 0; c < u; c++) w[c] = this.autoIncrement(), p[c] = b[c][D];else for (c = 0; c < u; c++) f = b[c], w[c] = f[K], p[c] = f[D];\n            } else g(12, !1, q);\n          } else for (c = 0; c < u; c++) f = {\n            series: d\n          }, d.pointClass.prototype.applyOptions.apply(f, [b[c]]), d.updateParallelArrays(f, c);\n          p && Q(p[0]) && g(14, !0, q);\n          d.data = [];\n          d.options.data = d.userOptions.data = b;\n          for (c = h; c--;) null === (e = l[c]) || void 0 === e ? void 0 : e.destroy();\n          m && (m.minRange = m.userMinRange);\n          d.isDirty = q.isDirtyBox = !0;\n          d.isDirtyData = !!l;\n          c = !1;\n        }\n        \"point\" === k.legendType && (this.processData(), this.generatePoints());\n        a && q.redraw(c);\n      }\n      sortData(b) {\n        const a = this,\n          c = a.options.dataSorting.sortKey || \"y\",\n          f = function (b, a) {\n            return l(a) && b.pointClass.prototype.optionsToObject.call({\n              series: b\n            }, a) || {};\n          };\n        b.forEach(function (c, g) {\n          b[g] = f(a, c);\n          b[g].index = g;\n        }, this);\n        b.concat().sort((b, a) => {\n          b = x(c, b);\n          a = x(c, a);\n          return a < b ? -1 : a > b ? 1 : 0;\n        }).forEach(function (b, a) {\n          b.x = a;\n        }, this);\n        a.linkedSeries && a.linkedSeries.forEach(function (a) {\n          const c = a.options,\n            g = c.data;\n          c.dataSorting && c.dataSorting.enabled || !g || (g.forEach(function (c, e) {\n            g[e] = f(a, c);\n            b[e] && (g[e].x = b[e].x, g[e].index = e);\n          }), a.setData(g, !1));\n        });\n        return b;\n      }\n      getProcessedData(b) {\n        var a = this.xAxis,\n          c = this.options,\n          f = c.cropThreshold;\n        const e = b || this.getExtremesFromAll || c.getExtremesFromAll,\n          d = this.isCartesian;\n        b = a && a.val2lin;\n        c = !(!a || !a.logarithmic);\n        let l = 0,\n          h;\n        let k,\n          q,\n          m = this.xData,\n          n = this.yData,\n          x = this.requireSorting;\n        var w = !1;\n        const p = m.length;\n        a && (w = a.getExtremes(), k = w.min, q = w.max, w = !(!a.categories || a.names.length));\n        if (d && this.sorted && !e && (!f || p > f || this.forceCrop)) if (m[p - 1] < k || m[0] > q) m = [], n = [];else if (this.yData && (m[0] < k || m[p - 1] > q)) {\n          var z = this.cropData(this.xData, this.yData, k, q);\n          m = z.xData;\n          n = z.yData;\n          l = z.start;\n          z = !0;\n        }\n        for (f = m.length || 1; --f;) a = c ? b(m[f]) - b(m[f - 1]) : m[f] - m[f - 1], 0 < a && (\"undefined\" === typeof h || a < h) ? h = a : 0 > a && x && !w && (g(15, !1, this.chart), x = !1);\n        return {\n          xData: m,\n          yData: n,\n          cropped: z,\n          cropStart: l,\n          closestPointRange: h\n        };\n      }\n      processData(b) {\n        const a = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;\n        b = this.getProcessedData();\n        this.cropped = b.cropped;\n        this.cropStart = b.cropStart;\n        this.processedXData = b.xData;\n        this.processedYData = b.yData;\n        this.closestPointRange = this.basePointRange = b.closestPointRange;\n        f(this, \"afterProcessData\");\n      }\n      cropData(b, a, c, f, g) {\n        const e = b.length;\n        let d,\n          l = 0,\n          h = e;\n        g = N(g, this.cropShoulder);\n        for (d = 0; d < e; d++) if (b[d] >= c) {\n          l = Math.max(0, d - g);\n          break;\n        }\n        for (c = d; c < e; c++) if (b[c] > f) {\n          h = c + g;\n          break;\n        }\n        return {\n          xData: b.slice(l, h),\n          yData: a.slice(l, h),\n          start: l,\n          end: h\n        };\n      }\n      generatePoints() {\n        var a = this.options;\n        const c = this.processedData || a.data,\n          g = this.processedXData,\n          e = this.processedYData,\n          d = this.pointClass,\n          l = g.length,\n          h = this.cropStart || 0,\n          k = this.hasGroupedData,\n          q = a.keys,\n          m = [];\n        a = a.dataGrouping && a.dataGrouping.groupAll ? h : 0;\n        let n;\n        let x,\n          w,\n          p = this.data;\n        if (!p && !k) {\n          var z = [];\n          z.length = c.length;\n          p = this.data = z;\n        }\n        q && k && (this.options.keys = !1);\n        for (w = 0; w < l; w++) z = h + w, k ? (x = new d().init(this, [g[w]].concat(ba(e[w]))), x.dataGroup = this.groupMap[a + w], x.dataGroup.options && (x.options = x.dataGroup.options, b(x, x.dataGroup.options), delete x.dataLabels)) : (x = p[z]) || \"undefined\" === typeof c[z] || (p[z] = x = new d().init(this, c[z], g[w])), x && (x.index = k ? a + w : z, m[w] = x);\n        this.options.keys = q;\n        if (p && (l !== (n = p.length) || k)) for (w = 0; w < n; w++) w !== h || k || (w += l), p[w] && (p[w].destroyElements(), p[w].plotX = void 0);\n        this.data = p;\n        this.points = m;\n        f(this, \"afterGeneratePoints\");\n      }\n      getXExtremes(b) {\n        return {\n          min: E(b),\n          max: u(b)\n        };\n      }\n      getExtremes(b, a) {\n        const c = this.xAxis;\n        var g = this.yAxis;\n        const e = this.processedXData || this.xData,\n          d = [],\n          l = this.requireSorting ? this.cropShoulder : 0;\n        g = g ? g.positiveValuesOnly : !1;\n        let h,\n          k = 0,\n          q = 0,\n          m = 0;\n        b = b || this.stackedYData || this.processedYData || [];\n        const n = b.length;\n        if (c) {\n          var x = c.getExtremes();\n          k = x.min;\n          q = x.max;\n        }\n        for (h = 0; h < n; h++) {\n          var w = e[h];\n          x = b[h];\n          var p = (z(x) || J(x)) && (x.length || 0 < x || !g);\n          w = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (e[h + l] || w) >= k && (e[h - l] || w) <= q;\n          if (p && w) if (p = x.length) for (; p--;) z(x[p]) && (d[m++] = x[p]);else d[m++] = x;\n        }\n        b = {\n          activeYData: d,\n          dataMin: E(d),\n          dataMax: u(d)\n        };\n        f(this, \"afterGetExtremes\", {\n          dataExtremes: b\n        });\n        return b;\n      }\n      applyExtremes() {\n        const b = this.getExtremes();\n        this.dataMin = b.dataMin;\n        this.dataMax = b.dataMax;\n        return b;\n      }\n      getFirstValidPoint(b) {\n        const a = b.length;\n        let c = 0,\n          f = null;\n        for (; null === f && c < a;) f = b[c], c++;\n        return f;\n      }\n      translate() {\n        var b;\n        this.processedXData || this.processData();\n        this.generatePoints();\n        const a = this.options,\n          c = a.stacking,\n          g = this.xAxis,\n          d = g.categories,\n          h = this.enabledDataSorting,\n          k = this.yAxis,\n          q = this.points,\n          m = q.length,\n          n = this.pointPlacementToXValue(),\n          x = !!n,\n          w = a.threshold,\n          p = a.startFromThreshold ? w : 0,\n          r = this.zoneAxis || \"y\";\n        let v,\n          D,\n          t,\n          u,\n          E = Number.MAX_VALUE;\n        for (v = 0; v < m; v++) {\n          const f = q[v],\n            m = f.x;\n          let K,\n            O,\n            Q = f.y,\n            L = f.low;\n          const P = c && (null === (b = k.stacking) || void 0 === b ? void 0 : b.stacks[(this.negStacks && Q < (p ? 0 : w) ? \"-\" : \"\") + this.stackKey]);\n          D = g.translate(m, !1, !1, !1, !0, n);\n          f.plotX = z(D) ? y(e(D, -1E5, 1E5)) : void 0;\n          c && this.visible && P && P[m] && (u = this.getStackIndicator(u, m, this.index), !f.isNull && u.key && (K = P[m], O = K.points[u.key]), K && J(O) && (L = O[0], Q = O[1], L === p && u.key === P[m].base && (L = N(z(w) ? w : k.min)), k.positiveValuesOnly && l(L) && 0 >= L && (L = void 0), f.total = f.stackTotal = N(K.total), f.percentage = l(f.y) && K.total ? f.y / K.total * 100 : void 0, f.stackY = Q, this.irregularWidths || K.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));\n          f.yBottom = l(L) ? e(k.translate(L, !1, !0, !1, !0), -1E5, 1E5) : void 0;\n          this.dataModify && (Q = this.dataModify.modifyValue(Q, v));\n          let R;\n          z(Q) && void 0 !== f.plotX && (R = k.translate(Q, !1, !0, !1, !0), R = z(R) ? e(R, -1E5, 1E5) : void 0);\n          f.plotY = R;\n          f.isInside = this.isPointInside(f);\n          f.clientX = x ? y(g.translate(m, !1, !1, !1, !0, n)) : D;\n          f.negative = f[r] < (a[r + \"Threshold\"] || w || 0);\n          f.category = N(d && d[f.x], f.x);\n          f.isNull || !1 === f.visible || (\"undefined\" !== typeof t && (E = Math.min(E, Math.abs(D - t))), t = D);\n          f.zone = this.zones.length ? f.getZone() : void 0;\n          !f.graphic && this.group && h && (f.isNew = !0);\n        }\n        this.closestPointRangePx = E;\n        f(this, \"afterTranslate\");\n      }\n      getValidPoints(b, a, c) {\n        const f = this.chart;\n        return (b || this.points || []).filter(function (b) {\n          const {\n            plotX: g,\n            plotY: e\n          } = b;\n          return !c && (b.isNull || !z(e)) || a && !f.isInsidePlot(g, e, {\n            inverted: f.inverted\n          }) ? !1 : !1 !== b.visible;\n        });\n      }\n      getClipBox() {\n        const {\n            chart: b,\n            xAxis: a,\n            yAxis: c\n          } = this,\n          f = S(b.clipBox);\n        a && a.len !== b.plotSizeX && (f.width = a.len);\n        c && c.len !== b.plotSizeY && (f.height = c.len);\n        return f;\n      }\n      getSharedClipKey() {\n        return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0);\n      }\n      setClip() {\n        const {\n            chart: b,\n            group: a,\n            markerGroup: c\n          } = this,\n          f = b.sharedClips,\n          g = b.renderer,\n          e = this.getClipBox(),\n          d = this.getSharedClipKey();\n        let l = f[d];\n        l ? l.animate(e) : f[d] = l = g.clipRect(e);\n        a && a.clip(!1 === this.options.clip ? void 0 : l);\n        c && c.clip();\n      }\n      animate(b) {\n        const {\n            chart: a,\n            group: c,\n            markerGroup: f\n          } = this,\n          g = a.inverted;\n        var e = d(this.options.animation),\n          l = [this.getSharedClipKey(), e.duration, e.easing, e.defer].join();\n        let h = a.sharedClips[l],\n          k = a.sharedClips[l + \"m\"];\n        if (b && c) e = this.getClipBox(), h ? h.attr(\"height\", e.height) : (e.width = 0, g && (e.x = a.plotHeight), h = a.renderer.clipRect(e), a.sharedClips[l] = h, k = a.renderer.clipRect({\n          x: -99,\n          y: -99,\n          width: g ? a.plotWidth + 199 : 99,\n          height: g ? 99 : a.plotHeight + 199\n        }), a.sharedClips[l + \"m\"] = k), c.clip(h), f && f.clip(k);else if (h && !h.hasClass(\"highcharts-animating\")) {\n          l = this.getClipBox();\n          const b = e.step;\n          f && f.element.childNodes.length && (e.step = function (a, c) {\n            b && b.apply(c, arguments);\n            \"width\" === c.prop && k && k.element && k.attr(g ? \"height\" : \"width\", a + 99);\n          });\n          h.addClass(\"highcharts-animating\").animate(l, e);\n        }\n      }\n      afterAnimate() {\n        this.setClip();\n        R(this.chart.sharedClips, (b, a, c) => {\n          b && !this.chart.container.querySelector(`[clip-path=\"url(#${b.id})\"]`) && (b.destroy(), delete c[a]);\n        });\n        this.finishedAnimating = !0;\n        f(this, \"afterAnimate\");\n      }\n      drawPoints(b = this.points) {\n        const a = this.chart,\n          c = a.styledMode,\n          {\n            colorAxis: f,\n            options: g\n          } = this,\n          e = g.marker,\n          d = this[this.specialGroup || \"markerGroup\"],\n          l = this.xAxis,\n          h = N(e.enabled, !l || l.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);\n        let k, q, m, n;\n        let x, w;\n        if (!1 !== e.enabled || this._hasPointMarkers) for (k = 0; k < b.length; k++) {\n          q = b[k];\n          n = (m = q.graphic) ? \"animate\" : \"attr\";\n          var p = q.marker || {};\n          x = !!q.marker;\n          if ((h && \"undefined\" === typeof p.enabled || p.enabled) && !q.isNull && !1 !== q.visible) {\n            const b = N(p.symbol, this.symbol, \"rect\");\n            w = this.markerAttribs(q, q.selected && \"select\");\n            this.enabledDataSorting && (q.startXPos = l.reversed ? -(w.width || 0) : l.width);\n            const g = !1 !== q.isInside;\n            !m && g && (0 < (w.width || 0) || q.hasImage) && (q.graphic = m = a.renderer.symbol(b, w.x, w.y, w.width, w.height, x ? p : e).add(d), this.enabledDataSorting && a.hasRendered && (m.attr({\n              x: q.startXPos\n            }), n = \"animate\"));\n            m && \"animate\" === n && m[g ? \"show\" : \"hide\"](g).animate(w);\n            if (m) if (p = this.pointAttribs(q, c || !q.selected ? void 0 : \"select\"), c) f && m.css({\n              fill: p.fill\n            });else m[n](p);\n            m && m.addClass(q.getClassName(), !0);\n          } else m && (q.graphic = m.destroy());\n        }\n      }\n      markerAttribs(b, a) {\n        const c = this.options;\n        var f = c.marker;\n        const g = b.marker || {},\n          e = g.symbol || f.symbol,\n          d = {};\n        let l = N(g.radius, f && f.radius);\n        a && (f = f.states[a], a = g.states && g.states[a], l = N(a && a.radius, f && f.radius, l && l + (f && f.radiusPlus || 0)));\n        b.hasImage = e && 0 === e.indexOf(\"url\");\n        b.hasImage && (l = 0);\n        b = b.pos();\n        z(l) && b && (d.x = b[0] - l, d.y = b[1] - l, c.crisp && (d.x = Math.floor(d.x)));\n        l && (d.width = d.height = 2 * l);\n        return d;\n      }\n      pointAttribs(b, a) {\n        var c = this.options.marker,\n          f = b && b.options;\n        const g = f && f.marker || {};\n        var e = f && f.color,\n          d = b && b.color;\n        const l = b && b.zone && b.zone.color;\n        let h = this.color;\n        b = N(g.lineWidth, c.lineWidth);\n        f = 1;\n        h = e || l || d || h;\n        e = g.fillColor || c.fillColor || h;\n        d = g.lineColor || c.lineColor || h;\n        a = a || \"normal\";\n        c = c.states[a] || {};\n        a = g.states && g.states[a] || {};\n        b = N(a.lineWidth, c.lineWidth, b + N(a.lineWidthPlus, c.lineWidthPlus, 0));\n        e = a.fillColor || c.fillColor || e;\n        d = a.lineColor || c.lineColor || d;\n        f = N(a.opacity, c.opacity, f);\n        return {\n          stroke: d,\n          \"stroke-width\": b,\n          fill: e,\n          opacity: f\n        };\n      }\n      destroy(b) {\n        const a = this,\n          c = a.chart,\n          g = /AppleWebKit\\/533/.test(h.navigator.userAgent),\n          e = a.data || [];\n        let d, l, k, q;\n        f(a, \"destroy\", {\n          keepEventsForUpdate: b\n        });\n        this.removeEvents(b);\n        (a.axisTypes || []).forEach(function (b) {\n          (q = a[b]) && q.series && (w(q.series, a), q.isDirty = q.forceRedraw = !0);\n        });\n        a.legendItem && a.chart.legend.destroyItem(a);\n        for (l = e.length; l--;) (k = e[l]) && k.destroy && k.destroy();\n        a.clips && a.clips.forEach(b => b.destroy());\n        r.clearTimeout(a.animationTimeout);\n        R(a, function (b, a) {\n          b instanceof t && !b.survive && (d = g && \"group\" === a ? \"hide\" : \"destroy\", b[d]());\n        });\n        c.hoverSeries === a && (c.hoverSeries = void 0);\n        w(c.series, a);\n        c.orderSeries();\n        R(a, function (c, f) {\n          b && \"hcEvents\" === f || delete a[f];\n        });\n      }\n      applyZones() {\n        const b = this,\n          a = this.chart,\n          c = a.renderer,\n          f = this.zones,\n          g = this.clips || [],\n          d = this.graph,\n          l = this.area,\n          h = Math.max(a.plotWidth, a.plotHeight),\n          k = this[(this.zoneAxis || \"y\") + \"Axis\"],\n          q = a.inverted;\n        let m,\n          n,\n          x,\n          w,\n          p,\n          z,\n          y,\n          v,\n          r,\n          J,\n          D,\n          t = !1;\n        f.length && (d || l) && k && \"undefined\" !== typeof k.min ? (p = k.reversed, z = k.horiz, d && !this.showLine && d.hide(), l && l.hide(), w = k.getExtremes(), f.forEach(function (f, u) {\n          m = p ? z ? a.plotWidth : 0 : z ? 0 : k.toPixels(w.min) || 0;\n          m = e(N(n, m), 0, h);\n          n = e(Math.round(k.toPixels(N(f.value, w.max), !0) || 0), 0, h);\n          t && (m = n = k.toPixels(w.max));\n          y = Math.abs(m - n);\n          v = Math.min(m, n);\n          r = Math.max(m, n);\n          k.isXAxis ? (x = {\n            x: q ? r : v,\n            y: 0,\n            width: y,\n            height: h\n          }, z || (x.x = a.plotHeight - x.x)) : (x = {\n            x: 0,\n            y: q ? r : v,\n            width: h,\n            height: y\n          }, z && (x.y = a.plotWidth - x.y));\n          g[u] ? g[u].animate(x) : g[u] = c.clipRect(x);\n          J = b[\"zone-area-\" + u];\n          D = b[\"zone-graph-\" + u];\n          d && D && D.clip(g[u]);\n          l && J && J.clip(g[u]);\n          t = f.value > w.max;\n          b.resetZones && 0 === n && (n = void 0);\n        }), this.clips = g) : b.visible && (d && d.show(), l && l.show());\n      }\n      plotGroup(b, a, c, f, g) {\n        let e = this[b];\n        const d = !e;\n        c = {\n          visibility: c,\n          zIndex: f || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (c.opacity = this.opacity);\n        d && (this[b] = e = this.chart.renderer.g().add(g));\n        e.addClass(\"highcharts-\" + a + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (l(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        e.attr(c)[d ? \"attr\" : \"animate\"](this.getPlotBox(a));\n        return e;\n      }\n      getPlotBox(b) {\n        let a = this.xAxis,\n          c = this.yAxis;\n        const f = this.chart;\n        b = f.inverted && !f.polar && a && !1 !== this.invertible && \"series\" === b;\n        f.inverted && (a = c, c = this.xAxis);\n        return {\n          translateX: a ? a.left : f.plotLeft,\n          translateY: c ? c.top : f.plotTop,\n          rotation: b ? 90 : 0,\n          rotationOriginX: b ? (a.len - c.len) / 2 : 0,\n          rotationOriginY: b ? (a.len + c.len) / 2 : 0,\n          scaleX: b ? -1 : 1,\n          scaleY: 1\n        };\n      }\n      removeEvents(b) {\n        b || O(this);\n        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {\n          b();\n        }), this.eventsToUnbind.length = 0);\n      }\n      render() {\n        const b = this;\n        var a = b.chart;\n        const c = b.options,\n          g = d(c.animation),\n          e = b.visible ? \"inherit\" : \"hidden\",\n          l = c.zIndex,\n          h = b.hasRendered;\n        a = a.seriesGroup;\n        let k = b.finishedAnimating ? 0 : g.duration;\n        f(this, \"render\");\n        b.plotGroup(\"group\", \"series\", e, l, a);\n        b.markerGroup = b.plotGroup(\"markerGroup\", \"markers\", e, l, a);\n        !1 !== c.clip && b.setClip();\n        b.animate && k && b.animate(!0);\n        b.drawGraph && (b.drawGraph(), b.applyZones());\n        b.visible && b.drawPoints();\n        b.drawDataLabels && b.drawDataLabels();\n        b.redrawPoints && b.redrawPoints();\n        b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();\n        b.animate && k && b.animate();\n        h || (k && g.defer && (k += g.defer), b.animationTimeout = da(function () {\n          b.afterAnimate();\n        }, k || 0));\n        b.isDirty = !1;\n        b.hasRendered = !0;\n        f(b, \"afterRender\");\n      }\n      redraw() {\n        const b = this.isDirty || this.isDirtyData;\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      }\n      searchPoint(b, a) {\n        const c = this.xAxis,\n          f = this.yAxis,\n          g = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: g ? c.len - b.chartY + c.pos : b.chartX - c.pos,\n          plotY: g ? f.len - b.chartX + f.pos : b.chartY - f.pos\n        }, a, b);\n      }\n      buildKDTree(b) {\n        function a(b, f, g) {\n          var e = b && b.length;\n          let d;\n          if (e) return d = c.kdAxisArray[f % g], b.sort(function (b, a) {\n            return b[d] - a[d];\n          }), e = Math.floor(e / 2), {\n            point: b[e],\n            left: a(b.slice(0, e), f + 1, g),\n            right: a(b.slice(e + 1), f + 1, g)\n          };\n        }\n        this.buildingKdTree = !0;\n        const c = this,\n          f = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete c.kdTree;\n        da(function () {\n          c.kdTree = a(c.getValidPoints(null, !c.directTouch), f, f);\n          c.buildingKdTree = !1;\n        }, c.options.kdNow || b && \"touchstart\" === b.type ? 0 : 1);\n      }\n      searchKDTree(b, a, c) {\n        function f(b, a, c, k) {\n          const q = a.point;\n          var m = g.kdAxisArray[c % k];\n          let n = q;\n          var x = l(b[e]) && l(q[e]) ? Math.pow(b[e] - q[e], 2) : null;\n          var w = l(b[d]) && l(q[d]) ? Math.pow(b[d] - q[d], 2) : null;\n          w = (x || 0) + (w || 0);\n          q.dist = l(w) ? Math.sqrt(w) : Number.MAX_VALUE;\n          q.distX = l(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n          m = b[m] - q[m];\n          w = 0 > m ? \"left\" : \"right\";\n          x = 0 > m ? \"right\" : \"left\";\n          a[w] && (w = f(b, a[w], c + 1, k), n = w[h] < n[h] ? w : q);\n          a[x] && Math.sqrt(m * m) < n[h] && (b = f(b, a[x], c + 1, k), n = b[h] < n[h] ? b : n);\n          return n;\n        }\n        const g = this,\n          e = this.kdAxisArray[0],\n          d = this.kdAxisArray[1],\n          h = a ? \"distX\" : \"dist\";\n        a = -1 < g.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(c);\n        if (this.kdTree) return f(b, this.kdTree, a, a);\n      }\n      pointPlacementToXValue() {\n        const {\n          options: {\n            pointPlacement: b,\n            pointRange: a\n          },\n          xAxis: c\n        } = this;\n        let f = b;\n        \"between\" === f && (f = c.reversed ? -.5 : .5);\n        return z(f) ? f * (a || c.pointRange) : 0;\n      }\n      isPointInside(b) {\n        const {\n          chart: a,\n          xAxis: c,\n          yAxis: f\n        } = this;\n        return \"undefined\" !== typeof b.plotY && \"undefined\" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (f ? f.len : a.plotHeight) && 0 <= b.plotX && b.plotX <= (c ? c.len : a.plotWidth);\n      }\n      drawTracker() {\n        const b = this,\n          a = b.options,\n          c = a.trackByArea,\n          g = [].concat(c ? b.areaPath : b.graphPath),\n          e = b.chart,\n          d = e.pointer,\n          l = e.renderer,\n          h = e.options.tooltip.snap,\n          k = b.tracker,\n          q = function (a) {\n            if (e.hoverSeries !== b) b.onMouseOver();\n          },\n          m = \"rgba(192,192,192,\" + (n ? .0001 : .002) + \")\";\n        k ? k.attr({\n          d: g\n        }) : b.graph && (b.tracker = l.path(g).attr({\n          visibility: b.visible ? \"inherit\" : \"hidden\",\n          zIndex: 2\n        }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(b.group), e.styledMode || b.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: m,\n          fill: c ? m : \"none\",\n          \"stroke-width\": b.graph.strokeWidth() + (c ? 0 : 2 * h)\n        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {\n          if (b && (b.addClass(\"highcharts-tracker\").on(\"mouseover\", q).on(\"mouseout\", function (b) {\n            d.onTrackerMouseOut(b);\n          }), a.cursor && !e.styledMode && b.css({\n            cursor: a.cursor\n          }), v)) b.on(\"touchstart\", q);\n        }));\n        f(this, \"afterDrawTracker\");\n      }\n      addPoint(b, a, c, g, e) {\n        const d = this.options,\n          l = this.data,\n          h = this.chart;\n        var k = this.xAxis;\n        k = k && k.hasNames && k.names;\n        const q = d.data,\n          m = this.xData;\n        let n, x;\n        a = N(a, !0);\n        const w = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(w, [b]);\n        const p = w.x;\n        x = m.length;\n        if (this.requireSorting && p < m[x - 1]) for (n = !0; x && m[x - 1] > p;) x--;\n        this.updateParallelArrays(w, \"splice\", [x, 0, 0]);\n        this.updateParallelArrays(w, x);\n        k && w.name && (k[p] = w.name);\n        q.splice(x, 0, b);\n        if (n || this.processedData) this.data.splice(x, 0, null), this.processData();\n        \"point\" === d.legendType && this.generatePoints();\n        c && (l[0] && l[0].remove ? l[0].remove(!1) : (l.shift(), this.updateParallelArrays(w, \"shift\"), q.shift()));\n        !1 !== e && f(this, \"addPoint\", {\n          point: w\n        });\n        this.isDirtyData = this.isDirty = !0;\n        a && h.redraw(g);\n      }\n      removePoint(b, a, c) {\n        const f = this,\n          g = f.data,\n          e = g[b],\n          d = f.points,\n          l = f.chart,\n          h = function () {\n            d && d.length === g.length && d.splice(b, 1);\n            g.splice(b, 1);\n            f.options.data.splice(b, 1);\n            f.updateParallelArrays(e || {\n              series: f\n            }, \"splice\", [b, 1]);\n            e && e.destroy();\n            f.isDirty = !0;\n            f.isDirtyData = !0;\n            a && l.redraw();\n          };\n        p(c, l);\n        a = N(a, !0);\n        e ? e.firePointEvent(\"remove\", null, h) : h();\n      }\n      remove(b, a, c, g) {\n        function e() {\n          d.destroy(g);\n          l.isDirtyLegend = l.isDirtyBox = !0;\n          l.linkSeries(g);\n          N(b, !0) && l.redraw(a);\n        }\n        const d = this,\n          l = d.chart;\n        !1 !== c ? f(d, \"remove\", null, e) : e();\n      }\n      update(a, c) {\n        a = q(a, this.userOptions);\n        f(this, \"update\", {\n          options: a\n        });\n        const e = this,\n          d = e.chart;\n        var l = e.userOptions;\n        const h = e.initialType || e.type;\n        var k = d.options.plotOptions;\n        const m = D[h].prototype;\n        var n = e.finishedAnimating && {\n          animation: !1\n        };\n        const x = {};\n        let w,\n          p = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n          z = a.type || l.type || d.options.chart.type;\n        const y = !(this.hasDerivedData || z && z !== this.type || \"undefined\" !== typeof a.pointStart || \"undefined\" !== typeof a.pointInterval || \"undefined\" !== typeof a.relativeXValue || a.joinBy || a.mapData || e.hasOptionChanged(\"dataGrouping\") || e.hasOptionChanged(\"pointStart\") || e.hasOptionChanged(\"pointInterval\") || e.hasOptionChanged(\"pointIntervalUnit\") || e.hasOptionChanged(\"keys\"));\n        z = z || h;\n        y && (p.push(\"data\", \"isDirtyData\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"clips\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && p.push(\"area\", \"graph\"), e.parallelArrays.forEach(function (b) {\n          p.push(b + \"Data\");\n        }), a.data && (a.dataSorting && b(e.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n        a = S(l, n, {\n          index: \"undefined\" === typeof l.index ? e.index : l.index,\n          pointStart: N(k && k.series && k.series.pointStart, l.pointStart, e.xData[0])\n        }, !y && {\n          data: e.options.data\n        }, a);\n        y && a.data && (a.data = e.options.data);\n        p = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(p);\n        p.forEach(function (b) {\n          p[b] = e[b];\n          delete e[b];\n        });\n        k = !1;\n        if (D[z]) {\n          if (k = z !== e.type, e.remove(!1, !1, !1, !0), k) if (Object.setPrototypeOf) Object.setPrototypeOf(e, D[z].prototype);else {\n            n = Object.hasOwnProperty.call(e, \"hcEvents\") && e.hcEvents;\n            for (w in m) e[w] = void 0;\n            b(e, D[z].prototype);\n            n ? e.hcEvents = n : delete e.hcEvents;\n          }\n        } else g(17, !0, d, {\n          missingModuleFor: z\n        });\n        p.forEach(function (b) {\n          e[b] = p[b];\n        });\n        e.init(d, a);\n        if (y && this.points) {\n          a = e.options;\n          if (!1 === a.visible) x.graphic = 1, x.dataLabel = 1;else if (!e._hasPointLabels) {\n            const {\n              marker: b,\n              dataLabels: c\n            } = a;\n            l = l.marker || {};\n            !b || !1 !== b.enabled && l.symbol === b.symbol && l.height === b.height && l.width === b.width || (x.graphic = 1);\n            c && !1 === c.enabled && (x.dataLabel = 1);\n          }\n          for (const b of this.points) b && b.series && (b.resolveColor(), Object.keys(x).length && b.destroyElements(x), !1 === a.showInLegend && b.legendItem && d.legend.destroyItem(b));\n        }\n        e.initialType = h;\n        d.linkSeries();\n        k && e.linkedSeries.length && (e.isDirtyData = !0);\n        f(this, \"afterUpdate\");\n        N(c, !0) && d.redraw(y ? void 0 : !1);\n      }\n      setName(b) {\n        this.name = this.options.name = this.userOptions.name = b;\n        this.chart.isDirtyLegend = !0;\n      }\n      hasOptionChanged(b) {\n        const a = this.options[b],\n          c = this.chart.options.plotOptions,\n          f = this.userOptions[b];\n        return f ? a !== f : a !== N(c && c[this.type] && c[this.type][b], c && c.series && c.series[b], a);\n      }\n      onMouseOver() {\n        const b = this.chart,\n          a = b.hoverSeries;\n        b.pointer.setHoverChartIndex();\n        if (a && a !== this) a.onMouseOut();\n        this.options.events.mouseOver && f(this, \"mouseOver\");\n        this.setState(\"hover\");\n        b.hoverSeries = this;\n      }\n      onMouseOut() {\n        const b = this.options,\n          a = this.chart,\n          c = a.tooltip,\n          g = a.hoverPoint;\n        a.hoverSeries = null;\n        if (g) g.onMouseOut();\n        this && b.events.mouseOut && f(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        a.series.forEach(function (b) {\n          b.setState(\"\", !0);\n        });\n      }\n      setState(b, a) {\n        const c = this;\n        var f = c.options;\n        const g = c.graph,\n          e = f.inactiveOtherPoints,\n          d = f.states,\n          l = N(d[b || \"normal\"] && d[b || \"normal\"].animation, c.chart.options.chart.animation);\n        let h = f.lineWidth,\n          k = 0,\n          q = f.opacity;\n        b = b || \"\";\n        if (c.state !== b && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (a) {\n          a && (c.state && a.removeClass(\"highcharts-series-\" + c.state), b && a.addClass(\"highcharts-series-\" + b));\n        }), c.state = b, !c.chart.styledMode)) {\n          if (d[b] && !1 === d[b].enabled) return;\n          b && (h = d[b].lineWidth || h + (d[b].lineWidthPlus || 0), q = N(d[b].opacity, q));\n          if (g && !g.dashstyle && z(h)) for (f = {\n            \"stroke-width\": h\n          }, g.animate(f, l); c[\"zone-graph-\" + k];) c[\"zone-graph-\" + k].animate(f, l), k += 1;\n          e || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (b) {\n            b && b.animate({\n              opacity: q\n            }, l);\n          });\n        }\n        a && e && c.points && c.setAllPointsToState(b || void 0);\n      }\n      setAllPointsToState(b) {\n        this.points.forEach(function (a) {\n          a.setState && a.setState(b);\n        });\n      }\n      setVisible(b, a) {\n        const c = this,\n          g = c.chart,\n          e = g.options.chart.ignoreHiddenSeries,\n          d = c.visible,\n          l = (c.visible = b = c.options.visible = c.userOptions.visible = \"undefined\" === typeof b ? !d : b) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (b) {\n          if (c[b]) c[b][l]();\n        });\n        if (g.hoverSeries === c || (g.hoverPoint && g.hoverPoint.series) === c) c.onMouseOut();\n        c.legendItem && g.legend.colorizeItem(c, b);\n        c.isDirty = !0;\n        c.options.stacking && g.series.forEach(function (b) {\n          b.options.stacking && b.visible && (b.isDirty = !0);\n        });\n        c.linkedSeries.forEach(function (a) {\n          a.setVisible(b, !1);\n        });\n        e && (g.isDirtyBox = !0);\n        f(c, l);\n        !1 !== a && g.redraw();\n      }\n      show() {\n        this.setVisible(!0);\n      }\n      hide() {\n        this.setVisible(!1);\n      }\n      select(b) {\n        this.selected = b = this.options.selected = \"undefined\" === typeof b ? !this.selected : b;\n        this.checkbox && (this.checkbox.checked = b);\n        f(this, b ? \"select\" : \"unselect\");\n      }\n      shouldShowTooltip(b, a, c = {}) {\n        c.series = this;\n        c.visiblePlotOnly = !0;\n        return this.chart.isInsidePlot(b, a, c);\n      }\n      drawLegendSymbol(b, a) {\n        var c;\n        null === (c = F[this.options.legendSymbol || \"rectangle\"]) || void 0 === c ? void 0 : c.call(this, b, a);\n      }\n    }\n    W.defaultOptions = C;\n    W.types = B.seriesTypes;\n    W.registerType = B.registerSeriesType;\n    b(W.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: G,\n      requireSorting: !0,\n      sorted: !0\n    });\n    B.series = W;\n    \"\";\n    \"\";\n    return W;\n  });\n  M(a, \"Extensions/ScrollablePlotArea.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G) {\n    const {\n        stop: u\n      } = a,\n      {\n        addEvent: B,\n        createElement: t,\n        defined: r,\n        merge: d,\n        pick: p\n      } = G;\n    B(H, \"afterSetChartSize\", function (a) {\n      var k = this.options.chart.scrollablePlotArea,\n        m = k && k.minWidth;\n      k = k && k.minHeight;\n      let n;\n      if (!this.renderer.forExport) {\n        if (m) {\n          if (this.scrollablePixelsX = m = Math.max(0, m - this.chartWidth)) this.scrollablePlotBox = this.renderer.scrollablePlotBox = d(this.plotBox), this.plotBox.width = this.plotWidth += m, this.inverted ? this.clipBox.height += m : this.clipBox.width += m, n = {\n            1: {\n              name: \"right\",\n              value: m\n            }\n          };\n        } else k && (this.scrollablePixelsY = m = Math.max(0, k - this.chartHeight), r(m) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = d(this.plotBox), this.plotBox.height = this.plotHeight += m, this.inverted ? this.clipBox.width += m : this.clipBox.height += m, n = {\n          2: {\n            name: \"bottom\",\n            value: m\n          }\n        }));\n        n && !a.skipAxes && this.axes.forEach(function (a) {\n          n[a.side] ? a.getPlotLinePath = function () {\n            let d = n[a.side].name,\n              h = this[d],\n              k;\n            this[d] = h - n[a.side].value;\n            k = A.prototype.getPlotLinePath.apply(this, arguments);\n            this[d] = h;\n            return k;\n          } : (a.setAxisSize(), a.setAxisTranslation());\n        });\n      }\n    });\n    B(H, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n    H.prototype.setUpScrolling = function () {\n      const a = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (a.overflowX = \"auto\");\n      this.scrollablePixelsY && (a.overflowY = \"auto\");\n      this.scrollingParent = t(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = t(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, a, this.scrollingParent);\n      let d;\n      B(this.scrollingContainer, \"scroll\", () => {\n        this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (d = this.hoverPoint), this.pointer.runPointActions(void 0, d, !0));\n      });\n      this.innerContainer = t(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n    H.prototype.moveFixedElements = function () {\n      let a = this.container,\n        d = this.fixedRenderer,\n        p = \".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n        n;\n      this.scrollablePixelsX && !this.inverted ? n = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? n = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? n = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (n = \".highcharts-yaxis\");\n      n && p.push(`${n}:not(.highcharts-radial-axis)`, `${n}-labels:not(.highcharts-radial-axis-labels)`);\n      p.forEach(function (h) {\n        [].forEach.call(a.querySelectorAll(h), function (a) {\n          (a.namespaceURI === d.SVG_NS ? d.box : d.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n    H.prototype.applyFixed = function () {\n      var a = !this.fixedDiv,\n        d = this.options.chart,\n        r = d.scrollablePlotArea,\n        n = F.getRendererType();\n      a ? (this.fixedDiv = t(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (d.style && d.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = d = new n(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = d.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": p(r.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), B(this, \"afterShowResetZoom\", this.moveFixedElements), B(this, \"afterApplyDrilldown\", this.moveFixedElements), B(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();\n      d = this.chartWidth + (this.scrollablePixelsX || 0);\n      n = this.chartHeight + (this.scrollablePixelsY || 0);\n      u(this.container);\n      this.container.style.width = d + \"px\";\n      this.container.style.height = n + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: d,\n        height: n,\n        viewBox: [0, 0, d, n].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: d,\n        height: n\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      a && (r.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * r.scrollPositionX), r.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * r.scrollPositionY));\n      n = this.axisOffset;\n      a = this.plotTop - n[0] - 1;\n      r = this.plotLeft - n[3] - 1;\n      d = this.plotTop + this.plotHeight + n[2] + 1;\n      n = this.plotLeft + this.plotWidth + n[1] + 1;\n      let h = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n        D = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      a = this.scrollablePixelsX ? [[\"M\", 0, a], [\"L\", this.plotLeft - 1, a], [\"L\", this.plotLeft - 1, d], [\"L\", 0, d], [\"Z\"], [\"M\", h, a], [\"L\", this.chartWidth, a], [\"L\", this.chartWidth, d], [\"L\", h, d], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", r, 0], [\"L\", r, this.plotTop - 1], [\"L\", n, this.plotTop - 1], [\"L\", n, 0], [\"Z\"], [\"M\", r, D], [\"L\", r, this.chartHeight], [\"L\", n, this.chartHeight], [\"L\", n, D], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: a\n      });\n    };\n    B(A, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    B(I, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    \"\";\n  });\n  M(a, \"Core/Axis/Stacking/StackItem.js\", [a[\"Core/FormatUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        format: u\n      } = a,\n      {\n        series: F\n      } = A,\n      {\n        destroyObjectProperties: G,\n        fireEvent: C,\n        isNumber: B,\n        pick: t\n      } = H;\n    class r {\n      constructor(a, p, m, k, r) {\n        const d = a.chart.inverted,\n          h = a.reversed;\n        this.axis = a;\n        a = this.isNegative = !!m !== !!h;\n        this.options = p = p || {};\n        this.x = k;\n        this.cumulative = this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = r;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: p.align || (d ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: p.verticalAlign || (d ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: p.y,\n          x: p.x\n        };\n        this.textAlign = p.textAlign || (d ? a ? \"right\" : \"left\" : \"center\");\n      }\n      destroy() {\n        G(this, this.axis);\n      }\n      render(a) {\n        const d = this.axis.chart,\n          m = this.options;\n        var k = m.format;\n        k = k ? u(k, this, d) : m.formatter.call(this);\n        this.label ? this.label.attr({\n          text: k,\n          visibility: \"hidden\"\n        }) : (this.label = d.renderer.label(k, null, void 0, m.shape, void 0, void 0, m.useHTML, !1, \"stack-labels\"), k = {\n          r: m.borderRadius || 0,\n          text: k,\n          padding: t(m.padding, 5),\n          visibility: \"hidden\"\n        }, d.styledMode || (k.fill = m.backgroundColor, k.stroke = m.borderColor, k[\"stroke-width\"] = m.borderWidth, this.label.css(m.style || {})), this.label.attr(k), this.label.added || this.label.add(a));\n        this.label.labelrank = d.plotSizeY;\n        C(this, \"afterRender\");\n      }\n      setOffset(a, p, m, k, r, n) {\n        const {\n            alignOptions: d,\n            axis: v,\n            label: u,\n            options: E,\n            textAlign: e\n          } = this,\n          q = v.chart;\n        m = this.getStackBox({\n          xOffset: a,\n          width: p,\n          boxBottom: m,\n          boxTop: k,\n          defaultX: r,\n          xAxis: n\n        });\n        var {\n          verticalAlign: y\n        } = d;\n        if (u && m) {\n          k = u.getBBox();\n          r = u.padding;\n          n = \"justify\" === t(E.overflow, \"justify\");\n          d.x = E.x || 0;\n          d.y = E.y || 0;\n          const {\n            x: a,\n            y: h\n          } = this.adjustStackPosition({\n            labelBox: k,\n            verticalAlign: y,\n            textAlign: e\n          });\n          m.x -= a;\n          m.y -= h;\n          u.align(d, !1, m);\n          (y = q.isInsidePlot(u.alignAttr.x + d.x + a, u.alignAttr.y + d.y + h)) || (n = !1);\n          n && F.prototype.justifyDataLabel.call(v, u, d, u.alignAttr, k, m);\n          u.attr({\n            x: u.alignAttr.x,\n            y: u.alignAttr.y,\n            rotation: E.rotation,\n            rotationOriginX: k.width / 2,\n            rotationOriginY: k.height / 2\n          });\n          t(!n && E.crop, !0) && (y = B(u.x) && B(u.y) && q.isInsidePlot(u.x - r + u.width, u.y) && q.isInsidePlot(u.x + r, u.y));\n          u[y ? \"show\" : \"hide\"]();\n        }\n        C(this, \"afterSetOffset\", {\n          xOffset: a,\n          width: p\n        });\n      }\n      adjustStackPosition({\n        labelBox: a,\n        verticalAlign: p,\n        textAlign: m\n      }) {\n        const d = {\n          bottom: 0,\n          middle: 1,\n          top: 2,\n          right: 1,\n          center: 0,\n          left: -1\n        };\n        return {\n          x: a.width / 2 + a.width / 2 * d[m],\n          y: a.height / 2 * d[p]\n        };\n      }\n      getStackBox(a) {\n        var d = this.axis;\n        const m = d.chart,\n          {\n            boxTop: k,\n            defaultX: r,\n            xOffset: n,\n            width: h,\n            boxBottom: D\n          } = a;\n        var u = d.stacking.usePercentage ? 100 : t(k, this.total, 0);\n        u = d.toPixels(u);\n        a = a.xAxis || m.xAxis[0];\n        const E = t(r, a.translate(this.x)) + n;\n        d = d.toPixels(D || B(d.min) && d.logarithmic && d.logarithmic.lin2log(d.min) || 0);\n        d = Math.abs(u - d);\n        const e = this.isNegative;\n        return m.inverted ? {\n          x: (e ? u : u - d) - m.plotLeft,\n          y: a.height - E - h,\n          width: d,\n          height: h\n        } : {\n          x: E + a.transB - m.plotLeft,\n          y: (e ? u - d : u) - m.plotTop,\n          width: h,\n          height: d\n        };\n      }\n    }\n    \"\";\n    return r;\n  });\n  M(a, \"Core/Axis/Stacking/StackingAxis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F) {\n    function u() {\n      const b = this,\n        a = b.inverted;\n      b.yAxis.forEach(b => {\n        b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);\n      });\n      b.series.forEach(c => {\n        const f = c.xAxis && c.xAxis.options || {};\n        !c.options.stacking || !0 !== c.visible && !1 !== b.options.chart.ignoreHiddenSeries || (c.stackKey = [c.type, l(c.options.stack, \"\"), a ? f.top : f.left, a ? f.height : f.width].join());\n      });\n    }\n    function C() {\n      const b = this.stacking;\n      if (b) {\n        var a = b.stacks;\n        y(a, function (b, c) {\n          L(b);\n          a[c] = null;\n        });\n        b && b.stackTotalGroup && b.stackTotalGroup.destroy();\n      }\n    }\n    function B() {\n      \"yAxis\" !== this.coll || this.stacking || (this.stacking = new w(this));\n    }\n    function t(b, a, f, g) {\n      !D(b) || b.x !== a || g && b.stackKey !== g ? b = {\n        x: a,\n        index: 0,\n        key: g,\n        stackKey: g\n      } : b.index++;\n      b.key = [f, a, b.index].join();\n      return b;\n    }\n    function r() {\n      const b = this,\n        a = b.stackKey,\n        f = b.yAxis.stacking.stacks,\n        g = b.processedXData,\n        e = b[b.options.stacking + \"Stacker\"];\n      let d;\n      e && [a, \"-\" + a].forEach(a => {\n        let c = g.length;\n        let l;\n        for (; c--;) {\n          var h = g[c];\n          d = b.getStackIndicator(d, h, b.index, a);\n          (l = (h = f[a] && f[a][h]) && h.points[d.key]) && e.call(b, l, h, c);\n        }\n      });\n    }\n    function d(b, a, f) {\n      a = a.total ? 100 / a.total : 0;\n      b[0] = h(b[0] * a);\n      b[1] = h(b[1] * a);\n      this.stackedYData[f] = b[1];\n    }\n    function p() {\n      const b = this.yAxis.stacking;\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length ? v.setStackedPoints.call(this, \"group\") : b && y(b.stacks, (a, f) => {\n        \"group\" === f.slice(-5) && (y(a, b => b.destroy()), delete b.stacks[f]);\n      });\n    }\n    function m(b) {\n      var a = this.chart;\n      const f = b || this.options.stacking;\n      if (f && (!0 === this.visible || !1 === a.options.chart.ignoreHiddenSeries)) {\n        var g = this.processedXData,\n          d = this.processedYData,\n          k = [],\n          q = d.length,\n          m = this.options,\n          n = m.threshold,\n          w = l(m.startFromThreshold && n, 0);\n        m = m.stack;\n        b = b ? `${this.type},${f}` : this.stackKey;\n        var p = \"-\" + b,\n          y = this.negStacks;\n        a = \"group\" === f ? a.yAxis[0] : this.yAxis;\n        var r = a.stacking.stacks,\n          v = a.stacking.oldStacks,\n          u,\n          t;\n        a.stacking.stacksTouched += 1;\n        for (t = 0; t < q; t++) {\n          var E = g[t];\n          var B = d[t];\n          var L = this.getStackIndicator(L, E, this.index);\n          var A = L.key;\n          var C = (u = y && B < (w ? 0 : n)) ? p : b;\n          r[C] || (r[C] = {});\n          r[C][E] || (v[C] && v[C][E] ? (r[C][E] = v[C][E], r[C][E].total = null) : r[C][E] = new I(a, a.options.stackLabels, !!u, E, m));\n          C = r[C][E];\n          null !== B ? (C.points[A] = C.points[this.index] = [l(C.cumulative, w)], D(C.cumulative) || (C.base = A), C.touched = a.stacking.stacksTouched, 0 < L.index && !1 === this.singleStacks && (C.points[A][0] = C.points[this.index + \",\" + E + \",0\"][0])) : C.points[A] = C.points[this.index] = null;\n          \"percent\" === f ? (u = u ? b : p, y && r[u] && r[u][E] ? (u = r[u][E], C.total = u.total = Math.max(u.total, C.total) + Math.abs(B) || 0) : C.total = h(C.total + (Math.abs(B) || 0))) : \"group\" === f ? (e(B) && (B = B[0]), null !== B && (C.total = (C.total || 0) + 1)) : C.total = h(C.total + (B || 0));\n          C.cumulative = \"group\" === f ? (C.total || 1) - 1 : h(l(C.cumulative, w) + (B || 0));\n          null !== B && (C.points[A].push(C.cumulative), k[t] = C.cumulative, C.hasValidPoints = !0);\n        }\n        \"percent\" === f && (a.stacking.usePercentage = !0);\n        \"group\" !== f && (this.stackedYData = k);\n        a.stacking.oldStacks = {};\n      }\n    }\n    const {\n        getDeferredAnimation: k\n      } = a,\n      {\n        series: {\n          prototype: v\n        }\n      } = H,\n      {\n        addEvent: n,\n        correctFloat: h,\n        defined: D,\n        destroyObjectProperties: L,\n        fireEvent: E,\n        isArray: e,\n        isNumber: q,\n        objectEach: y,\n        pick: l\n      } = F;\n    class w {\n      constructor(b) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = b;\n      }\n      buildStacks() {\n        const b = this.axis,\n          a = b.series,\n          f = b.options.reversedStacks,\n          g = a.length;\n        let e, d;\n        this.usePercentage = !1;\n        for (d = g; d--;) e = a[f ? d : g - d - 1], e.setStackedPoints(), e.setGroupedPoints();\n        for (d = 0; d < g; d++) a[d].modifyStacks();\n        E(b, \"afterBuildStacks\");\n      }\n      cleanStacks() {\n        let b;\n        this.oldStacks && (b = this.stacks = this.oldStacks);\n        y(b, function (b) {\n          y(b, function (b) {\n            b.cumulative = b.total;\n          });\n        });\n      }\n      resetStacks() {\n        y(this.stacks, b => {\n          y(b, (a, f) => {\n            q(a.touched) && a.touched < this.stacksTouched ? (a.destroy(), delete b[f]) : (a.total = null, a.cumulative = null);\n          });\n        });\n      }\n      renderStackTotals() {\n        var b = this.axis;\n        const a = b.chart,\n          f = a.renderer,\n          g = this.stacks;\n        b = k(a, b.options.stackLabels && b.options.stackLabels.animation || !1);\n        const e = this.stackTotalGroup = this.stackTotalGroup || f.g(\"stack-labels\").attr({\n          zIndex: 6,\n          opacity: 0\n        }).add();\n        e.translate(a.plotLeft, a.plotTop);\n        y(g, function (b) {\n          y(b, function (b) {\n            b.render(e);\n          });\n        });\n        e.animate({\n          opacity: 1\n        }, b);\n      }\n    }\n    var g;\n    (function (b) {\n      const a = [];\n      b.compose = function (b, c, g) {\n        F.pushUnique(a, b) && (n(b, \"init\", B), n(b, \"destroy\", C));\n        F.pushUnique(a, c) && (c.prototype.getStacks = u);\n        F.pushUnique(a, g) && (b = g.prototype, b.getStackIndicator = t, b.modifyStacks = r, b.percentStacker = d, b.setGroupedPoints = p, b.setStackedPoints = m);\n      };\n    })(g || (g = {}));\n    return g;\n  });\n  M(a, \"Series/Line/LineSeries.js\", [a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n      defined: u,\n      merge: F\n    } = H;\n    class G extends a {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawGraph() {\n        const a = this,\n          u = this.options,\n          t = (this.gappedPath || this.getGraphPath).call(this),\n          r = this.chart.styledMode;\n        let d = [[\"graph\", \"highcharts-graph\"]];\n        r || d[0].push(u.lineColor || this.color || \"#cccccc\", u.dashStyle);\n        d = a.getZonesGraphs(d);\n        d.forEach(function (d, m) {\n          var k = d[0];\n          let p = a[k];\n          const n = p ? \"animate\" : \"attr\";\n          p ? (p.endX = a.preventGraphAnimation ? null : t.xMap, p.animate({\n            d: t\n          })) : t.length && (a[k] = p = a.chart.renderer.path(t).addClass(d[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          p && !r && (k = {\n            stroke: d[2],\n            \"stroke-width\": u.lineWidth || 0,\n            fill: a.fillGraph && a.color || \"none\"\n          }, d[3] ? k.dashstyle = d[3] : \"square\" !== u.linecap && (k[\"stroke-linecap\"] = k[\"stroke-linejoin\"] = \"round\"), p[n](k).shadow(2 > m && u.shadow));\n          p && (p.startX = t.xMap, p.isArea = t.isArea);\n        });\n      }\n      getGraphPath(a, B, t) {\n        const r = this,\n          d = r.options,\n          p = [],\n          m = [];\n        let k,\n          v = d.step;\n        a = a || r.points;\n        const n = a.reversed;\n        n && a.reverse();\n        (v = {\n          right: 1,\n          center: 2\n        }[v] || v && 3) && n && (v = 4 - v);\n        a = this.getValidPoints(a, !1, !(d.connectNulls && !B && !t));\n        a.forEach(function (h, n) {\n          const D = h.plotX,\n            E = h.plotY,\n            e = a[n - 1],\n            q = h.isNull || \"number\" !== typeof E;\n          (h.leftCliff || e && e.rightCliff) && !t && (k = !0);\n          q && !u(B) && 0 < n ? k = !d.connectNulls : q && !B ? k = !0 : (0 === n || k ? n = [[\"M\", h.plotX, h.plotY]] : r.getPointSpline ? n = [r.getPointSpline(a, h, n)] : v ? (n = 1 === v ? [[\"L\", e.plotX, E]] : 2 === v ? [[\"L\", (e.plotX + D) / 2, e.plotY], [\"L\", (e.plotX + D) / 2, E]] : [[\"L\", D, e.plotY]], n.push([\"L\", D, E])) : n = [[\"L\", D, E]], m.push(h.x), v && (m.push(h.x), 2 === v && m.push(h.x)), p.push.apply(p, n), k = !1);\n        });\n        p.xMap = m;\n        return r.graphPath = p;\n      }\n      getZonesGraphs(a) {\n        this.zones.forEach(function (u, t) {\n          t = [\"zone-graph-\" + t, \"highcharts-graph highcharts-zone-graph-\" + t + \" \" + (u.className || \"\")];\n          this.chart.styledMode || t.push(u.color || this.color, u.dashStyle || this.options.dashStyle);\n          a.push(t);\n        }, this);\n        return a;\n      }\n    }\n    G.defaultOptions = F(a.defaultOptions, {\n      legendSymbol: \"lineMarker\"\n    });\n    A.registerSeriesType(\"line\", G);\n    \"\";\n    return G;\n  });\n  M(a, \"Series/Area/AreaSeries.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        parse: u\n      } = a,\n      {\n        seriesTypes: {\n          line: F\n        }\n      } = A,\n      {\n        extend: G,\n        merge: C,\n        objectEach: B,\n        pick: t\n      } = H;\n    class r extends F {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawGraph() {\n        this.areaPath = [];\n        super.drawGraph.apply(this);\n        const a = this,\n          p = this.areaPath,\n          m = this.options,\n          k = [[\"area\", \"highcharts-area\", this.color, m.fillColor]];\n        this.zones.forEach(function (d, n) {\n          k.push([\"zone-area-\" + n, \"highcharts-area highcharts-zone-area-\" + n + \" \" + d.className, d.color || a.color, d.fillColor || m.fillColor]);\n        });\n        k.forEach(function (d) {\n          const k = d[0],\n            h = {};\n          let r = a[k];\n          const v = r ? \"animate\" : \"attr\";\n          r ? (r.endX = a.preventGraphAnimation ? null : p.xMap, r.animate({\n            d: p\n          })) : (h.zIndex = 0, r = a[k] = a.chart.renderer.path(p).addClass(d[1]).add(a.group), r.isArea = !0);\n          a.chart.styledMode || (h.fill = t(d[3], u(d[2]).setOpacity(t(m.fillOpacity, .75)).get()));\n          r[v](h);\n          r.startX = p.xMap;\n          r.shiftUnit = m.step ? 2 : 1;\n        });\n      }\n      getGraphPath(a) {\n        var d = F.prototype.getGraphPath,\n          m = this.options;\n        const k = m.stacking,\n          r = this.yAxis,\n          n = [],\n          h = [],\n          u = this.index,\n          B = r.stacking.stacks[this.stackKey],\n          E = m.threshold,\n          e = Math.round(r.getThreshold(m.threshold));\n        m = t(m.connectNulls, \"percent\" === k);\n        var q = function (g, b, c) {\n          var f = a[g];\n          g = k && B[f.x].points[u];\n          const d = f[c + \"Null\"] || 0;\n          c = f[c + \"Cliff\"] || 0;\n          let l, q;\n          f = !0;\n          c || d ? (l = (d ? g[0] : g[1]) + c, q = g[0] + c, f = !!d) : !k && a[b] && a[b].isNull && (l = q = E);\n          \"undefined\" !== typeof l && (h.push({\n            plotX: y,\n            plotY: null === l ? e : r.getThreshold(l),\n            isNull: f,\n            isCliff: !0\n          }), n.push({\n            plotX: y,\n            plotY: null === q ? e : r.getThreshold(q),\n            doCurve: !1\n          }));\n        };\n        let y;\n        a = a || this.points;\n        k && (a = this.getStackPoints(a));\n        for (let g = 0, b = a.length; g < b; ++g) {\n          k || (a[g].leftCliff = a[g].rightCliff = a[g].leftNull = a[g].rightNull = void 0);\n          var l = a[g].isNull;\n          y = t(a[g].rectPlotX, a[g].plotX);\n          var w = k ? t(a[g].yBottom, e) : e;\n          if (!l || m) m || q(g, g - 1, \"left\"), l && !k && m || (h.push(a[g]), n.push({\n            x: g,\n            plotX: y,\n            plotY: w\n          })), m || q(g, g + 1, \"right\");\n        }\n        q = d.call(this, h, !0, !0);\n        n.reversed = !0;\n        l = d.call(this, n, !0, !0);\n        (w = l[0]) && \"M\" === w[0] && (l[0] = [\"L\", w[1], w[2]]);\n        l = q.concat(l);\n        l.length && l.push([\"Z\"]);\n        d = d.call(this, h, !1, m);\n        l.xMap = q.xMap;\n        this.areaPath = l;\n        return d;\n      }\n      getStackPoints(a) {\n        const d = this,\n          m = [],\n          k = [],\n          r = this.xAxis,\n          n = this.yAxis,\n          h = n.stacking.stacks[this.stackKey],\n          u = {},\n          L = n.series,\n          E = L.length,\n          e = n.options.reversedStacks ? 1 : -1,\n          q = L.indexOf(d);\n        a = a || this.points;\n        if (this.options.stacking) {\n          for (let e = 0; e < a.length; e++) a[e].leftNull = a[e].rightNull = void 0, u[a[e].x] = a[e];\n          B(h, function (a, e) {\n            null !== a.total && k.push(e);\n          });\n          k.sort(function (a, e) {\n            return a - e;\n          });\n          const p = L.map(a => a.visible);\n          k.forEach(function (a, w) {\n            let g = 0,\n              b,\n              c;\n            if (u[a] && !u[a].isNull) m.push(u[a]), [-1, 1].forEach(function (f) {\n              const g = 1 === f ? \"rightNull\" : \"leftNull\",\n                l = h[k[w + f]];\n              let m = 0;\n              if (l) {\n                let f = q;\n                for (; 0 <= f && f < E;) {\n                  const k = L[f].index;\n                  b = l.points[k];\n                  b || (k === d.index ? u[a][g] = !0 : p[f] && (c = h[a].points[k]) && (m -= c[1] - c[0]));\n                  f += e;\n                }\n              }\n              u[a][1 === f ? \"rightCliff\" : \"leftCliff\"] = m;\n            });else {\n              let c = q;\n              for (; 0 <= c && c < E;) {\n                if (b = h[a].points[L[c].index]) {\n                  g = b[1];\n                  break;\n                }\n                c += e;\n              }\n              g = t(g, 0);\n              g = n.translate(g, 0, 1, 0, 1);\n              m.push({\n                isNull: !0,\n                plotX: r.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: g,\n                yBottom: g\n              });\n            }\n          });\n        }\n        return m;\n      }\n    }\n    r.defaultOptions = C(F.defaultOptions, {\n      threshold: 0,\n      legendSymbol: \"rectangle\"\n    });\n    G(r.prototype, {\n      singleStacks: !1\n    });\n    A.registerSeriesType(\"area\", r);\n    \"\";\n    return r;\n  });\n  M(a, \"Series/Spline/SplineSeries.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    const {\n        line: u\n      } = a.seriesTypes,\n      {\n        merge: I,\n        pick: F\n      } = A;\n    class G extends u {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      getPointSpline(a, u, t) {\n        const r = u.plotX || 0,\n          d = u.plotY || 0,\n          p = a[t - 1];\n        t = a[t + 1];\n        let m, k;\n        let v;\n        if (p && !p.isNull && !1 !== p.doCurve && !u.isCliff && t && !t.isNull && !1 !== t.doCurve && !u.isCliff) {\n          a = p.plotY || 0;\n          var n = t.plotX || 0;\n          t = t.plotY || 0;\n          let h = 0;\n          m = (1.5 * r + (p.plotX || 0)) / 2.5;\n          k = (1.5 * d + a) / 2.5;\n          n = (1.5 * r + n) / 2.5;\n          v = (1.5 * d + t) / 2.5;\n          n !== m && (h = (v - k) * (n - r) / (n - m) + d - v);\n          k += h;\n          v += h;\n          k > a && k > d ? (k = Math.max(a, d), v = 2 * d - k) : k < a && k < d && (k = Math.min(a, d), v = 2 * d - k);\n          v > t && v > d ? (v = Math.max(t, d), k = 2 * d - v) : v < t && v < d && (v = Math.min(t, d), k = 2 * d - v);\n          u.rightContX = n;\n          u.rightContY = v;\n        }\n        u = [\"C\", F(p.rightContX, p.plotX, 0), F(p.rightContY, p.plotY, 0), F(m, r, 0), F(k, d, 0), r, d];\n        p.rightContX = p.rightContY = void 0;\n        return u;\n      }\n    }\n    G.defaultOptions = I(u.defaultOptions);\n    a.registerSeriesType(\"spline\", G);\n    \"\";\n    return G;\n  });\n  M(a, \"Series/AreaSpline/AreaSplineSeries.js\", [a[\"Series/Spline/SplineSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        area: u,\n        area: {\n          prototype: F\n        }\n      } = A.seriesTypes,\n      {\n        extend: G,\n        merge: C\n      } = H;\n    class B extends a {\n      constructor() {\n        super(...arguments);\n        this.options = this.points = this.data = void 0;\n      }\n    }\n    B.defaultOptions = C(a.defaultOptions, u.defaultOptions);\n    G(B.prototype, {\n      getGraphPath: F.getGraphPath,\n      getStackPoints: F.getStackPoints,\n      drawGraph: F.drawGraph\n    });\n    A.registerSeriesType(\"areaspline\", B);\n    \"\";\n    return B;\n  });\n  M(a, \"Series/Column/ColumnSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    };\n  });\n  M(a, \"Series/Column/ColumnSeries.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Series/Column/ColumnSeriesDefaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C) {\n    const {\n        animObject: u\n      } = a,\n      {\n        parse: t\n      } = A,\n      {\n        hasTouch: r,\n        noop: d\n      } = I,\n      {\n        clamp: p,\n        defined: m,\n        extend: k,\n        fireEvent: v,\n        isArray: n,\n        isNumber: h,\n        merge: D,\n        pick: L,\n        objectEach: E\n      } = C;\n    class e extends F {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.group = this.data = this.borderWidth = void 0;\n      }\n      animate(a) {\n        const e = this,\n          d = this.yAxis,\n          h = d.pos,\n          g = e.options,\n          b = this.chart.inverted,\n          c = {},\n          f = b ? \"translateX\" : \"translateY\";\n        let q;\n        a ? (c.scaleY = .001, a = p(d.toPixels(g.threshold), h, h + d.len), b ? c.translateX = a - d.len : c.translateY = a, e.clipBox && e.setClip(), e.group.attr(c)) : (q = Number(e.group.attr(f)), e.group.animate({\n          scaleY: 1\n        }, k(u(e.options.animation), {\n          step: function (b, a) {\n            e.group && (c[f] = q + a.pos * (h - q), e.group.attr(c));\n          }\n        })));\n      }\n      init(a, e) {\n        super.init.apply(this, arguments);\n        const d = this;\n        a = d.chart;\n        a.hasRendered && a.series.forEach(function (a) {\n          a.type === d.type && (a.isDirty = !0);\n        });\n      }\n      getColumnMetrics() {\n        const a = this;\n        var e = a.options;\n        const d = a.xAxis,\n          h = a.yAxis;\n        var g = d.options.reversedStacks;\n        g = d.reversed && !g || !d.reversed && g;\n        const b = {};\n        let c,\n          f = 0;\n        !1 === e.grouping ? f = 1 : a.chart.series.forEach(function (g) {\n          const e = g.yAxis,\n            d = g.options;\n          let l;\n          g.type !== a.type || !g.visible && a.chart.options.chart.ignoreHiddenSeries || h.len !== e.len || h.pos !== e.pos || (d.stacking && \"group\" !== d.stacking ? (c = g.stackKey, \"undefined\" === typeof b[c] && (b[c] = f++), l = b[c]) : !1 !== d.grouping && (l = f++), g.columnIndex = l);\n        });\n        const k = Math.min(Math.abs(d.transA) * (d.ordinal && d.ordinal.slope || e.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),\n          m = k * e.groupPadding,\n          n = (k - 2 * m) / (f || 1);\n        e = Math.min(e.maxPointWidth || d.len, L(e.pointWidth, n * (1 - 2 * e.pointPadding)));\n        a.columnMetrics = {\n          width: e,\n          offset: (n - e) / 2 + (m + ((a.columnIndex || 0) + (g ? 1 : 0)) * n - k / 2) * (g ? -1 : 1),\n          paddedWidth: n,\n          columnCount: f\n        };\n        return a.columnMetrics;\n      }\n      crispCol(a, e, d, h) {\n        var g = this.borderWidth,\n          b = -(g % 2 ? .5 : 0);\n        g = g % 2 ? .5 : 1;\n        this.options.crisp && (d = Math.round(a + d) + b, a = Math.round(a) + b, d -= a);\n        h = Math.round(e + h) + g;\n        b = .5 >= Math.abs(e) && .5 < h;\n        e = Math.round(e) + g;\n        h -= e;\n        b && h && (--e, h += 1);\n        return {\n          x: a,\n          y: e,\n          width: d,\n          height: h\n        };\n      }\n      adjustForMissingColumns(a, e, d, h) {\n        const g = this.options.stacking;\n        if (!d.isNull && 1 < h.columnCount) {\n          const b = this.yAxis.options.reversedStacks;\n          let c = 0,\n            f = b ? 0 : -h.columnCount;\n          E(this.yAxis.stacking && this.yAxis.stacking.stacks, a => {\n            if (\"number\" === typeof d.x) {\n              const e = a[d.x.toString()];\n              e && (a = e.points[this.index], g ? (a && (c = f), e.hasValidPoints && (b ? f++ : f--)) : n(a) && (a = Object.keys(e.points).filter(b => !b.match(\",\") && e.points[b] && 1 < e.points[b].length).map(parseFloat).sort((b, a) => a - b), c = a.indexOf(this.index), f = a.length));\n            }\n          });\n          a = (d.plotX || 0) + ((f - 1) * h.paddedWidth + e) / 2 - e - c * h.paddedWidth;\n        }\n        return a;\n      }\n      translate() {\n        const a = this,\n          e = a.chart,\n          d = a.options;\n        var k = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        k = a.borderWidth = L(d.borderWidth, k ? 0 : 1);\n        const g = a.xAxis,\n          b = a.yAxis,\n          c = d.threshold,\n          f = L(d.minPointLength, 5),\n          n = a.getColumnMetrics(),\n          r = n.width,\n          z = a.pointXOffset = n.offset,\n          u = a.dataMin,\n          t = a.dataMax;\n        let D = a.barW = Math.max(r, 1 + 2 * k),\n          E = a.translatedThreshold = b.getThreshold(c);\n        e.inverted && (E -= .5);\n        d.pointPadding && (D = Math.ceil(D));\n        F.prototype.translate.apply(a);\n        a.points.forEach(function (l) {\n          const k = L(l.yBottom, E);\n          var q = 999 + Math.abs(k),\n            x = l.plotX || 0;\n          q = p(l.plotY, -q, b.len + q);\n          let w = Math.min(q, k),\n            y = Math.max(q, k) - w,\n            J = r,\n            v = x + z,\n            N = D;\n          f && Math.abs(y) < f && (y = f, x = !b.reversed && !l.negative || b.reversed && l.negative, h(c) && h(t) && l.y === c && t <= c && (b.min || 0) < c && (u !== t || (b.max || 0) <= c) && (x = !x), w = Math.abs(w - E) > f ? k - f : E - (x ? f : 0));\n          m(l.options.pointWidth) && (J = N = Math.ceil(l.options.pointWidth), v -= Math.round((J - r) / 2));\n          d.centerInCategory && (v = a.adjustForMissingColumns(v, J, l, n));\n          l.barX = v;\n          l.pointWidth = J;\n          l.tooltipPos = e.inverted ? [p(b.len + b.pos - e.plotLeft - q, b.pos - e.plotLeft, b.len + b.pos - e.plotLeft), g.len + g.pos - e.plotTop - v - N / 2, y] : [g.left - e.plotLeft + v + N / 2, p(q + b.pos - e.plotTop, b.pos - e.plotTop, b.len + b.pos - e.plotTop), y];\n          l.shapeType = a.pointClass.prototype.shapeType || \"roundedRect\";\n          l.shapeArgs = a.crispCol(v, l.isNull ? E : w, N, l.isNull ? 0 : y);\n        });\n        v(this, \"afterColumnTranslate\");\n      }\n      drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      }\n      pointAttribs(a, e) {\n        const d = this.options;\n        var h = this.pointAttrToOptions || {},\n          g = h.stroke || \"borderColor\";\n        const b = h[\"stroke-width\"] || \"borderWidth\";\n        let c,\n          f = a && a.color || this.color,\n          k = a && a[g] || d[g] || f;\n        h = a && a.options.dashStyle || d.dashStyle;\n        let m = a && a[b] || d[b] || this[b] || 0,\n          q = L(a && a.opacity, d.opacity, 1);\n        a && this.zones.length && (c = a.getZone(), f = a.options.color || c && (c.color || a.nonZonedColor) || this.color, c && (k = c.borderColor || k, h = c.dashStyle || h, m = c.borderWidth || m));\n        e && a && (a = D(d.states[e], a.options.states && a.options.states[e] || {}), e = a.brightness, f = a.color || \"undefined\" !== typeof e && t(f).brighten(a.brightness).get() || f, k = a[g] || k, m = a[b] || m, h = a.dashStyle || h, q = L(a.opacity, q));\n        g = {\n          fill: f,\n          stroke: k,\n          \"stroke-width\": m,\n          opacity: q\n        };\n        h && (g.dashstyle = h);\n        return g;\n      }\n      drawPoints(a = this.points) {\n        const e = this,\n          d = this.chart,\n          k = e.options,\n          g = d.renderer,\n          b = k.animationLimit || 250;\n        let c;\n        a.forEach(function (a) {\n          let f = a.graphic,\n            l = !!f,\n            m = f && d.pointCount < b ? \"animate\" : \"attr\";\n          if (h(a.plotY) && null !== a.y) {\n            c = a.shapeArgs;\n            f && a.hasNewShapeType() && (f = f.destroy());\n            e.enabledDataSorting && (a.startXPos = e.xAxis.reversed ? -(c ? c.width || 0 : 0) : e.xAxis.width);\n            f || (a.graphic = f = g[a.shapeType](c).add(a.group || e.group)) && e.enabledDataSorting && d.hasRendered && d.pointCount < b && (f.attr({\n              x: a.startXPos\n            }), l = !0, m = \"animate\");\n            if (f && l) f[m](D(c));\n            d.styledMode || f[m](e.pointAttribs(a, a.selected && \"select\")).shadow(!1 !== a.allowShadow && k.shadow);\n            f && (f.addClass(a.getClassName(), !0), f.attr({\n              visibility: a.visible ? \"inherit\" : \"hidden\"\n            }));\n          } else f && (a.graphic = f.destroy());\n        });\n      }\n      drawTracker(a = this.points) {\n        const e = this,\n          d = e.chart,\n          h = d.pointer,\n          g = function (b) {\n            const a = h.getPointFromEvent(b);\n            \"undefined\" !== typeof a && (h.isDirectTouch = !0, a.onMouseOver(b));\n          };\n        let b;\n        a.forEach(function (a) {\n          b = n(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          b.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        e._hasTracking || (e.trackerGroups.forEach(function (b) {\n          if (e[b]) {\n            e[b].addClass(\"highcharts-tracker\").on(\"mouseover\", g).on(\"mouseout\", function (b) {\n              h.onTrackerMouseOut(b);\n            });\n            if (r) e[b].on(\"touchstart\", g);\n            !d.styledMode && e.options.cursor && e[b].css({\n              cursor: e.options.cursor\n            });\n          }\n        }), e._hasTracking = !0);\n        v(this, \"afterDrawTracker\");\n      }\n      remove() {\n        const a = this,\n          e = a.chart;\n        e.hasRendered && e.series.forEach(function (e) {\n          e.type === a.type && (e.isDirty = !0);\n        });\n        F.prototype.remove.apply(a, arguments);\n      }\n    }\n    e.defaultOptions = D(F.defaultOptions, H);\n    k(e.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      getSymbol: d,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    G.registerSeriesType(\"column\", e);\n    \"\";\n    return e;\n  });\n  M(a, \"Core/Series/DataLabel.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        getDeferredAnimation: u\n      } = a,\n      {\n        format: F\n      } = A,\n      {\n        defined: G,\n        extend: C,\n        fireEvent: B,\n        isArray: t,\n        isString: r,\n        merge: d,\n        objectEach: p,\n        pick: m,\n        splat: k\n      } = H;\n    var v;\n    (function (a) {\n      function h(a, b, c, f, e) {\n        const g = this.chart;\n        var d = this.isCartesian && g.inverted;\n        const l = this.enabledDataSorting;\n        var h = a.plotX,\n          k = a.plotY;\n        const q = c.rotation;\n        var n = c.align;\n        k = G(h) && G(k) && g.isInsidePlot(h, Math.round(k), {\n          inverted: d,\n          paneCoordinates: !0,\n          series: this\n        });\n        let x = \"justify\" === m(c.overflow, l ? \"none\" : \"justify\");\n        d = this.visible && !1 !== a.visible && G(h) && (a.series.forceDL || l && !x || k || m(c.inside, !!this.options.stacking) && f && g.isInsidePlot(h, d ? f.x + 1 : f.y + f.height - 1, {\n          inverted: d,\n          paneCoordinates: !0,\n          series: this\n        }));\n        h = a.pos();\n        if (d && h) {\n          q && b.attr({\n            align: n\n          });\n          n = b.getBBox(!0);\n          var w = [0, 0];\n          var p = g.renderer.fontMetrics(b).b;\n          f = C({\n            x: h[0],\n            y: Math.round(h[1]),\n            width: 0,\n            height: 0\n          }, f);\n          C(c, {\n            width: n.width,\n            height: n.height\n          });\n          q ? (x = !1, w = g.renderer.rotCorr(p, q), p = {\n            x: f.x + (c.x || 0) + f.width / 2 + w.x,\n            y: f.y + (c.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[c.verticalAlign] * f.height\n          }, w = [n.x - Number(b.attr(\"x\")), n.y - Number(b.attr(\"y\"))], l && this.xAxis && !x && this.setDataLabelStartPos(a, b, e, k, p), b[e ? \"attr\" : \"animate\"](p)) : (l && this.xAxis && !x && this.setDataLabelStartPos(a, b, e, k, f), b.align(c, void 0, f), p = b.alignAttr);\n          if (x && 0 <= f.height) this.justifyDataLabel(b, c, p, n, f, e);else if (m(c.crop, !0)) {\n            let {\n              x: b,\n              y: a\n            } = p;\n            b += w[0];\n            a += w[1];\n            d = g.isInsidePlot(b, a, {\n              paneCoordinates: !0,\n              series: this\n            }) && g.isInsidePlot(b + n.width, a + n.height, {\n              paneCoordinates: !0,\n              series: this\n            });\n          }\n          if (c.shape && !q) b[e ? \"attr\" : \"animate\"]({\n            anchorX: h[0],\n            anchorY: h[1]\n          });\n        }\n        e && l && (b.placed = !1);\n        d || l && !x ? b.show() : (b.hide(), b.placed = !1);\n      }\n      function n(a, b) {\n        var c = b.filter;\n        return c ? (b = c.operator, a = a[c.property], c = c.value, \">\" === b && a > c || \"<\" === b && a < c || \">=\" === b && a >= c || \"<=\" === b && a <= c || \"==\" === b && a == c || \"===\" === b && a === c ? !0 : !1) : !0;\n      }\n      function v() {\n        return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n      }\n      function E(a) {\n        const b = this.hasRendered || 0,\n          c = this.initDataLabelsGroup().attr({\n            opacity: +b\n          });\n        !b && c && (this.visible && c.show(), this.options.animation ? c.animate({\n          opacity: 1\n        }, a) : c.attr({\n          opacity: 1\n        }));\n        return c;\n      }\n      function e(a = this.points) {\n        const b = this,\n          c = b.chart,\n          f = b.options,\n          g = c.renderer,\n          {\n            backgroundColor: e,\n            plotBackgroundColor: d\n          } = c.options.chart,\n          l = g.getContrast(r(d) && d || r(e) && e || \"#000000\");\n        let h = f.dataLabels,\n          q,\n          w;\n        var v = k(h)[0];\n        const D = v.animation;\n        v = v.defer ? u(c, D, b) : {\n          defer: 0,\n          duration: 0\n        };\n        h = y(y(c.options.plotOptions && c.options.plotOptions.series && c.options.plotOptions.series.dataLabels, c.options.plotOptions && c.options.plotOptions[b.type] && c.options.plotOptions[b.type].dataLabels), h);\n        B(this, \"drawDataLabels\");\n        if (t(h) || h.enabled || b._hasPointLabels) w = this.initDataLabels(v), a.forEach(a => {\n          q = k(y(h, a.dlOptions || a.options && a.options.dataLabels));\n          q.forEach((e, d) => {\n            const h = e.enabled && (!a.isNull || a.dataLabelOnNull) && n(a, e),\n              k = a.connectors ? a.connectors[d] : a.connector;\n            let q,\n              x,\n              r = a.dataLabels ? a.dataLabels[d] : a.dataLabel,\n              z = !r;\n            const y = m(e.distance, a.labelDistance);\n            if (h) {\n              var v = a.getLabelConfig();\n              var u = m(e[a.formatPrefix + \"Format\"], e.format);\n              v = G(u) ? F(u, v, c) : (e[a.formatPrefix + \"Formatter\"] || e.formatter).call(v, e);\n              u = e.style;\n              q = e.rotation;\n              c.styledMode || (u.color = m(e.color, u.color, b.color, \"#000000\"), \"contrast\" === u.color ? (a.contrastColor = g.getContrast(a.color || b.color), u.color = !G(y) && e.inside || 0 > y || f.stacking ? a.contrastColor : l) : delete a.contrastColor, f.cursor && (u.cursor = f.cursor));\n              x = {\n                r: e.borderRadius || 0,\n                rotation: q,\n                padding: e.padding,\n                zIndex: 1\n              };\n              if (!c.styledMode) {\n                const {\n                  backgroundColor: b,\n                  borderColor: c\n                } = e;\n                x.fill = \"auto\" === b ? a.color : b;\n                x.stroke = \"auto\" === c ? a.color : c;\n                x[\"stroke-width\"] = e.borderWidth;\n              }\n              p(x, function (b, a) {\n                \"undefined\" === typeof b && delete x[a];\n              });\n            }\n            !r || h && G(v) && !!r.div === !!e.useHTML && (r.rotation && e.rotation || r.rotation === e.rotation) || (z = !0, a.dataLabel = r = a.dataLabel && a.dataLabel.destroy(), a.dataLabels && (1 === a.dataLabels.length ? delete a.dataLabels : delete a.dataLabels[d]), d || delete a.dataLabel, k && (a.connector = a.connector.destroy(), a.connectors && (1 === a.connectors.length ? delete a.connectors : delete a.connectors[d])));\n            h && G(v) ? (r ? x.text = v : (a.dataLabels = a.dataLabels || [], r = a.dataLabels[d] = q ? g.text(v, 0, 0, e.useHTML).addClass(\"highcharts-data-label\") : g.label(v, 0, 0, e.shape, null, null, e.useHTML, null, \"data-label\"), d || (a.dataLabel = r), r.addClass(\" highcharts-data-label-color-\" + a.colorIndex + \" \" + (e.className || \"\") + (e.useHTML ? \" highcharts-tracker\" : \"\"))), r.options = e, r.attr(x), c.styledMode || r.css(u).shadow(e.shadow), (d = e[a.formatPrefix + \"TextPath\"] || e.textPath) && !e.useHTML && (r.setTextPath(a.getDataLabelPath && a.getDataLabelPath(r) || a.graphic, d), a.dataLabelPath && !d.enabled && (a.dataLabelPath = a.dataLabelPath.destroy())), r.added || r.add(w), b.alignDataLabel(a, r, e, null, z)) : r && r.hide();\n          });\n        });\n        B(this, \"afterDrawDataLabels\");\n      }\n      function q(a, b, c, f, e, d) {\n        const g = this.chart,\n          l = b.align,\n          h = b.verticalAlign,\n          k = a.box ? 0 : a.padding || 0;\n        let {\n            x: m = 0,\n            y: q = 0\n          } = b,\n          n,\n          x;\n        n = (c.x || 0) + k;\n        0 > n && (\"right\" === l && 0 <= m ? (b.align = \"left\", b.inside = !0) : m -= n, x = !0);\n        n = (c.x || 0) + f.width - k;\n        n > g.plotWidth && (\"left\" === l && 0 >= m ? (b.align = \"right\", b.inside = !0) : m += g.plotWidth - n, x = !0);\n        n = c.y + k;\n        0 > n && (\"bottom\" === h && 0 <= q ? (b.verticalAlign = \"top\", b.inside = !0) : q -= n, x = !0);\n        n = (c.y || 0) + f.height - k;\n        n > g.plotHeight && (\"top\" === h && 0 >= q ? (b.verticalAlign = \"bottom\", b.inside = !0) : q += g.plotHeight - n, x = !0);\n        x && (b.x = m, b.y = q, a.placed = !d, a.align(b, void 0, e));\n        return x;\n      }\n      function y(a, b) {\n        let c = [],\n          f;\n        if (t(a) && !t(b)) c = a.map(function (a) {\n          return d(a, b);\n        });else if (t(b) && !t(a)) c = b.map(function (b) {\n          return d(a, b);\n        });else if (t(a) || t(b)) for (f = Math.max(a.length, b.length); f--;) c[f] = d(a[f], b[f]);else c = d(a, b);\n        return c;\n      }\n      function l(a, b, c, f, e) {\n        const g = this.chart,\n          d = g.inverted,\n          l = this.xAxis,\n          h = l.reversed,\n          k = d ? b.height / 2 : b.width / 2;\n        a = (a = a.pointWidth) ? a / 2 : 0;\n        b.startXPos = d ? e.x : h ? -k - a : l.width - k + a;\n        b.startYPos = d ? h ? this.yAxis.height - k + a : -k - a : e.y;\n        f ? \"hidden\" === b.visibility && (b.show(), b.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : b.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, b.hide);\n        g.hasRendered && (c && b.attr({\n          x: b.startXPos,\n          y: b.startYPos\n        }), b.placed = !0);\n      }\n      const w = [];\n      a.compose = function (a) {\n        H.pushUnique(w, a) && (a = a.prototype, a.initDataLabelsGroup = v, a.initDataLabels = E, a.alignDataLabel = h, a.drawDataLabels = e, a.justifyDataLabel = q, a.setDataLabelStartPos = l);\n      };\n    })(v || (v = {}));\n    \"\";\n    return v;\n  });\n  M(a, \"Series/Column/ColumnDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        series: u\n      } = A,\n      {\n        merge: F,\n        pick: G\n      } = H;\n    var C;\n    (function (B) {\n      function t(a, p, m, k, r) {\n        let d = this.chart.inverted;\n        var h = a.series;\n        let v = (h.xAxis ? h.xAxis.len : this.chart.plotSizeX) || 0;\n        h = (h.yAxis ? h.yAxis.len : this.chart.plotSizeY) || 0;\n        var t = a.dlBox || a.shapeArgs;\n        let E = G(a.below, a.plotY > G(this.translatedThreshold, h)),\n          e = G(m.inside, !!this.options.stacking);\n        t && (k = F(t), 0 > k.y && (k.height += k.y, k.y = 0), t = k.y + k.height - h, 0 < t && t < k.height && (k.height -= t), d && (k = {\n          x: h - k.y - k.height,\n          y: v - k.x - k.width,\n          width: k.height,\n          height: k.width\n        }), e || (d ? (k.x += E ? 0 : k.width, k.width = 0) : (k.y += E ? k.height : 0, k.height = 0)));\n        m.align = G(m.align, !d || e ? \"center\" : E ? \"right\" : \"left\");\n        m.verticalAlign = G(m.verticalAlign, d || e ? \"middle\" : E ? \"top\" : \"bottom\");\n        u.prototype.alignDataLabel.call(this, a, p, m, k, r);\n        m.inside && a.contrastColor && p.css({\n          color: a.contrastColor\n        });\n      }\n      const r = [];\n      B.compose = function (d) {\n        a.compose(u);\n        H.pushUnique(r, d) && (d.prototype.alignDataLabel = t);\n      };\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Series/Bar/BarSeries.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n      extend: u,\n      merge: F\n    } = H;\n    class G extends a {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n    }\n    G.defaultOptions = F(a.defaultOptions, {});\n    u(G.prototype, {\n      inverted: !0\n    });\n    A.registerSeriesType(\"bar\", G);\n    \"\";\n    return G;\n  });\n  M(a, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    };\n  });\n  M(a, \"Series/Scatter/ScatterSeries.js\", [a[\"Series/Scatter/ScatterSeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        column: u,\n        line: F\n      } = A.seriesTypes,\n      {\n        addEvent: G,\n        extend: C,\n        merge: B\n      } = H;\n    class t extends F {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      applyJitter() {\n        const a = this,\n          d = this.options.jitter,\n          p = this.points.length;\n        d && this.points.forEach(function (m, k) {\n          [\"x\", \"y\"].forEach(function (r, n) {\n            let h = \"plot\" + r.toUpperCase(),\n              v,\n              u;\n            if (d[r] && !m.isNull) {\n              var t = a[r + \"Axis\"];\n              u = d[r] * t.transA;\n              t && !t.isLog && (v = Math.max(0, m[h] - u), t = Math.min(t.len, m[h] + u), n = 1E4 * Math.sin(k + n * p), n -= Math.floor(n), m[h] = v + (t - v) * n, \"x\" === r && (m.clientX = m.plotX));\n            }\n          });\n        });\n      }\n      drawGraph() {\n        this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());\n      }\n    }\n    t.defaultOptions = B(F.defaultOptions, a);\n    C(t.prototype, {\n      drawTracker: u.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    G(t, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    A.registerSeriesType(\"scatter\", t);\n    return t;\n  });\n  M(a, \"Series/CenteredUtilities.js\", [a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        deg2rad: u\n      } = a,\n      {\n        fireEvent: F,\n        isNumber: G,\n        pick: C,\n        relativeLength: B\n      } = H;\n    var t = /*#__PURE__*/(() => {\n      (function (a) {\n        a.getCenter = function () {\n          var a = this.options,\n            p = this.chart;\n          const m = 2 * (a.slicedOffset || 0),\n            k = p.plotWidth - 2 * m,\n            r = p.plotHeight - 2 * m;\n          var n = a.center;\n          const h = Math.min(k, r),\n            u = a.thickness;\n          var t = a.size;\n          let E = a.innerSize || 0;\n          \"string\" === typeof t && (t = parseFloat(t));\n          \"string\" === typeof E && (E = parseFloat(E));\n          a = [C(n[0], \"50%\"), C(n[1], \"50%\"), C(t && 0 > t ? void 0 : a.size, \"100%\"), C(E && 0 > E ? void 0 : a.innerSize || 0, \"0%\")];\n          !p.angular || this instanceof A || (a[3] = 0);\n          for (n = 0; 4 > n; ++n) t = a[n], p = 2 > n || 2 === n && /%$/.test(t), a[n] = B(t, [k, r, h, a[2]][n]) + (p ? m : 0);\n          a[3] > a[2] && (a[3] = a[2]);\n          G(u) && 2 * u < a[2] && 0 < u && (a[3] = a[2] - 2 * u);\n          F(this, \"afterGetCenter\", {\n            positions: a\n          });\n          return a;\n        };\n        a.getStartAndEndRadians = function (a, p) {\n          a = G(a) ? a : 0;\n          p = G(p) && p > a && 360 > p - a ? p : a + 360;\n          return {\n            start: u * (a + -90),\n            end: u * (p + -90)\n          };\n        };\n      })(t || (t = {}));\n      return t;\n    })();\n    \"\";\n    return t;\n  });\n  M(a, \"Series/Pie/PiePoint.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        setAnimation: u\n      } = a,\n      {\n        addEvent: F,\n        defined: G,\n        extend: C,\n        isNumber: B,\n        pick: t,\n        relativeLength: r\n      } = H;\n    class d extends A {\n      constructor() {\n        super(...arguments);\n        this.series = this.options = this.labelDistance = void 0;\n      }\n      getConnectorPath() {\n        const a = this.labelPosition,\n          d = this.series.options.dataLabels,\n          k = this.connectorShapes;\n        let r = d.connectorShape;\n        k[r] && (r = k[r]);\n        return r.call(this, {\n          x: a.computed.x,\n          y: a.computed.y,\n          alignment: a.alignment\n        }, a.connectorPosition, d);\n      }\n      getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      }\n      haloPath(a) {\n        const d = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(d.x, d.y, d.r + a, d.r + a, {\n          innerR: d.r - 1,\n          start: d.start,\n          end: d.end,\n          borderRadius: d.borderRadius\n        });\n      }\n      init() {\n        super.init.apply(this, arguments);\n        this.name = t(this.name, \"Slice\");\n        const a = a => {\n          this.slice(\"select\" === a.type);\n        };\n        F(this, \"select\", a);\n        F(this, \"unselect\", a);\n        return this;\n      }\n      isValid() {\n        return B(this.y) && 0 <= this.y;\n      }\n      setVisible(a, d) {\n        const k = this.series,\n          m = k.chart,\n          n = k.options.ignoreHiddenPoint;\n        d = t(d, n);\n        a !== this.visible && (this.visible = this.options.visible = a = \"undefined\" === typeof a ? !this.visible : a, k.options.data[k.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\"].forEach(d => {\n          if (this[d]) this[d][a ? \"show\" : \"hide\"](a);\n        }), this.legendItem && m.legend.colorizeItem(this, a), a || \"hover\" !== this.state || this.setState(\"\"), n && (k.isDirty = !0), d && m.redraw());\n      }\n      slice(a, d, k) {\n        const m = this.series;\n        u(k, m.chart);\n        t(d, !0);\n        this.sliced = this.options.sliced = G(a) ? a : !this.sliced;\n        m.options.data[m.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n      }\n    }\n    C(d.prototype, {\n      connectorShapes: {\n        fixedOffset: function (a, d, k) {\n          const m = d.breakAt;\n          d = d.touchingSliceAt;\n          return [[\"M\", a.x, a.y], k.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * m.x - d.x, 2 * m.y - d.y, m.x, m.y] : [\"L\", m.x, m.y], [\"L\", d.x, d.y]];\n        },\n        straight: function (a, d) {\n          d = d.touchingSliceAt;\n          return [[\"M\", a.x, a.y], [\"L\", d.x, d.y]];\n        },\n        crookedLine: function (a, d, k) {\n          const {\n            breakAt: m,\n            touchingSliceAt: n\n          } = d;\n          ({\n            series: d\n          } = this);\n          const [h, p, u] = d.center,\n            t = u / 2,\n            e = d.chart.plotWidth,\n            q = d.chart.plotLeft;\n          d = \"left\" === a.alignment;\n          const {\n            x: y,\n            y: l\n          } = a;\n          k.crookDistance ? (a = r(k.crookDistance, 1), a = d ? h + t + (e + q - h - t) * (1 - a) : q + (h - t) * a) : a = h + (p - l) * Math.tan((this.angle || 0) - Math.PI / 2);\n          k = [[\"M\", y, l]];\n          (d ? a <= y && a >= m.x : a >= y && a <= m.x) && k.push([\"L\", a, l]);\n          k.push([\"L\", m.x, m.y], [\"L\", n.x, n.y]);\n          return k;\n        }\n      }\n    });\n    return d;\n  });\n  M(a, \"Series/Pie/PieSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"crookedLine\",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  });\n  M(a, \"Series/Pie/PieSeries.js\", [a[\"Series/CenteredUtilities.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Globals.js\"], a[\"Series/Pie/PiePoint.js\"], a[\"Series/Pie/PieSeriesDefaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C, B, t) {\n    const {\n      getStartAndEndRadians: r\n    } = a;\n    ({\n      noop: H\n    } = H);\n    const {\n      clamp: d,\n      extend: p,\n      fireEvent: m,\n      merge: k,\n      pick: u,\n      relativeLength: n\n    } = t;\n    class h extends G {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.maxLabelDistance = this.data = this.center = void 0;\n      }\n      animate(a) {\n        const d = this,\n          h = d.points,\n          e = d.startAngleRad;\n        a || h.forEach(function (a) {\n          const h = a.graphic,\n            l = a.shapeArgs;\n          h && l && (h.attr({\n            r: u(a.startR, d.center && d.center[3] / 2),\n            start: e,\n            end: e\n          }), h.animate({\n            r: l.r,\n            start: l.start,\n            end: l.end\n          }, d.options.animation));\n        });\n      }\n      drawEmpty() {\n        const a = this.startAngleRad,\n          d = this.endAngleRad,\n          h = this.options;\n        let e, k;\n        0 === this.total && this.center ? (e = this.center[0], k = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(e, k, this.center[1] / 2, 0, a, d).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n          d: B.arc(e, k, this.center[2] / 2, 0, {\n            start: a,\n            end: d,\n            innerR: this.center[3] / 2\n          })\n        }), this.chart.styledMode || this.graph.attr({\n          \"stroke-width\": h.borderWidth,\n          fill: h.fillColor || \"none\",\n          stroke: h.color || \"#cccccc\"\n        })) : this.graph && (this.graph = this.graph.destroy());\n      }\n      drawPoints() {\n        const a = this.chart.renderer;\n        this.points.forEach(function (d) {\n          d.graphic && d.hasNewShapeType() && (d.graphic = d.graphic.destroy());\n          d.graphic || (d.graphic = a[d.shapeType](d.shapeArgs).add(d.series.group), d.delayedRendering = !0);\n        });\n      }\n      generatePoints() {\n        super.generatePoints();\n        this.updateTotals();\n      }\n      getX(a, h, k) {\n        const e = this.center,\n          n = this.radii ? this.radii[k.index] || 0 : e[2] / 2;\n        a = Math.asin(d((a - e[1]) / (n + k.labelDistance), -1, 1));\n        return e[0] + (h ? -1 : 1) * Math.cos(a) * (n + k.labelDistance) + (0 < k.labelDistance ? (h ? -1 : 1) * this.options.dataLabels.padding : 0);\n      }\n      hasData() {\n        return !!this.processedXData.length;\n      }\n      redrawPoints() {\n        const a = this,\n          d = a.chart;\n        let h, e, n, m;\n        this.drawEmpty();\n        a.group && !d.styledMode && a.group.shadow(a.options.shadow);\n        a.points.forEach(function (l) {\n          const q = {};\n          e = l.graphic;\n          !l.isNull && e ? (m = l.shapeArgs, h = l.getTranslate(), d.styledMode || (n = a.pointAttribs(l, l.selected && \"select\")), l.delayedRendering ? (e.setRadialReference(a.center).attr(m).attr(h), d.styledMode || e.attr(n).attr({\n            \"stroke-linejoin\": \"round\"\n          }), l.delayedRendering = !1) : (e.setRadialReference(a.center), d.styledMode || k(!0, q, n), k(!0, q, m, h), e.animate(q)), e.attr({\n            visibility: l.visible ? \"inherit\" : \"hidden\"\n          }), e.addClass(l.getClassName(), !0)) : e && (l.graphic = e.destroy());\n        });\n      }\n      sortByAngle(a, d) {\n        a.sort(function (a, e) {\n          return \"undefined\" !== typeof a.angle && (e.angle - a.angle) * d;\n        });\n      }\n      translate(a) {\n        m(this, \"translate\");\n        this.generatePoints();\n        var d = this.options;\n        const h = d.slicedOffset,\n          e = h + (d.borderWidth || 0);\n        var k = r(d.startAngle, d.endAngle);\n        const p = this.startAngleRad = k.start;\n        k = (this.endAngleRad = k.end) - p;\n        const l = this.points,\n          w = d.dataLabels.distance;\n        d = d.ignoreHiddenPoint;\n        const g = l.length;\n        let b,\n          c,\n          f,\n          x = 0;\n        a || (this.center = a = this.getCenter());\n        for (c = 0; c < g; c++) {\n          f = l[c];\n          var v = p + x * k;\n          !f.isValid() || d && !f.visible || (x += f.percentage / 100);\n          var z = p + x * k;\n          var t = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * v) / 1E3,\n            end: Math.round(1E3 * z) / 1E3\n          };\n          f.shapeType = \"arc\";\n          f.shapeArgs = t;\n          f.labelDistance = u(f.options.dataLabels && f.options.dataLabels.distance, w);\n          f.labelDistance = n(f.labelDistance, t.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, f.labelDistance);\n          z = (z + v) / 2;\n          z > 1.5 * Math.PI ? z -= 2 * Math.PI : z < -Math.PI / 2 && (z += 2 * Math.PI);\n          f.slicedTranslation = {\n            translateX: Math.round(Math.cos(z) * h),\n            translateY: Math.round(Math.sin(z) * h)\n          };\n          t = Math.cos(z) * a[2] / 2;\n          b = Math.sin(z) * a[2] / 2;\n          f.tooltipPos = [a[0] + .7 * t, a[1] + .7 * b];\n          f.half = z < -Math.PI / 2 || z > Math.PI / 2 ? 1 : 0;\n          f.angle = z;\n          v = Math.min(e, f.labelDistance / 5);\n          f.labelPosition = {\n            natural: {\n              x: a[0] + t + Math.cos(z) * f.labelDistance,\n              y: a[1] + b + Math.sin(z) * f.labelDistance\n            },\n            computed: {},\n            alignment: 0 > f.labelDistance ? \"center\" : f.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + t + Math.cos(z) * v,\n                y: a[1] + b + Math.sin(z) * v\n              },\n              touchingSliceAt: {\n                x: a[0] + t,\n                y: a[1] + b\n              }\n            }\n          };\n        }\n        m(this, \"afterTranslate\");\n      }\n      updateTotals() {\n        const a = this.points,\n          d = a.length,\n          h = this.options.ignoreHiddenPoint;\n        let e,\n          k,\n          n = 0;\n        for (e = 0; e < d; e++) k = a[e], !k.isValid() || h && !k.visible || (n += k.y);\n        this.total = n;\n        for (e = 0; e < d; e++) k = a[e], k.percentage = 0 < n && (k.visible || !h) ? k.y / n * 100 : 0, k.total = n;\n      }\n    }\n    h.defaultOptions = k(G.defaultOptions, F);\n    p(h.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: A.prototype.drawTracker,\n      getCenter: a.getCenter,\n      getSymbol: H,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: A.prototype.pointAttribs,\n      pointClass: I,\n      requireSorting: !1,\n      searchPoint: H,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    C.registerSeriesType(\"pie\", h);\n    return h;\n  });\n  M(a, \"Series/Pie/PieDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F) {\n    const {\n        noop: u\n      } = A,\n      {\n        distribute: C\n      } = H,\n      {\n        series: B\n      } = I,\n      {\n        arrayMax: t,\n        clamp: r,\n        defined: d,\n        merge: p,\n        pick: m,\n        relativeLength: k\n      } = F;\n    var v;\n    (function (n) {\n      function h() {\n        const a = this,\n          e = a.data,\n          l = a.chart,\n          h = a.options.dataLabels || {},\n          g = h.connectorPadding,\n          b = l.plotWidth,\n          c = l.plotHeight,\n          f = l.plotLeft,\n          k = Math.round(l.chartWidth / 3),\n          n = a.center,\n          r = n[2] / 2,\n          u = n[1],\n          v = [[], []],\n          D = [0, 0, 0, 0],\n          E = a.dataLabelPositioners;\n        let O, A, F, L, K, G, H, I, M, X, U, Z;\n        a.visible && (h.enabled || a._hasPointLabels) && (e.forEach(function (a) {\n          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), a.dataLabel.shortened = !1);\n        }), B.prototype.drawDataLabels.apply(a), e.forEach(function (a) {\n          a.dataLabel && (a.visible ? (v[a.half].push(a), a.dataLabel._pos = null, !d(h.style.width) && !d(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > k && (a.dataLabel.css({\n            width: Math.round(.7 * k) + \"px\"\n          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n        }), v.forEach((e, k) => {\n          const q = e.length,\n            x = [];\n          let w,\n            p = 0;\n          if (q) {\n            a.sortByAngle(e, k - .5);\n            if (0 < a.maxLabelDistance) {\n              var z = Math.max(0, u - r - a.maxLabelDistance);\n              w = Math.min(u + r + a.maxLabelDistance, l.plotHeight);\n              e.forEach(function (a) {\n                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, u - r - a.labelDistance), a.bottom = Math.min(u + r + a.labelDistance, l.plotHeight), p = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                  target: a.labelPosition.natural.y - a.top + p / 2,\n                  size: p,\n                  rank: a.y\n                }, x.push(a.distributeBox));\n              });\n              z = w + p - z;\n              C(x, z, z / 5);\n            }\n            for (U = 0; U < q; U++) {\n              O = e[U];\n              G = O.labelPosition;\n              L = O.dataLabel;\n              X = !1 === O.visible ? \"hidden\" : \"inherit\";\n              M = z = G.natural.y;\n              x && d(O.distributeBox) && (\"undefined\" === typeof O.distributeBox.pos ? X = \"hidden\" : (H = O.distributeBox.size, M = E.radialDistributionY(O)));\n              delete O.positionIndex;\n              if (h.justify) I = E.justify(O, r, n);else switch (h.alignTo) {\n                case \"connectors\":\n                  I = E.alignToConnectors(e, k, b, f);\n                  break;\n                case \"plotEdges\":\n                  I = E.alignToPlotEdges(L, k, b, f);\n                  break;\n                default:\n                  I = E.radialDistributionX(a, O, M, z);\n              }\n              L._attr = {\n                visibility: X,\n                align: G.alignment\n              };\n              Z = O.options.dataLabels || {};\n              L._pos = {\n                x: I + m(Z.x, h.x) + ({\n                  left: g,\n                  right: -g\n                }[G.alignment] || 0),\n                y: M + m(Z.y, h.y) - L.getBBox().height / 2\n              };\n              G && (G.computed.x = I, G.computed.y = M);\n              m(h.crop, !0) && (K = L.getBBox().width, z = null, I - K < g && 1 === k ? (z = Math.round(K - I + g), D[3] = Math.max(z, D[3])) : I + K > b - g && 0 === k && (z = Math.round(I + K - b + g), D[1] = Math.max(z, D[1])), 0 > M - H / 2 ? D[0] = Math.max(Math.round(-M + H / 2), D[0]) : M + H / 2 > c && (D[2] = Math.max(Math.round(M + H / 2 - c), D[2])), L.sideOverflow = z);\n            }\n          }\n        }), 0 === t(D) || this.verifyDataLabelOverflow(D)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n          Z = p(h, b.options.dataLabels);\n          if (A = m(Z.connectorWidth, 1)) {\n            let c;\n            F = b.connector;\n            if ((L = b.dataLabel) && L._pos && b.visible && 0 < b.labelDistance) {\n              X = L._attr.visibility;\n              if (c = !F) b.connector = F = l.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(a.dataLabelsGroup), l.styledMode || F.attr({\n                \"stroke-width\": A,\n                stroke: Z.connectorColor || b.color || \"#666666\"\n              });\n              F[c ? \"attr\" : \"animate\"]({\n                d: b.getConnectorPath()\n              });\n              F.attr(\"visibility\", X);\n            } else F && (b.connector = F.destroy());\n          }\n        }));\n      }\n      function v() {\n        this.points.forEach(function (a) {\n          let e = a.dataLabel,\n            d;\n          e && a.visible && ((d = e._pos) ? (e.sideOverflow && (e._attr.width = Math.max(e.getBBox().width - e.sideOverflow, 0), e.css({\n            width: e._attr.width + \"px\",\n            textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n          }), e.shortened = !0), e.attr(e._attr), e[e.moved ? \"animate\" : \"attr\"](d), e.moved = !0) : e && e.attr({\n            y: -9999\n          }));\n          delete a.distributeBox;\n        }, this);\n      }\n      function A(a) {\n        let e = this.center,\n          d = this.options,\n          h = d.center,\n          g = d.minSize || 80,\n          b,\n          c = null !== d.size;\n        c || (null !== h[0] ? b = Math.max(e[2] - Math.max(a[1], a[3]), g) : (b = Math.max(e[2] - a[1] - a[3], g), e[0] += (a[3] - a[1]) / 2), null !== h[1] ? b = r(b, g, e[2] - Math.max(a[0], a[2])) : (b = r(b, g, e[2] - a[0] - a[2]), e[1] += (a[0] - a[2]) / 2), b < e[2] ? (e[2] = b, e[3] = Math.min(d.thickness ? Math.max(0, b - 2 * d.thickness) : Math.max(0, k(d.innerSize || 0, b)), b), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : c = !0);\n        return c;\n      }\n      const E = [],\n        e = {\n          radialDistributionY: function (a) {\n            return a.top + a.distributeBox.pos;\n          },\n          radialDistributionX: function (a, e, d, h) {\n            return a.getX(d < e.top + 2 || d > e.bottom - 2 ? h : d, e.half, e);\n          },\n          justify: function (a, e, d) {\n            return d[0] + (a.half ? -1 : 1) * (e + a.labelDistance);\n          },\n          alignToPlotEdges: function (a, e, d, h) {\n            a = a.getBBox().width;\n            return e ? a + h : d - a - h;\n          },\n          alignToConnectors: function (a, e, d, h) {\n            let g = 0,\n              b;\n            a.forEach(function (a) {\n              b = a.dataLabel.getBBox().width;\n              b > g && (g = b);\n            });\n            return e ? g + h : d - g - h;\n          }\n        };\n      n.compose = function (d) {\n        a.compose(B);\n        F.pushUnique(E, d) && (d = d.prototype, d.dataLabelPositioners = e, d.alignDataLabel = u, d.drawDataLabels = h, d.placeDataLabels = v, d.verifyDataLabelOverflow = A);\n      };\n    })(v || (v = {}));\n    return v;\n  });\n  M(a, \"Extensions/OverlappingDataLabels.js\", [a[\"Core/Chart/Chart.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    function u(a, d) {\n      let p,\n        m = !1;\n      a && (p = a.newOpacity, a.oldOpacity !== p && (a.alignAttr && a.placed ? (a[p ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), m = !0, a.alignAttr.opacity = p, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, function () {\n        d.styledMode || a.css({\n          pointerEvents: p ? \"auto\" : \"none\"\n        });\n      }), F(d, \"afterHideOverlappingLabel\")) : a.attr({\n        opacity: p\n      })), a.isOld = !0);\n      return m;\n    }\n    const {\n      addEvent: I,\n      fireEvent: F,\n      isArray: G,\n      isNumber: C,\n      objectEach: B,\n      pick: t\n    } = A;\n    I(a, \"render\", function () {\n      let a = this,\n        d = [];\n      (this.labelCollectors || []).forEach(function (a) {\n        d = d.concat(a());\n      });\n      (this.yAxis || []).forEach(function (a) {\n        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && B(a.stacking.stacks, function (a) {\n          B(a, function (a) {\n            a.label && d.push(a.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (p) {\n        var m = p.options.dataLabels;\n        p.visible && (!1 !== m.enabled || p._hasPointLabels) && (m = k => k.forEach(k => {\n          k.visible && (G(k.dataLabels) ? k.dataLabels : k.dataLabel ? [k.dataLabel] : []).forEach(function (n) {\n            const h = n.options;\n            n.labelrank = t(h.labelrank, k.labelrank, k.shapeArgs && k.shapeArgs.height);\n            h.allowOverlap ? (n.oldOpacity = n.opacity, n.newOpacity = 1, u(n, a)) : d.push(n);\n          });\n        }), m(p.nodes || []), m(p.points));\n      });\n      this.hideOverlappingLabels(d);\n    });\n    a.prototype.hideOverlappingLabels = function (a) {\n      let d = this,\n        p = a.length,\n        m = d.renderer;\n      var k;\n      let r;\n      let n,\n        h,\n        t,\n        B = !1;\n      var E = function (a) {\n        let e, d;\n        var h;\n        let k = a.box ? 0 : a.padding || 0,\n          g = h = 0,\n          b,\n          c;\n        if (a && (!a.alignAttr || a.placed)) return e = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, d = a.parentGroup, a.width || (h = a.getBBox(), a.width = h.width, a.height = h.height, h = m.fontMetrics(a.element).h), b = a.width - 2 * k, (c = {\n          left: \"0\",\n          center: \"0.5\",\n          right: \"1\"\n        }[a.alignValue]) ? g = +c * b : C(a.x) && Math.round(a.x) !== a.translateX && (g = a.x - a.translateX), {\n          x: e.x + (d.translateX || 0) + k - (g || 0),\n          y: e.y + (d.translateY || 0) + k - h,\n          width: a.width - 2 * k,\n          height: a.height - 2 * k\n        };\n      };\n      for (r = 0; r < p; r++) if (k = a[r]) k.oldOpacity = k.opacity, k.newOpacity = 1, k.absoluteBox = E(k);\n      a.sort(function (a, d) {\n        return (d.labelrank || 0) - (a.labelrank || 0);\n      });\n      for (r = 0; r < p; r++) for (h = (E = a[r]) && E.absoluteBox, k = r + 1; k < p; ++k) t = (n = a[k]) && n.absoluteBox, !h || !t || E === n || 0 === E.newOpacity || 0 === n.newOpacity || \"hidden\" === E.visibility || \"hidden\" === n.visibility || t.x >= h.x + h.width || t.x + t.width <= h.x || t.y >= h.y + h.height || t.y + t.height <= h.y || ((E.labelrank < n.labelrank ? E : n).newOpacity = 0);\n      a.forEach(function (a) {\n        u(a, d) && (B = !0);\n      });\n      B && F(d, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  M(a, \"Extensions/BorderRadius.js\", [a[\"Core/Defaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G) {\n    const {\n      defaultOptions: u\n    } = a;\n    ({\n      seriesTypes: a\n    } = H);\n    const {\n        addEvent: B,\n        extend: t,\n        isObject: r,\n        merge: d,\n        relativeLength: p\n      } = G,\n      m = {\n        radius: 0,\n        scope: \"stack\",\n        where: void 0\n      },\n      k = (a, k) => {\n        r(a) || (a = {\n          radius: a || 0\n        });\n        return d(m, k, a);\n      };\n    if (-1 === I.symbolCustomAttribs.indexOf(\"borderRadius\")) {\n      I.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\");\n      const d = F.prototype.symbols.arc;\n      F.prototype.symbols.arc = function (a, k, n, m, e = {}) {\n        a = d(a, k, n, m, e);\n        const {\n          innerR: h = 0,\n          r = n,\n          start: l = 0,\n          end: w = 0\n        } = e;\n        if (e.open || !e.borderRadius) return a;\n        n = w - l;\n        k = Math.sin(n / 2);\n        e = Math.max(Math.min(p(e.borderRadius || 0, r - h), (r - h) / 2, r * k / (1 + k)), 0);\n        n = Math.min(e, n / Math.PI * 2 * h);\n        for (k = a.length - 1; k--;) {\n          {\n            let d = void 0,\n              h = void 0,\n              l = void 0;\n            m = a;\n            var g = k,\n              b = 1 < k ? n : e,\n              c = m[g],\n              f = m[g + 1];\n            \"Z\" === f[0] && (f = m[0]);\n            \"M\" !== c[0] && \"L\" !== c[0] || \"A\" !== f[0] ? \"A\" !== c[0] || \"M\" !== f[0] && \"L\" !== f[0] || (l = f, h = c) : (l = c, h = f, d = !0);\n            if (l && h && h.params) {\n              c = h[1];\n              var x = h[5];\n              f = h.params;\n              const {\n                start: a,\n                end: e,\n                cx: k,\n                cy: n\n              } = f;\n              var u = x ? c - b : c + b;\n              const q = u ? Math.asin(b / u) : 0;\n              x = x ? q : -q;\n              u *= Math.cos(q);\n              d ? (f.start = a + x, l[1] = k + u * Math.cos(a), l[2] = n + u * Math.sin(a), m.splice(g + 1, 0, [\"A\", b, b, 0, 0, 1, k + c * Math.cos(f.start), n + c * Math.sin(f.start)])) : (f.end = e - x, h[6] = k + c * Math.cos(f.end), h[7] = n + c * Math.sin(f.end), m.splice(g + 1, 0, [\"A\", b, b, 0, 0, 1, k + u * Math.cos(e), n + u * Math.sin(e)]));\n              h[4] = Math.abs(f.end - f.start) < Math.PI ? 0 : 1;\n            }\n          }\n        }\n        return a;\n      };\n      const n = F.prototype.symbols.roundedRect;\n      F.prototype.symbols.roundedRect = function (a, d, k, m, e = {}) {\n        const h = n(a, d, k, m, e),\n          {\n            r: p = 0,\n            brBoxHeight: l = m,\n            brBoxY: w = d\n          } = e;\n        var g = d - w,\n          b = w + l - (d + m);\n        e = -.1 < g - p ? 0 : p;\n        const c = -.1 < b - p ? 0 : p;\n        var f = Math.max(e && g, 0);\n        const x = Math.max(c && b, 0);\n        b = [a + e, d];\n        g = [a + k - e, d];\n        const r = [a + k, d + e],\n          z = [a + k, d + m - c],\n          u = [a + k - c, d + m],\n          t = [a + c, d + m],\n          v = [a, d + m - c],\n          D = [a, d + e];\n        if (f) {\n          const a = Math.sqrt(Math.pow(e, 2) - Math.pow(e - f, 2));\n          b[0] -= a;\n          g[0] += a;\n          r[1] = D[1] = d + e - f;\n        }\n        m < e - f && (f = Math.sqrt(Math.pow(e, 2) - Math.pow(e - f - m, 2)), r[0] = z[0] = a + k - e + f, u[0] = Math.min(r[0], u[0]), t[0] = Math.max(z[0], t[0]), v[0] = D[0] = a + e - f, r[1] = D[1] = d + m);\n        x && (f = Math.sqrt(Math.pow(c, 2) - Math.pow(c - x, 2)), u[0] += f, t[0] -= f, z[1] = v[1] = d + m - c + x);\n        m < c - x && (m = Math.sqrt(Math.pow(c, 2) - Math.pow(c - x - m, 2)), r[0] = z[0] = a + k - c + m, g[0] = Math.min(r[0], g[0]), b[0] = Math.max(z[0], b[0]), v[0] = D[0] = a + c - m, z[1] = v[1] = d);\n        h.length = 0;\n        h.push([\"M\", ...b], [\"L\", ...g], [\"A\", e, e, 0, 0, 1, ...r], [\"L\", ...z], [\"A\", c, c, 0, 0, 1, ...u], [\"L\", ...t], [\"A\", c, c, 0, 0, 1, ...v], [\"L\", ...D], [\"A\", e, e, 0, 0, 1, ...b], [\"Z\"]);\n        return h;\n      };\n      B(a.pie, \"afterTranslate\", function () {\n        const a = k(this.options.borderRadius);\n        for (const d of this.points) {\n          const h = d.shapeArgs;\n          h && (h.borderRadius = p(a.radius, (h.r || 0) - (h.innerR || 0)));\n        }\n      });\n      B(A, \"afterColumnTranslate\", function () {\n        var a, d;\n        if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {\n          const {\n              options: h,\n              yAxis: v\n            } = this,\n            l = \"percent\" === h.stacking;\n          var n = null === (d = null === (a = u.plotOptions) || void 0 === a ? void 0 : a[this.type]) || void 0 === d ? void 0 : d.borderRadius;\n          a = k(h.borderRadius, r(n) ? n : {});\n          d = v.options.reversed;\n          for (const k of this.points) if (({\n            shapeArgs: n\n          } = k), \"roundedRect\" === k.shapeType && n) {\n            const {\n              width: g = 0,\n              height: b = 0,\n              y: c = 0\n            } = n;\n            var m = c,\n              e = b;\n            \"stack\" === a.scope && k.stackTotal && (m = v.translate(l ? 100 : k.stackTotal, !1, !0, !1, !0), e = v.translate(h.threshold || 0, !1, !0, !1, !0), e = this.crispCol(0, Math.min(m, e), 0, Math.abs(m - e)), m = e.y, e = e.height);\n            const f = -1 === (k.negative ? -1 : 1) * (d ? -1 : 1);\n            let q = a.where;\n            !q && this.is(\"waterfall\") && Math.abs((k.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (q = \"all\");\n            q || (q = \"end\");\n            const w = Math.min(p(a.radius, g), g / 2, \"all\" === q ? b / 2 : Infinity) || 0;\n            \"end\" === q && (f && (m -= w), e += w);\n            t(n, {\n              brBoxHeight: e,\n              brBoxY: m,\n              r: w\n            });\n          }\n        }\n      }, {\n        order: 9\n      });\n    }\n    A = {\n      optionsToObject: k\n    };\n    \"\";\n    return A;\n  });\n  M(a, \"Core/Responsive.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      extend: u,\n      find: H,\n      isArray: I,\n      isObject: F,\n      merge: G,\n      objectEach: C,\n      pick: B,\n      splat: t,\n      uniqueKey: r\n    } = a;\n    var d;\n    (function (d) {\n      function m(a) {\n        function d(a, k, n, l) {\n          let e;\n          C(a, function (a, b) {\n            if (!l && -1 < h.collectionsWithUpdate.indexOf(b) && k[b]) for (a = t(a), n[b] = [], e = 0; e < Math.max(a.length, k[b].length); e++) k[b][e] && (void 0 === a[e] ? n[b][e] = k[b][e] : (n[b][e] = {}, d(a[e], k[b][e], n[b][e], l + 1)));else F(a) ? (n[b] = I(a) ? [] : {}, d(a, k[b] || {}, n[b], l + 1)) : n[b] = \"undefined\" === typeof k[b] ? null : k[b];\n          });\n        }\n        const h = this,\n          k = {};\n        d(a, this.options, k, 0);\n        return k;\n      }\n      function k(a, d) {\n        const h = a.condition;\n        (h.callback || function () {\n          return this.chartWidth <= B(h.maxWidth, Number.MAX_VALUE) && this.chartHeight <= B(h.maxHeight, Number.MAX_VALUE) && this.chartWidth >= B(h.minWidth, 0) && this.chartHeight >= B(h.minHeight, 0);\n        }).call(this) && d.push(a._id);\n      }\n      function p(a, d) {\n        const h = this.options.responsive;\n        var k = this.currentResponsive;\n        let e = [];\n        !d && h && h.rules && h.rules.forEach(a => {\n          \"undefined\" === typeof a._id && (a._id = r());\n          this.matchResponsiveRule(a, e);\n        }, this);\n        d = G(...e.map(a => H((h || {}).rules || [], e => e._id === a)).map(a => a && a.chartOptions));\n        d.isResponsiveOptions = !0;\n        e = e.toString() || void 0;\n        e !== (k && k.ruleIds) && (k && this.update(k.undoOptions, a, !0), e ? (k = this.currentOptions(d), k.isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: e,\n          mergedOptions: d,\n          undoOptions: k\n        }, this.update(d, a, !0)) : this.currentResponsive = void 0);\n      }\n      const n = [];\n      d.compose = function (d) {\n        a.pushUnique(n, d) && u(d.prototype, {\n          currentOptions: m,\n          matchResponsiveRule: k,\n          setResponsive: p\n        });\n        return d;\n      };\n    })(d || (d = {}));\n    \"\";\n    \"\";\n    return d;\n  });\n  M(a, \"masters/highcharts.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Animation/Fx.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Renderer/HTML/HTMLElement.js\"], a[\"Core/Renderer/HTML/HTMLRenderer.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Axis/DateTimeAxis.js\"], a[\"Core/Axis/LogarithmicAxis.js\"], a[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Tooltip.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Pointer.js\"], a[\"Core/Legend/Legend.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Axis/Stacking/StackingAxis.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Series/Column/ColumnDataLabel.js\"], a[\"Series/Pie/PieSeries.js\"], a[\"Series/Pie/PieDataLabel.js\"], a[\"Core/Series/DataLabel.js\"], a[\"Core/Responsive.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Time.js\"]], function (a, A, H, I, F, G, C, B, t, r, d, p, m, k, v, n, h, D, L, E, e, q, y, l, w, g, b, c, f, x, J, z, Q, S) {\n    a.animate = F.animate;\n    a.animObject = F.animObject;\n    a.getDeferredAnimation = F.getDeferredAnimation;\n    a.setAnimation = F.setAnimation;\n    a.stop = F.stop;\n    a.timers = I.timers;\n    a.AST = G;\n    a.Axis = m;\n    a.Chart = q;\n    a.chart = q.chart;\n    a.Fx = I;\n    a.Legend = e;\n    a.PlotLineOrBand = n;\n    a.Point = L;\n    a.Pointer = E;\n    a.Series = w;\n    a.StackItem = l;\n    a.SVGElement = t;\n    a.SVGRenderer = r;\n    a.Tick = h;\n    a.Time = S;\n    a.Tooltip = D;\n    a.Color = Q;\n    a.color = Q.parse;\n    p.compose(r);\n    d.compose(t);\n    E.compose(q);\n    e.compose(q);\n    a.defaultOptions = H.defaultOptions;\n    a.getOptions = H.getOptions;\n    a.time = H.defaultTime;\n    a.setOptions = H.setOptions;\n    a.dateFormat = C.dateFormat;\n    a.format = C.format;\n    a.numberFormat = C.numberFormat;\n    a.addEvent = A.addEvent;\n    a.arrayMax = A.arrayMax;\n    a.arrayMin = A.arrayMin;\n    a.attr = A.attr;\n    a.clearTimeout = A.clearTimeout;\n    a.correctFloat = A.correctFloat;\n    a.createElement = A.createElement;\n    a.css = A.css;\n    a.defined = A.defined;\n    a.destroyObjectProperties = A.destroyObjectProperties;\n    a.discardElement = A.discardElement;\n    a.distribute = B.distribute;\n    a.erase = A.erase;\n    a.error = A.error;\n    a.extend = A.extend;\n    a.extendClass = A.extendClass;\n    a.find = A.find;\n    a.fireEvent = A.fireEvent;\n    a.getMagnitude = A.getMagnitude;\n    a.getStyle = A.getStyle;\n    a.inArray = A.inArray;\n    a.isArray = A.isArray;\n    a.isClass = A.isClass;\n    a.isDOMElement = A.isDOMElement;\n    a.isFunction = A.isFunction;\n    a.isNumber = A.isNumber;\n    a.isObject = A.isObject;\n    a.isString = A.isString;\n    a.keys = A.keys;\n    a.merge = A.merge;\n    a.normalizeTickInterval = A.normalizeTickInterval;\n    a.objectEach = A.objectEach;\n    a.offset = A.offset;\n    a.pad = A.pad;\n    a.pick = A.pick;\n    a.pInt = A.pInt;\n    a.relativeLength = A.relativeLength;\n    a.removeEvent = A.removeEvent;\n    a.seriesType = g.seriesType;\n    a.splat = A.splat;\n    a.stableSort = A.stableSort;\n    a.syncTimeout = A.syncTimeout;\n    a.timeUnits = A.timeUnits;\n    a.uniqueKey = A.uniqueKey;\n    a.useSerialIds = A.useSerialIds;\n    a.wrap = A.wrap;\n    c.compose(b);\n    J.compose(w);\n    k.compose(m);\n    v.compose(m);\n    x.compose(f);\n    n.compose(m);\n    z.compose(q);\n    y.compose(m, q, w);\n    D.compose(E);\n    return a;\n  });\n  M(a, \"Core/Axis/BrokenAxis.js\", [a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    const {\n      addEvent: u,\n      find: I,\n      fireEvent: F,\n      isArray: G,\n      isNumber: C,\n      pick: B\n    } = A;\n    var t;\n    (function (r) {\n      function d() {\n        \"undefined\" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n      function p() {\n        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);\n      }\n      function m() {\n        const a = this.brokenAxis;\n        if (a && a.hasBreaks) {\n          const e = this.tickPositions,\n            d = this.tickPositions.info,\n            h = [];\n          for (let d = 0; d < e.length; d++) a.isInAnyBreak(e[d]) || h.push(e[d]);\n          this.tickPositions = h;\n          this.tickPositions.info = d;\n        }\n      }\n      function k() {\n        this.brokenAxis || (this.brokenAxis = new E(this));\n      }\n      function t() {\n        const {\n          isDirty: a,\n          options: {\n            connectNulls: d\n          },\n          points: h,\n          xAxis: l,\n          yAxis: k\n        } = this;\n        if (a) {\n          let a = h.length;\n          for (; a--;) {\n            const b = h[a],\n              c = !(null === b.y && !1 === d) && (l && l.brokenAxis && l.brokenAxis.isInAnyBreak(b.x, !0) || k && k.brokenAxis && k.brokenAxis.isInAnyBreak(b.y, !0));\n            b.visible = c ? !1 : !1 !== b.options.visible;\n          }\n        }\n      }\n      function n() {\n        this.drawBreaks(this.xAxis, [\"x\"]);\n        this.drawBreaks(this.yAxis, B(this.pointArrayMap, [\"y\"]));\n      }\n      function h(a, d) {\n        const e = this,\n          h = e.points;\n        let k, g, b, c;\n        if (a && a.brokenAxis && a.brokenAxis.hasBreaks) {\n          const f = a.brokenAxis;\n          d.forEach(function (d) {\n            k = f && f.breakArray || [];\n            g = a.isXAxis ? a.min : B(e.options.threshold, a.min);\n            h.forEach(function (f) {\n              c = B(f[\"stack\" + d.toUpperCase()], f[d]);\n              k.forEach(function (e) {\n                if (C(g) && C(c)) {\n                  b = !1;\n                  if (g < e.from && c > e.to || g > e.from && c < e.from) b = \"pointBreak\";else if (g < e.from && c > e.from && c < e.to || g > e.from && c > e.to && c < e.from) b = \"pointInBreak\";\n                  b && F(a, b, {\n                    point: f,\n                    brk: e\n                  });\n                }\n              });\n            });\n          });\n        }\n      }\n      function D() {\n        var e = this.currentDataGrouping,\n          d = e && e.gapSize;\n        e = this.points.slice();\n        const h = this.yAxis;\n        let l = this.options.gapSize,\n          k = e.length - 1;\n        var g;\n        if (l && 0 < k) for (\"value\" !== this.options.gapUnit && (l *= this.basePointRange), d && d > l && d >= this.basePointRange && (l = d); k--;) g && !1 !== g.visible || (g = e[k + 1]), d = e[k], !1 !== g.visible && !1 !== d.visible && (g.x - d.x > l && (g = (d.x + g.x) / 2, e.splice(k + 1, 0, {\n          isNull: !0,\n          x: g\n        }), h.stacking && this.options.stacking && (g = h.stacking.stacks[this.stackKey][g] = new a(h, h.options.stackLabels, !1, g, this.stack), g.total = 0)), g = d);\n        return this.getGraphPath(e);\n      }\n      const H = [];\n      r.compose = function (a, q) {\n        A.pushUnique(H, a) && (a.keepProps.push(\"brokenAxis\"), u(a, \"init\", k), u(a, \"afterInit\", d), u(a, \"afterSetTickPositions\", m), u(a, \"afterSetOptions\", p));\n        if (A.pushUnique(H, q)) {\n          const a = q.prototype;\n          a.drawBreaks = h;\n          a.gappedPath = D;\n          u(q, \"afterGeneratePoints\", t);\n          u(q, \"afterRender\", n);\n        }\n        return a;\n      };\n      class E {\n        static isInBreak(a, d) {\n          const e = a.repeat || Infinity,\n            h = a.from,\n            k = a.to - a.from;\n          d = d >= h ? (d - h) % e : e - (h - d) % e;\n          return a.inclusive ? d <= k : d < k && 0 !== d;\n        }\n        static lin2Val(a) {\n          var e = this.brokenAxis;\n          e = e && e.breakArray;\n          if (!e || !C(a)) return a;\n          let d, h;\n          for (h = 0; h < e.length && !(d = e[h], d.from >= a); h++) d.to < a ? a += d.len : E.isInBreak(d, a) && (a += d.len);\n          return a;\n        }\n        static val2Lin(a) {\n          var e = this.brokenAxis;\n          e = e && e.breakArray;\n          if (!e || !C(a)) return a;\n          let d = a,\n            h,\n            k;\n          for (k = 0; k < e.length; k++) if (h = e[k], h.to <= a) d -= h.len;else if (h.from >= a) break;else if (E.isInBreak(h, a)) {\n            d -= a - h.from;\n            break;\n          }\n          return d;\n        }\n        constructor(a) {\n          this.hasBreaks = !1;\n          this.axis = a;\n        }\n        findBreakAt(a, d) {\n          return I(d, function (e) {\n            return e.from < a && a < e.to;\n          });\n        }\n        isInAnyBreak(a, d) {\n          const e = this.axis,\n            h = e.options.breaks || [];\n          let k = h.length,\n            g,\n            b,\n            c;\n          if (k && C(a)) {\n            for (; k--;) E.isInBreak(h[k], a) && (g = !0, b || (b = B(h[k].showPoints, !e.isXAxis)));\n            c = g && d ? g && !b : g;\n          }\n          return c;\n        }\n        setBreaks(a, d) {\n          const e = this,\n            h = e.axis,\n            k = G(a) && !!a.length;\n          h.isDirty = e.hasBreaks !== k;\n          e.hasBreaks = k;\n          h.options.breaks = h.userOptions.breaks = a;\n          h.forceRedraw = !0;\n          h.series.forEach(function (a) {\n            a.isDirty = !0;\n          });\n          k || h.val2lin !== E.val2Lin || (delete h.val2lin, delete h.lin2val);\n          k && (h.userOptions.ordinal = !1, h.lin2val = E.lin2Val, h.val2lin = E.val2Lin, h.setExtremes = function (a, b, c, f, d) {\n            if (e.hasBreaks) {\n              const c = this.options.breaks || [];\n              let f;\n              for (; f = e.findBreakAt(a, c);) a = f.to;\n              for (; f = e.findBreakAt(b, c);) b = f.from;\n              b < a && (b = a);\n            }\n            h.constructor.prototype.setExtremes.call(this, a, b, c, f, d);\n          }, h.setAxisTranslation = function () {\n            h.constructor.prototype.setAxisTranslation.call(this);\n            e.unitLength = void 0;\n            if (e.hasBreaks) {\n              const a = h.options.breaks || [],\n                b = [],\n                c = [],\n                f = B(h.pointRangePadding, 0);\n              let d = 0,\n                k,\n                l,\n                n = h.userMin || h.min,\n                m = h.userMax || h.max,\n                q,\n                p;\n              a.forEach(function (a) {\n                l = a.repeat || Infinity;\n                C(n) && C(m) && (E.isInBreak(a, n) && (n += a.to % l - n % l), E.isInBreak(a, m) && (m -= m % l - a.from % l));\n              });\n              a.forEach(function (a) {\n                q = a.from;\n                l = a.repeat || Infinity;\n                if (C(n) && C(m)) {\n                  for (; q - l > n;) q -= l;\n                  for (; q < n;) q += l;\n                  for (p = q; p < m; p += l) b.push({\n                    value: p,\n                    move: \"in\"\n                  }), b.push({\n                    value: p + a.to - a.from,\n                    move: \"out\",\n                    size: a.breakSize\n                  });\n                }\n              });\n              b.sort(function (a, b) {\n                return a.value === b.value ? (\"in\" === a.move ? 0 : 1) - (\"in\" === b.move ? 0 : 1) : a.value - b.value;\n              });\n              k = 0;\n              q = n;\n              b.forEach(function (a) {\n                k += \"in\" === a.move ? 1 : -1;\n                1 === k && \"in\" === a.move && (q = a.value);\n                0 === k && C(q) && (c.push({\n                  from: q,\n                  to: a.value,\n                  len: a.value - q - (a.size || 0)\n                }), d += a.value - q - (a.size || 0));\n              });\n              e.breakArray = c;\n              C(n) && C(m) && C(h.min) && (e.unitLength = m - n - d + f, F(h, \"afterBreaks\"), h.staticScale ? h.transA = h.staticScale : e.unitLength && (h.transA *= (m - h.min + f) / e.unitLength), f && (h.minPixelPadding = h.transA * (h.minPointOffset || 0)), h.min = n, h.max = m);\n            }\n          });\n          B(d, !0) && h.chart.redraw();\n        }\n      }\n      r.Additions = E;\n    })(t || (t = {}));\n    return t;\n  });\n  M(a, \"masters/modules/broken-axis.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Axis/BrokenAxis.js\"]], function (a, A) {\n    A.compose(a.Axis, a.Series);\n  });\n  M(a, \"Extensions/DataGrouping/ApproximationRegistry.js\", [], function () {\n    return {};\n  });\n  M(a, \"Extensions/DataGrouping/ApproximationDefaults.js\", [a[\"Extensions/DataGrouping/ApproximationRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    function u(a) {\n      const d = a.length;\n      a = I(a);\n      t(a) && d && (a = C(a / d));\n      return a;\n    }\n    function I(a) {\n      let d = a.length,\n        p;\n      if (!d && a.hasNulls) p = null;else if (d) for (p = 0; d--;) p += a[d];\n      return p;\n    }\n    const {\n      arrayMax: F,\n      arrayMin: G,\n      correctFloat: C,\n      extend: B,\n      isNumber: t\n    } = A;\n    A = {\n      average: u,\n      averages: function () {\n        const a = [];\n        [].forEach.call(arguments, function (d) {\n          a.push(u(d));\n        });\n        return \"undefined\" === typeof a[0] ? void 0 : a;\n      },\n      close: function (a) {\n        return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;\n      },\n      high: function (a) {\n        return a.length ? F(a) : a.hasNulls ? null : void 0;\n      },\n      hlc: function (r, d, p) {\n        r = a.high(r);\n        d = a.low(d);\n        p = a.close(p);\n        if (t(r) || t(d) || t(p)) return [r, d, p];\n      },\n      low: function (a) {\n        return a.length ? G(a) : a.hasNulls ? null : void 0;\n      },\n      ohlc: function (r, d, p, m) {\n        r = a.open(r);\n        d = a.high(d);\n        p = a.low(p);\n        m = a.close(m);\n        if (t(r) || t(d) || t(p) || t(m)) return [r, d, p, m];\n      },\n      open: function (a) {\n        return a.length ? a[0] : a.hasNulls ? null : void 0;\n      },\n      range: function (r, d) {\n        r = a.low(r);\n        d = a.high(d);\n        if (t(r) || t(d)) return [r, d];\n        if (null === r && null === d) return null;\n      },\n      sum: I\n    };\n    B(a, A);\n    return A;\n  });\n  M(a, \"Extensions/DataGrouping/DataGroupingDefaults.js\", [], function () {\n    return {\n      common: {\n        groupPixelWidth: 2,\n        dateTimeLabelFormats: {\n          millisecond: [\"%A, %e %b, %H:%M:%S.%L\", \"%A, %e %b, %H:%M:%S.%L\", \"-%H:%M:%S.%L\"],\n          second: [\"%A, %e %b, %H:%M:%S\", \"%A, %e %b, %H:%M:%S\", \"-%H:%M:%S\"],\n          minute: [\"%A, %e %b, %H:%M\", \"%A, %e %b, %H:%M\", \"-%H:%M\"],\n          hour: [\"%A, %e %b, %H:%M\", \"%A, %e %b, %H:%M\", \"-%H:%M\"],\n          day: [\"%A, %e %b %Y\", \"%A, %e %b\", \"-%A, %e %b %Y\"],\n          week: [\"Week from %A, %e %b %Y\", \"%A, %e %b\", \"-%A, %e %b %Y\"],\n          month: [\"%B %Y\", \"%B\", \"-%B %Y\"],\n          year: [\"%Y\", \"%Y\", \"-%Y\"]\n        }\n      },\n      seriesSpecific: {\n        line: {},\n        spline: {},\n        area: {},\n        areaspline: {},\n        arearange: {},\n        column: {\n          groupPixelWidth: 10\n        },\n        columnrange: {\n          groupPixelWidth: 10\n        },\n        candlestick: {\n          groupPixelWidth: 10\n        },\n        ohlc: {\n          groupPixelWidth: 5\n        },\n        hlc: {\n          groupPixelWidth: 5\n        },\n        heikinashi: {\n          groupPixelWidth: 10\n        }\n      },\n      units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1, 3, 6]], [\"year\", null]]\n    };\n  });\n  M(a, \"Extensions/DataGrouping/DataGroupingAxisComposition.js\", [a[\"Extensions/DataGrouping/DataGroupingDefaults.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    function u(a) {\n      const d = this,\n        m = d.series;\n      m.forEach(function (a) {\n        a.groupPixelWidth = void 0;\n      });\n      m.forEach(function (k) {\n        k.groupPixelWidth = d.getGroupPixelWidth && d.getGroupPixelWidth();\n        k.groupPixelWidth && (k.hasProcessed = !0);\n        k.applyGrouping(!!a.hasExtremesChanged);\n      });\n    }\n    function I() {\n      const d = this.series;\n      let k = d.length,\n        p = 0,\n        n = !1,\n        h,\n        t;\n      for (; k--;) if (t = d[k].options.dataGrouping) if (p = Math.max(p, r(t.groupPixelWidth, a.common.groupPixelWidth)), h = (d[k].processedXData || d[k].data).length, d[k].groupPixelWidth || h > this.chart.plotSizeX / p || h && t.forced) n = !0;\n      return n ? p : 0;\n    }\n    function F() {\n      this.series.forEach(function (a) {\n        a.hasProcessed = !1;\n      });\n    }\n    function G(a, d) {\n      let k;\n      d = r(d, !0);\n      a || (a = {\n        forced: !1,\n        units: null\n      });\n      if (this instanceof p) for (k = this.series.length; k--;) this.series[k].update({\n        dataGrouping: a\n      }, !1);else this.chart.options.series.forEach(function (d) {\n        d.dataGrouping = \"boolean\" === typeof a ? a : t(a, d.dataGrouping);\n      });\n      this.ordinal && (this.ordinal.slope = void 0);\n      d && this.chart.redraw();\n    }\n    const {\n        addEvent: C,\n        extend: B,\n        merge: t,\n        pick: r\n      } = A,\n      d = [];\n    let p;\n    return {\n      compose: function (a) {\n        p = a;\n        A.pushUnique(d, a) && (C(a, \"afterSetScale\", F), C(a, \"postProcessData\", u), B(a.prototype, {\n          applyGrouping: u,\n          getGroupPixelWidth: I,\n          setDataGrouping: G\n        }));\n      }\n    };\n  });\n  M(a, \"Extensions/DataGrouping/DataGroupingSeriesComposition.js\", [a[\"Extensions/DataGrouping/ApproximationRegistry.js\"], a[\"Extensions/DataGrouping/DataGroupingDefaults.js\"], a[\"Core/Axis/DateTimeAxis.js\"], a[\"Core/Defaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G) {\n    function u(a) {\n      var d = this.chart,\n        e = this.options.dataGrouping,\n        g = !1 !== this.allowDG && e && E(e.enabled, d.options.isStock),\n        b = this.visible || !d.options.chart.ignoreHiddenSeries;\n      const c = this.currentDataGrouping;\n      var f = !1;\n      g && !this.requireSorting && (this.requireSorting = f = !0);\n      a = !1 === !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !a) || !g;\n      f && (this.requireSorting = !1);\n      if (!a) {\n        this.destroyGroupedData();\n        a = e.groupAll ? this.xData : this.processedXData;\n        g = e.groupAll ? this.yData : this.processedYData;\n        var h = d.plotSizeX;\n        f = this.xAxis;\n        var k = f.options.ordinal,\n          q = this.groupPixelWidth,\n          p;\n        let l;\n        if (q && a && a.length && h) {\n          this.isDirty = l = !0;\n          this.points = null;\n          var r = f.getExtremes();\n          var t = r.min;\n          r = r.max;\n          k = k && f.ordinal && f.ordinal.getGroupIntervalFactor(t, r, this) || 1;\n          h = f.getTimeTicks(H.Additions.prototype.normalizeTimeTickInterval(q * (r - t) / h * k, e.units || A.units), Math.min(t, a[0]), Math.max(r, a[a.length - 1]), f.options.startOfWeek, a, this.closestPointRange);\n          q = m.groupData.apply(this, [a, g, h, e.approximation]);\n          a = q.groupedXData;\n          g = q.groupedYData;\n          k = 0;\n          e && e.smoothed && a.length && (e.firstAnchor = \"firstPoint\", e.anchor = \"middle\", e.lastAnchor = \"lastPoint\", n(32, !1, d, {\n            \"dataGrouping.smoothed\": \"use dataGrouping.anchor\"\n          }));\n          d = a;\n          var u = r,\n            y = this.options.dataGrouping;\n          r = this.currentDataGrouping && this.currentDataGrouping.gapSize;\n          if (y && this.xData && r && this.groupMap) {\n            t = d.length - 1;\n            var B = y.anchor;\n            const a = E(y.firstAnchor, B);\n            y = E(y.lastAnchor, B);\n            if (B && \"start\" !== B) {\n              var C = r * {\n                middle: .5,\n                end: 1\n              }[B];\n              for (B = d.length - 1; B-- && 0 < B;) d[B] += C;\n            }\n            a && \"start\" !== a && this.xData[0] >= d[0] && (B = this.groupMap[0].start, C = this.groupMap[0].length, D(B) && D(C) && (p = B + (C - 1)), d[0] = {\n              middle: d[0] + .5 * r,\n              end: d[0] + r,\n              firstPoint: this.xData[0],\n              lastPoint: p && this.xData[p]\n            }[a]);\n            y && \"start\" !== y && r && d[t] >= u - r && (p = this.groupMap[this.groupMap.length - 1].start, d[t] = {\n              middle: d[t] + .5 * r,\n              end: d[t] + r,\n              firstPoint: p && this.xData[p],\n              lastPoint: this.xData[this.xData.length - 1]\n            }[y]);\n          }\n          for (p = 1; p < h.length; p++) h.info.segmentStarts && -1 !== h.info.segmentStarts.indexOf(p) || (k = Math.max(h[p] - h[p - 1], k));\n          r = h.info;\n          r.gapSize = k;\n          this.closestPointRange = h.info.totalRange;\n          this.groupMap = q.groupMap;\n          if (b) {\n            b = f;\n            p = a;\n            if (v(p[0]) && D(b.min) && D(b.dataMin) && p[0] < b.min) {\n              if (!v(b.options.min) && b.min <= b.dataMin || b.min === b.dataMin) b.min = Math.min(p[0], b.min);\n              b.dataMin = Math.min(p[0], b.dataMin);\n            }\n            if (v(p[p.length - 1]) && D(b.max) && D(b.dataMax) && p[p.length - 1] > b.max) {\n              if (!v(b.options.max) && D(b.dataMax) && b.max >= b.dataMax || b.max === b.dataMax) b.max = Math.max(p[p.length - 1], b.max);\n              b.dataMax = Math.max(p[p.length - 1], b.dataMax);\n            }\n          }\n          e.groupAll && (this.allGroupedData = g, e = this.cropData(a, g, f.min, f.max, 1), a = e.xData, g = e.yData, this.cropStart = e.start);\n          this.processedXData = a;\n          this.processedYData = g;\n        } else this.groupMap = null;\n        this.hasGroupedData = l;\n        this.currentDataGrouping = r;\n        this.preventGraphAnimation = (c && c.totalRange) !== (r && r.totalRange);\n      }\n    }\n    function B() {\n      this.groupedData && (this.groupedData.forEach(function (a, d) {\n        a && (this.groupedData[d] = a.destroy ? a.destroy() : null);\n      }, this), this.groupedData.length = 0);\n    }\n    function t() {\n      e.apply(this);\n      this.destroyGroupedData();\n      this.groupedData = this.hasGroupedData ? this.points : null;\n    }\n    function r() {\n      return this.is(\"arearange\") ? \"range\" : this.is(\"ohlc\") ? \"ohlc\" : this.is(\"hlc\") ? \"hlc\" : this.is(\"column\") ? \"sum\" : \"average\";\n    }\n    function d(d, e, h, g) {\n      const b = this,\n        c = b.data,\n        f = b.options && b.options.data,\n        k = [],\n        l = [],\n        n = [],\n        m = d.length,\n        q = !!e,\n        p = [],\n        r = b.pointArrayMap,\n        w = r && r.length,\n        t = [\"x\"].concat(r || [\"y\"]),\n        u = this.options.dataGrouping && this.options.dataGrouping.groupAll;\n      let y = 0,\n        B = 0;\n      g = \"function\" === typeof g ? g : g && a[g] ? a[g] : a[b.getDGApproximation && b.getDGApproximation() || \"average\"];\n      if (w) for (var E = r.length; E--;) p.push([]);else p.push([]);\n      E = w || 1;\n      for (let a = 0; a <= m; a++) if (!(d[a] < h[0])) {\n        for (; \"undefined\" !== typeof h[y + 1] && d[a] >= h[y + 1] || a === m;) {\n          var A = h[y];\n          b.dataGroupInfo = {\n            start: u ? B : b.cropStart + B,\n            length: p[0].length\n          };\n          var C = g.apply(b, p);\n          b.pointClass && !v(b.dataGroupInfo.options) && (b.dataGroupInfo.options = L(b.pointClass.prototype.optionsToObject.call({\n            series: b\n          }, b.options.data[b.cropStart + B])), t.forEach(function (a) {\n            delete b.dataGroupInfo.options[a];\n          }));\n          \"undefined\" !== typeof C && (k.push(A), l.push(C), n.push(b.dataGroupInfo));\n          B = a;\n          for (A = 0; A < E; A++) p[A].length = 0, p[A].hasNulls = !1;\n          y += 1;\n          if (a === m) break;\n        }\n        if (a === m) break;\n        if (r) {\n          A = b.options.dataGrouping && b.options.dataGrouping.groupAll ? a : b.cropStart + a;\n          A = c && c[A] || b.pointClass.prototype.applyOptions.apply({\n            series: b\n          }, [f[A]]);\n          for (let a = 0; a < w; a++) C = A[r[a]], D(C) ? p[a].push(C) : null === C && (p[a].hasNulls = !0);\n        } else A = q ? e[a] : null, D(A) ? p[0].push(A) : null === A && (p[0].hasNulls = !0);\n      }\n      return {\n        groupedXData: k,\n        groupedYData: l,\n        groupMap: n\n      };\n    }\n    function p(a) {\n      a = a.options;\n      const d = this.type,\n        e = this.chart.options.plotOptions,\n        g = this.useCommonDataGrouping && A.common,\n        b = A.seriesSpecific;\n      let c = I.defaultOptions.plotOptions[d].dataGrouping;\n      if (e && (b[d] || g)) {\n        const f = this.chart.rangeSelector;\n        c || (c = L(A.common, b[d]));\n        a.dataGrouping = L(g, c, e.series && e.series.dataGrouping, e[d].dataGrouping, this.userOptions.dataGrouping, !a.isInternal && f && D(f.selected) && f.buttonOptions[f.selected].dataGrouping);\n      }\n    }\n    const {\n        series: {\n          prototype: m\n        }\n      } = F,\n      {\n        addEvent: k,\n        defined: v,\n        error: n,\n        extend: h,\n        isNumber: D,\n        merge: L,\n        pick: E\n      } = G,\n      e = m.generatePoints,\n      q = [];\n    return {\n      compose: function (a) {\n        const e = a.prototype.pointClass;\n        G.pushUnique(q, e) && k(e, \"update\", function () {\n          if (this.dataGroup) return n(24, !1, this.series.chart), !1;\n        });\n        G.pushUnique(q, a) && (k(a, \"afterSetOptions\", p), k(a, \"destroy\", B), h(a.prototype, {\n          applyGrouping: u,\n          destroyGroupedData: B,\n          generatePoints: t,\n          getDGApproximation: r,\n          groupData: d\n        }));\n      },\n      groupData: d\n    };\n  });\n  M(a, \"Extensions/DataGrouping/DataGrouping.js\", [a[\"Extensions/DataGrouping/DataGroupingAxisComposition.js\"], a[\"Extensions/DataGrouping/DataGroupingDefaults.js\"], a[\"Extensions/DataGrouping/DataGroupingSeriesComposition.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F) {\n    function u(a) {\n      const d = this.chart,\n        k = d.time,\n        p = a.labelConfig,\n        n = p.series;\n      var h = n.tooltipOptions,\n        u = n.options.dataGrouping;\n      const B = n.xAxis;\n      var E = h.xDateFormat;\n      let e,\n        q,\n        y = h[a.isFooter ? \"footerFormat\" : \"headerFormat\"];\n      B && \"datetime\" === B.options.type && u && r(p.key) && (q = n.currentDataGrouping, u = u.dateTimeLabelFormats || A.common.dateTimeLabelFormats, q ? (h = u[q.unitName], 1 === q.count ? E = h[0] : (E = h[1], e = h[2])) : !E && u && B.dateTime && (E = B.dateTime.getXDateFormat(p.x, h.dateTimeLabelFormats)), E = k.dateFormat(E, p.key), e && (E += k.dateFormat(e, p.key + q.totalRange - 1)), n.chart.styledMode && (y = this.styledModeFormat(y)), a.text = C(y, {\n        point: t(p.point, {\n          key: E\n        }),\n        series: n\n      }, d), a.preventDefault());\n    }\n    const {\n        format: C\n      } = I,\n      {\n        addEvent: B,\n        extend: t,\n        isNumber: r\n      } = F,\n      d = [];\n    I = {\n      compose: function (p, m, k) {\n        a.compose(p);\n        H.compose(m);\n        k && F.pushUnique(d, k) && B(k, \"headerFormatter\", u);\n      },\n      groupData: H.groupData\n    };\n    \"\";\n    \"\";\n    return I;\n  });\n  M(a, \"masters/modules/datagrouping.src.js\", [a[\"Core/Globals.js\"], a[\"Extensions/DataGrouping/ApproximationDefaults.js\"], a[\"Extensions/DataGrouping/ApproximationRegistry.js\"], a[\"Extensions/DataGrouping/DataGrouping.js\"]], function (a, A, H, I) {\n    a.dataGrouping = {\n      approximationDefaults: A,\n      approximations: H\n    };\n    I.compose(a.Axis, a.Series, a.Tooltip);\n  });\n  M(a, \"Series/DataModifyComposition.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I) {\n    const {\n        prototype: {\n          tooltipFormatter: u\n        }\n      } = A,\n      {\n        addEvent: G,\n        arrayMax: C,\n        arrayMin: B,\n        correctFloat: t,\n        defined: r,\n        isArray: d,\n        isNumber: p,\n        isString: m,\n        pick: k\n      } = I;\n    var v;\n    (function (a) {\n      function h(a, b, d) {\n        this.isXAxis || (this.series.forEach(function (c) {\n          \"compare\" === a && \"boolean\" !== typeof b ? c.setCompare(b, !1) : \"cumulative\" !== a || m(b) || c.setCumulative(b, !1);\n        }), k(d, !0) && this.chart.redraw());\n      }\n      function n(a) {\n        const b = this,\n          {\n            numberFormatter: c\n          } = b.series.chart,\n          d = function (f) {\n            a = a.replace(\"{point.\" + f + \"}\", (0 < b[f] && \"change\" === f ? \"+\" : \"\") + c(b[f], k(b.series.tooltipOptions.changeDecimals, 2)));\n          };\n        r(b.change) && d(\"change\");\n        r(b.cumulativeSum) && d(\"cumulativeSum\");\n        return u.apply(this, [a]);\n      }\n      function v() {\n        const a = this.options.compare;\n        let f;\n        if (\"percent\" === a || \"value\" === a || this.options.cumulative) f = new b(this), \"percent\" === a || \"value\" === a ? f.initCompare(a) : f.initCumulative();\n        this.dataModify = f;\n      }\n      function E(a) {\n        a = a.dataExtremes;\n        const c = a.activeYData;\n        if (this.dataModify && a) {\n          let f;\n          this.options.compare ? f = [this.dataModify.modifyValue(a.dataMin), this.dataModify.modifyValue(a.dataMax)] : this.options.cumulative && d(c) && 2 <= c.length && (f = b.getCumulativeExtremes(c));\n          f && (a.dataMin = B(f), a.dataMax = C(f));\n        }\n      }\n      function e(a, b) {\n        this.options.compare = this.userOptions.compare = a;\n        this.update({}, k(b, !0));\n        !this.dataModify || \"value\" !== a && \"percent\" !== a ? this.points.forEach(a => {\n          delete a.change;\n        }) : this.dataModify.initCompare(a);\n      }\n      function q() {\n        if (this.xAxis && this.processedYData && this.dataModify) {\n          const a = this.processedXData,\n            b = this.processedYData,\n            d = b.length,\n            e = !0 === this.options.compareStart ? 0 : 1;\n          let g = -1,\n            h;\n          this.pointArrayMap && (g = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || \"y\"));\n          for (h = 0; h < d - e; h++) {\n            const c = b[h] && -1 < g ? b[h][g] : b[h];\n            if (p(c) && 0 !== c && a[h + e] >= (this.xAxis.min || 0)) {\n              this.dataModify.compareValue = c;\n              break;\n            }\n          }\n        }\n      }\n      function y(a, b) {\n        this.setModifier(\"compare\", a, b);\n      }\n      function l(a, b) {\n        a = k(a, !1);\n        this.options.cumulative = this.userOptions.cumulative = a;\n        this.update({}, k(b, !0));\n        this.dataModify ? this.dataModify.initCumulative() : this.points.forEach(a => {\n          delete a.cumulativeSum;\n        });\n      }\n      function w(a, b) {\n        this.setModifier(\"cumulative\", a, b);\n      }\n      const g = [];\n      a.compose = function (a, b, d) {\n        if (I.pushUnique(g, a)) {\n          const b = a.prototype;\n          b.setCompare = e;\n          b.setCumulative = l;\n          G(a, \"afterInit\", v);\n          G(a, \"afterGetExtremes\", E);\n          G(a, \"afterProcessData\", q);\n        }\n        I.pushUnique(g, b) && (b = b.prototype, b.setCompare = y, b.setModifier = h, b.setCumulative = w);\n        I.pushUnique(g, d) && (d.prototype.tooltipFormatter = n);\n        return a;\n      };\n      class b {\n        constructor(a) {\n          this.series = a;\n        }\n        modifyValue() {\n          return 0;\n        }\n        static getCumulativeExtremes(a) {\n          let b = Infinity,\n            c = -Infinity;\n          a.reduce((a, f) => {\n            f = a + f;\n            b = Math.min(b, f, a);\n            c = Math.max(c, f, a);\n            return f;\n          });\n          return [b, c];\n        }\n        initCompare(a) {\n          this.modifyValue = function (b, c) {\n            null === b && (b = 0);\n            const f = this.compareValue;\n            return \"undefined\" !== typeof b && \"undefined\" !== typeof f ? (b = \"value\" === a ? b - f : b / f * 100 - (100 === this.series.options.compareBase ? 0 : 100), \"undefined\" !== typeof c && (c = this.series.points[c]) && (c.change = b), b) : 0;\n          };\n        }\n        initCumulative() {\n          this.modifyValue = function (a, b) {\n            null === a && (a = 0);\n            if (void 0 !== a && void 0 !== b) {\n              const c = 0 < b ? this.series.points[b - 1] : null;\n              c && c.cumulativeSum && (a = t(c.cumulativeSum + a));\n              if (b = this.series.points[b]) b.cumulativeSum = a;\n              return a;\n            }\n            return 0;\n          };\n        }\n      }\n      a.Additions = b;\n    })(v || (v = {}));\n    \"\";\n    return v;\n  });\n  M(a, \"Core/Axis/NavigatorAxisComposition.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    function u() {\n      this.navigatorAxis || (this.navigatorAxis = new p(this));\n    }\n    function I(a) {\n      var d = this.chart.options,\n        m = d.navigator;\n      const n = this.navigatorAxis,\n        h = d.chart.zooming.pinchType,\n        p = d.rangeSelector;\n      d = d.chart.zooming.type;\n      this.isXAxis && (m && m.enabled || p && p.enabled) && (\"y\" === d ? a.zoomed = !1 : (!F && \"xy\" === d || F && \"xy\" === h) && this.options.range && (m = n.previousZoom, B(a.newMin) ? n.previousZoom = [this.min, this.max] : m && (a.newMin = m[0], a.newMax = m[1], n.previousZoom = void 0)));\n      \"undefined\" !== typeof a.zoomed && a.preventDefault();\n    }\n    const {\n        isTouchDevice: F\n      } = a,\n      {\n        addEvent: G,\n        correctFloat: C,\n        defined: B,\n        isNumber: t,\n        pick: r\n      } = A,\n      d = [];\n    class p {\n      static compose(a) {\n        A.pushUnique(d, a) && (a.keepProps.push(\"navigatorAxis\"), G(a, \"init\", u), G(a, \"zoom\", I));\n      }\n      constructor(a) {\n        this.axis = a;\n      }\n      destroy() {\n        this.axis = void 0;\n      }\n      toFixedRange(a, d, p, n) {\n        var h = this.axis,\n          k = h.chart;\n        a = r(p, h.translate(a, !0, !h.horiz));\n        d = r(n, h.translate(d, !0, !h.horiz));\n        k = k && k.fixedRange;\n        h = (h.pointRange || 0) / 2;\n        const m = k && (d - a) / k;\n        B(p) || (a = C(a + h));\n        B(n) || (d = C(d - h));\n        .7 < m && 1.3 > m && (n ? a = d - k : d = a + k);\n        t(a) && t(d) || (a = d = void 0);\n        return {\n          min: a,\n          max: d\n        };\n      }\n    }\n    return p;\n  });\n  M(a, \"Stock/Navigator/NavigatorDefaults.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"]], function (a, A) {\n    ({\n      parse: a\n    } = a);\n    ({\n      seriesTypes: A\n    } = A);\n    A = {\n      height: 40,\n      margin: 25,\n      maskInside: !0,\n      handles: {\n        width: 7,\n        height: 15,\n        symbols: [\"navigator-handle\", \"navigator-handle\"],\n        enabled: !0,\n        lineWidth: 1,\n        backgroundColor: \"#f2f2f2\",\n        borderColor: \"#999999\"\n      },\n      maskFill: a(\"#667aff\").setOpacity(.3).get(),\n      outlineColor: \"#999999\",\n      outlineWidth: 1,\n      series: {\n        type: \"undefined\" === typeof A.areaspline ? \"line\" : \"areaspline\",\n        fillOpacity: .05,\n        lineWidth: 1,\n        compare: null,\n        sonification: {\n          enabled: !1\n        },\n        dataGrouping: {\n          approximation: \"average\",\n          enabled: !0,\n          groupPixelWidth: 2,\n          firstAnchor: \"firstPoint\",\n          anchor: \"middle\",\n          lastAnchor: \"lastPoint\",\n          units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n        },\n        dataLabels: {\n          enabled: !1,\n          zIndex: 2\n        },\n        id: \"highcharts-navigator-series\",\n        className: \"highcharts-navigator-series\",\n        lineColor: null,\n        marker: {\n          enabled: !1\n        },\n        threshold: null\n      },\n      xAxis: {\n        overscroll: 0,\n        className: \"highcharts-navigator-xaxis\",\n        tickLength: 0,\n        lineWidth: 0,\n        gridLineColor: \"#e6e6e6\",\n        gridLineWidth: 1,\n        tickPixelInterval: 200,\n        labels: {\n          align: \"left\",\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            opacity: .6,\n            textOutline: \"2px contrast\"\n          },\n          x: 3,\n          y: -4\n        },\n        crosshair: !1\n      },\n      yAxis: {\n        className: \"highcharts-navigator-yaxis\",\n        gridLineWidth: 0,\n        startOnTick: !1,\n        endOnTick: !1,\n        minPadding: .1,\n        maxPadding: .1,\n        labels: {\n          enabled: !1\n        },\n        crosshair: !1,\n        title: {\n          text: null\n        },\n        tickLength: 0,\n        tickWidth: 0\n      }\n    };\n    \"\";\n    return A;\n  });\n  M(a, \"Stock/Navigator/NavigatorSymbols.js\", [], function () {\n    return {\n      \"navigator-handle\": function (a, A, H, I, F = {}) {\n        a = F.width ? F.width / 2 : H;\n        A = Math.round(a / 3) + .5;\n        I = F.height || I;\n        return [[\"M\", -a - 1, .5], [\"L\", a, .5], [\"L\", a, I + .5], [\"L\", -a - 1, I + .5], [\"L\", -a - 1, .5], [\"M\", -A, 4], [\"L\", -A, I - 3], [\"M\", A - 1, 4], [\"L\", A - 1, I - 3]];\n      }\n    };\n  });\n  M(a, \"Stock/Navigator/NavigatorComposition.js\", [a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/NavigatorAxisComposition.js\"], a[\"Stock/Navigator/NavigatorDefaults.js\"], a[\"Stock/Navigator/NavigatorSymbols.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C) {\n    function u() {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }\n    function t() {\n      var a;\n      const b = this.legend,\n        c = this.navigator;\n      let f, d, e;\n      if (c) {\n        f = b && b.options;\n        d = c.xAxis;\n        e = c.yAxis;\n        const {\n          scrollbarHeight: g,\n          scrollButtonSize: h\n        } = c;\n        this.inverted ? (c.left = c.opposite ? this.chartWidth - g - c.height : this.spacing[3] + g, c.top = this.plotTop + h) : (c.left = y(d.left, this.plotLeft + h), c.top = c.navigatorOptions.top || this.chartHeight - c.height - g - ((null === (a = this.scrollbar) || void 0 === a ? void 0 : a.options.margin) || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (f && \"bottom\" === f.verticalAlign && \"proximate\" !== f.layout && f.enabled && !f.floating ? b.legendHeight + y(f.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        d && e && (this.inverted ? d.options.left = e.options.left = c.left : d.options.top = e.options.top = c.top, d.setAxisSize(), e.setAxisSize());\n      }\n    }\n    function r(a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new w(this), y(a.redraw, !0) && this.redraw(a.animation));\n    }\n    function d() {\n      const a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new w(this);\n    }\n    function p() {\n      const a = this.options,\n        b = a.navigator,\n        c = a.rangeSelector;\n      if ((b && b.enabled || c && c.enabled) && (!D && \"x\" === a.chart.zooming.type || D && \"x\" === a.chart.zooming.pinchType)) return !1;\n    }\n    function m(a) {\n      const b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    }\n    function k(a) {\n      const b = a.options.navigator || {},\n        c = a.options.scrollbar || {};\n      this.navigator || this.scroller || !b.enabled && !c.enabled || (q(!0, this.options.navigator, b), q(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);\n    }\n    function v() {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }\n    const {\n        defaultOptions: n,\n        setOptions: h\n      } = a,\n      {\n        isTouchDevice: D\n      } = A,\n      {\n        getRendererType: L\n      } = G,\n      {\n        addEvent: E,\n        extend: e,\n        merge: q,\n        pick: y\n      } = C,\n      l = [];\n    let w;\n    return {\n      compose: function (a, b, c, f) {\n        H.compose(a);\n        w = c;\n        C.pushUnique(l, b) && (b.prototype.callbacks.push(m), E(b, \"afterAddSeries\", u), E(b, \"afterSetChartSize\", t), E(b, \"afterUpdate\", r), E(b, \"beforeRender\", d), E(b, \"beforeShowResetZoom\", p), E(b, \"update\", k));\n        C.pushUnique(l, f) && E(f, \"afterUpdate\", v);\n        C.pushUnique(l, L) && e(L().prototype.symbols, F);\n        C.pushUnique(l, h) && e(n, {\n          navigator: I\n        });\n      }\n    };\n  });\n  M(a, \"Core/Axis/ScrollbarAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n        addEvent: u,\n        defined: H,\n        pick: I\n      } = a,\n      F = [];\n    class G {\n      static compose(A, B) {\n        if (!a.pushUnique(F, A)) return A;\n        const t = a => {\n          const d = I(a.options && a.options.min, a.min),\n            p = I(a.options && a.options.max, a.max);\n          return {\n            axisMin: d,\n            axisMax: p,\n            scrollMin: H(a.dataMin) ? Math.min(d, a.min, a.dataMin, I(a.threshold, Infinity)) : d,\n            scrollMax: H(a.dataMax) ? Math.max(p, a.max, a.dataMax, I(a.threshold, -Infinity)) : p\n          };\n        };\n        u(A, \"afterInit\", function () {\n          const a = this;\n          a.options && a.options.scrollbar && a.options.scrollbar.enabled && (a.options.scrollbar.vertical = !a.horiz, a.options.startOnTick = a.options.endOnTick = !1, a.scrollbar = new B(a.chart.renderer, a.options.scrollbar, a.chart), u(a.scrollbar, \"changed\", function (d) {\n            let {\n              axisMin: p,\n              axisMax: m,\n              scrollMin: k,\n              scrollMax: r\n            } = t(a);\n            var n = r - k;\n            let h;\n            H(p) && H(m) && (a.horiz && !a.reversed || !a.horiz && a.reversed ? (h = k + n * this.to, n = k + n * this.from) : (h = k + n * (1 - this.from), n = k + n * (1 - this.to)), this.shouldUpdateExtremes(d.DOMType) ? a.setExtremes(n, h, !0, \"mousemove\" === d.DOMType || \"touchmove\" === d.DOMType ? !1 : void 0, d) : this.setRange(this.from, this.to));\n          }));\n        });\n        u(A, \"afterRender\", function () {\n          let {\n              scrollMin: a,\n              scrollMax: d\n            } = t(this),\n            p = this.scrollbar;\n          var m = this.axisTitleMargin + (this.titleOffset || 0),\n            k = this.chart.scrollbarsOffsets;\n          let v = this.options.margin || 0;\n          p && (this.horiz ? (this.opposite || (k[1] += m), p.position(this.left, this.top + this.height + 2 + k[1] - (this.opposite ? v : 0), this.width, this.height), this.opposite || (k[1] += v), m = 1) : (this.opposite && (k[0] += m), p.position(p.options.opposite ? this.left + this.width + 2 + k[0] - (this.opposite ? 0 : v) : this.opposite ? 0 : v, this.top, this.width, this.height), this.opposite && (k[0] += v), m = 0), k[m] += p.size + (p.options.margin || 0), isNaN(a) || isNaN(d) || !H(this.min) || !H(this.max) || this.min === this.max ? p.setRange(0, 1) : (k = (this.min - a) / (d - a), m = (this.max - a) / (d - a), this.horiz && !this.reversed || !this.horiz && this.reversed ? p.setRange(k, m) : p.setRange(1 - m, 1 - k)));\n        });\n        u(A, \"afterGetOffset\", function () {\n          const a = this.scrollbar;\n          var d = a && !a.options.opposite;\n          d = this.horiz ? 2 : d ? 3 : 1;\n          a && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[d] += a.size + (a.options.margin || 0));\n        });\n        return A;\n      }\n    }\n    return G;\n  });\n  M(a, \"Stock/Scrollbar/ScrollbarDefaults.js\", [a[\"Core/Globals.js\"]], function (a) {\n    return {\n      height: 10,\n      barBorderRadius: 5,\n      buttonBorderRadius: 0,\n      buttonsEnabled: !1,\n      liveRedraw: void 0,\n      margin: void 0,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 0,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"none\",\n      trackBackgroundColor: \"rgba(255, 255, 255, 0.001)\",\n      trackBorderColor: \"#cccccc\",\n      trackBorderRadius: 5,\n      trackBorderWidth: 1\n    };\n  });\n  M(a, \"Stock/Scrollbar/Scrollbar.js\", [a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/ScrollbarAxis.js\"], a[\"Stock/Scrollbar/ScrollbarDefaults.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F) {\n    const {\n        defaultOptions: u\n      } = a,\n      {\n        addEvent: C,\n        correctFloat: B,\n        defined: t,\n        destroyObjectProperties: r,\n        fireEvent: d,\n        merge: p,\n        pick: m,\n        removeEvent: k\n      } = F;\n    let v = /*#__PURE__*/(() => {\n      class v {\n        static compose(a) {\n          H.compose(a, v);\n        }\n        static swapXY(a, d) {\n          d && a.forEach(a => {\n            const d = a.length;\n            let h;\n            for (let e = 0; e < d; e += 2) h = a[e + 1], \"number\" === typeof h && (a[e + 1] = a[e + 2], a[e + 2] = h);\n          });\n          return a;\n        }\n        constructor(a, d, k) {\n          this._events = [];\n          this.chart = void 0;\n          this.from = this.chartY = this.chartX = 0;\n          this.scrollbar = this.renderer = this.options = this.group = void 0;\n          this.scrollbarButtons = [];\n          this.scrollbarGroup = void 0;\n          this.scrollbarLeft = 0;\n          this.scrollbarRifles = void 0;\n          this.scrollbarStrokeWidth = 1;\n          this.to = this.size = this.scrollbarTop = 0;\n          this.track = void 0;\n          this.trackBorderWidth = 1;\n          this.userOptions = void 0;\n          this.y = this.x = 0;\n          this.init(a, d, k);\n        }\n        addEvents() {\n          var a = this.options.inverted ? [1, 0] : [0, 1];\n          const d = this.scrollbarButtons,\n            k = this.scrollbarGroup.element,\n            m = this.track.element,\n            p = this.mouseDownHandler.bind(this),\n            e = this.mouseMoveHandler.bind(this),\n            q = this.mouseUpHandler.bind(this);\n          a = [[d[a[0]].element, \"click\", this.buttonToMinClick.bind(this)], [d[a[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [m, \"click\", this.trackClick.bind(this)], [k, \"mousedown\", p], [k.ownerDocument, \"mousemove\", e], [k.ownerDocument, \"mouseup\", q]];\n          A.hasTouch && a.push([k, \"touchstart\", p], [k.ownerDocument, \"touchmove\", e], [k.ownerDocument, \"touchend\", q]);\n          a.forEach(function (a) {\n            C.apply(null, a);\n          });\n          this._events = a;\n        }\n        buttonToMaxClick(a) {\n          const h = (this.to - this.from) * m(this.options.step, .2);\n          this.updatePosition(this.from + h, this.to + h);\n          d(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: a\n          });\n        }\n        buttonToMinClick(a) {\n          const h = B(this.to - this.from) * m(this.options.step, .2);\n          this.updatePosition(B(this.from - h), B(this.to - h));\n          d(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: a\n          });\n        }\n        cursorToScrollbarPosition(a) {\n          var d = this.options;\n          d = d.minWidth > this.calculatedWidth ? d.minWidth : 0;\n          return {\n            chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - d),\n            chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - d)\n          };\n        }\n        destroy() {\n          const a = this,\n            d = a.chart.scroller;\n          a.removeEvents();\n          [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (d) {\n            a[d] && a[d].destroy && (a[d] = a[d].destroy());\n          });\n          d && a === d.scrollbar && (d.scrollbar = null, r(d.scrollbarButtons));\n        }\n        drawScrollbarButton(a) {\n          const d = this.renderer,\n            k = this.scrollbarButtons,\n            n = this.options,\n            m = this.size;\n          var e = d.g().add(this.group);\n          k.push(e);\n          n.buttonsEnabled && (e = d.rect().addClass(\"highcharts-scrollbar-button\").add(e), this.chart.styledMode || e.attr({\n            stroke: n.buttonBorderColor,\n            \"stroke-width\": n.buttonBorderWidth,\n            fill: n.buttonBackgroundColor\n          }), e.attr(e.crisp({\n            x: -.5,\n            y: -.5,\n            width: m + 1,\n            height: m + 1,\n            r: n.buttonBorderRadius\n          }, e.strokeWidth())), a = d.path(v.swapXY([[\"M\", m / 2 + (a ? -1 : 1), m / 2 - 3], [\"L\", m / 2 + (a ? -1 : 1), m / 2 + 3], [\"L\", m / 2 + (a ? 2 : -2), m / 2]], n.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(k[a]), this.chart.styledMode || a.attr({\n            fill: n.buttonArrowColor\n          }));\n        }\n        init(a, d, k) {\n          this.scrollbarButtons = [];\n          this.renderer = a;\n          this.userOptions = d;\n          this.options = p(I, u.scrollbar, d);\n          this.options.margin = m(this.options.margin, 10);\n          this.chart = k;\n          this.size = m(this.options.size, this.options.height);\n          d.enabled && (this.render(), this.addEvents());\n        }\n        mouseDownHandler(a) {\n          a = this.chart.pointer.normalize(a);\n          a = this.cursorToScrollbarPosition(a);\n          this.chartX = a.chartX;\n          this.chartY = a.chartY;\n          this.initPositions = [this.from, this.to];\n          this.grabbedCenter = !0;\n        }\n        mouseMoveHandler(a) {\n          var h = this.chart.pointer.normalize(a),\n            k = this.options.vertical ? \"chartY\" : \"chartX\";\n          const m = this.initPositions || [];\n          !this.grabbedCenter || a.touches && 0 === a.touches[0][k] || (h = this.cursorToScrollbarPosition(h)[k], k = this[k], k = h - k, this.hasDragged = !0, this.updatePosition(m[0] + k, m[1] + k), this.hasDragged && d(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMType: a.type,\n            DOMEvent: a\n          }));\n        }\n        mouseUpHandler(a) {\n          this.hasDragged && d(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMType: a.type,\n            DOMEvent: a\n          });\n          this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n        }\n        position(a, d, k, m) {\n          const {\n              buttonsEnabled: h,\n              margin: e = 0,\n              vertical: n\n            } = this.options,\n            p = this.rendered ? \"animate\" : \"attr\";\n          let l = m,\n            w = 0;\n          this.group.show();\n          this.x = a;\n          this.y = d + this.trackBorderWidth;\n          this.width = k;\n          this.height = m;\n          this.xOffset = l;\n          this.yOffset = w;\n          n ? (this.width = this.yOffset = k = this.size, this.xOffset = l = 0, this.yOffset = w = h ? this.size : 0, this.barWidth = m - (h ? 2 * k : 0), this.x = a += e) : (this.height = m = this.size, this.xOffset = l = h ? this.size : 0, this.barWidth = k - (h ? 2 * m : 0), this.y += e);\n          this.group[p]({\n            translateX: a,\n            translateY: this.y\n          });\n          this.track[p]({\n            width: k,\n            height: m\n          });\n          this.scrollbarButtons[1][p]({\n            translateX: n ? 0 : k - l,\n            translateY: n ? m - w : 0\n          });\n        }\n        removeEvents() {\n          this._events.forEach(function (a) {\n            k.apply(null, a);\n          });\n          this._events.length = 0;\n        }\n        render() {\n          const a = this.renderer,\n            d = this.options,\n            k = this.size,\n            m = this.chart.styledMode,\n            p = a.g(\"scrollbar\").attr({\n              zIndex: d.zIndex\n            }).hide().add();\n          this.group = p;\n          this.track = a.rect().addClass(\"highcharts-scrollbar-track\").attr({\n            r: d.trackBorderRadius || 0,\n            height: k,\n            width: k\n          }).add(p);\n          m || this.track.attr({\n            fill: d.trackBackgroundColor,\n            stroke: d.trackBorderColor,\n            \"stroke-width\": d.trackBorderWidth\n          });\n          const e = this.trackBorderWidth = this.track.strokeWidth();\n          this.track.attr({\n            x: -e % 2 / 2,\n            y: -e % 2 / 2\n          });\n          this.scrollbarGroup = a.g().add(p);\n          this.scrollbar = a.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n            height: k - e,\n            width: k - e,\n            r: d.barBorderRadius || 0\n          }).add(this.scrollbarGroup);\n          this.scrollbarRifles = a.path(v.swapXY([[\"M\", -3, k / 4], [\"L\", -3, 2 * k / 3], [\"M\", 0, k / 4], [\"L\", 0, 2 * k / 3], [\"M\", 3, k / 4], [\"L\", 3, 2 * k / 3]], d.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n          m || (this.scrollbar.attr({\n            fill: d.barBackgroundColor,\n            stroke: d.barBorderColor,\n            \"stroke-width\": d.barBorderWidth\n          }), this.scrollbarRifles.attr({\n            stroke: d.rifleColor,\n            \"stroke-width\": 1\n          }));\n          this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n          this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n          this.drawScrollbarButton(0);\n          this.drawScrollbarButton(1);\n        }\n        setRange(a, d) {\n          const h = this.options,\n            k = h.vertical;\n          var m = h.minWidth,\n            e = this.barWidth;\n          const n = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n          if (t(e)) {\n            var p = e * Math.min(d, 1);\n            a = Math.max(a, 0);\n            var l = Math.ceil(e * a);\n            this.calculatedWidth = p = B(p - l);\n            p < m && (l = (e - m + p) * a, p = m);\n            m = Math.floor(l + this.xOffset + this.yOffset);\n            e = p / 2 - .5;\n            this.from = a;\n            this.to = d;\n            k ? (this.scrollbarGroup[n]({\n              translateY: m\n            }), this.scrollbar[n]({\n              height: p\n            }), this.scrollbarRifles[n]({\n              translateY: e\n            }), this.scrollbarTop = m, this.scrollbarLeft = 0) : (this.scrollbarGroup[n]({\n              translateX: m\n            }), this.scrollbar[n]({\n              width: p\n            }), this.scrollbarRifles[n]({\n              translateX: e\n            }), this.scrollbarLeft = m, this.scrollbarTop = 0);\n            12 >= p ? this.scrollbarRifles.hide() : this.scrollbarRifles.show();\n            !1 === h.showFull && (0 >= a && 1 <= d ? this.group.hide() : this.group.show());\n            this.rendered = !0;\n          }\n        }\n        shouldUpdateExtremes(a) {\n          return m(this.options.liveRedraw, A.svg && !A.isTouchDevice && !this.chart.boosted) || \"mouseup\" === a || \"touchend\" === a || !t(a);\n        }\n        trackClick(a) {\n          const h = this.chart.pointer.normalize(a),\n            k = this.to - this.from,\n            m = this.y + this.scrollbarTop,\n            n = this.x + this.scrollbarLeft;\n          this.options.vertical && h.chartY > m || !this.options.vertical && h.chartX > n ? this.updatePosition(this.from + k, this.to + k) : this.updatePosition(this.from - k, this.to - k);\n          d(this, \"changed\", {\n            from: this.from,\n            to: this.to,\n            trigger: \"scrollbar\",\n            DOMEvent: a\n          });\n        }\n        update(a) {\n          this.destroy();\n          this.init(this.chart.renderer, p(!0, this.options, a), this.chart);\n        }\n        updatePosition(a, d) {\n          1 < d && (a = B(1 - B(d - a)), d = 1);\n          0 > a && (d = B(d - a), a = 0);\n          this.from = a;\n          this.to = d;\n        }\n      }\n      v.defaultOptions = I;\n      return v;\n    })();\n    u.scrollbar = p(!0, v.defaultOptions, u.scrollbar);\n    return v;\n  });\n  M(a, \"Stock/Navigator/Navigator.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/NavigatorAxisComposition.js\"], a[\"Stock/Navigator/NavigatorComposition.js\"], a[\"Stock/Scrollbar/Scrollbar.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C) {\n    function u(a, ...c) {\n      c = [].filter.call(c, e);\n      if (c.length) return Math[a].apply(0, c);\n    }\n    const {\n        defaultOptions: t\n      } = A,\n      {\n        hasTouch: r,\n        isTouchDevice: d\n      } = H,\n      {\n        addEvent: p,\n        clamp: m,\n        correctFloat: k,\n        defined: v,\n        destroyObjectProperties: n,\n        erase: h,\n        extend: D,\n        find: L,\n        isArray: E,\n        isNumber: e,\n        merge: q,\n        pick: y,\n        removeEvent: l,\n        splat: w\n      } = C;\n    class g {\n      static compose(a, c, f) {\n        F.compose(a, c, g, f);\n      }\n      constructor(a) {\n        this.rendered = this.range = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;\n        this.scrollbarHeight = 0;\n        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.scrollButtonSize = void 0;\n        this.init(a);\n      }\n      drawHandle(a, c, f, d) {\n        const b = this.navigatorOptions.handles.height;\n        this.handles[c][d](f ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - b)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - b / 2 - 1)\n        });\n      }\n      drawOutline(a, c, f, d) {\n        const b = this.navigatorOptions.maskInside;\n        var e = this.outline.strokeWidth();\n        const g = e / 2;\n        var h = e % 2 / 2;\n        const k = this.scrollButtonSize,\n          l = this.size,\n          m = this.top;\n        e = this.height;\n        const n = m - g,\n          q = m + e;\n        let p = this.left;\n        f ? (f = m + c + h, c = m + a + h, h = [[\"M\", p + e, m - k - h], [\"L\", p + e, f], [\"L\", p, f], [\"M\", p, c], [\"L\", p + e, c], [\"L\", p + e, m + l + k]], b && h.push([\"M\", p + e, f - g], [\"L\", p + e, c + g])) : (p -= k, a += p + k - h, c += p + k - h, h = [[\"M\", p, n], [\"L\", a, n], [\"L\", a, q], [\"M\", c, q], [\"L\", c, n], [\"L\", p + l + 2 * k, m + g]], b && h.push([\"M\", a - g, n], [\"L\", c + g, n]));\n        this.outline[d]({\n          d: h\n        });\n      }\n      drawMasks(a, c, f, d) {\n        const b = this.left,\n          e = this.top,\n          g = this.height;\n        let h, k, l, m;\n        f ? (l = [b, b, b], m = [e, e + a, e + c], k = [g, g, g], h = [a, c - a, this.size - c]) : (l = [b, b + a, b + c], m = [e, e, e], k = [a, c - a, this.size - c], h = [g, g, g]);\n        this.shades.forEach((a, b) => {\n          a[d]({\n            x: l[b],\n            y: m[b],\n            width: k[b],\n            height: h[b]\n          });\n        });\n      }\n      renderElements() {\n        const a = this,\n          c = a.navigatorOptions,\n          f = c.maskInside,\n          d = a.chart,\n          e = d.renderer,\n          g = {\n            cursor: d.inverted ? \"ns-resize\" : \"ew-resize\"\n          },\n          h = a.navigatorGroup = e.g(\"navigator\").attr({\n            zIndex: 8,\n            visibility: \"hidden\"\n          }).add();\n        [!f, f, !f].forEach((b, f) => {\n          const k = e.rect().addClass(\"highcharts-navigator-mask\" + (1 === f ? \"-inside\" : \"-outside\")).add(h);\n          d.styledMode || (k.attr({\n            fill: b ? c.maskFill : \"rgba(0,0,0,0)\"\n          }), 1 === f && k.css(g));\n          a.shades[f] = k;\n        });\n        a.outline = e.path().addClass(\"highcharts-navigator-outline\").add(h);\n        d.styledMode || a.outline.attr({\n          \"stroke-width\": c.outlineWidth,\n          stroke: c.outlineColor\n        });\n        if (c.handles && c.handles.enabled) {\n          const b = c.handles,\n            {\n              height: f,\n              width: k\n            } = b;\n          [0, 1].forEach(c => {\n            a.handles[c] = e.symbol(b.symbols[c], -k / 2 - 1, 0, k, f, b);\n            d.inverted && a.handles[c].attr({\n              rotation: 90,\n              rotationOriginX: Math.floor(-k / 2),\n              rotationOriginY: (f + k) / 2\n            });\n            a.handles[c].attr({\n              zIndex: 7 - c\n            }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(h);\n            d.styledMode || a.handles[c].attr({\n              fill: b.backgroundColor,\n              stroke: b.borderColor,\n              \"stroke-width\": b.lineWidth\n            }).css(g);\n          });\n        }\n      }\n      update(a) {\n        (this.series || []).forEach(a => {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        q(!0, this.chart.options.navigator, a);\n        this.init(this.chart);\n      }\n      render(a, c, f, d) {\n        var b = this.chart;\n        const g = this.xAxis,\n          h = g.pointRange || 0;\n        var l = g.navigatorAxis.fake ? b.xAxis[0] : g;\n        const n = this.navigatorEnabled;\n        var p = this.rendered,\n          q = b.inverted;\n        const x = b.xAxis[0].minRange,\n          w = b.xAxis[0].options.maxRange,\n          r = this.scrollButtonSize;\n        let t = this.scrollbarHeight,\n          u;\n        if (!this.hasDragged || v(f)) {\n          a = k(a - h / 2);\n          c = k(c + h / 2);\n          if (!e(a) || !e(c)) if (p) f = 0, d = y(g.width, l.width);else return;\n          this.left = y(g.left, b.plotLeft + r + (q ? b.plotWidth : 0));\n          var B = this.size = u = y(g.len, (q ? b.plotHeight : b.plotWidth) - 2 * r);\n          b = q ? t : u + 2 * r;\n          f = y(f, g.toPixels(a, !0));\n          d = y(d, g.toPixels(c, !0));\n          e(f) && Infinity !== Math.abs(f) || (f = 0, d = b);\n          a = g.toValue(f, !0);\n          c = g.toValue(d, !0);\n          var A = Math.abs(k(c - a));\n          A < x ? this.grabbedLeft ? f = g.toPixels(c - x - h, !0) : this.grabbedRight && (d = g.toPixels(a + x + h, !0)) : v(w) && k(A - h) > w && (this.grabbedLeft ? f = g.toPixels(c - w - h, !0) : this.grabbedRight && (d = g.toPixels(a + w + h, !0)));\n          this.zoomedMax = m(Math.max(f, d), 0, B);\n          this.zoomedMin = m(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(f, d), 0, B);\n          this.range = this.zoomedMax - this.zoomedMin;\n          B = Math.round(this.zoomedMax);\n          f = Math.round(this.zoomedMin);\n          n && (this.navigatorGroup.attr({\n            visibility: \"inherit\"\n          }), p = p && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(f, B, q, p), this.drawOutline(f, B, q, p), this.navigatorOptions.handles.enabled && (this.drawHandle(f, 0, q, p), this.drawHandle(B, 1, q, p)));\n          this.scrollbar && (q ? (q = this.top - r, l = this.left - t + (n || !l.opposite ? 0 : (l.titleOffset || 0) + l.axisTitleMargin), t = u + 2 * r) : (q = this.top + (n ? this.height : -t), l = this.left - r), this.scrollbar.position(l, q, b, t), this.scrollbar.setRange(this.zoomedMin / (u || 1), this.zoomedMax / (u || 1)));\n          this.rendered = !0;\n        }\n      }\n      addMouseEvents() {\n        const a = this,\n          c = a.chart,\n          f = c.container;\n        let d = [],\n          e,\n          g;\n        a.mouseMoveHandler = e = function (b) {\n          a.onMouseMove(b);\n        };\n        a.mouseUpHandler = g = function (b) {\n          a.onMouseUp(b);\n        };\n        d = a.getPartsEvents(\"mousedown\");\n        d.push(p(c.renderTo, \"mousemove\", e), p(f.ownerDocument, \"mouseup\", g));\n        r && (d.push(p(c.renderTo, \"touchmove\", e), p(f.ownerDocument, \"touchend\", g)), d.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = d;\n        a.series && a.series[0] && d.push(p(a.series[0].xAxis, \"foundExtremes\", function () {\n          c.navigator.modifyNavigatorAxisExtremes();\n        }));\n      }\n      getPartsEvents(a) {\n        const b = this,\n          f = [];\n        [\"shades\", \"handles\"].forEach(function (c) {\n          b[c].forEach(function (d, e) {\n            f.push(p(d.element, a, function (a) {\n              b[c + \"Mousedown\"](a, e);\n            }));\n          });\n        });\n        return f;\n      }\n      shadesMousedown(a, c) {\n        a = this.chart.pointer.normalize(a);\n        const b = this.chart,\n          d = this.xAxis,\n          e = this.zoomedMin,\n          g = this.size,\n          h = this.range;\n        let k = this.left,\n          l = a.chartX,\n          m,\n          n;\n        b.inverted && (l = a.chartY, k = this.top);\n        1 === c ? (this.grabbedCenter = l, this.fixedWidth = h, this.dragOffset = l - e) : (a = l - k - h / 2, 0 === c ? a = Math.max(0, a) : 2 === c && a + h >= g && (a = g - h, this.reversedExtremes ? (a -= h, n = this.getUnionExtremes().dataMin) : m = this.getUnionExtremes().dataMax), a !== e && (this.fixedWidth = h, c = d.navigatorAxis.toFixedRange(a, a + h, n, m), v(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, null, {\n          trigger: \"navigator\"\n        })));\n      }\n      handlesMousedown(a, c) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        const b = a.xAxis[0],\n          d = this.reversedExtremes;\n        0 === c ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? b.min : b.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? b.max : b.min);\n        a.fixedRange = null;\n      }\n      onMouseMove(a) {\n        const b = this;\n        var f = b.chart;\n        const e = b.navigatorSize,\n          g = b.range,\n          h = b.dragOffset,\n          k = f.inverted;\n        let l = b.left;\n        a.touches && 0 === a.touches[0].pageX || (a = f.pointer.normalize(a), f = a.chartX, k && (l = b.top, f = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, f - l, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, f - l)) : b.grabbedCenter && (b.hasDragged = !0, f < h ? f = h : f > e + h - g && (f = e + h - g), b.render(0, 0, f - h, f - h + g)), b.hasDragged && b.scrollbar && y(b.scrollbar.options.liveRedraw, !d && !this.chart.boosted) && (a.DOMType = a.type, setTimeout(function () {\n          b.onMouseUp(a);\n        }, 0)));\n      }\n      onMouseUp(a) {\n        var b = this.chart,\n          f = this.xAxis,\n          d = this.scrollbar;\n        const g = a.DOMEvent || a,\n          h = b.inverted,\n          k = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n        let l, m;\n        (!this.hasDragged || d && d.hasDragged) && \"scrollbar\" !== a.trigger || (d = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? l = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (m = this.fixedExtreme), this.zoomedMax === this.size && (m = this.reversedExtremes ? d.dataMin : d.dataMax), 0 === this.zoomedMin && (l = this.reversedExtremes ? d.dataMax : d.dataMin), f = f.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, l, m), v(f.min) && b.xAxis[0].setExtremes(Math.min(f.min, f.max), Math.max(f.min, f.max), !0, this.hasDragged ? !1 : null, {\n          trigger: \"navigator\",\n          triggerOp: \"navigator-drag\",\n          DOMEvent: g\n        }));\n        \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n        this.navigatorEnabled && e(this.zoomedMin) && e(this.zoomedMax) && (b = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a, h, k), this.outline && this.drawOutline(b, a, h, k), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, h, k), this.drawHandle(a, 1, h, k)));\n      }\n      removeEvents() {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      }\n      removeBaseSeriesEvents() {\n        const a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          l(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && l(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      }\n      init(b) {\n        var c = b.options,\n          d = c.navigator || {},\n          g = d.enabled,\n          h = c.scrollbar || {},\n          k = h.enabled;\n        c = g && d.height || 0;\n        var l = k && h.height || 0;\n        const m = h.buttonsEnabled && l || 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = b;\n        this.setBaseSeries();\n        this.height = c;\n        this.scrollbarHeight = l;\n        this.scrollButtonSize = m;\n        this.scrollbarEnabled = k;\n        this.navigatorEnabled = g;\n        this.navigatorOptions = d;\n        this.scrollbarOptions = h;\n        this.opposite = y(d.opposite, !(g || !b.inverted));\n        const n = this;\n        g = n.baseSeries;\n        h = b.xAxis.length;\n        k = b.yAxis.length;\n        l = g && g[0] && g[0].xAxis || b.xAxis[0] || {\n          options: {}\n        };\n        b.isDirtyBox = !0;\n        n.navigatorEnabled ? (n.xAxis = new a(b, q({\n          breaks: l.options.breaks,\n          ordinal: l.options.ordinal\n        }, d.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: h,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, b.inverted ? {\n          offsets: [m, 0, -m, 0],\n          width: c\n        } : {\n          offsets: [0, -m, 0, m],\n          height: c\n        })), n.yAxis = new a(b, q(d.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: k,\n          isInternal: !0,\n          reversed: y(d.yAxis && d.yAxis.reversed, b.yAxis[0] && b.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, b.inverted ? {\n          width: c\n        } : {\n          height: c\n        })), g || d.series.data ? n.updateNavigatorSeries(!1) : 0 === b.series.length && (n.unbindRedraw = p(b, \"beforeRedraw\", function () {\n          0 < b.series.length && !n.series && (n.setBaseSeries(), n.unbindRedraw());\n        })), n.reversedExtremes = b.inverted && !n.xAxis.reversed || !b.inverted && n.xAxis.reversed, n.renderElements(), n.addMouseEvents()) : (n.xAxis = {\n          chart: b,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function (a, c) {\n            var d = b.xAxis[0];\n            const f = d.getExtremes(),\n              e = d.len - 2 * m,\n              g = u(\"min\", d.options.min, f.dataMin);\n            d = u(\"max\", d.options.max, f.dataMax) - g;\n            return c ? a * d / e + g : e * (a - g) / d;\n          },\n          toPixels: function (a) {\n            return this.translate(a);\n          },\n          toValue: function (a) {\n            return this.translate(a, !0);\n          }\n        }, n.xAxis.navigatorAxis.axis = n.xAxis, n.xAxis.navigatorAxis.toFixedRange = I.prototype.toFixedRange.bind(n.xAxis.navigatorAxis));\n        b.options.scrollbar.enabled && (d = q(b.options.scrollbar, {\n          vertical: b.inverted\n        }), !e(d.margin) && n.navigatorEnabled && (d.margin = b.inverted ? -3 : 3), b.scrollbar = n.scrollbar = new G(b.renderer, d, b), p(n.scrollbar, \"changed\", function (a) {\n          var b = n.size;\n          const c = b * this.to;\n          b *= this.from;\n          n.hasDragged = n.scrollbar.hasDragged;\n          n.render(0, 0, b, c);\n          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {\n            n.onMouseUp(a);\n          });\n        }));\n        n.addBaseSeriesEvents();\n        n.addChartEvents();\n      }\n      getUnionExtremes(a) {\n        const b = this.chart.xAxis[0],\n          d = this.xAxis,\n          e = d.options,\n          g = b.options;\n        let h;\n        a && null === b.dataMin || (h = {\n          dataMin: y(e && e.min, u(\"min\", g.min, b.dataMin, d.dataMin, d.min)),\n          dataMax: y(e && e.max, u(\"max\", g.max, b.dataMax, d.dataMax, d.max))\n        });\n        return h;\n      }\n      setBaseSeries(a, c) {\n        const b = this.chart,\n          d = this.baseSeries = [];\n        a = a || b.options && b.options.navigator.baseSeries || (b.series.length ? L(b.series, a => !a.options.isInternal).index : 0);\n        (b.series || []).forEach((b, c) => {\n          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);\n        });\n        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, c);\n      }\n      updateNavigatorSeries(a, c) {\n        const b = this,\n          d = b.chart,\n          e = b.baseSeries,\n          g = {\n            enableMouseTracking: !1,\n            index: null,\n            linkedTo: null,\n            group: \"nav\",\n            padXAxis: !1,\n            xAxis: \"navigator-x-axis\",\n            yAxis: \"navigator-y-axis\",\n            showInLegend: !1,\n            stacking: void 0,\n            isInternal: !0,\n            states: {\n              inactive: {\n                opacity: 1\n              }\n            }\n          },\n          h = b.series = (b.series || []).filter(a => {\n            const c = a.baseSeries;\n            return 0 > e.indexOf(c) ? (c && (l(c, \"updatedData\", b.updatedDataHandler), delete c.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n          });\n        let k,\n          m,\n          n = b.navigatorOptions.series,\n          p;\n        e && e.length && e.forEach(a => {\n          const f = a.navigatorSeries;\n          var l = D({\n            color: a.color,\n            visible: a.visible\n          }, E(n) ? t.navigator.series : n);\n          f && !1 === b.navigatorOptions.adaptToUpdatedData || (g.name = \"Navigator \" + e.length, k = a.options || {}, p = k.navigatorOptions || {}, l.dataLabels = w(l.dataLabels), m = q(k, g, l, p), m.pointRange = y(l.pointRange, p.pointRange, t.plotOptions[m.type || \"line\"].pointRange), l = p.data || l.data, b.hasNavigatorData = b.hasNavigatorData || !!l, m.data = l || k.data && k.data.slice(0), f && f.options ? f.update(m, c) : (a.navigatorSeries = d.initSeries(m), a.navigatorSeries.baseSeries = a, h.push(a.navigatorSeries)));\n        });\n        if (n.data && (!e || !e.length) || E(n)) b.hasNavigatorData = !1, n = w(n), n.forEach((a, c) => {\n          g.name = \"Navigator \" + (h.length + 1);\n          m = q(t.navigator.series, {\n            color: d.series[c] && !d.series[c].options.isInternal && d.series[c].color || d.options.colors[c] || d.options.colors[0]\n          }, g, a);\n          m.data = a.data;\n          m.data && (b.hasNavigatorData = !0, h.push(d.initSeries(m)));\n        });\n        a && this.addBaseSeriesEvents();\n      }\n      addBaseSeriesEvents() {\n        const a = this,\n          c = a.baseSeries || [];\n        c[0] && c[0].xAxis && c[0].eventsToUnbind.push(p(c[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n        c.forEach(b => {\n          b.eventsToUnbind.push(p(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          }));\n          b.eventsToUnbind.push(p(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          }));\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(p(b, \"updatedData\", this.updatedDataHandler));\n          b.eventsToUnbind.push(p(b, \"remove\", function () {\n            this.navigatorSeries && (h(a.series, this.navigatorSeries), v(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          }));\n        });\n      }\n      getBaseSeriesMin(a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData && b.xData.length ? b.xData[0] : a);\n        }, a);\n      }\n      modifyNavigatorAxisExtremes() {\n        const a = this.xAxis;\n        if (\"undefined\" !== typeof a.getExtremes) {\n          const b = this.getUnionExtremes(!0);\n          !b || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax);\n        }\n      }\n      modifyBaseAxisExtremes() {\n        const a = this.chart.navigator;\n        var c = this.getExtremes();\n        const d = c.dataMin,\n          g = c.dataMax;\n        c = c.max - c.min;\n        const h = a.stickToMin,\n          k = a.stickToMax,\n          l = y(this.options.overscroll, 0),\n          m = a.series && a.series[0],\n          n = !!this.setExtremes;\n        let p, q;\n        this.eventArgs && \"rangeSelectorButton\" === this.eventArgs.trigger || (h && (q = d, p = q + c), k && (p = g + l, h || (q = Math.max(d, p - c, a.getBaseSeriesMin(m && m.xData ? m.xData[0] : -Number.MAX_VALUE)))), n && (h || k) && e(q) && (this.min = this.userMin = q, this.max = this.userMax = p));\n        a.stickToMin = a.stickToMax = null;\n      }\n      updatedDataHandler() {\n        const a = this.chart.navigator,\n          c = this.navigatorSeries;\n        a.stickToMax = y(this.chart.options.navigator && this.chart.options.navigator.stickToMax, a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size));\n        a.stickToMin = a.shouldStickToMin(this, a);\n        c && !a.hasNavigatorData && (c.options.pointStart = this.xData[0], c.setData(this.options.data, !1, null, !1));\n      }\n      shouldStickToMin(a, c) {\n        c = c.getBaseSeriesMin(a.xData[0]);\n        var b = a.xAxis;\n        a = b.max;\n        const d = b.min;\n        b = b.options.range;\n        return e(a) && e(d) ? b && 0 < a - c ? a - c < b : d <= c : !1;\n      }\n      addChartEvents() {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(p(this.chart, \"redraw\", function () {\n          const a = this.navigator,\n            c = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);\n          c && a.render(c.min, c.max);\n        }), p(this.chart, \"getMargins\", function () {\n          let a = this.navigator,\n            c = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (c = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[c] = (this[c] || 0) + (a.navigatorEnabled || !this.inverted ? a.height + a.scrollbarHeight : 0) + a.navigatorOptions.margin;\n        }));\n      }\n      destroy() {\n        this.removeEvents();\n        this.xAxis && (h(this.chart.xAxis, this.xAxis), h(this.chart.axes, this.xAxis));\n        this.yAxis && (h(this.chart.yAxis, this.yAxis), h(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(a => {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(a => {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        });\n        [this.handles].forEach(a => {\n          n(a);\n        });\n      }\n    }\n    return g;\n  });\n  M(a, \"Stock/RangeSelector/RangeSelectorDefaults.js\", [], function () {\n    return {\n      lang: {\n        rangeSelectorZoom: \"Zoom\",\n        rangeSelectorFrom: \"\",\n        rangeSelectorTo: \"\\u2192\"\n      },\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%e %b %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#334eff\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\"\n        },\n        labelStyle: {\n          color: \"#666666\",\n          fontSize: \"0.8em\"\n        }\n      }\n    };\n  });\n  M(a, \"Stock/RangeSelector/RangeSelectorComposition.js\", [a[\"Core/Defaults.js\"], a[\"Stock/RangeSelector/RangeSelectorDefaults.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    function u() {\n      const a = this.range,\n        d = a.type,\n        e = this.max,\n        b = this.chart.time,\n        c = function (a, c) {\n          const f = \"year\" === d ? \"FullYear\" : \"Month\",\n            e = new b.Date(a),\n            g = b.get(f, e);\n          b.set(f, e, g + c);\n          g === b.get(f, e) && b.set(\"Date\", e, 0);\n          return e.getTime() - a;\n        };\n      let f, h;\n      D(a) ? (f = e - a, h = a) : a && (f = e + c(e, -(a.count || 1)), this.chart && (this.chart.fixedRange = e - f));\n      const k = E(this.dataMin, Number.MIN_VALUE);\n      D(f) || (f = k);\n      f <= k && (f = k, \"undefined\" === typeof h && (h = c(f, a.count)), this.newMax = Math.min(f + h, E(this.dataMax, Number.MAX_VALUE)));\n      D(e) ? !D(a) && a && a._offsetMin && (f += a._offsetMin) : f = void 0;\n      return f;\n    }\n    function F() {\n      this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new y(this));\n    }\n    function G() {\n      var a = this.axes;\n      const d = this.rangeSelector;\n      d && (D(d.deferredYTDClick) && (d.clickButton(d.deferredYTDClick), delete d.deferredYTDClick), a.forEach(a => {\n        a.updateNames();\n        a.setScale();\n      }), this.getAxisMargins(), d.render(), a = d.options.verticalAlign, d.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n    }\n    function C(a) {\n      let d, g, b, c;\n      const f = a.rangeSelector,\n        l = () => {\n          f && (d = a.xAxis[0].getExtremes(), g = a.legend, c = f && f.options.verticalAlign, D(d.min) && f.render(d.min, d.max), g.display && \"top\" === c && c === g.options.verticalAlign && (b = L(a.spacingBox), b.y = \"vertical\" === g.options.layout ? a.plotTop : b.y + f.getHeight(), g.group.placed = !1, g.align(b)));\n        };\n      f && (h(e, b => b[0] === a) || e.push([a, [k(a.xAxis[0], \"afterSetExtremes\", function (a) {\n        f && f.render(a.min, a.max);\n      }), k(a, \"redraw\", l)]]), l());\n    }\n    function B() {\n      for (let a = 0, d = e.length; a < d; ++a) {\n        const d = e[a];\n        if (d[0] === this) {\n          d[1].forEach(a => a());\n          e.splice(a, 1);\n          break;\n        }\n      }\n    }\n    function t() {\n      var a = this.rangeSelector;\n      a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n    }\n    function r() {\n      var a = this.rangeSelector;\n      a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n    }\n    function d(a) {\n      var d = a.options.rangeSelector;\n      a = this.extraBottomMargin;\n      const e = this.extraTopMargin;\n      let b = this.rangeSelector;\n      d && d.enabled && !v(b) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = b = new y(this));\n      this.extraTopMargin = this.extraBottomMargin = !1;\n      b && (C(this), d = d && d.verticalAlign || b.options && b.options.verticalAlign, b.options.floating || (\"bottom\" === d ? this.extraBottomMargin = !0 : \"middle\" !== d && (this.extraTopMargin = !0)), this.extraBottomMargin !== a || this.extraTopMargin !== e) && (this.isDirtyBox = !0);\n    }\n    const {\n        defaultOptions: p,\n        setOptions: m\n      } = a,\n      {\n        addEvent: k,\n        defined: v,\n        extend: n,\n        find: h,\n        isNumber: D,\n        merge: L,\n        pick: E\n      } = H,\n      e = [],\n      q = [];\n    let y;\n    return {\n      compose: function (a, e, g) {\n        y = g;\n        H.pushUnique(q, a) && (a.prototype.minFromRange = u);\n        H.pushUnique(q, e) && (k(e, \"afterGetContainer\", F), k(e, \"beforeRender\", G), k(e, \"destroy\", B), k(e, \"getMargins\", t), k(e, \"render\", r), k(e, \"update\", d), e.prototype.callbacks.push(C));\n        H.pushUnique(q, m) && (n(p, {\n          rangeSelector: A.rangeSelector\n        }), n(p.lang, A.lang));\n      }\n    };\n  });\n  M(a, \"Stock/RangeSelector/RangeSelector.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/Globals.js\"], a[\"Stock/RangeSelector/RangeSelectorComposition.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G) {\n    function u(a) {\n      if (-1 !== a.indexOf(\"%L\")) return \"text\";\n      const d = \"aAdewbBmoyY\".split(\"\").some(b => -1 !== a.indexOf(\"%\" + b)),\n        b = \"HkIlMS\".split(\"\").some(b => -1 !== a.indexOf(\"%\" + b));\n      return d && b ? \"datetime-local\" : d ? \"date\" : b ? \"time\" : \"text\";\n    }\n    const {\n        defaultOptions: B\n      } = A,\n      {\n        addEvent: t,\n        createElement: r,\n        css: d,\n        defined: p,\n        destroyObjectProperties: m,\n        discardElement: k,\n        extend: v,\n        fireEvent: n,\n        isNumber: h,\n        merge: D,\n        objectEach: L,\n        pad: E,\n        pick: e,\n        pInt: q,\n        splat: y\n      } = G;\n    class l {\n      static compose(a, d) {\n        I.compose(a, d, l);\n      }\n      constructor(a) {\n        this.buttons = void 0;\n        this.buttonOptions = l.prototype.defaultButtons;\n        this.initialButtonGroupWidth = 0;\n        this.options = void 0;\n        this.chart = a;\n        this.init(a);\n      }\n      clickButton(d, g) {\n        const b = this.chart,\n          c = this.buttonOptions[d],\n          f = b.xAxis[0];\n        var k = b.scroller && b.scroller.getUnionExtremes() || f || {},\n          l = c.type;\n        const m = c.dataGrouping;\n        let q = k.dataMin,\n          r = k.dataMax,\n          w,\n          u = f && Math.round(Math.min(f.max, e(r, f.max))),\n          v;\n        k = c._range;\n        let B,\n          A,\n          E,\n          C = !0;\n        if (null !== q && null !== r) {\n          b.fixedRange = k;\n          this.setSelected(d);\n          m && (this.forcedDataGrouping = !0, a.prototype.setDataGrouping.call(f || {\n            chart: this.chart\n          }, m, !1), this.frozenStates = c.preserveDataGrouping);\n          if (\"month\" === l || \"year\" === l) f ? (l = {\n            range: c,\n            max: u,\n            chart: b,\n            dataMin: q,\n            dataMax: r\n          }, w = f.minFromRange.call(l), h(l.newMax) && (u = l.newMax), C = !1) : k = c;else if (k) w = Math.max(u - k, q), u = Math.min(w + k, r), C = !1;else if (\"ytd\" === l) {\n            if (f) {\n              if (\"undefined\" === typeof r || \"undefined\" === typeof q) q = Number.MAX_VALUE, r = Number.MIN_VALUE, b.series.forEach(a => {\n                if (a = a.xData) q = Math.min(a[0], q), r = Math.max(a[a.length - 1], r);\n              }), g = !1;\n              l = this.getYTDExtremes(r, q, b.time.useUTC);\n              w = B = l.min;\n              u = l.max;\n            } else {\n              this.deferredYTDClick = d;\n              return;\n            }\n          } else \"all\" === l && f && (b.navigator && b.navigator.baseSeries[0] && (b.navigator.baseSeries[0].xAxis.options.range = void 0), w = q, u = r);\n          C && c._offsetMin && p(w) && (w += c._offsetMin);\n          c._offsetMax && p(u) && (u += c._offsetMax);\n          this.dropdown && (this.dropdown.selectedIndex = d + 1);\n          f ? f.setExtremes(w, u, e(g, !0), void 0, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: c\n          }) : (v = y(b.options.xAxis)[0], E = v.range, v.range = k, A = v.min, v.min = B, t(b, \"load\", function () {\n            v.range = E;\n            v.min = A;\n          }));\n          n(this, \"afterBtnClick\");\n        }\n      }\n      setSelected(a) {\n        this.selected = this.options.selected = a;\n      }\n      init(a) {\n        const d = this,\n          b = a.options.rangeSelector,\n          c = b.buttons || d.defaultButtons.slice(),\n          f = b.selected,\n          e = function () {\n            const a = d.minInput,\n              b = d.maxInput;\n            a && a.blur && n(a, \"blur\");\n            b && b.blur && n(b, \"blur\");\n          };\n        d.chart = a;\n        d.options = b;\n        d.buttons = [];\n        d.buttonOptions = c;\n        this.eventsToUnbind = [];\n        this.eventsToUnbind.push(t(a.container, \"mousedown\", e));\n        this.eventsToUnbind.push(t(a, \"resize\", e));\n        c.forEach(d.computeButtonRange);\n        \"undefined\" !== typeof f && c[f] && this.clickButton(f, !1);\n        this.eventsToUnbind.push(t(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && t(a.xAxis[0], \"setExtremes\", function (b) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== b.trigger && \"updatedData\" !== b.trigger && d.forcedDataGrouping && !d.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      }\n      updateButtonStates() {\n        const a = this;\n        var d = this.chart;\n        const b = this.dropdown,\n          c = d.xAxis[0],\n          f = Math.round(c.max - c.min),\n          e = !c.hasVisibleSeries,\n          k = d.scroller && d.scroller.getUnionExtremes() || c,\n          l = k.dataMin,\n          m = k.dataMax;\n        d = a.getYTDExtremes(m, l, d.time.useUTC);\n        const n = d.min,\n          q = d.max,\n          p = a.selected,\n          r = a.options.allButtonsEnabled,\n          t = a.buttons;\n        let u = h(p);\n        a.buttonOptions.forEach((d, g) => {\n          var h = d._range,\n            k = d.type,\n            x = d.count || 1;\n          const w = t[g],\n            v = d._offsetMax - d._offsetMin,\n            z = g === p,\n            y = h > m - l,\n            B = h < c.minRange;\n          d = 0;\n          let A = !1,\n            J = !1;\n          h = h === f;\n          (\"month\" === k || \"year\" === k) && f + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[k] * x - v && f - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[k] * x + v ? h = !0 : \"ytd\" === k ? (h = q - n + v === f, A = !z) : \"all\" === k && (h = c.max - c.min >= m - l, J = !z && u && h);\n          k = !r && (y || B || J || e);\n          x = z && h || h && !u && !A || z && a.frozenStates;\n          k ? d = 3 : x && (u = !0, d = 2);\n          w.state !== d && (w.setState(d), b && (b.options[g + 1].disabled = k, 2 === d && (b.selectedIndex = g + 1)), 0 === d && p === g && a.setSelected());\n        });\n      }\n      computeButtonRange(a) {\n        const d = a.type,\n          b = a.count || 1,\n          c = {\n            millisecond: 1,\n            second: 1E3,\n            minute: 6E4,\n            hour: 36E5,\n            day: 864E5,\n            week: 6048E5\n          };\n        if (c[d]) a._range = c[d] * b;else if (\"month\" === d || \"year\" === d) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[d] * b;\n        a._offsetMin = e(a.offsetMin, 0);\n        a._offsetMax = e(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      }\n      getInputValue(a) {\n        a = \"min\" === a ? this.minInput : this.maxInput;\n        const d = this.chart.options.rangeSelector,\n          b = this.chart.time;\n        return a ? (\"text\" === a.type && d.inputDateParser || this.defaultInputDateParser)(a.value, b.useUTC, b) : 0;\n      }\n      setInputValue(a, d) {\n        const b = this.options,\n          c = this.chart.time,\n          f = \"min\" === a ? this.minInput : this.maxInput;\n        a = \"min\" === a ? this.minDateBox : this.maxDateBox;\n        if (f) {\n          var e = f.getAttribute(\"data-hc-time\");\n          e = p(e) ? Number(e) : void 0;\n          p(d) && (p(e) && f.setAttribute(\"data-hc-time-previous\", e), f.setAttribute(\"data-hc-time\", d), e = d);\n          f.value = c.dateFormat(this.inputTypeFormats[f.type] || b.inputEditDateFormat, e);\n          a && a.attr({\n            text: c.dateFormat(b.inputDateFormat, e)\n          });\n        }\n      }\n      setInputExtremes(a, d, b) {\n        if (a = \"min\" === a ? this.minInput : this.maxInput) {\n          const c = this.inputTypeFormats[a.type],\n            f = this.chart.time;\n          c && (d = f.dateFormat(c, d), a.min !== d && (a.min = d), b = f.dateFormat(c, b), a.max !== b && (a.max = b));\n        }\n      }\n      showInput(a) {\n        const e = \"min\" === a ? this.minDateBox : this.maxDateBox;\n        if ((a = \"min\" === a ? this.minInput : this.maxInput) && e && this.inputGroup) {\n          const b = \"text\" === a.type,\n            {\n              translateX: c,\n              translateY: f\n            } = this.inputGroup,\n            {\n              inputBoxWidth: g\n            } = this.options;\n          d(a, {\n            width: b ? e.width + (g ? -2 : 20) + \"px\" : \"auto\",\n            height: e.height - 2 + \"px\",\n            border: \"2px solid silver\"\n          });\n          b && g ? d(a, {\n            left: c + e.x + \"px\",\n            top: f + \"px\"\n          }) : d(a, {\n            left: Math.min(Math.round(e.x + c - (a.offsetWidth - e.width) / 2), this.chart.chartWidth - a.offsetWidth) + \"px\",\n            top: f - (a.offsetHeight - e.height) / 2 + \"px\"\n          });\n        }\n      }\n      hideInput(a) {\n        (a = \"min\" === a ? this.minInput : this.maxInput) && d(a, {\n          top: \"-9999em\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n      }\n      defaultInputDateParser(a, d, b) {\n        var c = a.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n        -1 === c.indexOf(\"T\") && (c += \"T00:00\");\n        if (d) c += \"Z\";else {\n          var e;\n          if (e = H.isSafari) e = c, e = !(6 < e.length && (e.lastIndexOf(\"-\") === e.length - 6 || e.lastIndexOf(\"+\") === e.length - 6));\n          e && (e = new Date(c).getTimezoneOffset() / 60, c += 0 >= e ? `+${E(-e)}:00` : `-${E(e)}:00`);\n        }\n        c = Date.parse(c);\n        h(c) || (a = a.split(\"-\"), c = Date.UTC(q(a[0]), q(a[1]) - 1, q(a[2])));\n        b && d && h(c) && (c += b.getTimezoneOffset(c));\n        return c;\n      }\n      drawInput(a) {\n        function e() {\n          const {\n              maxInput: c,\n              minInput: d\n            } = k,\n            e = b.xAxis[0];\n          var f = b.scroller && b.scroller.xAxis ? b.scroller.xAxis : e;\n          const g = f.dataMin;\n          f = f.dataMax;\n          let l = k.getInputValue(a);\n          l !== Number(t.getAttribute(\"data-hc-time-previous\")) && h(l) && (t.setAttribute(\"data-hc-time-previous\", l), q && c && h(g) ? l > Number(c.getAttribute(\"data-hc-time\")) ? l = void 0 : l < g && (l = g) : d && h(f) && (l < Number(d.getAttribute(\"data-hc-time\")) ? l = void 0 : l > f && (l = f)), \"undefined\" !== typeof l && e.setExtremes(q ? l : e.min, q ? e.max : l, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          }));\n        }\n        const {\n            chart: b,\n            div: c,\n            inputGroup: f\n          } = this,\n          k = this,\n          l = b.renderer.style || {};\n        var m = b.renderer;\n        const n = b.options.rangeSelector,\n          q = \"min\" === a;\n        var p = B.lang[q ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\";\n        p = m.label(p, 0).addClass(\"highcharts-range-label\").attr({\n          padding: p ? 2 : 0,\n          height: p ? n.inputBoxHeight : 0\n        }).add(f);\n        m = m.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: n.inputBoxWidth,\n          height: n.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          k.showInput(a);\n          k[a + \"Input\"].focus();\n        });\n        b.styledMode || m.attr({\n          stroke: n.inputBoxBorderColor,\n          \"stroke-width\": 1\n        });\n        m.add(f);\n        const t = r(\"input\", {\n          name: a,\n          className: \"highcharts-range-selector\"\n        }, void 0, c);\n        t.setAttribute(\"type\", u(n.inputDateFormat || \"%e %b %Y\"));\n        b.styledMode || (p.css(D(l, n.labelStyle)), m.css(D({\n          color: \"#333333\"\n        }, l, n.inputStyle)), d(t, v({\n          position: \"absolute\",\n          border: 0,\n          boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: l.fontSize,\n          fontFamily: l.fontFamily,\n          top: \"-9999em\"\n        }, n.inputStyle)));\n        t.onfocus = () => {\n          k.showInput(a);\n        };\n        t.onblur = () => {\n          t === H.doc.activeElement && e();\n          k.hideInput(a);\n          k.setInputValue(a);\n          t.blur();\n        };\n        let w = !1;\n        t.onchange = () => {\n          w || (e(), k.hideInput(a), t.blur());\n        };\n        t.onkeypress = a => {\n          13 === a.keyCode && e();\n        };\n        t.onkeydown = a => {\n          w = !0;\n          38 !== a.keyCode && 40 !== a.keyCode || e();\n        };\n        t.onkeyup = () => {\n          w = !1;\n        };\n        return {\n          dateBox: m,\n          input: t,\n          label: p\n        };\n      }\n      getPosition() {\n        var a = this.chart;\n        const d = a.options.rangeSelector;\n        a = \"top\" === d.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + d.buttonPosition.y,\n          inputTop: a + d.inputPosition.y - 10\n        };\n      }\n      getYTDExtremes(a, d, b) {\n        const c = this.chart.time;\n        var e = new c.Date(a);\n        const g = c.get(\"FullYear\", e);\n        b = b ? c.Date.UTC(g, 0, 1) : +new c.Date(g, 0, 1);\n        d = Math.max(d, b);\n        e = e.getTime();\n        return {\n          max: Math.min(a || e, e),\n          min: d\n        };\n      }\n      render(a, d) {\n        var b = this.chart,\n          c = b.renderer;\n        const f = b.container;\n        var g = b.options;\n        const h = g.rangeSelector,\n          k = e(g.chart.style && g.chart.style.zIndex, 0) + 1;\n        g = h.inputEnabled;\n        if (!1 !== h.enabled) {\n          this.rendered || (this.group = c.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = r(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: k\n          }), this.buttonOptions.length && this.renderButtons(), f.parentNode && f.parentNode.insertBefore(this.div, f), g && (this.inputGroup = c.g(\"input-group\").add(this.group), c = this.drawInput(\"min\"), this.minDateBox = c.dateBox, this.minLabel = c.label, this.minInput = c.input, c = this.drawInput(\"max\"), this.maxDateBox = c.dateBox, this.maxLabel = c.label, this.maxInput = c.input));\n          if (g && (this.setInputValue(\"min\", a), this.setInputValue(\"max\", d), a = b.scroller && b.scroller.getUnionExtremes() || b.xAxis[0] || {}, p(a.dataMin) && p(a.dataMax) && (b = b.xAxis[0].minRange || 0, this.setInputExtremes(\"min\", a.dataMin, Math.min(a.dataMax, this.getInputValue(\"max\")) - b), this.setInputExtremes(\"max\", Math.max(a.dataMin, this.getInputValue(\"min\")) + b, a.dataMax)), this.inputGroup)) {\n            let a = 0;\n            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(b => {\n              if (b) {\n                const {\n                  width: c\n                } = b.getBBox();\n                c && (b.attr({\n                  x: a\n                }), a += c + h.inputSpacing);\n              }\n            });\n          }\n          this.alignElements();\n          this.rendered = !0;\n        }\n      }\n      renderButtons() {\n        const {\n            buttons: a,\n            chart: d,\n            options: b\n          } = this,\n          c = B.lang,\n          f = d.renderer,\n          h = D(b.buttonTheme),\n          k = h && h.states,\n          l = h.width || 28;\n        delete h.width;\n        delete h.states;\n        this.buttonGroup = f.g(\"range-selector-buttons\").add(this.group);\n        const m = this.dropdown = r(\"select\", void 0, {\n          position: \"absolute\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          border: 0,\n          top: \"-9999em\",\n          cursor: \"pointer\",\n          opacity: .0001\n        }, this.div);\n        t(m, \"touchstart\", () => {\n          m.style.fontSize = \"16px\";\n        });\n        [[H.isMS ? \"mouseover\" : \"mouseenter\"], [H.isMS ? \"mouseout\" : \"mouseleave\"], [\"change\", \"click\"]].forEach(([b, c]) => {\n          t(m, b, () => {\n            const d = a[this.currentButtonIndex()];\n            d && n(d.element, c || b);\n          });\n        });\n        this.zoomText = f.label(c && c.rangeSelectorZoom || \"\", 0).attr({\n          padding: b.buttonTheme.padding,\n          height: b.buttonTheme.height,\n          paddingLeft: 0,\n          paddingRight: 0\n        }).add(this.buttonGroup);\n        this.chart.styledMode || (this.zoomText.css(b.labelStyle), h[\"stroke-width\"] = e(h[\"stroke-width\"], 0));\n        r(\"option\", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, m);\n        this.buttonOptions.forEach((b, c) => {\n          r(\"option\", {\n            textContent: b.title || b.text\n          }, void 0, m);\n          a[c] = f.button(b.text, 0, 0, a => {\n            const d = b.events && b.events.click;\n            let e;\n            d && (e = d.call(b, a));\n            !1 !== e && this.clickButton(c);\n            this.isActive = !0;\n          }, h, k && k.hover, k && k.select, k && k.disabled).attr({\n            \"text-align\": \"center\",\n            width: l\n          }).add(this.buttonGroup);\n          b.title && a[c].attr(\"title\", b.title);\n        });\n      }\n      alignElements() {\n        const {\n          buttonGroup: a,\n          buttons: d,\n          chart: b,\n          group: c,\n          inputGroup: f,\n          options: h,\n          zoomText: k\n        } = this;\n        var l = b.options;\n        const m = l.exporting && !1 !== l.exporting.enabled && l.navigation && l.navigation.buttonOptions,\n          {\n            buttonPosition: n,\n            inputPosition: p,\n            verticalAlign: q\n          } = h;\n        l = (a, c) => m && this.titleCollision(b) && \"top\" === q && \"right\" === c.align && c.y - a.getBBox().height - 12 < (m.y || 0) + (m.height || 0) + b.spacing[0] ? -40 : 0;\n        var r = b.plotLeft;\n        if (c && n && p) {\n          var t = n.x - b.spacing[3];\n          if (a) {\n            this.positionButtons();\n            if (!this.initialButtonGroupWidth) {\n              let a = 0;\n              k && (a += k.getBBox().width + 5);\n              d.forEach((b, c) => {\n                a += b.width;\n                c !== d.length - 1 && (a += h.buttonSpacing);\n              });\n              this.initialButtonGroupWidth = a;\n            }\n            r -= b.spacing[3];\n            this.updateButtonStates();\n            var u = l(a, n);\n            this.alignButtonGroup(u);\n            c.placed = a.placed = b.hasLoaded;\n          }\n          u = 0;\n          f && (u = l(f, p), \"left\" === p.align ? t = r : \"right\" === p.align && (t = -Math.max(b.axisOffset[1], -u)), f.align({\n            y: p.y,\n            width: f.getBBox().width,\n            align: p.align,\n            x: p.x + t - 2\n          }, !0, b.spacingBox), f.placed = b.hasLoaded);\n          this.handleCollision(u);\n          c.align({\n            verticalAlign: q\n          }, !0, b.spacingBox);\n          l = c.alignAttr.translateY;\n          r = c.getBBox().height + 20;\n          t = 0;\n          \"bottom\" === q && (t = (t = b.legend && b.legend.options) && \"bottom\" === t.verticalAlign && t.enabled && !t.floating ? b.legend.legendHeight + e(t.margin, 10) : 0, r = r + t - 20, t = l - r - (h.floating ? 0 : h.y) - (b.titleOffset ? b.titleOffset[2] : 0) - 10);\n          if (\"top\" === q) h.floating && (t = 0), b.titleOffset && b.titleOffset[0] && (t = b.titleOffset[0]), t += b.margin[0] - b.spacing[0] || 0;else if (\"middle\" === q) if (p.y === n.y) t = l;else if (p.y || n.y) t = 0 > p.y || 0 > n.y ? t - Math.min(p.y, n.y) : l - r;\n          c.translate(h.x, h.y + Math.floor(t));\n          const {\n            minInput: g,\n            maxInput: m,\n            dropdown: x\n          } = this;\n          h.inputEnabled && g && m && (g.style.marginTop = c.translateY + \"px\", m.style.marginTop = c.translateY + \"px\");\n          x && (x.style.marginTop = c.translateY + \"px\");\n        }\n      }\n      alignButtonGroup(a, d) {\n        const {\n            chart: b,\n            options: c,\n            buttonGroup: f\n          } = this,\n          {\n            buttonPosition: g\n          } = c,\n          h = b.plotLeft - b.spacing[3];\n        let k = g.x - b.spacing[3];\n        \"right\" === g.align ? k += a - h : \"center\" === g.align && (k -= h / 2);\n        f && f.align({\n          y: g.y,\n          width: e(d, this.initialButtonGroupWidth),\n          align: g.align,\n          x: k\n        }, !0, b.spacingBox);\n      }\n      positionButtons() {\n        const {\n            buttons: a,\n            chart: d,\n            options: b,\n            zoomText: c\n          } = this,\n          f = d.hasLoaded ? \"animate\" : \"attr\",\n          {\n            buttonPosition: h\n          } = b,\n          k = d.plotLeft;\n        let l = k;\n        c && \"hidden\" !== c.visibility && (c[f]({\n          x: e(k + h.x, k)\n        }), l += h.x + c.getBBox().width + 5);\n        for (let c = 0, d = this.buttonOptions.length; c < d; ++c) if (\"hidden\" !== a[c].visibility) a[c][f]({\n          x: l\n        }), l += a[c].width + b.buttonSpacing;else a[c][f]({\n          x: k\n        });\n      }\n      handleCollision(a) {\n        const {\n            chart: d,\n            buttonGroup: b,\n            inputGroup: c\n          } = this,\n          {\n            buttonPosition: e,\n            dropdown: h,\n            inputPosition: k\n          } = this.options,\n          l = () => {\n            let a = 0;\n            this.buttons.forEach(b => {\n              b = b.getBBox();\n              b.width > a && (a = b.width);\n            });\n            return a;\n          },\n          m = d => {\n            if (c && b) {\n              const f = c.alignAttr.translateX + c.alignOptions.x - a + c.getBBox().x + 2,\n                g = c.alignOptions.width,\n                h = b.alignAttr.translateX + b.getBBox().x;\n              return h + d > f && f + g > h && e.y < k.y + c.getBBox().height;\n            }\n            return !1;\n          },\n          n = () => {\n            c && b && c.attr({\n              translateX: c.alignAttr.translateX + (d.axisOffset[1] >= -a ? 0 : -a),\n              translateY: c.alignAttr.translateY + b.getBBox().height + 10\n            });\n          };\n        if (b) {\n          if (\"always\" === h) {\n            this.collapseButtons(a);\n            m(l()) && n();\n            return;\n          }\n          \"never\" === h && this.expandButtons();\n        }\n        c && b ? k.align === e.align || m(this.initialButtonGroupWidth + 20) ? \"responsive\" === h ? (this.collapseButtons(a), m(l()) && n()) : n() : \"responsive\" === h && this.expandButtons() : b && \"responsive\" === h && (this.initialButtonGroupWidth > d.plotWidth ? this.collapseButtons(a) : this.expandButtons());\n      }\n      collapseButtons(a) {\n        const {\n            buttons: d,\n            buttonOptions: b,\n            chart: c,\n            dropdown: f,\n            options: h,\n            zoomText: k\n          } = this,\n          l = c.userOptions.rangeSelector && c.userOptions.rangeSelector.buttonTheme || {},\n          m = a => ({\n            text: a ? `${a} \\u25be` : \"\\u25be\",\n            width: \"auto\",\n            paddingLeft: e(h.buttonTheme.paddingLeft, l.padding, 8),\n            paddingRight: e(h.buttonTheme.paddingRight, l.padding, 8)\n          });\n        k && k.hide();\n        let n = !1;\n        b.forEach((a, b) => {\n          b = d[b];\n          2 !== b.state ? b.hide() : (b.show(), b.attr(m(a.text)), n = !0);\n        });\n        n || (f && (f.selectedIndex = 0), d[0].show(), d[0].attr(m(this.zoomText && this.zoomText.textStr)));\n        const {\n          align: p\n        } = h.buttonPosition;\n        this.positionButtons();\n        \"right\" !== p && \"center\" !== p || this.alignButtonGroup(a, d[this.currentButtonIndex()].getBBox().width);\n        this.showDropdown();\n      }\n      expandButtons() {\n        const {\n          buttons: a,\n          buttonOptions: d,\n          options: b,\n          zoomText: c\n        } = this;\n        this.hideDropdown();\n        c && c.show();\n        d.forEach((c, d) => {\n          d = a[d];\n          d.show();\n          d.attr({\n            text: c.text,\n            width: b.buttonTheme.width || 28,\n            paddingLeft: e(b.buttonTheme.paddingLeft, \"unset\"),\n            paddingRight: e(b.buttonTheme.paddingRight, \"unset\")\n          });\n          2 > d.state && d.setState(0);\n        });\n        this.positionButtons();\n      }\n      currentButtonIndex() {\n        const {\n          dropdown: a\n        } = this;\n        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;\n      }\n      showDropdown() {\n        const {\n          buttonGroup: a,\n          buttons: e,\n          chart: b,\n          dropdown: c\n        } = this;\n        if (a && c) {\n          const {\n              translateX: f,\n              translateY: g\n            } = a,\n            h = e[this.currentButtonIndex()].getBBox();\n          d(c, {\n            left: b.plotLeft + f + \"px\",\n            top: g + .5 + \"px\",\n            width: h.width + \"px\",\n            height: h.height + \"px\"\n          });\n          this.hasVisibleDropdown = !0;\n        }\n      }\n      hideDropdown() {\n        const {\n          dropdown: a\n        } = this;\n        a && (d(a, {\n          top: \"-9999em\",\n          width: \"1px\",\n          height: \"1px\"\n        }), this.hasVisibleDropdown = !1);\n      }\n      getHeight() {\n        var a = this.options,\n          d = this.group;\n        const b = a.y,\n          c = a.buttonPosition.y,\n          e = a.inputPosition.y;\n        if (a.height) return a.height;\n        this.alignElements();\n        a = d ? d.getBBox(!0).height + 13 + b : 0;\n        d = Math.min(e, c);\n        if (0 > e && 0 > c || 0 < e && 0 < c) a += Math.abs(d);\n        return a;\n      }\n      titleCollision(a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      }\n      update(a) {\n        const d = this.chart;\n        D(!0, d.options.rangeSelector, a);\n        this.destroy();\n        this.init(d);\n        this.render();\n      }\n      destroy() {\n        const a = this,\n          d = a.minInput,\n          b = a.maxInput;\n        a.eventsToUnbind && (a.eventsToUnbind.forEach(a => a()), a.eventsToUnbind = void 0);\n        m(a.buttons);\n        d && (d.onfocus = d.onblur = d.onchange = null);\n        b && (b.onfocus = b.onblur = b.onchange = null);\n        L(a, function (b, d) {\n          b && \"chart\" !== d && (b instanceof F ? b.destroy() : b instanceof V.HTMLElement && k(b));\n          b !== l.prototype[d] && (a[d] = null);\n        }, this);\n      }\n    }\n    v(l.prototype, {\n      defaultButtons: [{\n        type: \"month\",\n        count: 1,\n        text: \"1m\",\n        title: \"View 1 month\"\n      }, {\n        type: \"month\",\n        count: 3,\n        text: \"3m\",\n        title: \"View 3 months\"\n      }, {\n        type: \"month\",\n        count: 6,\n        text: \"6m\",\n        title: \"View 6 months\"\n      }, {\n        type: \"ytd\",\n        text: \"YTD\",\n        title: \"View year to date\"\n      }, {\n        type: \"year\",\n        count: 1,\n        text: \"1y\",\n        title: \"View 1 year\"\n      }, {\n        type: \"all\",\n        text: \"All\",\n        title: \"View all\"\n      }],\n      inputTypeFormats: {\n        \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n        date: \"%Y-%m-%d\",\n        time: \"%H:%M:%S\"\n      }\n    });\n    \"\";\n    return l;\n  });\n  M(a, \"Core/Axis/OrdinalAxis.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I) {\n    const {\n        addEvent: u,\n        correctFloat: G,\n        css: C,\n        defined: B,\n        error: t,\n        pick: r,\n        timeUnits: d\n      } = I,\n      p = [];\n    var m;\n    (function (a) {\n      function k(a, c, e, g, h = [], k = 0, l) {\n        const b = {},\n          f = this.options.tickPixelInterval;\n        var m = this.chart.time,\n          n = [],\n          p;\n        let q;\n        let r;\n        var x = 0;\n        let u = [],\n          v = -Number.MAX_VALUE;\n        if (!this.options.ordinal && !this.options.breaks || !h || 3 > h.length || \"undefined\" === typeof c) return m.getTimeTicks.apply(m, arguments);\n        const w = h.length;\n        for (p = 0; p < w; p++) {\n          r = p && h[p - 1] > e;\n          h[p] < c && (x = p);\n          if (p === w - 1 || h[p + 1] - h[p] > 5 * k || r) {\n            if (h[p] > v) {\n              for (q = m.getTimeTicks(a, h[x], h[p], g); q.length && q[0] <= v;) q.shift();\n              q.length && (v = q[q.length - 1]);\n              n.push(u.length);\n              u = u.concat(q);\n            }\n            x = p + 1;\n          }\n          if (r) break;\n        }\n        if (q) {\n          h = q.info;\n          if (l && h.unitRange <= d.hour) {\n            p = u.length - 1;\n            for (x = 1; x < p; x++) if (m.dateFormat(\"%d\", u[x]) !== m.dateFormat(\"%d\", u[x - 1])) {\n              b[u[x]] = \"day\";\n              var z = !0;\n            }\n            z && (b[u[0]] = \"day\");\n            h.higherRanks = b;\n          }\n          h.segmentStarts = n;\n          u.info = h;\n        } else t(12, !1, this.chart);\n        if (l && B(f)) {\n          x = u.length;\n          m = [];\n          z = [];\n          let a;\n          for (p = x; p--;) n = this.translate(u[p]), a && (z[p] = a - n), m[p] = a = n;\n          z.sort();\n          z = z[Math.floor(z.length / 2)];\n          z < .6 * f && (z = null);\n          p = u[x - 1] > e ? x - 1 : x;\n          for (a = void 0; p--;) n = m[p], x = Math.abs(a - n), a && x < .8 * f && (null === z || x < .8 * z) ? (b[u[p]] && !b[u[p + 1]] ? (x = p + 1, a = n) : x = p, u.splice(x, 1)) : a = n;\n        }\n        return u;\n      }\n      function m(a) {\n        const b = this.ordinal.positions;\n        if (!b) return a;\n        let d = b.length - 1,\n          e;\n        0 > a ? a = b[0] : a > d ? a = b[d] : (d = Math.floor(a), e = a - d);\n        return \"undefined\" !== typeof e && \"undefined\" !== typeof b[d] ? b[d] + (e ? e * (b[d + 1] - b[d]) : 0) : a;\n      }\n      function h(a) {\n        var b = this.ordinal,\n          d = b.positions;\n        if (!d) return a;\n        var e = (a - (this.old ? this.old.min : this.min)) * (this.old ? this.old.transA : this.transA) + this.minPixelPadding;\n        0 < e && e < this.left + this.len || (b.extendedOrdinalPositions || (b.extendedOrdinalPositions = b.getExtendedPositions()), d = b.extendedOrdinalPositions);\n        if (d && d.length) {\n          a = b.getIndexOfPoint(e, d);\n          b = G(a % 1);\n          if (0 <= a && a < d.length - 1) return d[Math.floor(a)] + b * (d[Math.ceil(a)] - d[Math.floor(a)]);\n          b = d.length;\n          e = d[0];\n          d = d[b - 1];\n          const c = (d - e) / (b - 1);\n          return 0 > a ? e + c * a : d + c * (a - b);\n        }\n        return a;\n      }\n      function D(b, c) {\n        const d = a.Additions.findIndexOf(b, c, !0);\n        return b[d] === c ? d : d + (c - b[d]) / (b[d + 1] - b[d]);\n      }\n      function F() {\n        this.ordinal || (this.ordinal = new a.Additions(this));\n      }\n      function E() {\n        this.isXAxis && B(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && \"navigator\" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && B(this.userMin) && (this.min += this.options.overscroll));\n      }\n      function e() {\n        this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n      }\n      function q() {\n        this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));\n      }\n      function y(a) {\n        const b = this.xAxis[0],\n          d = b.options.overscroll,\n          e = a.originalEvent.chartX,\n          g = this.options.chart.panning;\n        let h = !1;\n        if (g && \"y\" !== g.type && b.options.ordinal && b.series.length) {\n          var k = this.mouseDownX;\n          const a = b.getExtremes(),\n            c = a.dataMax,\n            f = a.min,\n            g = a.max;\n          var l = this.hoverPoints,\n            m = b.closestPointRange || b.ordinal && b.ordinal.overscrollPointsRange;\n          k = (k - e) / (b.translationSlope * (b.ordinal.slope || m));\n          m = b.ordinal.getExtendedPositions();\n          var n = {\n            ordinal: {\n              positions: m,\n              extendedOrdinalPositions: m\n            }\n          };\n          m = b.index2val;\n          const p = b.val2lin;\n          let q;\n          n.ordinal.positions ? 1 < Math.abs(k) && (l && l.forEach(function (a) {\n            a.setState();\n          }), 0 > k ? (l = n, q = b.ordinal.positions ? b : n) : (l = b.ordinal.positions ? b : n, q = n), n = q.ordinal.positions, c > n[n.length - 1] && n.push(c), this.fixedRange = g - f, k = b.navigatorAxis.toFixedRange(void 0, void 0, m.apply(l, [p.apply(l, [f, !0]) + k]), m.apply(q, [p.apply(q, [g, !0]) + k])), k.min >= Math.min(a.dataMin, f) && k.max <= Math.max(c, g) + d && b.setExtremes(k.min, k.max, !0, !1, {\n            trigger: \"pan\"\n          }), this.mouseDownX = e, C(this.container, {\n            cursor: \"move\"\n          })) : h = !0;\n        } else h = !0;\n        h || g && /y/.test(g.type) ? d && (b.max = b.dataMax + d) : a.preventDefault();\n      }\n      function l() {\n        const a = this.xAxis;\n        a && a.options.ordinal && (delete a.ordinal.index, delete a.ordinal.extendedOrdinalPositions);\n      }\n      function w(a, c) {\n        const b = this.ordinal;\n        var d = b.positions;\n        let e = b.slope,\n          g = b.extendedOrdinalPositions;\n        if (!d) return a;\n        var h = d.length;\n        if (d[0] <= a && d[h - 1] >= a) a = D(d, a);else {\n          g || (g = b.getExtendedPositions && b.getExtendedPositions(), b.extendedOrdinalPositions = g);\n          if (!g || !g.length) return a;\n          h = g.length;\n          e || (e = (g[h - 1] - g[0]) / h);\n          d = D(g, d[0]);\n          a = a >= g[0] && a <= g[h - 1] ? D(g, a) - d : a < g[0] ? -d - (g[0] - a) / e : (a - g[h - 1]) / e + h - d;\n        }\n        return c ? a : e * (a || 0) + b.offset;\n      }\n      a.compose = function (a, c, d) {\n        if (I.pushUnique(p, a)) {\n          const b = a.prototype;\n          b.getTimeTicks = k;\n          b.index2val = m;\n          b.lin2val = h;\n          b.val2lin = w;\n          b.ordinal2lin = b.val2lin;\n          u(a, \"afterInit\", F);\n          u(a, \"foundExtremes\", E);\n          u(a, \"afterSetScale\", e);\n          u(a, \"initialAxisTranslation\", q);\n        }\n        I.pushUnique(p, d) && u(d, \"pan\", y);\n        I.pushUnique(p, c) && u(c, \"updatedData\", l);\n        return a;\n      };\n      class g {\n        constructor(a) {\n          this.index = {};\n          this.axis = a;\n        }\n        beforeSetTickPositions() {\n          const a = this.axis,\n            c = a.ordinal;\n          var d = a.getExtremes();\n          const e = d.min;\n          var g = d.max;\n          const h = a.isXAxis && !!a.options.breaks;\n          d = a.options.ordinal;\n          const k = a.chart.options.chart.ignoreHiddenSeries;\n          let l, m;\n          var n;\n          let p = [],\n            q = Number.MAX_VALUE,\n            t = !1,\n            u = !1,\n            v = !1;\n          if (d || h) {\n            let b = 0;\n            a.series.forEach(function (a, c) {\n              m = [];\n              0 < c && \"highcharts-navigator-series\" !== a.options.id && 1 < a.processedXData.length && (u = b !== a.processedXData[1] - a.processedXData[0]);\n              b = a.processedXData[1] - a.processedXData[0];\n              a.boosted && (v = a.boosted);\n              if (!(k && !1 === a.visible || !1 === a.takeOrdinalPosition && !h) && (p = p.concat(a.processedXData), l = p.length, p.sort(function (a, b) {\n                return a - b;\n              }), q = Math.min(q, r(a.closestPointRange, q)), l)) {\n                for (c = 0; c < l - 1;) p[c] !== p[c + 1] && m.push(p[c + 1]), c++;\n                m[0] !== p[0] && m.unshift(p[0]);\n                p = m;\n              }\n            });\n            u && v && (p.pop(), p.shift());\n            l = p.length;\n            if (2 < l) {\n              var w = p[1] - p[0];\n              for (n = l - 1; n-- && !t;) p[n + 1] - p[n] !== w && (t = !0);\n              !a.options.keepOrdinalPadding && (p[0] - e > w || g - p[p.length - 1] > w) && (t = !0);\n            } else a.options.overscroll && (2 === l ? q = p[1] - p[0] : 1 === l ? (q = a.options.overscroll, p = [p[0], p[0] + q]) : q = c.overscrollPointsRange);\n            t || a.forceOrdinal ? (a.options.overscroll && (c.overscrollPointsRange = q, p = p.concat(c.getOverscrollPositions())), c.positions = p, w = a.ordinal2lin(Math.max(e, p[0]), !0), n = Math.max(a.ordinal2lin(Math.min(g, p[p.length - 1]), !0), 1), c.slope = g = (g - e) / (n - w), c.offset = e - w * g) : (c.overscrollPointsRange = r(a.closestPointRange, c.overscrollPointsRange), c.positions = a.ordinal.slope = c.offset = void 0);\n          }\n          a.isOrdinal = d && t;\n          c.groupIntervalFactor = null;\n        }\n        static findIndexOf(a, c, d) {\n          let b = 0,\n            e = a.length - 1,\n            f;\n          for (; b < e;) f = Math.ceil((b + e) / 2), a[f] <= c ? b = f : e = f - 1;\n          return a[b] === c ? b : d ? b : -1;\n        }\n        getExtendedPositions() {\n          const a = this,\n            c = a.axis,\n            d = c.constructor.prototype,\n            e = c.chart,\n            g = c.series[0].currentDataGrouping,\n            h = g ? g.count + g.unitName : \"raw\",\n            k = c.options.overscroll,\n            l = c.getExtremes();\n          let m,\n            n = void 0,\n            p = a.index;\n          p || (p = a.index = {});\n          p[h] || (m = {\n            series: [],\n            chart: e,\n            forceOrdinal: !1,\n            getExtremes: function () {\n              return {\n                min: l.dataMin,\n                max: l.dataMax + k\n              };\n            },\n            getGroupPixelWidth: d.getGroupPixelWidth,\n            getTimeTicks: d.getTimeTicks,\n            options: {\n              ordinal: !0\n            },\n            ordinal: {\n              getGroupIntervalFactor: this.getGroupIntervalFactor\n            },\n            ordinal2lin: d.ordinal2lin,\n            getIndexOfPoint: d.getIndexOfPoint,\n            val2lin: d.val2lin\n          }, m.ordinal.axis = m, c.series.forEach(function (b) {\n            n = {\n              xAxis: m,\n              xData: b.xData.slice(),\n              chart: e,\n              destroyGroupedData: A.noop,\n              getProcessedData: H.prototype.getProcessedData,\n              applyGrouping: H.prototype.applyGrouping\n            };\n            n.xData = n.xData.concat(a.getOverscrollPositions());\n            n.options = {\n              dataGrouping: g ? {\n                firstAnchor: \"firstPoint\",\n                anchor: \"middle\",\n                lastAnchor: \"lastPoint\",\n                enabled: !0,\n                forced: !0,\n                approximation: \"open\",\n                units: [[g.unitName, [g.count]]]\n              } : {\n                enabled: !1\n              }\n            };\n            m.series.push(n);\n            b.processData.apply(n);\n          }), n.closestPointRange !== n.basePointRange && n.currentDataGrouping && (m.forceOrdinal = !0), c.ordinal.beforeSetTickPositions.apply({\n            axis: m\n          }), p[h] = m.ordinal.positions);\n          return p[h];\n        }\n        getGroupIntervalFactor(a, c, d) {\n          d = d.processedXData;\n          const b = d.length;\n          var e = [];\n          var f = this.groupIntervalFactor;\n          if (!f) {\n            for (f = 0; f < b - 1; f++) e[f] = d[f + 1] - d[f];\n            e.sort(function (a, b) {\n              return a - b;\n            });\n            e = e[Math.floor(b / 2)];\n            a = Math.max(a, d[0]);\n            c = Math.min(c, d[b - 1]);\n            this.groupIntervalFactor = f = b * e / (c - a);\n          }\n          return f;\n        }\n        getIndexOfPoint(a, c) {\n          const b = this.axis,\n            d = this.positions ? this.positions[0] : 0;\n          let e = b.series[0].points && b.series[0].points[0] && b.series[0].points[0].plotX || b.minPixelPadding;\n          1 < b.series.length && b.series.forEach(function (a) {\n            a.points && B(a.points[0]) && B(a.points[0].plotX) && a.points[0].plotX < e && a.points[0].plotX >= r(b.min, -Infinity) && (e = a.points[0].plotX);\n          });\n          a = (a - e) / (b.translationSlope * (this.slope || b.closestPointRange || this.overscrollPointsRange));\n          return g.findIndexOf(c, d) + a;\n        }\n        getOverscrollPositions() {\n          const a = this.axis,\n            c = a.options.overscroll,\n            d = this.overscrollPointsRange,\n            e = [];\n          let g = a.dataMax;\n          if (B(d)) for (; g <= a.dataMax + c;) g += d, e.push(g);\n          return e;\n        }\n        postProcessTickInterval(a) {\n          const b = this.axis,\n            d = this.slope;\n          return d ? b.options.breaks ? b.closestPointRange || a : a / (d / b.closestPointRange) : a;\n        }\n      }\n      a.Additions = g;\n    })(m || (m = {}));\n    return m;\n  });\n  M(a, \"Series/HLC/HLCPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"]], function (a) {\n    ({\n      column: {\n        prototype: {\n          pointClass: a\n        }\n      }\n    } = a.seriesTypes);\n    class u extends a {\n      constructor() {\n        super(...arguments);\n        this.series = this.plotClose = this.options = this.low = this.high = this.close = void 0;\n      }\n    }\n    return u;\n  });\n  M(a, \"Series/HLC/HLCSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      lineWidth: 1,\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'\n      },\n      threshold: null,\n      states: {\n        hover: {\n          lineWidth: 3\n        }\n      },\n      stickyTracking: !0\n    };\n  });\n  M(a, \"Series/HLC/HLCSeries.js\", [a[\"Series/HLC/HLCPoint.js\"], a[\"Series/HLC/HLCSeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I) {\n    const {\n        column: u\n      } = H.seriesTypes,\n      {\n        extend: G,\n        merge: C\n      } = I;\n    class B extends u {\n      constructor() {\n        super(...arguments);\n        this.yData = this.points = this.options = this.data = void 0;\n      }\n      extendStem(a, r, d) {\n        const p = a[0];\n        a = a[1];\n        \"number\" === typeof p[2] && (p[2] = Math.max(d + r, p[2]));\n        \"number\" === typeof a[2] && (a[2] = Math.min(d - r, a[2]));\n      }\n      getPointPath(a, r) {\n        r = r.strokeWidth();\n        const d = a.series,\n          p = r % 2 / 2,\n          m = Math.round(a.plotX) - p,\n          k = Math.round(a.shapeArgs.width / 2),\n          t = [[\"M\", m, Math.round(a.yBottom)], [\"L\", m, Math.round(a.plotHigh)]];\n        null !== a.close && (a = Math.round(a.plotClose) + p, t.push([\"M\", m, a], [\"L\", m + k, a]), d.extendStem(t, r / 2, a));\n        return t;\n      }\n      drawSinglePoint(a) {\n        var r = a.series;\n        const d = r.chart;\n        let p = a.graphic;\n        \"undefined\" !== typeof a.plotY && (p || (a.graphic = p = d.renderer.path().add(r.group)), d.styledMode || p.attr(r.pointAttribs(a, a.selected && \"select\")), r = r.getPointPath(a, p), p[p ? \"animate\" : \"attr\"]({\n          d: r\n        }).addClass(a.getClassName(), !0));\n      }\n      drawPoints() {\n        this.points.forEach(this.drawSinglePoint);\n      }\n      init() {\n        super.init.apply(this, arguments);\n        this.options.stacking = void 0;\n      }\n      pointAttribs(a, r) {\n        a = super.pointAttribs.call(this, a, r);\n        delete a.fill;\n        return a;\n      }\n      toYData(a) {\n        return [a.high, a.low, a.close];\n      }\n      translate() {\n        const a = this,\n          r = a.yAxis,\n          d = this.pointArrayMap && this.pointArrayMap.slice() || [],\n          p = d.map(a => `plot${a.charAt(0).toUpperCase() + a.slice(1)}`);\n        p.push(\"yBottom\");\n        d.push(\"low\");\n        super.translate.apply(a);\n        a.points.forEach(function (m) {\n          d.forEach(function (d, t) {\n            d = m[d];\n            null !== d && (a.dataModify && (d = a.dataModify.modifyValue(d)), m[p[t]] = r.toPixels(d, !0));\n          });\n          m.tooltipPos[1] = m.plotHigh + r.pos - a.chart.plotTop;\n        });\n      }\n    }\n    B.defaultOptions = C(u.defaultOptions, A);\n    G(B.prototype, {\n      pointClass: a,\n      animate: null,\n      directTouch: !1,\n      pointArrayMap: [\"high\", \"low\", \"close\"],\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      pointValKey: \"close\"\n    });\n    H.registerSeriesType(\"hlc\", B);\n    return B;\n  });\n  M(a, \"Series/OHLC/OHLCPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"]], function (a) {\n    ({\n      seriesTypes: {\n        hlc: a\n      }\n    } = a);\n    class u extends a.prototype.pointClass {\n      constructor() {\n        super(...arguments);\n        this.series = this.plotOpen = this.options = this.open = void 0;\n      }\n      getClassName() {\n        return super.getClassName.call(this) + (this.open < this.close ? \" highcharts-point-up\" : \" highcharts-point-down\");\n      }\n      resolveUpColor() {\n        this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);\n      }\n      resolveColor() {\n        super.resolveColor();\n        this.resolveUpColor();\n      }\n      getZone() {\n        const a = super.getZone();\n        this.resolveUpColor();\n        return a;\n      }\n      applyOptions() {\n        super.applyOptions.apply(this, arguments);\n        this.resolveColor && this.resolveColor();\n        return this;\n      }\n    }\n    return u;\n  });\n  M(a, \"Series/OHLC/OHLCSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'\n      }\n    };\n  });\n  M(a, \"Series/OHLC/OHLCSeries.js\", [a[\"Series/OHLC/OHLCPoint.js\"], a[\"Series/OHLC/OHLCSeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I) {\n    function u(a) {\n      a = a.options;\n      const d = a.dataGrouping;\n      d && a.useOhlcData && \"highcharts-navigator-series\" !== a.id && (d.approximation = \"ohlc\");\n    }\n    function G(a) {\n      a = a.options;\n      a.useOhlcData && \"highcharts-navigator-series\" !== a.id && t(this, {\n        pointValKey: p.prototype.pointValKey,\n        pointArrayMap: p.prototype.pointArrayMap,\n        toYData: p.prototype.toYData\n      });\n    }\n    const {\n        seriesTypes: {\n          hlc: C\n        }\n      } = H,\n      {\n        addEvent: B,\n        extend: t,\n        merge: r\n      } = I,\n      d = [];\n    class p extends C {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      static compose(a, ...k) {\n        I.pushUnique(d, a) && (B(a, \"afterSetOptions\", u), B(a, \"init\", G));\n      }\n      getPointPath(a, d) {\n        const k = super.getPointPath(a, d);\n        d = d.strokeWidth();\n        const m = d % 2 / 2,\n          h = Math.round(a.plotX) - m,\n          p = Math.round(a.shapeArgs.width / 2);\n        null !== a.open && (a = Math.round(a.plotOpen) + m, k.push([\"M\", h, a], [\"L\", h - p, a]), super.extendStem(k, d / 2, a));\n        return k;\n      }\n      pointAttribs(a, d) {\n        d = super.pointAttribs.call(this, a, d);\n        const k = this.options;\n        delete d.fill;\n        !a.options.color && k.upColor && a.open < a.close && (d.stroke = k.upColor);\n        return d;\n      }\n      toYData(a) {\n        return [a.open, a.high, a.low, a.close];\n      }\n    }\n    p.defaultOptions = r(C.defaultOptions, A);\n    t(p.prototype, {\n      pointClass: a,\n      pointArrayMap: [\"open\", \"high\", \"low\", \"close\"]\n    });\n    H.registerSeriesType(\"ohlc\", p);\n    return p;\n  });\n  M(a, \"Series/Candlestick/CandlestickSeriesDefaults.js\", [a[\"Core/Defaults.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    \"\";\n\n    return {\n      states: {\n        hover: {\n          lineWidth: 2\n        }\n      },\n      threshold: null,\n      lineColor: \"#000000\",\n      lineWidth: 1,\n      upColor: \"#ffffff\",\n      stickyTracking: !0\n    };\n  });\n  M(a, \"Series/Candlestick/CandlestickSeries.js\", [a[\"Series/Candlestick/CandlestickSeriesDefaults.js\"], a[\"Core/Defaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I) {\n    ({\n      defaultOptions: A\n    } = A);\n    const {\n      column: u,\n      ohlc: G\n    } = H.seriesTypes;\n    ({\n      merge: I\n    } = I);\n    class C extends G {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      pointAttribs(a, t) {\n        const r = u.prototype.pointAttribs.call(this, a, t),\n          d = this.options,\n          p = a.open < a.close,\n          m = d.lineColor || this.color,\n          k = a.color || this.color;\n        r[\"stroke-width\"] = d.lineWidth;\n        r.fill = a.options.color || (p ? d.upColor || k : k);\n        r.stroke = a.options.lineColor || (p ? d.upLineColor || m : m);\n        t && (a = d.states[t], r.fill = a.color || r.fill, r.stroke = a.lineColor || r.stroke, r[\"stroke-width\"] = a.lineWidth || r[\"stroke-width\"]);\n        return r;\n      }\n      drawPoints() {\n        var a = this.points;\n        const t = this.chart,\n          r = this.yAxis.reversed;\n        for (const k of a) {\n          a = k.graphic;\n          var d = void 0,\n            p = void 0;\n          let u, n;\n          var m = void 0;\n          let h, A;\n          const B = !a;\n          \"undefined\" !== typeof k.plotY && (a || (k.graphic = a = t.renderer.path().add(this.group)), this.chart.styledMode || a.attr(this.pointAttribs(k, k.selected && \"select\")).shadow(this.options.shadow), m = a.strokeWidth() % 2 / 2, h = Math.round(k.plotX) - m, d = k.plotOpen, p = k.plotClose, u = Math.min(d, p), d = Math.max(d, p), A = Math.round(k.shapeArgs.width / 2), p = r ? d !== k.yBottom : Math.round(u) !== Math.round(k.plotHigh), n = r ? Math.round(u) !== Math.round(k.plotHigh) : d !== k.yBottom, u = Math.round(u) + m, d = Math.round(d) + m, m = [], m.push([\"M\", h - A, d], [\"L\", h - A, u], [\"L\", h + A, u], [\"L\", h + A, d], [\"Z\"], [\"M\", h, u], [\"L\", h, p ? Math.round(r ? k.yBottom : k.plotHigh) : u], [\"M\", h, d], [\"L\", h, n ? Math.round(r ? k.plotHigh : k.yBottom) : d]), a[B ? \"attr\" : \"animate\"]({\n            d: m\n          }).addClass(k.getClassName(), !0));\n        }\n      }\n    }\n    C.defaultOptions = I(G.defaultOptions, A.plotOptions, {\n      tooltip: G.defaultOptions.tooltip\n    }, a);\n    H.registerSeriesType(\"candlestick\", C);\n    return C;\n  });\n  M(a, \"Series/Flags/FlagsPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, A) {\n    ({\n      column: {\n        prototype: {\n          pointClass: a\n        }\n      }\n    } = a.seriesTypes);\n    const {\n      isNumber: u\n    } = A;\n    class I extends a {\n      constructor() {\n        super(...arguments);\n        this.series = this.options = void 0;\n        this.ttBelow = !1;\n      }\n      isValid() {\n        return u(this.y) || \"undefined\" === typeof this.y;\n      }\n      hasNewShapeType() {\n        const a = this.options.shape || this.series.options.shape;\n        return this.graphic && a && a !== this.graphic.symbolKey;\n      }\n    }\n    return I;\n  });\n  M(a, \"Series/Flags/FlagsSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      pointRange: 0,\n      allowOverlapX: !1,\n      shape: \"flag\",\n      stackDistance: 12,\n      textAlign: \"center\",\n      tooltip: {\n        pointFormat: \"{point.text}\"\n      },\n      threshold: null,\n      y: -30,\n      fillColor: \"#ffffff\",\n      lineWidth: 1,\n      states: {\n        hover: {\n          lineColor: \"#000000\",\n          fillColor: \"#ccd3ff\"\n        }\n      },\n      style: {\n        fontSize: \"0.7em\",\n        fontWeight: \"bold\"\n      }\n    };\n  });\n  M(a, \"Series/Flags/FlagsSymbols.js\", [a[\"Core/Renderer/RendererRegistry.js\"]], function (a) {\n    var u;\n    (function (u) {\n      function A(a, u, t, r, d) {\n        const p = d && d.anchorX || a;\n        d = d && d.anchorY || u;\n        const m = this.circle(p - 1, d - 1, 2, 2);\n        m.push([\"M\", p, d], [\"L\", a, u + r], [\"L\", a, u], [\"L\", a + t, u], [\"L\", a + t, u + r], [\"L\", a, u + r], [\"Z\"]);\n        return m;\n      }\n      function F(a, u) {\n        a[u + \"pin\"] = function (t, r, d, p, m) {\n          const k = m && m.anchorX;\n          m = m && m.anchorY;\n          let v;\n          \"circle\" === u && p > d && (t -= Math.round((p - d) / 2), d = p);\n          v = a[u](t, r, d, p);\n          if (k && m) {\n            let n = k;\n            \"circle\" === u ? n = t + d / 2 : (t = v[0], d = v[1], \"M\" === t[0] && \"L\" === d[0] && (n = (t[1] + d[1]) / 2));\n            v.push([\"M\", n, r > m ? r : r + p], [\"L\", k, m]);\n            v = v.concat(a.circle(k - 1, m - 1, 2, 2));\n          }\n          return v;\n        };\n      }\n      const G = [];\n      u.compose = function (u) {\n        -1 === G.indexOf(u) && (G.push(u), u = u.prototype.symbols, u.flag = A, F(u, \"circle\"), F(u, \"square\"));\n        u = a.getRendererType();\n        G.indexOf(u) && G.push(u);\n      };\n    })(u || (u = {}));\n    return u;\n  });\n  M(a, \"Series/OnSeriesComposition.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, A, H) {\n    const {\n        prototype: u\n      } = a,\n      {\n        prototype: F\n      } = A,\n      {\n        defined: G,\n        stableSort: C\n      } = H;\n    var B;\n    (function (a) {\n      function r(a) {\n        return F.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this, a);\n      }\n      function d() {\n        u.translate.apply(this);\n        const a = this;\n        var d = a.options,\n          p = a.chart;\n        const n = a.points;\n        var h = d.onSeries;\n        const r = (h = h && p.get(h)) && h.options.step,\n          t = h && h.points,\n          A = p.inverted,\n          e = a.xAxis,\n          q = a.yAxis;\n        p = n.length - 1;\n        let y;\n        d = d.onKey || \"y\";\n        let l = t && t.length,\n          w = 0,\n          g,\n          b,\n          c,\n          f;\n        if (h && h.visible && l) {\n          w = (h.pointXOffset || 0) + (h.barW || 0) / 2;\n          var x = h.currentDataGrouping;\n          b = t[l - 1].x + (x ? x.totalRange : 0);\n          C(n, (a, b) => a.x - b.x);\n          for (d = \"plot\" + d[0].toUpperCase() + d.substr(1); l-- && n[p] && !(g = t[l], x = n[p], x.y = g.y, g.x <= x.x && \"undefined\" !== typeof g[d] && (x.x <= b && (x.plotY = g[d], g.x < x.x && !r && (c = t[l + 1]) && \"undefined\" !== typeof c[d] && (f = (x.x - g.x) / (c.x - g.x), x.plotY += f * (c[d] - g[d]), x.y += f * (c.y - g.y))), p--, l++, 0 > p)););\n        }\n        n.forEach((b, c) => {\n          let d;\n          b.plotX += w;\n          if (\"undefined\" === typeof b.plotY || A) 0 <= b.plotX && b.plotX <= e.len ? A ? (b.plotY = e.translate(b.x, 0, 1, 0, 1), b.plotX = G(b.y) ? q.translate(b.y, 0, 0, 0, 1) : 0) : b.plotY = (e.opposite ? 0 : a.yAxis.len) + e.offset : b.shapeArgs = {};\n          (y = n[c - 1]) && y.plotX === b.plotX && (\"undefined\" === typeof y.stackIndex && (y.stackIndex = 0), d = y.stackIndex + 1);\n          b.stackIndex = d;\n        });\n        this.onSeries = h;\n      }\n      const p = [];\n      a.compose = function (a) {\n        if (H.pushUnique(p, a)) {\n          const k = a.prototype;\n          k.getPlotBox = r;\n          k.translate = d;\n        }\n        return a;\n      };\n      a.getPlotBox = r;\n      a.translate = d;\n    })(B || (B = {}));\n    return B;\n  });\n  M(a, \"Series/Flags/FlagsSeries.js\", [a[\"Series/Flags/FlagsPoint.js\"], a[\"Series/Flags/FlagsSeriesDefaults.js\"], a[\"Series/Flags/FlagsSymbols.js\"], a[\"Core/Globals.js\"], a[\"Series/OnSeriesComposition.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C, B, t) {\n    ({\n      noop: I\n    } = I);\n    const {\n        distribute: r\n      } = G,\n      {\n        series: d,\n        seriesTypes: {\n          column: p\n        }\n      } = C,\n      {\n        addEvent: m,\n        defined: k,\n        extend: u,\n        merge: n,\n        objectEach: h,\n        wrap: D\n      } = t;\n    class L extends p {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      animate(a) {\n        a && this.setClip();\n      }\n      drawPoints() {\n        var a = this.points,\n          d = this.chart;\n        const m = d.renderer,\n          p = d.inverted,\n          l = this.options,\n          t = l.y,\n          g = this.yAxis,\n          b = {},\n          c = [];\n        let f, u;\n        let v, z;\n        let A, C, F;\n        for (v = a.length; v--;) {\n          z = a[v];\n          C = (p ? z.plotY : z.plotX) > this.xAxis.len;\n          f = z.plotX;\n          var G = z.stackIndex;\n          var H = z.options.shape || l.shape;\n          u = z.plotY;\n          \"undefined\" !== typeof u && (u = z.plotY + t - (\"undefined\" !== typeof G && G * l.stackDistance));\n          z.anchorX = G ? void 0 : z.plotX;\n          A = G ? void 0 : z.plotY;\n          F = \"flag\" !== H;\n          G = z.graphic;\n          \"undefined\" !== typeof u && 0 <= f && !C ? (G && z.hasNewShapeType() && (G = G.destroy()), G || (G = z.graphic = m.label(\"\", null, null, H, null, null, l.useHTML).addClass(\"highcharts-point\").add(this.markerGroup), z.graphic.div && (z.graphic.div.point = z), G.isNew = !0), G.attr({\n            align: F ? \"center\" : \"left\",\n            width: l.width,\n            height: l.height,\n            \"text-align\": l.textAlign\n          }), d.styledMode || G.attr(this.pointAttribs(z)).css(n(l.style, z.style)).shadow(l.shadow), 0 < f && (f -= G.strokeWidth() % 2), H = {\n            y: u,\n            anchorY: A\n          }, l.allowOverlapX && (H.x = f, H.anchorX = z.anchorX), G.attr({\n            text: z.options.title || l.title || \"A\"\n          })[G.isNew ? \"attr\" : \"animate\"](H), l.allowOverlapX || (b[z.plotX] ? b[z.plotX].size = Math.max(b[z.plotX].size, G.width) : b[z.plotX] = {\n            align: F ? .5 : 0,\n            size: G.width,\n            target: f,\n            anchorX: f\n          }), z.tooltipPos = [f, u + g.pos - d.plotTop]) : G && (z.graphic = G.destroy());\n        }\n        if (!l.allowOverlapX) {\n          let e = 100;\n          h(b, function (a) {\n            a.plotX = a.anchorX;\n            c.push(a);\n            e = Math.max(a.size, e);\n          });\n          r(c, p ? g.len : this.xAxis.len, e);\n          for (const c of a) d = c.plotX, (d = (a = c.graphic) && b[d]) && a && (k(d.pos) ? a[a.isNew ? \"attr\" : \"animate\"]({\n            x: d.pos + (d.align || 0) * d.size,\n            anchorX: c.anchorX\n          }).show().isNew = !1 : a.hide().isNew = !0);\n        }\n        l.useHTML && this.markerGroup && D(this.markerGroup, \"on\", function (a) {\n          return B.prototype.on.apply(a.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));\n        });\n      }\n      drawTracker() {\n        const a = this.points;\n        super.drawTracker();\n        for (const d of a) {\n          const e = d.graphic;\n          e && (d.unbindMouseOver && d.unbindMouseOver(), d.unbindMouseOver = m(e.element, \"mouseover\", function () {\n            0 < d.stackIndex && !d.raised && (d._y = e.y, e.attr({\n              y: d._y - 8\n            }), d.raised = !0);\n            for (const e of a) e !== d && e.raised && e.graphic && (e.graphic.attr({\n              y: e._y\n            }), e.raised = !1);\n          }));\n        }\n      }\n      pointAttribs(a, d) {\n        const e = this.options,\n          h = a && a.color || this.color;\n        let k = e.lineColor,\n          m = a && a.lineWidth;\n        a = a && a.fillColor || e.fillColor;\n        d && (a = e.states[d].fillColor, k = e.states[d].lineColor, m = e.states[d].lineWidth);\n        return {\n          fill: a || h,\n          stroke: k || h,\n          \"stroke-width\": m || e.lineWidth || 0\n        };\n      }\n      setClip() {\n        d.prototype.setClip.apply(this, arguments);\n        !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);\n      }\n    }\n    L.compose = H.compose;\n    L.defaultOptions = n(p.defaultOptions, A);\n    F.compose(L);\n    u(L.prototype, {\n      allowDG: !1,\n      forceCrop: !0,\n      invertible: !1,\n      noSharedTooltip: !0,\n      pointClass: a,\n      sorted: !1,\n      takeOrdinalPosition: !1,\n      trackerGroups: [\"markerGroup\"],\n      buildKDTree: I,\n      init: d.prototype.init\n    });\n    C.registerSeriesType(\"flags\", L);\n    \"\";\n    return L;\n  });\n  M(a, \"Core/Chart/StockChart.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Stock/Navigator/NavigatorDefaults.js\"], a[\"Stock/RangeSelector/RangeSelectorDefaults.js\"], a[\"Stock/Scrollbar/ScrollbarDefaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, A, H, I, F, G, C, B, t, r) {\n    function d(a, b) {\n      return \"xAxis\" === a ? {\n        minPadding: 0,\n        maxPadding: 0,\n        overscroll: 0,\n        ordinal: !0,\n        title: {\n          text: null\n        },\n        labels: {\n          overflow: \"justify\"\n        },\n        showLastLabel: !0\n      } : \"yAxis\" === a ? {\n        labels: {\n          y: -2\n        },\n        opposite: y(b.opposite, !0),\n        showLastLabel: !(!b.categories && \"category\" !== b.type),\n        title: {\n          text: null\n        }\n      } : {};\n    }\n    function p(a, b) {\n      return \"xAxis\" === a ? (a = {\n        type: \"datetime\",\n        categories: void 0\n      }, y(b.navigator && b.navigator.enabled, F.enabled, !0) && (a.startOnTick = !1, a.endOnTick = !1), a) : {};\n    }\n    const {\n        format: m\n      } = H,\n      {\n        getOptions: k\n      } = I,\n      {\n        addEvent: u,\n        clamp: n,\n        defined: h,\n        extend: D,\n        find: L,\n        isNumber: E,\n        isString: e,\n        merge: q,\n        pick: y,\n        splat: l\n      } = r;\n    class w extends A {\n      init(a, b) {\n        const c = k(),\n          e = a.xAxis,\n          g = a.yAxis;\n        var h = y(a.navigator && a.navigator.enabled, F.enabled, !0);\n        a.xAxis = a.yAxis = void 0;\n        h = q({\n          chart: {\n            panning: {\n              enabled: !0,\n              type: \"x\"\n            },\n            zooming: {\n              pinchType: \"x\"\n            }\n          },\n          navigator: {\n            enabled: h\n          },\n          scrollbar: {\n            enabled: y(C.enabled, !0)\n          },\n          rangeSelector: {\n            enabled: y(G.rangeSelector.enabled, !0)\n          },\n          title: {\n            text: null\n          },\n          tooltip: {\n            split: y(c.tooltip.split, !0),\n            crosshairs: !0\n          },\n          legend: {\n            enabled: !1\n          }\n        }, a, {\n          isStock: !0\n        });\n        a.xAxis = e;\n        a.yAxis = g;\n        h.xAxis = l(a.xAxis || {}).map(function (b, e) {\n          return q(d(\"xAxis\", b), c.xAxis, c.xAxis && c.xAxis[e], b, p(\"xAxis\", a));\n        });\n        h.yAxis = l(a.yAxis || {}).map(function (a, b) {\n          return q(d(\"yAxis\", a), c.yAxis, c.yAxis && c.yAxis[b], a);\n        });\n        super.init(h, b);\n      }\n      createAxis(a, b) {\n        b.axis = q(d(a, b.axis), b.axis, p(a, this.userOptions));\n        return super.createAxis(a, b);\n      }\n    }\n    (function (a) {\n      a.stockChart = function (b, c, d) {\n        return new a(b, c, d);\n      };\n    })(w || (w = {}));\n    u(B, \"setOptions\", function (a) {\n      let b;\n      this.chart.options.isStock && (this.is(\"column\") || this.is(\"columnrange\") ? b = {\n        borderWidth: 0,\n        shadow: !1\n      } : this.is(\"scatter\") || this.is(\"sma\") || (b = {\n        marker: {\n          enabled: !1,\n          radius: 2\n        }\n      }), b && (a.plotOptions[this.type] = q(a.plotOptions[this.type], b)));\n    });\n    u(a, \"autoLabelAlign\", function (a) {\n      const {\n          chart: b,\n          options: c\n        } = this,\n        d = b._labelPanes = b._labelPanes || {},\n        e = c.labels;\n      if (b.options.isStock && \"yAxis\" === this.coll) {\n        const b = c.top + \",\" + c.height;\n        !d[b] && e.enabled && (15 === e.distance && 1 === this.side && (e.distance = 0), \"undefined\" === typeof e.align && (e.align = \"right\"), d[b] = this, a.align = \"right\", a.preventDefault());\n      }\n    });\n    u(a, \"destroy\", function () {\n      const a = this.chart,\n        b = this.options && this.options.top + \",\" + this.options.height;\n      b && a._labelPanes && a._labelPanes[b] === this && delete a._labelPanes[b];\n    });\n    u(a, \"getPlotLinePath\", function (a) {\n      function b(a) {\n        const b = \"xAxis\" === a ? \"yAxis\" : \"xAxis\";\n        a = c.options[b];\n        return E(a) ? [g[b][a]] : e(a) ? [g.get(a)] : d.map(function (a) {\n          return a[b];\n        });\n      }\n      let c = this,\n        d = this.isLinked && !this.series ? this.linkedParent.series : this.series,\n        g = c.chart,\n        k = g.renderer,\n        l = c.left,\n        m = c.top,\n        p,\n        q,\n        r,\n        t,\n        u = [],\n        v = [],\n        w,\n        A,\n        B = a.translatedValue,\n        C = a.value,\n        D = a.force,\n        F;\n      if (g.options.isStock && !1 !== a.acrossPanes && \"xAxis\" === c.coll || \"yAxis\" === c.coll) a.preventDefault(), v = b(c.coll), w = c.isXAxis ? g.yAxis : g.xAxis, w.forEach(function (a) {\n        if (h(a.options.id) ? -1 === a.options.id.indexOf(\"navigator\") : 1) {\n          var b = a.isXAxis ? \"yAxis\" : \"xAxis\";\n          b = h(a.options[b]) ? g[b][a.options[b]] : g[b][0];\n          c === b && v.push(a);\n        }\n      }), A = v.length ? [] : [c.isXAxis ? g.yAxis[0] : g.xAxis[0]], v.forEach(function (a) {\n        -1 !== A.indexOf(a) || L(A, function (b) {\n          return b.pos === a.pos && b.len === a.len;\n        }) || A.push(a);\n      }), F = y(B, c.translate(C, void 0, void 0, a.old)), E(F) && (c.horiz ? A.forEach(function (a) {\n        let b;\n        q = a.pos;\n        t = q + a.len;\n        p = r = Math.round(F + c.transB);\n        \"pass\" !== D && (p < l || p > l + c.width) && (D ? p = r = n(p, l, l + c.width) : b = !0);\n        b || u.push([\"M\", p, q], [\"L\", r, t]);\n      }) : A.forEach(function (a) {\n        let b;\n        p = a.pos;\n        r = p + a.len;\n        q = t = Math.round(m + c.height - F);\n        \"pass\" !== D && (q < m || q > m + c.height) && (D ? q = t = n(q, m, m + c.height) : b = !0);\n        b || u.push([\"M\", p, q], [\"L\", r, t]);\n      })), a.path = 0 < u.length ? k.crispPolyLine(u, a.lineWidth || 1) : null;\n    });\n    t.prototype.crispPolyLine = function (a, b) {\n      for (let c = 0; c < a.length; c += 2) {\n        const d = a[c],\n          e = a[c + 1];\n        d[1] === e[1] && (d[1] = e[1] = Math.round(d[1]) - b % 2 / 2);\n        d[2] === e[2] && (d[2] = e[2] = Math.round(d[2]) + b % 2 / 2);\n      }\n      return a;\n    };\n    u(a, \"afterHideCrosshair\", function () {\n      this.crossLabel && (this.crossLabel = this.crossLabel.hide());\n    });\n    u(a, \"afterDrawCrosshair\", function (a) {\n      var b, c;\n      if (this.crosshair && this.crosshair.label && this.crosshair.label.enabled && this.cross && E(this.min) && E(this.max)) {\n        var d = this.chart,\n          e = this.logarithmic,\n          g = this.crosshair.label,\n          h = this.horiz,\n          k = this.opposite,\n          l = this.left,\n          n = this.top,\n          p = this.width,\n          q = this.crossLabel,\n          r = g.format,\n          t = \"\",\n          u = \"inside\" === this.options.tickPosition,\n          v = !1 !== this.crosshair.snap,\n          w = 0,\n          A = a.e || this.cross && this.cross.e;\n        a = a.point;\n        var B = this.min,\n          C = this.max;\n        e && (B = e.lin2log(B), C = e.lin2log(C));\n        e = h ? \"center\" : k ? \"right\" === this.labelAlign ? \"right\" : \"left\" : \"left\" === this.labelAlign ? \"left\" : \"center\";\n        q || (q = this.crossLabel = d.renderer.label(\"\", 0, void 0, g.shape || \"callout\").addClass(\"highcharts-crosshair-label highcharts-color-\" + (a && a.series ? a.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({\n          align: g.align || e,\n          padding: y(g.padding, 8),\n          r: y(g.borderRadius, 3),\n          zIndex: 2\n        }).add(this.labelGroup), d.styledMode || q.attr({\n          fill: g.backgroundColor || a && a.series && a.series.color || \"#666666\",\n          stroke: g.borderColor || \"\",\n          \"stroke-width\": g.borderWidth || 0\n        }).css(D({\n          color: \"#ffffff\",\n          fontWeight: \"normal\",\n          fontSize: \"0.7em\",\n          textAlign: \"center\"\n        }, g.style || {})));\n        h ? (p = v ? (a.plotX || 0) + l : A.chartX, n += k ? 0 : this.height) : (p = l + this.offset + (k ? p : 0), n = v ? (a.plotY || 0) + n : A.chartY);\n        r || g.formatter || (this.dateTime && (t = \"%b %d, %Y\"), r = \"{value\" + (t ? \":\" + t : \"\") + \"}\");\n        t = v ? this.isXAxis ? a.x : a.y : this.toValue(h ? A.chartX : A.chartY);\n        v = a && a.series ? a.series.isPointInside(a) : E(t) && t > B && t < C;\n        A = \"\";\n        r ? A = m(r, {\n          value: t\n        }, d) : g.formatter && E(t) && (A = g.formatter.call(this, t));\n        q.attr({\n          text: A,\n          x: p,\n          y: n,\n          visibility: v ? \"inherit\" : \"hidden\"\n        });\n        g = q.getBBox();\n        !E(q.x) || h || k || (p = q.x - g.width / 2);\n        if (E(q.y)) if (h) {\n          if (u && !k || !u && k) n = q.y - g.height;\n        } else n = q.y - g.height / 2;\n        h ? (b = l - g.x, c = l + this.width - g.x) : (b = \"left\" === this.labelAlign ? l : 0, c = \"right\" === this.labelAlign ? l + this.width : d.chartWidth);\n        q.translateX < b && (w = b - q.translateX);\n        q.translateX + g.width >= c && (w = -(q.translateX + g.width - c));\n        q.attr({\n          x: p + w,\n          y: n,\n          anchorX: h ? p : this.opposite ? 0 : d.chartWidth,\n          anchorY: h ? this.opposite ? d.chartHeight : 0 : n + g.height / 2\n        });\n      }\n    });\n    B.prototype.forceCropping = function () {\n      const a = this.chart,\n        b = this.options.dataGrouping;\n      return !1 !== this.allowDG && b && y(b.enabled, a.options.isStock);\n    };\n    u(A, \"update\", function (a) {\n      a = a.options;\n      \"scrollbar\" in a && this.navigator && (q(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}), delete a.scrollbar);\n    });\n    return w;\n  });\n  M(a, \"masters/modules/stock.src.js\", [a[\"Core/Globals.js\"], a[\"Series/DataModifyComposition.js\"], a[\"Stock/Navigator/Navigator.js\"], a[\"Stock/RangeSelector/RangeSelector.js\"], a[\"Stock/Scrollbar/Scrollbar.js\"], a[\"Core/Axis/OrdinalAxis.js\"], a[\"Series/OHLC/OHLCSeries.js\"], a[\"Series/Flags/FlagsSeries.js\"], a[\"Core/Chart/StockChart.js\"]], function (a, A, H, I, F, G, C, B, t) {\n    a.Navigator = H;\n    a.RangeSelector = I;\n    a.Scrollbar = F;\n    a.StockChart = a.stockChart = t.stockChart;\n    A.compose(a.Series, a.Axis, a.Point);\n    B.compose(a.Renderer);\n    H.compose(a.Axis, a.Chart, a.Series);\n    C.compose(a.Series);\n    G.compose(a.Axis, a.Series, a.Chart);\n    I.compose(a.Axis, a.Chart);\n    F.compose(a.Axis);\n  });\n  M(a, \"masters/highstock.src.js\", [a[\"masters/highcharts.src.js\"]], function (a) {\n    a.product = \"Highstock\";\n    return a;\n  });\n  a[\"masters/highstock.src.js\"]._modules = a;\n  return a[\"masters/highstock.src.js\"];\n});\n//# sourceMappingURL=highstock.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}